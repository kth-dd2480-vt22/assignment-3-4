
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>bufferpool: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">github.com/gohugoio/hugo/bufferpool/bufpool.go (100.0%)</option>
				
				<option value="file1">github.com/gohugoio/hugo/cache/filecache/filecache.go (87.1%)</option>
				
				<option value="file2">github.com/gohugoio/hugo/cache/filecache/filecache_config.go (83.3%)</option>
				
				<option value="file3">github.com/gohugoio/hugo/cache/filecache/filecache_pruner.go (78.7%)</option>
				
				<option value="file4">github.com/gohugoio/hugo/cache/namedmemcache/named_cache.go (100.0%)</option>
				
				<option value="file5">github.com/gohugoio/hugo/codegen/methods.go (83.9%)</option>
				
				<option value="file6">github.com/gohugoio/hugo/commands/commandeer.go (68.6%)</option>
				
				<option value="file7">github.com/gohugoio/hugo/commands/commands.go (89.3%)</option>
				
				<option value="file8">github.com/gohugoio/hugo/commands/config.go (56.8%)</option>
				
				<option value="file9">github.com/gohugoio/hugo/commands/convert.go (73.8%)</option>
				
				<option value="file10">github.com/gohugoio/hugo/commands/deploy.go (90.5%)</option>
				
				<option value="file11">github.com/gohugoio/hugo/commands/env.go (72.7%)</option>
				
				<option value="file12">github.com/gohugoio/hugo/commands/gen.go (100.0%)</option>
				
				<option value="file13">github.com/gohugoio/hugo/commands/genchromastyles.go (88.9%)</option>
				
				<option value="file14">github.com/gohugoio/hugo/commands/gendoc.go (96.2%)</option>
				
				<option value="file15">github.com/gohugoio/hugo/commands/gendocshelper.go (23.5%)</option>
				
				<option value="file16">github.com/gohugoio/hugo/commands/genman.go (94.1%)</option>
				
				<option value="file17">github.com/gohugoio/hugo/commands/helpers.go (0.0%)</option>
				
				<option value="file18">github.com/gohugoio/hugo/commands/hugo.go (35.8%)</option>
				
				<option value="file19">github.com/gohugoio/hugo/commands/import_jekyll.go (37.9%)</option>
				
				<option value="file20">github.com/gohugoio/hugo/commands/limit_others.go (0.0%)</option>
				
				<option value="file21">github.com/gohugoio/hugo/commands/list.go (75.0%)</option>
				
				<option value="file22">github.com/gohugoio/hugo/commands/mod.go (21.2%)</option>
				
				<option value="file23">github.com/gohugoio/hugo/commands/mod_npm.go (42.9%)</option>
				
				<option value="file24">github.com/gohugoio/hugo/commands/new.go (81.1%)</option>
				
				<option value="file25">github.com/gohugoio/hugo/commands/new_site.go (70.5%)</option>
				
				<option value="file26">github.com/gohugoio/hugo/commands/new_theme.go (84.4%)</option>
				
				<option value="file27">github.com/gohugoio/hugo/commands/release_noop.go (100.0%)</option>
				
				<option value="file28">github.com/gohugoio/hugo/commands/server.go (61.1%)</option>
				
				<option value="file29">github.com/gohugoio/hugo/commands/server_errors.go (0.0%)</option>
				
				<option value="file30">github.com/gohugoio/hugo/commands/static_syncer.go (2.6%)</option>
				
				<option value="file31">github.com/gohugoio/hugo/commands/version.go (100.0%)</option>
				
				<option value="file32">github.com/gohugoio/hugo/common/collections/append.go (95.3%)</option>
				
				<option value="file33">github.com/gohugoio/hugo/common/collections/slice.go (82.6%)</option>
				
				<option value="file34">github.com/gohugoio/hugo/common/herrors/error_locator.go (37.6%)</option>
				
				<option value="file35">github.com/gohugoio/hugo/common/herrors/errors.go (0.0%)</option>
				
				<option value="file36">github.com/gohugoio/hugo/common/herrors/file_error.go (43.8%)</option>
				
				<option value="file37">github.com/gohugoio/hugo/common/herrors/line_number_extractors.go (85.0%)</option>
				
				<option value="file38">github.com/gohugoio/hugo/common/hreflect/helpers.go (32.4%)</option>
				
				<option value="file39">github.com/gohugoio/hugo/common/htime/time.go (76.7%)</option>
				
				<option value="file40">github.com/gohugoio/hugo/common/hugo/hugo.go (17.5%)</option>
				
				<option value="file41">github.com/gohugoio/hugo/common/hugo/version.go (71.1%)</option>
				
				<option value="file42">github.com/gohugoio/hugo/common/loggers/ignorableLogger.go (0.0%)</option>
				
				<option value="file43">github.com/gohugoio/hugo/common/loggers/loggers.go (25.6%)</option>
				
				<option value="file44">github.com/gohugoio/hugo/common/maps/maps.go (62.3%)</option>
				
				<option value="file45">github.com/gohugoio/hugo/common/maps/params.go (81.4%)</option>
				
				<option value="file46">github.com/gohugoio/hugo/common/maps/scratch.go (95.3%)</option>
				
				<option value="file47">github.com/gohugoio/hugo/common/math/math.go (98.6%)</option>
				
				<option value="file48">github.com/gohugoio/hugo/common/para/para.go (0.0%)</option>
				
				<option value="file49">github.com/gohugoio/hugo/common/paths/path.go (82.4%)</option>
				
				<option value="file50">github.com/gohugoio/hugo/common/paths/url.go (89.1%)</option>
				
				<option value="file51">github.com/gohugoio/hugo/common/text/position.go (88.9%)</option>
				
				<option value="file52">github.com/gohugoio/hugo/common/text/transform.go (100.0%)</option>
				
				<option value="file53">github.com/gohugoio/hugo/common/types/convert.go (56.8%)</option>
				
				<option value="file54">github.com/gohugoio/hugo/common/types/evictingqueue.go (100.0%)</option>
				
				<option value="file55">github.com/gohugoio/hugo/common/types/types.go (41.7%)</option>
				
				<option value="file56">github.com/gohugoio/hugo/compare/compare_strings.go (100.0%)</option>
				
				<option value="file57">github.com/gohugoio/hugo/config/commonConfig.go (78.1%)</option>
				
				<option value="file58">github.com/gohugoio/hugo/config/compositeConfig.go (21.2%)</option>
				
				<option value="file59">github.com/gohugoio/hugo/config/configLoader.go (19.5%)</option>
				
				<option value="file60">github.com/gohugoio/hugo/config/configProvider.go (20.0%)</option>
				
				<option value="file61">github.com/gohugoio/hugo/config/defaultConfigProvider.go (59.4%)</option>
				
				<option value="file62">github.com/gohugoio/hugo/config/docshelper.go (20.0%)</option>
				
				<option value="file63">github.com/gohugoio/hugo/config/env.go (69.2%)</option>
				
				<option value="file64">github.com/gohugoio/hugo/config/privacy/privacyConfig.go (100.0%)</option>
				
				<option value="file65">github.com/gohugoio/hugo/config/security/docshelper.go (66.7%)</option>
				
				<option value="file66">github.com/gohugoio/hugo/config/security/securityConfig.go (57.1%)</option>
				
				<option value="file67">github.com/gohugoio/hugo/config/security/whitelist.go (90.0%)</option>
				
				<option value="file68">github.com/gohugoio/hugo/config/services/servicesConfig.go (100.0%)</option>
				
				<option value="file69">github.com/gohugoio/hugo/create/content.go (78.4%)</option>
				
				<option value="file70">github.com/gohugoio/hugo/deploy/cloudfront.go (0.0%)</option>
				
				<option value="file71">github.com/gohugoio/hugo/deploy/deploy.go (71.8%)</option>
				
				<option value="file72">github.com/gohugoio/hugo/deploy/deployConfig.go (84.6%)</option>
				
				<option value="file73">github.com/gohugoio/hugo/deploy/google.go (0.0%)</option>
				
				<option value="file74">github.com/gohugoio/hugo/deps/deps.go (0.9%)</option>
				
				<option value="file75">github.com/gohugoio/hugo/helpers/content.go (84.1%)</option>
				
				<option value="file76">github.com/gohugoio/hugo/helpers/docshelper.go (11.1%)</option>
				
				<option value="file77">github.com/gohugoio/hugo/helpers/emoji.go (93.3%)</option>
				
				<option value="file78">github.com/gohugoio/hugo/helpers/general.go (58.5%)</option>
				
				<option value="file79">github.com/gohugoio/hugo/helpers/path.go (63.1%)</option>
				
				<option value="file80">github.com/gohugoio/hugo/helpers/pathspec.go (63.2%)</option>
				
				<option value="file81">github.com/gohugoio/hugo/helpers/processing_stats.go (3.3%)</option>
				
				<option value="file82">github.com/gohugoio/hugo/helpers/url.go (78.3%)</option>
				
				<option value="file83">github.com/gohugoio/hugo/htesting/test_helpers.go (25.6%)</option>
				
				<option value="file84">github.com/gohugoio/hugo/htesting/testdata_builder.go (0.0%)</option>
				
				<option value="file85">github.com/gohugoio/hugo/hugofs/createcounting_fs.go (0.0%)</option>
				
				<option value="file86">github.com/gohugoio/hugo/hugofs/decorators.go (77.1%)</option>
				
				<option value="file87">github.com/gohugoio/hugo/hugofs/fileinfo.go (85.4%)</option>
				
				<option value="file88">github.com/gohugoio/hugo/hugofs/filename_filter_fs.go (62.0%)</option>
				
				<option value="file89">github.com/gohugoio/hugo/hugofs/files/classifier.go (51.7%)</option>
				
				<option value="file90">github.com/gohugoio/hugo/hugofs/filter_fs.go (11.9%)</option>
				
				<option value="file91">github.com/gohugoio/hugo/hugofs/fs.go (40.9%)</option>
				
				<option value="file92">github.com/gohugoio/hugo/hugofs/glob.go (86.2%)</option>
				
				<option value="file93">github.com/gohugoio/hugo/hugofs/glob/filename_filter.go (79.7%)</option>
				
				<option value="file94">github.com/gohugoio/hugo/hugofs/glob/glob.go (93.0%)</option>
				
				<option value="file95">github.com/gohugoio/hugo/hugofs/hashing_fs.go (66.7%)</option>
				
				<option value="file96">github.com/gohugoio/hugo/hugofs/language_composite_fs.go (0.0%)</option>
				
				<option value="file97">github.com/gohugoio/hugo/hugofs/noop_fs.go (0.0%)</option>
				
				<option value="file98">github.com/gohugoio/hugo/hugofs/nosymlink_fs.go (83.7%)</option>
				
				<option value="file99">github.com/gohugoio/hugo/hugofs/rootmapping_fs.go (88.5%)</option>
				
				<option value="file100">github.com/gohugoio/hugo/hugofs/slice_fs.go (0.0%)</option>
				
				<option value="file101">github.com/gohugoio/hugo/hugofs/stacktracer_fs.go (0.0%)</option>
				
				<option value="file102">github.com/gohugoio/hugo/hugofs/walk.go (66.1%)</option>
				
				<option value="file103">github.com/gohugoio/hugo/hugolib/alias.go (87.3%)</option>
				
				<option value="file104">github.com/gohugoio/hugo/hugolib/collections.go (20.0%)</option>
				
				<option value="file105">github.com/gohugoio/hugo/hugolib/config.go (86.4%)</option>
				
				<option value="file106">github.com/gohugoio/hugo/hugolib/content_factory.go (61.5%)</option>
				
				<option value="file107">github.com/gohugoio/hugo/hugolib/content_map.go (92.6%)</option>
				
				<option value="file108">github.com/gohugoio/hugo/hugolib/content_map_page.go (89.8%)</option>
				
				<option value="file109">github.com/gohugoio/hugo/hugolib/fileInfo.go (37.0%)</option>
				
				<option value="file110">github.com/gohugoio/hugo/hugolib/filesystems/basefs.go (63.7%)</option>
				
				<option value="file111">github.com/gohugoio/hugo/hugolib/gitinfo.go (87.5%)</option>
				
				<option value="file112">github.com/gohugoio/hugo/hugolib/hugo_sites.go (75.8%)</option>
				
				<option value="file113">github.com/gohugoio/hugo/hugolib/hugo_sites_build.go (79.8%)</option>
				
				<option value="file114">github.com/gohugoio/hugo/hugolib/integrationtest_builder.go (0.0%)</option>
				
				<option value="file115">github.com/gohugoio/hugo/hugolib/multilingual.go (57.1%)</option>
				
				<option value="file116">github.com/gohugoio/hugo/hugolib/page.go (86.4%)</option>
				
				<option value="file117">github.com/gohugoio/hugo/hugolib/page__common.go (100.0%)</option>
				
				<option value="file118">github.com/gohugoio/hugo/hugolib/page__content.go (87.0%)</option>
				
				<option value="file119">github.com/gohugoio/hugo/hugolib/page__data.go (100.0%)</option>
				
				<option value="file120">github.com/gohugoio/hugo/hugolib/page__menus.go (93.8%)</option>
				
				<option value="file121">github.com/gohugoio/hugo/hugolib/page__meta.go (81.9%)</option>
				
				<option value="file122">github.com/gohugoio/hugo/hugolib/page__new.go (75.3%)</option>
				
				<option value="file123">github.com/gohugoio/hugo/hugolib/page__output.go (95.7%)</option>
				
				<option value="file124">github.com/gohugoio/hugo/hugolib/page__paginator.go (74.4%)</option>
				
				<option value="file125">github.com/gohugoio/hugo/hugolib/page__paths.go (94.2%)</option>
				
				<option value="file126">github.com/gohugoio/hugo/hugolib/page__per_output.go (85.9%)</option>
				
				<option value="file127">github.com/gohugoio/hugo/hugolib/page__position.go (83.3%)</option>
				
				<option value="file128">github.com/gohugoio/hugo/hugolib/page__ref.go (75.0%)</option>
				
				<option value="file129">github.com/gohugoio/hugo/hugolib/page__tree.go (89.6%)</option>
				
				<option value="file130">github.com/gohugoio/hugo/hugolib/page_kinds.go (66.7%)</option>
				
				<option value="file131">github.com/gohugoio/hugo/hugolib/page_unwrap.go (60.0%)</option>
				
				<option value="file132">github.com/gohugoio/hugo/hugolib/pagecollections.go (95.3%)</option>
				
				<option value="file133">github.com/gohugoio/hugo/hugolib/pages_capture.go (88.3%)</option>
				
				<option value="file134">github.com/gohugoio/hugo/hugolib/pages_process.go (79.4%)</option>
				
				<option value="file135">github.com/gohugoio/hugo/hugolib/paths/baseURL.go (96.2%)</option>
				
				<option value="file136">github.com/gohugoio/hugo/hugolib/paths/paths.go (43.4%)</option>
				
				<option value="file137">github.com/gohugoio/hugo/hugolib/prune_resources.go (0.0%)</option>
				
				<option value="file138">github.com/gohugoio/hugo/hugolib/shortcode.go (86.9%)</option>
				
				<option value="file139">github.com/gohugoio/hugo/hugolib/shortcode_page.go (100.0%)</option>
				
				<option value="file140">github.com/gohugoio/hugo/hugolib/site.go (82.7%)</option>
				
				<option value="file141">github.com/gohugoio/hugo/hugolib/site_output.go (94.7%)</option>
				
				<option value="file142">github.com/gohugoio/hugo/hugolib/site_render.go (86.1%)</option>
				
				<option value="file143">github.com/gohugoio/hugo/hugolib/site_sections.go (80.0%)</option>
				
				<option value="file144">github.com/gohugoio/hugo/hugolib/taxonomy.go (77.1%)</option>
				
				<option value="file145">github.com/gohugoio/hugo/hugolib/translations.go (95.2%)</option>
				
				<option value="file146">github.com/gohugoio/hugo/identity/identity.go (34.4%)</option>
				
				<option value="file147">github.com/gohugoio/hugo/langs/config.go (0.0%)</option>
				
				<option value="file148">github.com/gohugoio/hugo/langs/i18n/i18n.go (91.3%)</option>
				
				<option value="file149">github.com/gohugoio/hugo/langs/i18n/translationProvider.go (67.9%)</option>
				
				<option value="file150">github.com/gohugoio/hugo/langs/language.go (41.0%)</option>
				
				<option value="file151">github.com/gohugoio/hugo/lazy/init.go (78.3%)</option>
				
				<option value="file152">github.com/gohugoio/hugo/lazy/once.go (88.2%)</option>
				
				<option value="file153">github.com/gohugoio/hugo/markup/asciidocext/convert.go (40.0%)</option>
				
				<option value="file154">github.com/gohugoio/hugo/markup/blackfriday/convert.go (88.6%)</option>
				
				<option value="file155">github.com/gohugoio/hugo/markup/blackfriday/renderer.go (0.0%)</option>
				
				<option value="file156">github.com/gohugoio/hugo/markup/goldmark/autoid.go (92.1%)</option>
				
				<option value="file157">github.com/gohugoio/hugo/markup/goldmark/convert.go (84.5%)</option>
				
				<option value="file158">github.com/gohugoio/hugo/markup/goldmark/render_hooks.go (51.8%)</option>
				
				<option value="file159">github.com/gohugoio/hugo/markup/goldmark/toc.go (94.6%)</option>
				
				<option value="file160">github.com/gohugoio/hugo/markup/highlight/config.go (86.4%)</option>
				
				<option value="file161">github.com/gohugoio/hugo/markup/highlight/highlight.go (82.8%)</option>
				
				<option value="file162">github.com/gohugoio/hugo/markup/markup.go (73.0%)</option>
				
				<option value="file163">github.com/gohugoio/hugo/markup/markup_config/config.go (78.1%)</option>
				
				<option value="file164">github.com/gohugoio/hugo/markup/org/convert.go (55.0%)</option>
				
				<option value="file165">github.com/gohugoio/hugo/markup/pandoc/convert.go (21.7%)</option>
				
				<option value="file166">github.com/gohugoio/hugo/markup/rst/convert.go (16.3%)</option>
				
				<option value="file167">github.com/gohugoio/hugo/markup/tableofcontents/tableofcontents.go (100.0%)</option>
				
				<option value="file168">github.com/gohugoio/hugo/media/docshelper.go (66.7%)</option>
				
				<option value="file169">github.com/gohugoio/hugo/media/mediaType.go (87.4%)</option>
				
				<option value="file170">github.com/gohugoio/hugo/metrics/metrics.go (37.1%)</option>
				
				<option value="file171">github.com/gohugoio/hugo/minifiers/config.go (92.0%)</option>
				
				<option value="file172">github.com/gohugoio/hugo/minifiers/minifiers.go (82.9%)</option>
				
				<option value="file173">github.com/gohugoio/hugo/modules/client.go (53.9%)</option>
				
				<option value="file174">github.com/gohugoio/hugo/modules/collect.go (70.7%)</option>
				
				<option value="file175">github.com/gohugoio/hugo/modules/config.go (33.3%)</option>
				
				<option value="file176">github.com/gohugoio/hugo/modules/module.go (53.3%)</option>
				
				<option value="file177">github.com/gohugoio/hugo/modules/npm/package_builder.go (32.6%)</option>
				
				<option value="file178">github.com/gohugoio/hugo/navigation/menu.go (0.0%)</option>
				
				<option value="file179">github.com/gohugoio/hugo/navigation/menu_cache.go (80.0%)</option>
				
				<option value="file180">github.com/gohugoio/hugo/navigation/pagemenus.go (0.0%)</option>
				
				<option value="file181">github.com/gohugoio/hugo/output/docshelper.go (11.1%)</option>
				
				<option value="file182">github.com/gohugoio/hugo/output/layout.go (97.2%)</option>
				
				<option value="file183">github.com/gohugoio/hugo/output/outputFormat.go (83.9%)</option>
				
				<option value="file184">github.com/gohugoio/hugo/parser/frontmatter.go (37.8%)</option>
				
				<option value="file185">github.com/gohugoio/hugo/parser/lowercase_camel_json.go (0.0%)</option>
				
				<option value="file186">github.com/gohugoio/hugo/parser/metadecoders/decoder.go (77.0%)</option>
				
				<option value="file187">github.com/gohugoio/hugo/parser/metadecoders/format.go (94.6%)</option>
				
				<option value="file188">github.com/gohugoio/hugo/parser/pageparser/item.go (40.5%)</option>
				
				<option value="file189">github.com/gohugoio/hugo/parser/pageparser/itemtype_string.go (0.0%)</option>
				
				<option value="file190">github.com/gohugoio/hugo/parser/pageparser/pagelexer.go (96.1%)</option>
				
				<option value="file191">github.com/gohugoio/hugo/parser/pageparser/pagelexer_intro.go (93.5%)</option>
				
				<option value="file192">github.com/gohugoio/hugo/parser/pageparser/pagelexer_shortcode.go (98.9%)</option>
				
				<option value="file193">github.com/gohugoio/hugo/parser/pageparser/pageparser.go (18.5%)</option>
				
				<option value="file194">github.com/gohugoio/hugo/publisher/htmlElementsCollector.go (91.9%)</option>
				
				<option value="file195">github.com/gohugoio/hugo/publisher/publisher.go (0.0%)</option>
				
				<option value="file196">github.com/gohugoio/hugo/related/inverted_index.go (64.1%)</option>
				
				<option value="file197">github.com/gohugoio/hugo/releaser/git.go (52.0%)</option>
				
				<option value="file198">github.com/gohugoio/hugo/releaser/github.go (2.2%)</option>
				
				<option value="file199">github.com/gohugoio/hugo/releaser/releasenotes_writer.go (0.0%)</option>
				
				<option value="file200">github.com/gohugoio/hugo/releaser/releaser.go (0.8%)</option>
				
				<option value="file201">github.com/gohugoio/hugo/resources/errorResource.go (0.0%)</option>
				
				<option value="file202">github.com/gohugoio/hugo/resources/image.go (85.7%)</option>
				
				<option value="file203">github.com/gohugoio/hugo/resources/image_cache.go (79.7%)</option>
				
				<option value="file204">github.com/gohugoio/hugo/resources/images/color.go (96.3%)</option>
				
				<option value="file205">github.com/gohugoio/hugo/resources/images/config.go (67.2%)</option>
				
				<option value="file206">github.com/gohugoio/hugo/resources/images/exif/exif.go (72.4%)</option>
				
				<option value="file207">github.com/gohugoio/hugo/resources/images/filters.go (11.1%)</option>
				
				<option value="file208">github.com/gohugoio/hugo/resources/images/image.go (1.0%)</option>
				
				<option value="file209">github.com/gohugoio/hugo/resources/images/overlay.go (0.0%)</option>
				
				<option value="file210">github.com/gohugoio/hugo/resources/images/resampling.go (1.7%)</option>
				
				<option value="file211">github.com/gohugoio/hugo/resources/images/smartcrop.go (0.0%)</option>
				
				<option value="file212">github.com/gohugoio/hugo/resources/images/text.go (0.0%)</option>
				
				<option value="file213">github.com/gohugoio/hugo/resources/internal/key.go (75.0%)</option>
				
				<option value="file214">github.com/gohugoio/hugo/resources/jsconfig/jsconfig.go (95.7%)</option>
				
				<option value="file215">github.com/gohugoio/hugo/resources/page/page.go (0.0%)</option>
				
				<option value="file216">github.com/gohugoio/hugo/resources/page/page_data.go (85.7%)</option>
				
				<option value="file217">github.com/gohugoio/hugo/resources/page/page_kinds.go (100.0%)</option>
				
				<option value="file218">github.com/gohugoio/hugo/resources/page/page_lazy_contentprovider.go (0.0%)</option>
				
				<option value="file219">github.com/gohugoio/hugo/resources/page/page_marshaljson.autogen.go (0.0%)</option>
				
				<option value="file220">github.com/gohugoio/hugo/resources/page/page_matcher.go (61.7%)</option>
				
				<option value="file221">github.com/gohugoio/hugo/resources/page/page_nop.go (0.0%)</option>
				
				<option value="file222">github.com/gohugoio/hugo/resources/page/page_outputformat.go (0.0%)</option>
				
				<option value="file223">github.com/gohugoio/hugo/resources/page/page_paths.go (88.5%)</option>
				
				<option value="file224">github.com/gohugoio/hugo/resources/page/page_wrappers.autogen.go (0.0%)</option>
				
				<option value="file225">github.com/gohugoio/hugo/resources/page/pagegroup.go (79.5%)</option>
				
				<option value="file226">github.com/gohugoio/hugo/resources/page/pagemeta/page_frontmatter.go (90.2%)</option>
				
				<option value="file227">github.com/gohugoio/hugo/resources/page/pagemeta/pagemeta.go (55.6%)</option>
				
				<option value="file228">github.com/gohugoio/hugo/resources/page/pages.go (72.7%)</option>
				
				<option value="file229">github.com/gohugoio/hugo/resources/page/pages_cache.go (83.0%)</option>
				
				<option value="file230">github.com/gohugoio/hugo/resources/page/pages_language_merge.go (0.0%)</option>
				
				<option value="file231">github.com/gohugoio/hugo/resources/page/pages_prev_next.go (100.0%)</option>
				
				<option value="file232">github.com/gohugoio/hugo/resources/page/pages_related.go (77.4%)</option>
				
				<option value="file233">github.com/gohugoio/hugo/resources/page/pages_sort.go (75.0%)</option>
				
				<option value="file234">github.com/gohugoio/hugo/resources/page/pages_sort_search.go (78.8%)</option>
				
				<option value="file235">github.com/gohugoio/hugo/resources/page/pagination.go (83.9%)</option>
				
				<option value="file236">github.com/gohugoio/hugo/resources/page/permalinks.go (88.5%)</option>
				
				<option value="file237">github.com/gohugoio/hugo/resources/page/site.go (0.0%)</option>
				
				<option value="file238">github.com/gohugoio/hugo/resources/page/weighted.go (36.6%)</option>
				
				<option value="file239">github.com/gohugoio/hugo/resources/page/zero_file.autogen.go (0.0%)</option>
				
				<option value="file240">github.com/gohugoio/hugo/resources/post_publish.go (0.0%)</option>
				
				<option value="file241">github.com/gohugoio/hugo/resources/postpub/fields.go (78.9%)</option>
				
				<option value="file242">github.com/gohugoio/hugo/resources/postpub/postpub.go (0.0%)</option>
				
				<option value="file243">github.com/gohugoio/hugo/resources/resource.go (78.0%)</option>
				
				<option value="file244">github.com/gohugoio/hugo/resources/resource_cache.go (46.9%)</option>
				
				<option value="file245">github.com/gohugoio/hugo/resources/resource_factories/bundler/bundler.go (24.0%)</option>
				
				<option value="file246">github.com/gohugoio/hugo/resources/resource_factories/create/create.go (0.0%)</option>
				
				<option value="file247">github.com/gohugoio/hugo/resources/resource_factories/create/remote.go (5.4%)</option>
				
				<option value="file248">github.com/gohugoio/hugo/resources/resource_metadata.go (98.0%)</option>
				
				<option value="file249">github.com/gohugoio/hugo/resources/resource_spec.go (66.7%)</option>
				
				<option value="file250">github.com/gohugoio/hugo/resources/resource_transformers/babel/babel.go (0.0%)</option>
				
				<option value="file251">github.com/gohugoio/hugo/resources/resource_transformers/integrity/integrity.go (90.0%)</option>
				
				<option value="file252">github.com/gohugoio/hugo/resources/resource_transformers/js/build.go (31.7%)</option>
				
				<option value="file253">github.com/gohugoio/hugo/resources/resource_transformers/js/options.go (72.6%)</option>
				
				<option value="file254">github.com/gohugoio/hugo/resources/resource_transformers/minifier/minify.go (87.5%)</option>
				
				<option value="file255">github.com/gohugoio/hugo/resources/resource_transformers/postcss/postcss.go (41.1%)</option>
				
				<option value="file256">github.com/gohugoio/hugo/resources/resource_transformers/templates/execute_as_template.go (76.9%)</option>
				
				<option value="file257">github.com/gohugoio/hugo/resources/resource_transformers/tocss/dartsass/client.go (0.0%)</option>
				
				<option value="file258">github.com/gohugoio/hugo/resources/resource_transformers/tocss/dartsass/transform.go (2.4%)</option>
				
				<option value="file259">github.com/gohugoio/hugo/resources/resource_transformers/tocss/scss/client.go (30.0%)</option>
				
				<option value="file260">github.com/gohugoio/hugo/resources/resource_transformers/tocss/scss/client_notavailable.go (50.0%)</option>
				
				<option value="file261">github.com/gohugoio/hugo/resources/transform.go (78.4%)</option>
				
				<option value="file262">github.com/gohugoio/hugo/source/fileInfo.go (66.1%)</option>
				
				<option value="file263">github.com/gohugoio/hugo/source/filesystem.go (30.6%)</option>
				
				<option value="file264">github.com/gohugoio/hugo/source/sourceSpec.go (59.3%)</option>
				
				<option value="file265">github.com/gohugoio/hugo/tpl/cast/cast.go (100.0%)</option>
				
				<option value="file266">github.com/gohugoio/hugo/tpl/cast/docshelper.go (16.7%)</option>
				
				<option value="file267">github.com/gohugoio/hugo/tpl/cast/init.go (100.0%)</option>
				
				<option value="file268">github.com/gohugoio/hugo/tpl/collections/append.go (100.0%)</option>
				
				<option value="file269">github.com/gohugoio/hugo/tpl/collections/apply.go (74.2%)</option>
				
				<option value="file270">github.com/gohugoio/hugo/tpl/collections/collections.go (96.5%)</option>
				
				<option value="file271">github.com/gohugoio/hugo/tpl/collections/complement.go (100.0%)</option>
				
				<option value="file272">github.com/gohugoio/hugo/tpl/collections/index.go (77.1%)</option>
				
				<option value="file273">github.com/gohugoio/hugo/tpl/collections/init.go (100.0%)</option>
				
				<option value="file274">github.com/gohugoio/hugo/tpl/collections/merge.go (97.8%)</option>
				
				<option value="file275">github.com/gohugoio/hugo/tpl/collections/reflect_helpers.go (86.9%)</option>
				
				<option value="file276">github.com/gohugoio/hugo/tpl/collections/sort.go (97.4%)</option>
				
				<option value="file277">github.com/gohugoio/hugo/tpl/collections/symdiff.go (92.0%)</option>
				
				<option value="file278">github.com/gohugoio/hugo/tpl/collections/where.go (91.1%)</option>
				
				<option value="file279">github.com/gohugoio/hugo/tpl/compare/compare.go (91.2%)</option>
				
				<option value="file280">github.com/gohugoio/hugo/tpl/compare/init.go (100.0%)</option>
				
				<option value="file281">github.com/gohugoio/hugo/tpl/crypto/crypto.go (89.2%)</option>
				
				<option value="file282">github.com/gohugoio/hugo/tpl/crypto/init.go (100.0%)</option>
				
				<option value="file283">github.com/gohugoio/hugo/tpl/data/data.go (93.5%)</option>
				
				<option value="file284">github.com/gohugoio/hugo/tpl/data/init.go (100.0%)</option>
				
				<option value="file285">github.com/gohugoio/hugo/tpl/data/resources.go (88.2%)</option>
				
				<option value="file286">github.com/gohugoio/hugo/tpl/debug/debug.go (50.0%)</option>
				
				<option value="file287">github.com/gohugoio/hugo/tpl/debug/init.go (100.0%)</option>
				
				<option value="file288">github.com/gohugoio/hugo/tpl/encoding/encoding.go (91.3%)</option>
				
				<option value="file289">github.com/gohugoio/hugo/tpl/encoding/init.go (100.0%)</option>
				
				<option value="file290">github.com/gohugoio/hugo/tpl/fmt/fmt.go (35.3%)</option>
				
				<option value="file291">github.com/gohugoio/hugo/tpl/fmt/init.go (100.0%)</option>
				
				<option value="file292">github.com/gohugoio/hugo/tpl/hugo/init.go (100.0%)</option>
				
				<option value="file293">github.com/gohugoio/hugo/tpl/images/images.go (77.8%)</option>
				
				<option value="file294">github.com/gohugoio/hugo/tpl/images/init.go (100.0%)</option>
				
				<option value="file295">github.com/gohugoio/hugo/tpl/inflect/inflect.go (100.0%)</option>
				
				<option value="file296">github.com/gohugoio/hugo/tpl/inflect/init.go (100.0%)</option>
				
				<option value="file297">github.com/gohugoio/hugo/tpl/internal/go_templates/fmtsort/sort.go (89.5%)</option>
				
				<option value="file298">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/attr.go (100.0%)</option>
				
				<option value="file299">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/attr_string.go (66.7%)</option>
				
				<option value="file300">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/content.go (100.0%)</option>
				
				<option value="file301">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/context.go (92.0%)</option>
				
				<option value="file302">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/css.go (97.7%)</option>
				
				<option value="file303">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/delim_string.go (66.7%)</option>
				
				<option value="file304">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/element_string.go (66.7%)</option>
				
				<option value="file305">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/error.go (85.7%)</option>
				
				<option value="file306">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/escape.go (96.4%)</option>
				
				<option value="file307">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/html.go (97.5%)</option>
				
				<option value="file308">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/hugo_template.go (0.0%)</option>
				
				<option value="file309">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/js.go (86.7%)</option>
				
				<option value="file310">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/jsctx_string.go (66.7%)</option>
				
				<option value="file311">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/state_string.go (66.7%)</option>
				
				<option value="file312">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/template.go (92.9%)</option>
				
				<option value="file313">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/transition.go (95.0%)</option>
				
				<option value="file314">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/url.go (98.8%)</option>
				
				<option value="file315">github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate/urlpart_string.go (66.7%)</option>
				
				<option value="file316">github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/exec.go (61.6%)</option>
				
				<option value="file317">github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/funcs.go (90.9%)</option>
				
				<option value="file318">github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/helper.go (88.2%)</option>
				
				<option value="file319">github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/hugo_template.go (95.0%)</option>
				
				<option value="file320">github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/option.go (88.2%)</option>
				
				<option value="file321">github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/parse/lex.go (95.8%)</option>
				
				<option value="file322">github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/parse/node.go (79.8%)</option>
				
				<option value="file323">github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/parse/parse.go (93.3%)</option>
				
				<option value="file324">github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/template.go (93.8%)</option>
				
				<option value="file325">github.com/gohugoio/hugo/tpl/internal/templatefuncsRegistry.go (5.0%)</option>
				
				<option value="file326">github.com/gohugoio/hugo/tpl/lang/init.go (100.0%)</option>
				
				<option value="file327">github.com/gohugoio/hugo/tpl/lang/lang.go (69.8%)</option>
				
				<option value="file328">github.com/gohugoio/hugo/tpl/math/init.go (100.0%)</option>
				
				<option value="file329">github.com/gohugoio/hugo/tpl/math/math.go (100.0%)</option>
				
				<option value="file330">github.com/gohugoio/hugo/tpl/math/round.go (100.0%)</option>
				
				<option value="file331">github.com/gohugoio/hugo/tpl/openapi/openapi3/init.go (100.0%)</option>
				
				<option value="file332">github.com/gohugoio/hugo/tpl/openapi/openapi3/openapi3.go (75.9%)</option>
				
				<option value="file333">github.com/gohugoio/hugo/tpl/os/init.go (100.0%)</option>
				
				<option value="file334">github.com/gohugoio/hugo/tpl/os/os.go (61.2%)</option>
				
				<option value="file335">github.com/gohugoio/hugo/tpl/partials/init.go (90.0%)</option>
				
				<option value="file336">github.com/gohugoio/hugo/tpl/partials/partials.go (15.6%)</option>
				
				<option value="file337">github.com/gohugoio/hugo/tpl/path/init.go (100.0%)</option>
				
				<option value="file338">github.com/gohugoio/hugo/tpl/path/path.go (100.0%)</option>
				
				<option value="file339">github.com/gohugoio/hugo/tpl/reflect/init.go (100.0%)</option>
				
				<option value="file340">github.com/gohugoio/hugo/tpl/reflect/reflect.go (100.0%)</option>
				
				<option value="file341">github.com/gohugoio/hugo/tpl/safe/init.go (100.0%)</option>
				
				<option value="file342">github.com/gohugoio/hugo/tpl/safe/safe.go (100.0%)</option>
				
				<option value="file343">github.com/gohugoio/hugo/tpl/site/init.go (87.5%)</option>
				
				<option value="file344">github.com/gohugoio/hugo/tpl/strings/init.go (100.0%)</option>
				
				<option value="file345">github.com/gohugoio/hugo/tpl/strings/regexp.go (93.8%)</option>
				
				<option value="file346">github.com/gohugoio/hugo/tpl/strings/strings.go (92.9%)</option>
				
				<option value="file347">github.com/gohugoio/hugo/tpl/strings/truncate.go (85.7%)</option>
				
				<option value="file348">github.com/gohugoio/hugo/tpl/template.go (57.1%)</option>
				
				<option value="file349">github.com/gohugoio/hugo/tpl/template_info.go (0.0%)</option>
				
				<option value="file350">github.com/gohugoio/hugo/tpl/templates/init.go (100.0%)</option>
				
				<option value="file351">github.com/gohugoio/hugo/tpl/templates/templates.go (100.0%)</option>
				
				<option value="file352">github.com/gohugoio/hugo/tpl/time/init.go (76.5%)</option>
				
				<option value="file353">github.com/gohugoio/hugo/tpl/time/time.go (72.4%)</option>
				
				<option value="file354">github.com/gohugoio/hugo/tpl/tplimpl/shortcodes.go (100.0%)</option>
				
				<option value="file355">github.com/gohugoio/hugo/tpl/tplimpl/template.go (44.5%)</option>
				
				<option value="file356">github.com/gohugoio/hugo/tpl/tplimpl/templateProvider.go (42.9%)</option>
				
				<option value="file357">github.com/gohugoio/hugo/tpl/tplimpl/template_ast_transformers.go (80.6%)</option>
				
				<option value="file358">github.com/gohugoio/hugo/tpl/tplimpl/template_errors.go (20.0%)</option>
				
				<option value="file359">github.com/gohugoio/hugo/tpl/tplimpl/template_funcs.go (70.8%)</option>
				
				<option value="file360">github.com/gohugoio/hugo/tpl/transform/init.go (100.0%)</option>
				
				<option value="file361">github.com/gohugoio/hugo/tpl/transform/remarshal.go (78.8%)</option>
				
				<option value="file362">github.com/gohugoio/hugo/tpl/transform/transform.go (92.1%)</option>
				
				<option value="file363">github.com/gohugoio/hugo/tpl/transform/unmarshal.go (81.9%)</option>
				
				<option value="file364">github.com/gohugoio/hugo/tpl/urls/init.go (100.0%)</option>
				
				<option value="file365">github.com/gohugoio/hugo/tpl/urls/urls.go (7.7%)</option>
				
				<option value="file366">github.com/gohugoio/hugo/transform/chain.go (92.6%)</option>
				
				<option value="file367">github.com/gohugoio/hugo/transform/livereloadinject/livereloadinject.go (96.2%)</option>
				
				<option value="file368">github.com/gohugoio/hugo/transform/metainject/hugogenerator.go (86.7%)</option>
				
				<option value="file369">github.com/gohugoio/hugo/transform/urlreplacers/absurl.go (100.0%)</option>
				
				<option value="file370">github.com/gohugoio/hugo/transform/urlreplacers/absurlreplacer.go (93.1%)</option>
				
				<option value="file371">github.com/gohugoio/hugo/watcher/filenotify/filenotify.go (12.5%)</option>
				
				<option value="file372">github.com/gohugoio/hugo/watcher/filenotify/fsnotify.go (0.0%)</option>
				
				<option value="file373">github.com/gohugoio/hugo/watcher/filenotify/poller.go (85.7%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package bufferpool provides a pool of bytes buffers.
package bufferpool

import (
        "bytes"
        "sync"
)

var bufferPool = &amp;sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return &amp;bytes.Buffer{}
        }</span>,
}

// GetBuffer returns a buffer from the pool.
func GetBuffer() (buf *bytes.Buffer) <span class="cov8" title="1">{
        return bufferPool.Get().(*bytes.Buffer)
}</span>

// PutBuffer returns a buffer to the pool.
// The buffer is reset before it is put back into circulation.
func PutBuffer(buf *bytes.Buffer) <span class="cov8" title="1">{
        buf.Reset()
        bufferPool.Put(buf)
}</span>
</pre>
		
		<pre class="file" id="file1" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package filecache

import (
        "bytes"
        "errors"
        "io"
        "io/ioutil"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "time"

        "github.com/gohugoio/hugo/common/hugio"

        "github.com/gohugoio/hugo/helpers"

        "github.com/BurntSushi/locker"
        "github.com/spf13/afero"
)

// ErrFatal can be used to signal an unrecoverable error.
var ErrFatal = errors.New("fatal filecache error")

const (
        filecacheRootDirname = "filecache"
)

// Cache caches a set of files in a directory. This is usually a file on
// disk, but since this is backed by an Afero file system, it can be anything.
type Cache struct {
        Fs afero.Fs

        // Max age for items in this cache. Negative duration means forever,
        // 0 is effectively turning this cache off.
        maxAge time.Duration

        // When set, we just remove this entire root directory on expiration.
        pruneAllRootDir string

        nlocker *lockTracker
}

type lockTracker struct {
        seenMu sync.RWMutex
        seen   map[string]struct{}

        *locker.Locker
}

// Lock tracks the ids in use. We use this information to do garbage collection
// after a Hugo build.
func (l *lockTracker) Lock(id string) <span class="cov8" title="1">{
        l.seenMu.RLock()
        if _, seen := l.seen[id]; !seen </span><span class="cov8" title="1">{
                l.seenMu.RUnlock()
                l.seenMu.Lock()
                l.seen[id] = struct{}{}
                l.seenMu.Unlock()
        }</span> else<span class="cov8" title="1"> {
                l.seenMu.RUnlock()
        }</span>

        <span class="cov8" title="1">l.Locker.Lock(id)</span>
}

// ItemInfo contains info about a cached file.
type ItemInfo struct {
        // This is the file's name relative to the cache's filesystem.
        Name string
}

// NewCache creates a new file cache with the given filesystem and max age.
func NewCache(fs afero.Fs, maxAge time.Duration, pruneAllRootDir string) *Cache <span class="cov8" title="1">{
        return &amp;Cache{
                Fs:              fs,
                nlocker:         &amp;lockTracker{Locker: locker.NewLocker(), seen: make(map[string]struct{})},
                maxAge:          maxAge,
                pruneAllRootDir: pruneAllRootDir,
        }
}</span>

// lockedFile is a file with a lock that is released on Close.
type lockedFile struct {
        afero.File
        unlock func()
}

func (l *lockedFile) Close() error <span class="cov8" title="1">{
        defer l.unlock()
        return l.File.Close()
}</span>

// WriteCloser returns a transactional writer into the cache.
// It's important that it's closed when done.
func (c *Cache) WriteCloser(id string) (ItemInfo, io.WriteCloser, error) <span class="cov8" title="1">{
        id = cleanID(id)
        c.nlocker.Lock(id)

        info := ItemInfo{Name: id}

        f, err := helpers.OpenFileForWriting(c.Fs, id)
        if err != nil </span><span class="cov0" title="0">{
                c.nlocker.Unlock(id)
                return info, nil, err
        }</span>

        <span class="cov8" title="1">return info, &amp;lockedFile{
                File:   f,
                unlock: func() </span><span class="cov8" title="1">{ c.nlocker.Unlock(id) }</span>,
        }, nil
}

// ReadOrCreate tries to lookup the file in cache.
// If found, it is passed to read and then closed.
// If not found a new file is created and passed to create, which should close
// it when done.
func (c *Cache) ReadOrCreate(id string,
        read func(info ItemInfo, r io.ReadSeeker) error,
        create func(info ItemInfo, w io.WriteCloser) error) (info ItemInfo, err error) <span class="cov8" title="1">{
        id = cleanID(id)

        c.nlocker.Lock(id)
        defer c.nlocker.Unlock(id)

        info = ItemInfo{Name: id}

        if r := c.getOrRemove(id); r != nil </span><span class="cov8" title="1">{
                err = read(info, r)
                defer r.Close()
                if err == nil || err == ErrFatal </span><span class="cov8" title="1">{
                        // See https://github.com/gohugoio/hugo/issues/6401
                        // To recover from file corruption we handle read errors
                        // as the cache item was not found.
                        // Any file permission issue will also fail in the next step.
                        return
                }</span>
        }

        <span class="cov8" title="1">f, err := helpers.OpenFileForWriting(c.Fs, id)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">err = create(info, f)

        return</span>
}

// GetOrCreate tries to get the file with the given id from cache. If not found or expired, create will
// be invoked and the result cached.
// This method is protected by a named lock using the given id as identifier.
func (c *Cache) GetOrCreate(id string, create func() (io.ReadCloser, error)) (ItemInfo, io.ReadCloser, error) <span class="cov8" title="1">{
        id = cleanID(id)

        c.nlocker.Lock(id)
        defer c.nlocker.Unlock(id)

        info := ItemInfo{Name: id}

        if r := c.getOrRemove(id); r != nil </span><span class="cov8" title="1">{
                return info, r, nil
        }</span>

        <span class="cov8" title="1">var (
                r   io.ReadCloser
                err error
        )

        r, err = create()
        if err != nil </span><span class="cov0" title="0">{
                return info, nil, err
        }</span>

        <span class="cov8" title="1">if c.maxAge == 0 </span><span class="cov0" title="0">{
                // No caching.
                return info, hugio.ToReadCloser(r), nil
        }</span>

        <span class="cov8" title="1">var buff bytes.Buffer
        return info,
                hugio.ToReadCloser(&amp;buff),
                afero.WriteReader(c.Fs, id, io.TeeReader(r, &amp;buff))</span>
}

// GetOrCreateBytes is the same as GetOrCreate, but produces a byte slice.
func (c *Cache) GetOrCreateBytes(id string, create func() ([]byte, error)) (ItemInfo, []byte, error) <span class="cov8" title="1">{
        id = cleanID(id)

        c.nlocker.Lock(id)
        defer c.nlocker.Unlock(id)

        info := ItemInfo{Name: id}

        if r := c.getOrRemove(id); r != nil </span><span class="cov8" title="1">{
                defer r.Close()
                b, err := ioutil.ReadAll(r)
                return info, b, err
        }</span>

        <span class="cov8" title="1">var (
                b   []byte
                err error
        )

        b, err = create()
        if err != nil </span><span class="cov0" title="0">{
                return info, nil, err
        }</span>

        <span class="cov8" title="1">if c.maxAge == 0 </span><span class="cov0" title="0">{
                return info, b, nil
        }</span>

        <span class="cov8" title="1">if err := afero.WriteReader(c.Fs, id, bytes.NewReader(b)); err != nil </span><span class="cov0" title="0">{
                return info, nil, err
        }</span>
        <span class="cov8" title="1">return info, b, nil</span>
}

// GetBytes gets the file content with the given id from the cache, nil if none found.
func (c *Cache) GetBytes(id string) (ItemInfo, []byte, error) <span class="cov8" title="1">{
        id = cleanID(id)

        c.nlocker.Lock(id)
        defer c.nlocker.Unlock(id)

        info := ItemInfo{Name: id}

        if r := c.getOrRemove(id); r != nil </span><span class="cov8" title="1">{
                defer r.Close()
                b, err := ioutil.ReadAll(r)
                return info, b, err
        }</span>

        <span class="cov0" title="0">return info, nil, nil</span>
}

// Get gets the file with the given id from the cahce, nil if none found.
func (c *Cache) Get(id string) (ItemInfo, io.ReadCloser, error) <span class="cov8" title="1">{
        id = cleanID(id)

        c.nlocker.Lock(id)
        defer c.nlocker.Unlock(id)

        info := ItemInfo{Name: id}

        r := c.getOrRemove(id)

        return info, r, nil
}</span>

// getOrRemove gets the file with the given id. If it's expired, it will
// be removed.
func (c *Cache) getOrRemove(id string) hugio.ReadSeekCloser <span class="cov8" title="1">{
        if c.maxAge == 0 </span><span class="cov0" title="0">{
                // No caching.
                return nil
        }</span>

        <span class="cov8" title="1">if c.maxAge &gt; 0 </span><span class="cov8" title="1">{
                fi, err := c.Fs.Stat(id)
                if err != nil </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">if c.isExpired(fi.ModTime()) </span><span class="cov0" title="0">{
                        c.Fs.Remove(id)
                        return nil
                }</span>
        }

        <span class="cov8" title="1">f, err := c.Fs.Open(id)
        if err != nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return f</span>
}

func (c *Cache) isExpired(modTime time.Time) bool <span class="cov8" title="1">{
        if c.maxAge &lt; 0 </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return c.maxAge == 0 || time.Since(modTime) &gt; c.maxAge</span>
}

// For testing
func (c *Cache) getString(id string) string <span class="cov8" title="1">{
        id = cleanID(id)

        c.nlocker.Lock(id)
        defer c.nlocker.Unlock(id)

        f, err := c.Fs.Open(id)
        if err != nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">defer f.Close()

        b, _ := ioutil.ReadAll(f)
        return string(b)</span>
}

// Caches is a named set of caches.
type Caches map[string]*Cache

// Get gets a named cache, nil if none found.
func (f Caches) Get(name string) *Cache <span class="cov8" title="1">{
        return f[strings.ToLower(name)]
}</span>

// NewCaches creates a new set of file caches from the given
// configuration.
func NewCaches(p *helpers.PathSpec) (Caches, error) <span class="cov8" title="1">{
        var dcfg Configs
        if c, ok := p.Cfg.Get("filecacheConfigs").(Configs); ok </span><span class="cov0" title="0">{
                dcfg = c
        }</span> else<span class="cov8" title="1"> {
                var err error
                dcfg, err = DecodeConfig(p.Fs.Source, p.Cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">fs := p.Fs.Source

        m := make(Caches)
        for k, v := range dcfg </span><span class="cov8" title="1">{
                var cfs afero.Fs

                if v.isResourceDir </span><span class="cov8" title="1">{
                        cfs = p.BaseFs.ResourcesCache
                }</span> else<span class="cov8" title="1"> {
                        cfs = fs
                }</span>

                <span class="cov8" title="1">if cfs == nil </span><span class="cov0" title="0">{
                        // TODO(bep) we still have some places that do not initialize the
                        // full dependencies of a site, e.g. the import Jekyll command.
                        // That command does not need these caches, so let us just continue
                        // for now.
                        continue</span>
                }

                <span class="cov8" title="1">baseDir := v.Dir

                if err := cfs.MkdirAll(baseDir, 0777); err != nil &amp;&amp; !os.IsExist(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">bfs := afero.NewBasePathFs(cfs, baseDir)

                var pruneAllRootDir string
                if k == cacheKeyModules </span><span class="cov8" title="1">{
                        pruneAllRootDir = "pkg"
                }</span>

                <span class="cov8" title="1">m[k] = NewCache(bfs, v.MaxAge, pruneAllRootDir)</span>
        }

        <span class="cov8" title="1">return m, nil</span>
}

func cleanID(name string) string <span class="cov8" title="1">{
        return strings.TrimPrefix(filepath.Clean(name), helpers.FilePathSeparator)
}</span>
</pre>
		
		<pre class="file" id="file2" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package filecache

import (
        "path"
        "path/filepath"
        "strings"
        "time"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/config"

        "github.com/gohugoio/hugo/helpers"

        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"
        "github.com/spf13/afero"
)

const (
        cachesConfigKey = "caches"

        resourcesGenDir = ":resourceDir/_gen"
        cacheDirProject = ":cacheDir/:project"
)

var defaultCacheConfig = Config{
        MaxAge: -1, // Never expire
        Dir:    cacheDirProject,
}

const (
        cacheKeyGetJSON     = "getjson"
        cacheKeyGetCSV      = "getcsv"
        cacheKeyImages      = "images"
        cacheKeyAssets      = "assets"
        cacheKeyModules     = "modules"
        cacheKeyGetResource = "getresource"
)

type Configs map[string]Config

func (c Configs) CacheDirModules() string <span class="cov0" title="0">{
        return c[cacheKeyModules].Dir
}</span>

var defaultCacheConfigs = Configs{
        cacheKeyModules: {
                MaxAge: -1,
                Dir:    ":cacheDir/modules",
        },
        cacheKeyGetJSON: defaultCacheConfig,
        cacheKeyGetCSV:  defaultCacheConfig,
        cacheKeyImages: {
                MaxAge: -1,
                Dir:    resourcesGenDir,
        },
        cacheKeyAssets: {
                MaxAge: -1,
                Dir:    resourcesGenDir,
        },
        cacheKeyGetResource: Config{
                MaxAge: -1, // Never expire
                Dir:    cacheDirProject,
        },
}

type Config struct {
        // Max age of cache entries in this cache. Any items older than this will
        // be removed and not returned from the cache.
        // a negative value means forever, 0 means cache is disabled.
        MaxAge time.Duration

        // The directory where files are stored.
        Dir string

        // Will resources/_gen will get its own composite filesystem that
        // also checks any theme.
        isResourceDir bool
}

// GetJSONCache gets the file cache for getJSON.
func (f Caches) GetJSONCache() *Cache <span class="cov8" title="1">{
        return f[cacheKeyGetJSON]
}</span>

// GetCSVCache gets the file cache for getCSV.
func (f Caches) GetCSVCache() *Cache <span class="cov8" title="1">{
        return f[cacheKeyGetCSV]
}</span>

// ImageCache gets the file cache for processed images.
func (f Caches) ImageCache() *Cache <span class="cov8" title="1">{
        return f[cacheKeyImages]
}</span>

// ModulesCache gets the file cache for Hugo Modules.
func (f Caches) ModulesCache() *Cache <span class="cov0" title="0">{
        return f[cacheKeyModules]
}</span>

// AssetsCache gets the file cache for assets (processed resources, SCSS etc.).
func (f Caches) AssetsCache() *Cache <span class="cov8" title="1">{
        return f[cacheKeyAssets]
}</span>

// GetResourceCache gets the file cache for remote resources.
func (f Caches) GetResourceCache() *Cache <span class="cov0" title="0">{
        return f[cacheKeyGetResource]
}</span>

func DecodeConfig(fs afero.Fs, cfg config.Provider) (Configs, error) <span class="cov8" title="1">{
        c := make(Configs)
        valid := make(map[string]bool)
        // Add defaults
        for k, v := range defaultCacheConfigs </span><span class="cov8" title="1">{
                c[k] = v
                valid[k] = true
        }</span>

        <span class="cov8" title="1">m := cfg.GetStringMap(cachesConfigKey)

        _, isOsFs := fs.(*afero.OsFs)

        for k, v := range m </span><span class="cov8" title="1">{
                if _, ok := v.(maps.Params); !ok </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">cc := defaultCacheConfig

                dc := &amp;mapstructure.DecoderConfig{
                        Result:           &amp;cc,
                        DecodeHook:       mapstructure.StringToTimeDurationHookFunc(),
                        WeaklyTypedInput: true,
                }

                decoder, err := mapstructure.NewDecoder(dc)
                if err != nil </span><span class="cov0" title="0">{
                        return c, err
                }</span>

                <span class="cov8" title="1">if err := decoder.Decode(v); err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to decode filecache config")
                }</span>

                <span class="cov8" title="1">if cc.Dir == "" </span><span class="cov0" title="0">{
                        return c, errors.New("must provide cache Dir")
                }</span>

                <span class="cov8" title="1">name := strings.ToLower(k)
                if !valid[name] </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%q is not a valid cache name", name)
                }</span>

                <span class="cov8" title="1">c[name] = cc</span>
        }

        // This is a very old flag in Hugo, but we need to respect it.
        <span class="cov8" title="1">disabled := cfg.GetBool("ignoreCache")

        for k, v := range c </span><span class="cov8" title="1">{
                dir := filepath.ToSlash(filepath.Clean(v.Dir))
                hadSlash := strings.HasPrefix(dir, "/")
                parts := strings.Split(dir, "/")

                for i, part := range parts </span><span class="cov8" title="1">{
                        if strings.HasPrefix(part, ":") </span><span class="cov8" title="1">{
                                resolved, isResource, err := resolveDirPlaceholder(fs, cfg, part)
                                if err != nil </span><span class="cov0" title="0">{
                                        return c, err
                                }</span>
                                <span class="cov8" title="1">if isResource </span><span class="cov8" title="1">{
                                        v.isResourceDir = true
                                }</span>
                                <span class="cov8" title="1">parts[i] = resolved</span>
                        }
                }

                <span class="cov8" title="1">dir = path.Join(parts...)
                if hadSlash </span><span class="cov8" title="1">{
                        dir = "/" + dir
                }</span>
                <span class="cov8" title="1">v.Dir = filepath.Clean(filepath.FromSlash(dir))

                if !v.isResourceDir </span><span class="cov8" title="1">{
                        if isOsFs &amp;&amp; !filepath.IsAbs(v.Dir) </span><span class="cov0" title="0">{
                                return c, errors.Errorf("%q must resolve to an absolute directory", v.Dir)
                        }</span>

                        // Avoid cache in root, e.g. / (Unix) or c:\ (Windows)
                        <span class="cov8" title="1">if len(strings.TrimPrefix(v.Dir, filepath.VolumeName(v.Dir))) == 1 </span><span class="cov8" title="1">{
                                return c, errors.Errorf("%q is a root folder and not allowed as cache dir", v.Dir)
                        }</span>
                }

                <span class="cov8" title="1">if !strings.HasPrefix(v.Dir, "_gen") </span><span class="cov8" title="1">{
                        // We do cache eviction (file removes) and since the user can set
                        // his/hers own cache directory, we really want to make sure
                        // we do not delete any files that do not belong to this cache.
                        // We do add the cache name as the root, but this is an extra safe
                        // guard. We skip the files inside /resources/_gen/ because
                        // that would be breaking.
                        v.Dir = filepath.Join(v.Dir, filecacheRootDirname, k)
                }</span> else<span class="cov8" title="1"> {
                        v.Dir = filepath.Join(v.Dir, k)
                }</span>

                <span class="cov8" title="1">if disabled </span><span class="cov8" title="1">{
                        v.MaxAge = 0
                }</span>

                <span class="cov8" title="1">c[k] = v</span>
        }

        <span class="cov8" title="1">return c, nil</span>
}

// Resolves :resourceDir =&gt; /myproject/resources etc., :cacheDir =&gt; ...
func resolveDirPlaceholder(fs afero.Fs, cfg config.Provider, placeholder string) (cacheDir string, isResource bool, err error) <span class="cov8" title="1">{
        workingDir := cfg.GetString("workingDir")

        switch strings.ToLower(placeholder) </span>{
        case ":resourcedir":<span class="cov8" title="1">
                return "", true, nil</span>
        case ":cachedir":<span class="cov8" title="1">
                d, err := helpers.GetCacheDir(fs, cfg)
                return d, false, err</span>
        case ":project":<span class="cov8" title="1">
                return filepath.Base(workingDir), false, nil</span>
        }

        <span class="cov0" title="0">return "", false, errors.Errorf("%q is not a valid placeholder (valid values are :cacheDir or :resourceDir)", placeholder)</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package filecache

import (
        "io"
        "os"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/pkg/errors"
        "github.com/spf13/afero"
)

// Prune removes expired and unused items from this cache.
// The last one requires a full build so the cache usage can be tracked.
// Note that we operate directly on the filesystem here, so this is not
// thread safe.
func (c Caches) Prune() (int, error) <span class="cov8" title="1">{
        counter := 0
        for k, cache := range c </span><span class="cov8" title="1">{

                count, err := cache.Prune(false)

                counter += count

                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return counter, errors.Wrapf(err, "failed to prune cache %q", k)</span>
                }

        }

        <span class="cov8" title="1">return counter, nil</span>
}

// Prune removes expired and unused items from this cache.
// If force is set, everything will be removed not considering expiry time.
func (c *Cache) Prune(force bool) (int, error) <span class="cov8" title="1">{
        if c.pruneAllRootDir != "" </span><span class="cov8" title="1">{
                return c.pruneRootDir(force)
        }</span>

        <span class="cov8" title="1">counter := 0

        err := afero.Walk(c.Fs, "", func(name string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if info == nil </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov8" title="1">name = cleanID(name)

                if info.IsDir() </span><span class="cov8" title="1">{
                        f, err := c.Fs.Open(name)
                        if err != nil </span><span class="cov8" title="1">{
                                // This cache dir may not exist.
                                return nil
                        }</span>
                        <span class="cov8" title="1">defer f.Close()
                        _, err = f.Readdirnames(1)
                        if err == io.EOF </span><span class="cov8" title="1">{
                                // Empty dir.
                                err = c.Fs.Remove(name)
                        }</span>

                        <span class="cov8" title="1">if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                }

                <span class="cov8" title="1">shouldRemove := force || c.isExpired(info.ModTime())

                if !shouldRemove &amp;&amp; len(c.nlocker.seen) &gt; 0 </span><span class="cov8" title="1">{
                        // Remove it if it's not been touched/used in the last build.
                        _, seen := c.nlocker.seen[name]
                        shouldRemove = !seen
                }</span>

                <span class="cov8" title="1">if shouldRemove </span><span class="cov8" title="1">{
                        err := c.Fs.Remove(name)
                        if err == nil </span><span class="cov8" title="1">{
                                counter++
                        }</span>

                        <span class="cov8" title="1">if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return err
                        }</span>

                }

                <span class="cov8" title="1">return nil</span>
        })

        <span class="cov8" title="1">return counter, err</span>
}

func (c *Cache) pruneRootDir(force bool) (int, error) <span class="cov8" title="1">{
        info, err := c.Fs.Stat(c.pruneAllRootDir)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return 0, nil
                }</span>
                <span class="cov0" title="0">return 0, err</span>
        }

        <span class="cov0" title="0">if !force &amp;&amp; !c.isExpired(info.ModTime()) </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov0" title="0">return hugofs.MakeReadableAndRemoveAllModulePkgDir(c.Fs, c.pruneAllRootDir)</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package namedmemcache provides a memory cache with a named lock. This is suitable
// for situations where creating the cached resource can be time consuming or otherwise
// resource hungry, or in situations where a "once only per key" is a requirement.
package namedmemcache

import (
        "sync"

        "github.com/BurntSushi/locker"
)

// Cache holds the cached values.
type Cache struct {
        nlocker *locker.Locker
        cache   map[string]cacheEntry
        mu      sync.RWMutex
}

type cacheEntry struct {
        value interface{}
        err   error
}

// New creates a new cache.
func New() *Cache <span class="cov8" title="1">{
        return &amp;Cache{
                nlocker: locker.NewLocker(),
                cache:   make(map[string]cacheEntry),
        }
}</span>

// Clear clears the cache state.
func (c *Cache) Clear() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.cache = make(map[string]cacheEntry)
        c.nlocker = locker.NewLocker()
}</span>

// GetOrCreate tries to get the value with the given cache key, if not found
// create will be called and cached.
// This method is thread safe. It also guarantees that the create func for a given
// key is invoked only once for this cache.
func (c *Cache) GetOrCreate(key string, create func() (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        c.mu.RLock()
        entry, found := c.cache[key]
        c.mu.RUnlock()

        if found </span><span class="cov8" title="1">{
                return entry.value, entry.err
        }</span>

        <span class="cov8" title="1">c.nlocker.Lock(key)
        defer c.nlocker.Unlock(key)

        // Create it.
        value, err := create()

        c.mu.Lock()
        c.cache[key] = cacheEntry{value: value, err: err}
        c.mu.Unlock()

        return value, err</span>
}
</pre>
		
		<pre class="file" id="file5" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
// Some functions in this file (see comments) is based on the Go source code,
// copyright The Go Authors and  governed by a BSD-style license.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package codegen contains helpers for code generation.
package codegen

import (
        "fmt"
        "go/ast"
        "go/parser"
        "go/token"
        "os"
        "path"
        "path/filepath"
        "reflect"
        "regexp"
        "sort"
        "strings"
        "sync"
)

// Make room for insertions
const weightWidth = 1000

// NewInspector creates a new Inspector given a source root.
func NewInspector(root string) *Inspector <span class="cov8" title="1">{
        return &amp;Inspector{ProjectRootDir: root}
}</span>

// Inspector provides methods to help code generation. It uses a combination
// of reflection and source code AST to do the heavy lifting.
type Inspector struct {
        ProjectRootDir string

        init sync.Once

        // Determines method order. Go's reflect sorts lexicographically, so
        // we must parse the source to preserve this order.
        methodWeight map[string]map[string]int
}

// MethodsFromTypes create a method set from the include slice, excluding any
// method in exclude.
func (c *Inspector) MethodsFromTypes(include []reflect.Type, exclude []reflect.Type) Methods <span class="cov8" title="1">{
        c.parseSource()

        var methods Methods

        excludes := make(map[string]bool)

        if len(exclude) &gt; 0 </span><span class="cov8" title="1">{
                for _, m := range c.MethodsFromTypes(exclude, nil) </span><span class="cov8" title="1">{
                        excludes[m.Name] = true
                }</span>
        }

        // There may be overlapping interfaces in types. Do a simple check for now.
        <span class="cov8" title="1">seen := make(map[string]bool)

        nameAndPackage := func(t reflect.Type) (string, string) </span><span class="cov8" title="1">{
                var name, pkg string

                isPointer := t.Kind() == reflect.Ptr

                if isPointer </span><span class="cov8" title="1">{
                        t = t.Elem()
                }</span>

                <span class="cov8" title="1">pkgPrefix := ""
                if pkgPath := t.PkgPath(); pkgPath != "" </span><span class="cov8" title="1">{
                        pkgPath = strings.TrimSuffix(pkgPath, "/")
                        _, shortPath := path.Split(pkgPath)
                        pkgPrefix = shortPath + "."
                        pkg = pkgPath
                }</span>

                <span class="cov8" title="1">name = t.Name()
                if name == "" </span><span class="cov8" title="1">{
                        // interface{}
                        name = t.String()
                }</span>

                <span class="cov8" title="1">if isPointer </span><span class="cov8" title="1">{
                        pkgPrefix = "*" + pkgPrefix
                }</span>

                <span class="cov8" title="1">name = pkgPrefix + name

                return name, pkg</span>
        }

        <span class="cov8" title="1">for _, t := range include </span><span class="cov8" title="1">{
                for i := 0; i &lt; t.NumMethod(); i++ </span><span class="cov8" title="1">{

                        m := t.Method(i)
                        if excludes[m.Name] || seen[m.Name] </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">seen[m.Name] = true

                        if m.PkgPath != "" </span><span class="cov8" title="1">{
                                // Not exported
                                continue</span>
                        }

                        <span class="cov8" title="1">numIn := m.Type.NumIn()

                        ownerName, _ := nameAndPackage(t)

                        method := Method{Owner: t, OwnerName: ownerName, Name: m.Name}

                        for i := 0; i &lt; numIn; i++ </span><span class="cov8" title="1">{
                                in := m.Type.In(i)

                                name, pkg := nameAndPackage(in)

                                if pkg != "" </span><span class="cov8" title="1">{
                                        method.Imports = append(method.Imports, pkg)
                                }</span>

                                <span class="cov8" title="1">method.In = append(method.In, name)</span>
                        }

                        <span class="cov8" title="1">numOut := m.Type.NumOut()

                        if numOut &gt; 0 </span><span class="cov8" title="1">{
                                for i := 0; i &lt; numOut; i++ </span><span class="cov8" title="1">{
                                        out := m.Type.Out(i)
                                        name, pkg := nameAndPackage(out)

                                        if pkg != "" </span><span class="cov8" title="1">{
                                                method.Imports = append(method.Imports, pkg)
                                        }</span>

                                        <span class="cov8" title="1">method.Out = append(method.Out, name)</span>
                                }
                        }

                        <span class="cov8" title="1">methods = append(methods, method)</span>
                }
        }

        <span class="cov8" title="1">sort.SliceStable(methods, func(i, j int) bool </span><span class="cov8" title="1">{
                mi, mj := methods[i], methods[j]

                wi := c.methodWeight[mi.OwnerName][mi.Name]
                wj := c.methodWeight[mj.OwnerName][mj.Name]

                if wi == wj </span><span class="cov0" title="0">{
                        return mi.Name &lt; mj.Name
                }</span>

                <span class="cov8" title="1">return wi &lt; wj</span>
        })

        <span class="cov8" title="1">return methods</span>
}

func (c *Inspector) parseSource() <span class="cov8" title="1">{
        c.init.Do(func() </span><span class="cov8" title="1">{
                if !strings.Contains(c.ProjectRootDir, "hugo") </span><span class="cov0" title="0">{
                        panic("dir must be set to the Hugo root")</span>
                }

                <span class="cov8" title="1">c.methodWeight = make(map[string]map[string]int)
                dirExcludes := regexp.MustCompile("docs|examples")
                fileExcludes := regexp.MustCompile("autogen")
                var filenames []string

                filepath.Walk(c.ProjectRootDir, func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                        if info.IsDir() </span><span class="cov8" title="1">{
                                if dirExcludes.MatchString(info.Name()) </span><span class="cov0" title="0">{
                                        return filepath.SkipDir
                                }</span>
                        }

                        <span class="cov8" title="1">if !strings.HasSuffix(path, ".go") || fileExcludes.MatchString(path) </span><span class="cov8" title="1">{
                                return nil
                        }</span>

                        <span class="cov8" title="1">filenames = append(filenames, path)

                        return nil</span>
                })

                <span class="cov8" title="1">for _, filename := range filenames </span><span class="cov8" title="1">{

                        pkg := c.packageFromPath(filename)

                        fset := token.NewFileSet()
                        node, err := parser.ParseFile(fset, filename, nil, parser.ParseComments)
                        if err != nil </span><span class="cov0" title="0">{
                                panic(err)</span>
                        }

                        <span class="cov8" title="1">ast.Inspect(node, func(n ast.Node) bool </span><span class="cov8" title="1">{
                                switch t := n.(type) </span>{
                                case *ast.TypeSpec:<span class="cov8" title="1">
                                        if t.Name.IsExported() </span><span class="cov8" title="1">{
                                                switch it := t.Type.(type) </span>{
                                                case *ast.InterfaceType:<span class="cov8" title="1">
                                                        iface := pkg + "." + t.Name.Name
                                                        methodNames := collectMethodsRecursive(pkg, it.Methods.List)
                                                        weights := make(map[string]int)
                                                        weight := weightWidth
                                                        for _, name := range methodNames </span><span class="cov8" title="1">{
                                                                weights[name] = weight
                                                                weight += weightWidth
                                                        }</span>
                                                        <span class="cov8" title="1">c.methodWeight[iface] = weights</span>
                                                }
                                        }
                                }
                                <span class="cov8" title="1">return true</span>
                        })

                }

                // Complement
                <span class="cov8" title="1">for _, v1 := range c.methodWeight </span><span class="cov8" title="1">{
                        for k2, w := range v1 </span><span class="cov8" title="1">{
                                if v, found := c.methodWeight[k2]; found </span><span class="cov8" title="1">{
                                        for k3, v3 := range v </span><span class="cov8" title="1">{
                                                v1[k3] = (v3 / weightWidth) + w
                                        }</span>
                                }
                        }
                }
        })
}

func (c *Inspector) packageFromPath(p string) string <span class="cov8" title="1">{
        p = filepath.ToSlash(p)
        base := path.Base(p)
        if !strings.Contains(base, ".") </span><span class="cov0" title="0">{
                return base
        }</span>
        <span class="cov8" title="1">return path.Base(strings.TrimSuffix(p, base))</span>
}

// Method holds enough information about it to recreate it.
type Method struct {
        // The interface we extracted this method from.
        Owner reflect.Type

        // String version of the above, on the form PACKAGE.NAME, e.g.
        // page.Page
        OwnerName string

        // Method name.
        Name string

        // Imports needed to satisfy the method signature.
        Imports []string

        // Argument types, including any package prefix, e.g. string, int, interface{},
        // net.Url
        In []string

        // Return types.
        Out []string
}

// Declaration creates a method declaration (without any body) for the given receiver.
func (m Method) Declaration(receiver string) string <span class="cov0" title="0">{
        return fmt.Sprintf("func (%s %s) %s%s %s", receiverShort(receiver), receiver, m.Name, m.inStr(), m.outStr())
}</span>

// DeclarationNamed creates a method declaration (without any body) for the given receiver
// with named return values.
func (m Method) DeclarationNamed(receiver string) string <span class="cov0" title="0">{
        return fmt.Sprintf("func (%s %s) %s%s %s", receiverShort(receiver), receiver, m.Name, m.inStr(), m.outStrNamed())
}</span>

// Delegate creates a delegate call string.
func (m Method) Delegate(receiver, delegate string) string <span class="cov0" title="0">{
        ret := ""
        if len(m.Out) &gt; 0 </span><span class="cov0" title="0">{
                ret = "return "
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s%s.%s.%s%s", ret, receiverShort(receiver), delegate, m.Name, m.inOutStr())</span>
}

func (m Method) String() string <span class="cov8" title="1">{
        return m.Name + m.inStr() + " " + m.outStr() + "\n"
}</span>

func (m Method) inOutStr() string <span class="cov0" title="0">{
        if len(m.In) == 0 </span><span class="cov0" title="0">{
                return "()"
        }</span>

        <span class="cov0" title="0">args := make([]string, len(m.In))
        for i := 0; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                args[i] = fmt.Sprintf("arg%d", i)
        }</span>
        <span class="cov0" title="0">return "(" + strings.Join(args, ", ") + ")"</span>
}

func (m Method) inStr() string <span class="cov8" title="1">{
        if len(m.In) == 0 </span><span class="cov8" title="1">{
                return "()"
        }</span>

        <span class="cov8" title="1">args := make([]string, len(m.In))
        for i := 0; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                args[i] = fmt.Sprintf("arg%d %s", i, m.In[i])
        }</span>
        <span class="cov8" title="1">return "(" + strings.Join(args, ", ") + ")"</span>
}

func (m Method) outStr() string <span class="cov8" title="1">{
        if len(m.Out) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if len(m.Out) == 1 </span><span class="cov8" title="1">{
                return m.Out[0]
        }</span>

        <span class="cov8" title="1">return "(" + strings.Join(m.Out, ", ") + ")"</span>
}

func (m Method) outStrNamed() string <span class="cov0" title="0">{
        if len(m.Out) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">outs := make([]string, len(m.Out))
        for i := 0; i &lt; len(outs); i++ </span><span class="cov0" title="0">{
                outs[i] = fmt.Sprintf("o%d %s", i, m.Out[i])
        }</span>

        <span class="cov0" title="0">return "(" + strings.Join(outs, ", ") + ")"</span>
}

// Methods represents a list of methods for one or more interfaces.
// The order matches the defined order in their source file(s).
type Methods []Method

// Imports returns a sorted list of package imports needed to satisfy the
// signatures of all methods.
func (m Methods) Imports() []string <span class="cov8" title="1">{
        var pkgImports []string
        for _, method := range m </span><span class="cov8" title="1">{
                pkgImports = append(pkgImports, method.Imports...)
        }</span>
        <span class="cov8" title="1">if len(pkgImports) &gt; 0 </span><span class="cov8" title="1">{
                pkgImports = uniqueNonEmptyStrings(pkgImports)
                sort.Strings(pkgImports)
        }</span>
        <span class="cov8" title="1">return pkgImports</span>
}

// ToMarshalJSON creates a MarshalJSON method for these methods. Any method name
// matching any of the regexps in excludes will be ignored.
func (m Methods) ToMarshalJSON(receiver, pkgPath string, excludes ...string) (string, []string) <span class="cov8" title="1">{
        var sb strings.Builder

        r := receiverShort(receiver)
        what := firstToUpper(trimAsterisk(receiver))
        pgkName := path.Base(pkgPath)

        fmt.Fprintf(&amp;sb, "func Marshal%sToJSON(%s %s) ([]byte, error) {\n", what, r, receiver)

        var methods Methods
        excludeRes := make([]*regexp.Regexp, len(excludes))

        for i, exclude := range excludes </span><span class="cov0" title="0">{
                excludeRes[i] = regexp.MustCompile(exclude)
        }</span>

        <span class="cov8" title="1">for _, method := range m </span><span class="cov8" title="1">{
                // Exclude methods with arguments and incompatible return values
                if len(method.In) &gt; 0 || len(method.Out) == 0 || len(method.Out) &gt; 2 </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if len(method.Out) == 2 </span><span class="cov8" title="1">{
                        if method.Out[1] != "error" </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov8" title="1">for _, re := range excludeRes </span><span class="cov0" title="0">{
                        if re.MatchString(method.Name) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov8" title="1">methods = append(methods, method)</span>
        }

        <span class="cov8" title="1">for _, method := range methods </span><span class="cov8" title="1">{
                varn := varName(method.Name)
                if len(method.Out) == 1 </span><span class="cov8" title="1">{
                        fmt.Fprintf(&amp;sb, "\t%s := %s.%s()\n", varn, r, method.Name)
                }</span> else<span class="cov8" title="1"> {
                        fmt.Fprintf(&amp;sb, "\t%s, err := %s.%s()\n", varn, r, method.Name)
                        fmt.Fprint(&amp;sb, "\tif err != nil {\n\t\treturn nil, err\n\t}\n")
                }</span>
        }

        <span class="cov8" title="1">fmt.Fprint(&amp;sb, "\n\ts := struct {\n")

        for _, method := range methods </span><span class="cov8" title="1">{
                fmt.Fprintf(&amp;sb, "\t\t%s %s\n", method.Name, typeName(method.Out[0], pgkName))
        }</span>

        <span class="cov8" title="1">fmt.Fprint(&amp;sb, "\n\t}{\n")

        for _, method := range methods </span><span class="cov8" title="1">{
                varn := varName(method.Name)
                fmt.Fprintf(&amp;sb, "\t\t%s: %s,\n", method.Name, varn)
        }</span>

        <span class="cov8" title="1">fmt.Fprint(&amp;sb, "\n\t}\n\n")
        fmt.Fprint(&amp;sb, "\treturn json.Marshal(&amp;s)\n}")

        pkgImports := append(methods.Imports(), "encoding/json")

        if pkgPath != "" </span><span class="cov8" title="1">{
                // Exclude self
                for i, pkgImp := range pkgImports </span><span class="cov8" title="1">{
                        if pkgImp == pkgPath </span><span class="cov0" title="0">{
                                pkgImports = append(pkgImports[:i], pkgImports[i+1:]...)
                        }</span>
                }
        }

        <span class="cov8" title="1">return sb.String(), pkgImports</span>
}

func collectMethodsRecursive(pkg string, f []*ast.Field) []string <span class="cov8" title="1">{
        var methodNames []string
        for _, m := range f </span><span class="cov8" title="1">{
                if m.Names != nil </span><span class="cov8" title="1">{
                        methodNames = append(methodNames, m.Names[0].Name)
                        continue</span>
                }

                <span class="cov8" title="1">if ident, ok := m.Type.(*ast.Ident); ok &amp;&amp; ident.Obj != nil </span><span class="cov0" title="0">{
                        // Embedded interface
                        methodNames = append(
                                methodNames,
                                collectMethodsRecursive(
                                        pkg,
                                        ident.Obj.Decl.(*ast.TypeSpec).Type.(*ast.InterfaceType).Methods.List)...)
                }</span> else<span class="cov8" title="1"> {
                        // Embedded, but in a different file/package. Return the
                        // package.Name and deal with that later.
                        name := packageName(m.Type)
                        if !strings.Contains(name, ".") </span><span class="cov8" title="1">{
                                // Assume current package
                                name = pkg + "." + name
                        }</span>
                        <span class="cov8" title="1">methodNames = append(methodNames, name)</span>
                }
        }

        <span class="cov8" title="1">return methodNames</span>
}

func firstToLower(name string) string <span class="cov8" title="1">{
        return strings.ToLower(name[:1]) + name[1:]
}</span>

func firstToUpper(name string) string <span class="cov8" title="1">{
        return strings.ToUpper(name[:1]) + name[1:]
}</span>

func packageName(e ast.Expr) string <span class="cov8" title="1">{
        switch tp := e.(type) </span>{
        case *ast.Ident:<span class="cov8" title="1">
                return tp.Name</span>
        case *ast.SelectorExpr:<span class="cov0" title="0">
                return fmt.Sprintf("%s.%s", packageName(tp.X), packageName(tp.Sel))</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func receiverShort(receiver string) string <span class="cov8" title="1">{
        return strings.ToLower(trimAsterisk(receiver))[:1]
}</span>

func trimAsterisk(name string) string <span class="cov8" title="1">{
        return strings.TrimPrefix(name, "*")
}</span>

func typeName(name, pkg string) string <span class="cov8" title="1">{
        return strings.TrimPrefix(name, pkg+".")
}</span>

func uniqueNonEmptyStrings(s []string) []string <span class="cov8" title="1">{
        var unique []string
        set := map[string]interface{}{}
        for _, val := range s </span><span class="cov8" title="1">{
                if val == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if _, ok := set[val]; !ok </span><span class="cov8" title="1">{
                        unique = append(unique, val)
                        set[val] = val
                }</span>
        }
        <span class="cov8" title="1">return unique</span>
}

func varName(name string) string <span class="cov8" title="1">{
        name = firstToLower(name)

        // Adjust some reserved keywords, see https://golang.org/ref/spec#Keywords
        switch name </span>{
        case "type":<span class="cov0" title="0">
                name = "typ"</span>
        case "package":<span class="cov0" title="0">
                name = "pkg"</span>
                // Not reserved, but syntax highlighters has it as a keyword.
        case "len":<span class="cov0" title="0">
                name = "length"</span>
        }

        <span class="cov8" title="1">return name</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "errors"
        "io/ioutil"
        "os"
        "path/filepath"
        "regexp"
        "sync"
        "time"

        hconfig "github.com/gohugoio/hugo/config"

        "golang.org/x/sync/semaphore"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/hugo"

        jww "github.com/spf13/jwalterweatherman"

        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/config"

        "github.com/spf13/cobra"

        "github.com/gohugoio/hugo/hugolib"
        "github.com/spf13/afero"

        "github.com/bep/debounce"
        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/langs"
)

type commandeerHugoState struct {
        *deps.DepsCfg
        hugoSites *hugolib.HugoSites
        fsCreate  sync.Once
        created   chan struct{}
}

type commandeer struct {
        *commandeerHugoState

        logger       loggers.Logger
        serverConfig *config.Server

        buildLock func() (unlock func(), err error)

        // Loading state
        mustHaveConfigFile bool
        failOnInitErr      bool
        running            bool

        // Currently only set when in "fast render mode". But it seems to
        // be fast enough that we could maybe just add it for all server modes.
        changeDetector *fileChangeDetector

        // We need to reuse this on server rebuilds.
        destinationFs afero.Fs

        h    *hugoBuilderCommon
        ftch flagsToConfigHandler

        visitedURLs *types.EvictingStringQueue

        cfgInit func(c *commandeer) error

        // We watch these for changes.
        configFiles []string

        // Used in cases where we get flooded with events in server mode.
        debounce func(f func())

        serverPorts         []int
        languagesConfigured bool
        languages           langs.Languages
        doLiveReload        bool
        fastRenderMode      bool
        showErrorInBrowser  bool
        wasError            bool

        configured bool
        paused     bool

        fullRebuildSem *semaphore.Weighted

        // Any error from the last build.
        buildErr error
}

func newCommandeerHugoState() *commandeerHugoState <span class="cov8" title="1">{
        return &amp;commandeerHugoState{
                created: make(chan struct{}),
        }
}</span>

func (c *commandeerHugoState) hugo() *hugolib.HugoSites <span class="cov8" title="1">{
        &lt;-c.created
        return c.hugoSites
}</span>

func (c *commandeer) errCount() int <span class="cov8" title="1">{
        return int(c.logger.LogCounters().ErrorCounter.Count())
}</span>

func (c *commandeer) getErrorWithContext() interface{} <span class="cov8" title="1">{
        errCount := c.errCount()

        if errCount == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">m := make(map[string]interface{})

        m["Error"] = errors.New(removeErrorPrefixFromLog(c.logger.Errors()))
        m["Version"] = hugo.BuildVersionString()

        fe := herrors.UnwrapErrorWithFileContext(c.buildErr)
        if fe != nil </span><span class="cov0" title="0">{
                m["File"] = fe
        }</span>

        <span class="cov0" title="0">if c.h.verbose </span><span class="cov0" title="0">{
                var b bytes.Buffer
                herrors.FprintStackTraceFromErr(&amp;b, c.buildErr)
                m["StackTrace"] = b.String()
        }</span>

        <span class="cov0" title="0">return m</span>
}

func (c *commandeer) Set(key string, value interface{}) <span class="cov8" title="1">{
        if c.configured </span><span class="cov0" title="0">{
                panic("commandeer cannot be changed")</span>
        }
        <span class="cov8" title="1">c.Cfg.Set(key, value)</span>
}

func (c *commandeer) initFs(fs *hugofs.Fs) error <span class="cov8" title="1">{
        c.destinationFs = fs.Destination
        c.DepsCfg.Fs = fs

        return nil
}</span>

func newCommandeer(mustHaveConfigFile, failOnInitErr, running bool, h *hugoBuilderCommon, f flagsToConfigHandler, cfgInit func(c *commandeer) error, subCmdVs ...*cobra.Command) (*commandeer, error) <span class="cov8" title="1">{
        var rebuildDebouncer func(f func())
        if running </span><span class="cov8" title="1">{
                // The time value used is tested with mass content replacements in a fairly big Hugo site.
                // It is better to wait for some seconds in those cases rather than get flooded
                // with rebuilds.
                rebuildDebouncer = debounce.New(4 * time.Second)
        }</span>

        <span class="cov8" title="1">out := ioutil.Discard
        if !h.quiet </span><span class="cov8" title="1">{
                out = os.Stdout
        }</span>

        <span class="cov8" title="1">c := &amp;commandeer{
                h:                   h,
                ftch:                f,
                commandeerHugoState: newCommandeerHugoState(),
                cfgInit:             cfgInit,
                visitedURLs:         types.NewEvictingStringQueue(10),
                debounce:            rebuildDebouncer,
                fullRebuildSem:      semaphore.NewWeighted(1),

                // Init state
                mustHaveConfigFile: mustHaveConfigFile,
                failOnInitErr:      failOnInitErr,
                running:            running,

                // This will be replaced later, but we need something to log to before the configuration is read.
                logger: loggers.NewLogger(jww.LevelWarn, jww.LevelError, out, ioutil.Discard, running),
        }

        return c, c.loadConfig()</span>
}

type fileChangeDetector struct {
        sync.Mutex
        current map[string]string
        prev    map[string]string

        irrelevantRe *regexp.Regexp
}

func (f *fileChangeDetector) OnFileClose(name, md5sum string) <span class="cov8" title="1">{
        f.Lock()
        defer f.Unlock()
        f.current[name] = md5sum
}</span>

func (f *fileChangeDetector) changed() []string <span class="cov0" title="0">{
        if f == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">f.Lock()
        defer f.Unlock()
        var c []string
        for k, v := range f.current </span><span class="cov0" title="0">{
                vv, found := f.prev[k]
                if !found || v != vv </span><span class="cov0" title="0">{
                        c = append(c, k)
                }</span>
        }

        <span class="cov0" title="0">return f.filterIrrelevant(c)</span>
}

func (f *fileChangeDetector) filterIrrelevant(in []string) []string <span class="cov0" title="0">{
        var filtered []string
        for _, v := range in </span><span class="cov0" title="0">{
                if !f.irrelevantRe.MatchString(v) </span><span class="cov0" title="0">{
                        filtered = append(filtered, v)
                }</span>
        }
        <span class="cov0" title="0">return filtered</span>
}

func (f *fileChangeDetector) PrepareNew() <span class="cov8" title="1">{
        if f == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">f.Lock()
        defer f.Unlock()

        if f.current == nil </span><span class="cov8" title="1">{
                f.current = make(map[string]string)
                f.prev = make(map[string]string)
                return
        }</span>

        <span class="cov0" title="0">f.prev = make(map[string]string)
        for k, v := range f.current </span><span class="cov0" title="0">{
                f.prev[k] = v
        }</span>
        <span class="cov0" title="0">f.current = make(map[string]string)</span>
}

func (c *commandeer) loadConfig() error <span class="cov8" title="1">{
        if c.DepsCfg == nil </span><span class="cov8" title="1">{
                c.DepsCfg = &amp;deps.DepsCfg{}
        }</span>

        <span class="cov8" title="1">if c.logger != nil </span><span class="cov8" title="1">{
                // Truncate the error log if this is a reload.
                c.logger.Reset()
        }</span>

        <span class="cov8" title="1">cfg := c.DepsCfg
        c.configured = false
        cfg.Running = c.running

        var dir string
        if c.h.source != "" </span><span class="cov8" title="1">{
                dir, _ = filepath.Abs(c.h.source)
        }</span> else<span class="cov0" title="0"> {
                dir, _ = os.Getwd()
        }</span>

        <span class="cov8" title="1">var sourceFs afero.Fs = hugofs.Os
        if c.DepsCfg.Fs != nil </span><span class="cov0" title="0">{
                sourceFs = c.DepsCfg.Fs.Source
        }</span>

        <span class="cov8" title="1">environment := c.h.getEnvironment(c.running)

        doWithConfig := func(cfg config.Provider) error </span><span class="cov8" title="1">{
                if c.ftch != nil </span><span class="cov8" title="1">{
                        c.ftch.flagsToConfig(cfg)
                }</span>

                <span class="cov8" title="1">cfg.Set("workingDir", dir)
                cfg.Set("environment", environment)
                return nil</span>
        }

        <span class="cov8" title="1">cfgSetAndInit := func(cfg config.Provider) error </span><span class="cov8" title="1">{
                c.Cfg = cfg
                if c.cfgInit == nil </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">err := c.cfgInit(c)
                return err</span>
        }

        <span class="cov8" title="1">configPath := c.h.source
        if configPath == "" </span><span class="cov0" title="0">{
                configPath = dir
        }</span>
        <span class="cov8" title="1">config, configFiles, err := hugolib.LoadConfig(
                hugolib.ConfigSourceDescriptor{
                        Fs:           sourceFs,
                        Logger:       c.logger,
                        Path:         configPath,
                        WorkingDir:   dir,
                        Filename:     c.h.cfgFile,
                        AbsConfigDir: c.h.getConfigDir(dir),
                        Environment:  environment,
                },
                cfgSetAndInit,
                doWithConfig)

        if err != nil </span><span class="cov0" title="0">{
                // We should improve the error handling here,
                // but with hugo mod init and similar there is a chicken and egg situation
                // with modules already configured in config.toml, so ignore those errors.
                if c.mustHaveConfigFile || (c.failOnInitErr &amp;&amp; !moduleNotFoundRe.MatchString(err.Error())) </span><span class="cov0" title="0">{
                        return err
                }</span> else<span class="cov0" title="0"> {
                        // Just make it a warning.
                        c.logger.Warnln(err)
                }</span>
        } else<span class="cov8" title="1"> if c.mustHaveConfigFile &amp;&amp; len(configFiles) == 0 </span><span class="cov0" title="0">{
                return hugolib.ErrNoConfigFile
        }</span>

        <span class="cov8" title="1">c.configFiles = configFiles

        if l, ok := c.Cfg.Get("languagesSorted").(langs.Languages); ok </span><span class="cov8" title="1">{
                c.languagesConfigured = true
                c.languages = l
        }</span>

        // Set some commonly used flags
        <span class="cov8" title="1">c.doLiveReload = c.running &amp;&amp; !c.Cfg.GetBool("disableLiveReload")
        c.fastRenderMode = c.doLiveReload &amp;&amp; !c.Cfg.GetBool("disableFastRender")
        c.showErrorInBrowser = c.doLiveReload &amp;&amp; !c.Cfg.GetBool("disableBrowserError")

        // This is potentially double work, but we need to do this one more time now
        // that all the languages have been configured.
        if c.cfgInit != nil </span><span class="cov8" title="1">{
                if err := c.cfgInit(c); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">logger, err := c.createLogger(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">cfg.Logger = logger
        c.logger = logger
        c.serverConfig, err = hconfig.DecodeServer(cfg.Cfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">createMemFs := config.GetBool("renderToMemory")

        if createMemFs </span><span class="cov8" title="1">{
                // Rendering to memoryFS, publish to Root regardless of publishDir.
                config.Set("publishDir", "/")
        }</span>

        <span class="cov8" title="1">c.fsCreate.Do(func() </span><span class="cov8" title="1">{
                fs := hugofs.NewFrom(sourceFs, config)

                if c.destinationFs != nil </span><span class="cov0" title="0">{
                        // Need to reuse the destination on server rebuilds.
                        fs.Destination = c.destinationFs
                }</span> else<span class="cov8" title="1"> if createMemFs </span><span class="cov8" title="1">{
                        // Hugo writes the output to memory instead of the disk.
                        fs.Destination = new(afero.MemMapFs)
                }</span>

                <span class="cov8" title="1">if c.fastRenderMode </span><span class="cov8" title="1">{
                        // For now, fast render mode only. It should, however, be fast enough
                        // for the full variant, too.
                        changeDetector := &amp;fileChangeDetector{
                                // We use this detector to decide to do a Hot reload of a single path or not.
                                // We need to filter out source maps and possibly some other to be able
                                // to make that decision.
                                irrelevantRe: regexp.MustCompile(`\.map$`),
                        }

                        changeDetector.PrepareNew()
                        fs.Destination = hugofs.NewHashingFs(fs.Destination, changeDetector)
                        c.changeDetector = changeDetector
                }</span>

                <span class="cov8" title="1">if c.Cfg.GetBool("logPathWarnings") </span><span class="cov0" title="0">{
                        fs.Destination = hugofs.NewCreateCountingFs(fs.Destination)
                }</span>

                // To debug hard-to-find path issues.
                // fs.Destination = hugofs.NewStacktracerFs(fs.Destination, `fr/fr`)

                <span class="cov8" title="1">err = c.initFs(fs)
                if err != nil </span><span class="cov0" title="0">{
                        close(c.created)
                        return
                }</span>

                <span class="cov8" title="1">var h *hugolib.HugoSites

                var createErr error
                h, createErr = hugolib.NewHugoSites(*c.DepsCfg)
                if h == nil || c.failOnInitErr </span><span class="cov8" title="1">{
                        err = createErr
                }</span>
                <span class="cov8" title="1">c.hugoSites = h
                // TODO(bep) improve.
                if c.buildLock == nil </span><span class="cov8" title="1">{
                        c.buildLock = h.LockBuild
                }</span>
                <span class="cov8" title="1">close(c.created)</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">cacheDir, err := helpers.GetCacheDir(sourceFs, config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">config.Set("cacheDir", cacheDir)

        return nil</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "fmt"
        "os"
        "time"

        "github.com/gohugoio/hugo/hugolib/paths"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/cobra"
)

type commandsBuilder struct {
        hugoBuilderCommon

        commands []cmder
}

func newCommandsBuilder() *commandsBuilder <span class="cov8" title="1">{
        return &amp;commandsBuilder{}
}</span>

func (b *commandsBuilder) addCommands(commands ...cmder) *commandsBuilder <span class="cov8" title="1">{
        b.commands = append(b.commands, commands...)
        return b
}</span>

func (b *commandsBuilder) addAll() *commandsBuilder <span class="cov8" title="1">{
        b.addCommands(
                b.newServerCmd(),
                newVersionCmd(),
                newEnvCmd(),
                b.newConfigCmd(),
                b.newDeployCmd(),
                b.newConvertCmd(),
                b.newNewCmd(),
                b.newListCmd(),
                newImportCmd(),
                newGenCmd(),
                createReleaser(),
                b.newModCmd(),
        )

        return b
}</span>

func (b *commandsBuilder) build() *hugoCmd <span class="cov8" title="1">{
        h := b.newHugoCmd()
        addCommands(h.getCommand(), b.commands...)
        return h
}</span>

func addCommands(root *cobra.Command, commands ...cmder) <span class="cov8" title="1">{
        for _, command := range commands </span><span class="cov8" title="1">{
                cmd := command.getCommand()
                if cmd == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">root.AddCommand(cmd)</span>
        }
}

type baseCmd struct {
        cmd *cobra.Command
}

var _ commandsBuilderGetter = (*baseBuilderCmd)(nil)

// Used in tests.
type commandsBuilderGetter interface {
        getCommandsBuilder() *commandsBuilder
}

type baseBuilderCmd struct {
        *baseCmd
        *commandsBuilder
}

func (b *baseBuilderCmd) getCommandsBuilder() *commandsBuilder <span class="cov0" title="0">{
        return b.commandsBuilder
}</span>

func (c *baseCmd) getCommand() *cobra.Command <span class="cov8" title="1">{
        return c.cmd
}</span>

func newBaseCmd(cmd *cobra.Command) *baseCmd <span class="cov8" title="1">{
        return &amp;baseCmd{cmd: cmd}
}</span>

func (b *commandsBuilder) newBuilderCmd(cmd *cobra.Command) *baseBuilderCmd <span class="cov8" title="1">{
        bcmd := &amp;baseBuilderCmd{commandsBuilder: b, baseCmd: &amp;baseCmd{cmd: cmd}}
        bcmd.hugoBuilderCommon.handleFlags(cmd)
        return bcmd
}</span>

func (b *commandsBuilder) newBuilderBasicCmd(cmd *cobra.Command) *baseBuilderCmd <span class="cov8" title="1">{
        bcmd := &amp;baseBuilderCmd{commandsBuilder: b, baseCmd: &amp;baseCmd{cmd: cmd}}
        bcmd.hugoBuilderCommon.handleCommonBuilderFlags(cmd)
        return bcmd
}</span>

func (c *baseCmd) flagsToConfig(cfg config.Provider) <span class="cov8" title="1">{
        initializeFlags(c.cmd, cfg)
}</span>

type hugoCmd struct {
        *baseBuilderCmd

        // Need to get the sites once built.
        c *commandeer
}

var _ cmder = (*nilCommand)(nil)

type nilCommand struct{}

func (c *nilCommand) getCommand() *cobra.Command <span class="cov8" title="1">{
        return nil
}</span>

func (c *nilCommand) flagsToConfig(cfg config.Provider) {<span class="cov0" title="0">
}</span>

func (b *commandsBuilder) newHugoCmd() *hugoCmd <span class="cov8" title="1">{
        cc := &amp;hugoCmd{}

        cc.baseBuilderCmd = b.newBuilderCmd(&amp;cobra.Command{
                Use:   "hugo",
                Short: "hugo builds your site",
                Long: `hugo is the main command, used to build your Hugo site.

Hugo is a Fast and Flexible Static Site Generator
built with love by spf13 and friends in Go.

Complete documentation is available at http://gohugo.io/.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        defer cc.timeTrack(time.Now(), "Total")
                        cfgInit := func(c *commandeer) error </span><span class="cov8" title="1">{
                                if cc.buildWatch </span><span class="cov0" title="0">{
                                        c.Set("disableLiveReload", true)
                                }</span>
                                <span class="cov8" title="1">return nil</span>
                        }

                        // prevent cobra printing error so it can be handled here (before the timeTrack prints)
                        <span class="cov8" title="1">cmd.SilenceErrors = true

                        c, err := initializeConfig(true, true, cc.buildWatch, &amp;cc.hugoBuilderCommon, cc, cfgInit)
                        if err != nil </span><span class="cov0" title="0">{
                                cmd.PrintErrln("Error:", err.Error())
                                return err
                        }</span>
                        <span class="cov8" title="1">cc.c = c

                        err = c.build()
                        if err != nil </span><span class="cov0" title="0">{
                                cmd.PrintErrln("Error:", err.Error())
                        }</span>
                        <span class="cov8" title="1">return err</span>
                },
        })

        <span class="cov8" title="1">cc.cmd.PersistentFlags().StringVar(&amp;cc.cfgFile, "config", "", "config file (default is path/config.yaml|json|toml)")
        cc.cmd.PersistentFlags().StringVar(&amp;cc.cfgDir, "configDir", "config", "config dir")
        cc.cmd.PersistentFlags().BoolVar(&amp;cc.quiet, "quiet", false, "build in quiet mode")

        // Set bash-completion
        _ = cc.cmd.PersistentFlags().SetAnnotation("config", cobra.BashCompFilenameExt, config.ValidConfigFileExtensions)

        cc.cmd.PersistentFlags().BoolVarP(&amp;cc.verbose, "verbose", "v", false, "verbose output")
        cc.cmd.PersistentFlags().BoolVarP(&amp;cc.debug, "debug", "", false, "debug output")
        cc.cmd.PersistentFlags().BoolVar(&amp;cc.logging, "log", false, "enable Logging")
        cc.cmd.PersistentFlags().StringVar(&amp;cc.logFile, "logFile", "", "log File path (if set, logging enabled automatically)")
        cc.cmd.PersistentFlags().BoolVar(&amp;cc.verboseLog, "verboseLog", false, "verbose logging")

        cc.cmd.Flags().BoolVarP(&amp;cc.buildWatch, "watch", "w", false, "watch filesystem for changes and recreate as needed")

        cc.cmd.Flags().Bool("renderToMemory", false, "render to memory (only useful for benchmark testing)")

        // Set bash-completion
        _ = cc.cmd.PersistentFlags().SetAnnotation("logFile", cobra.BashCompFilenameExt, []string{})

        cc.cmd.SetGlobalNormalizationFunc(helpers.NormalizeHugoFlags)
        cc.cmd.SilenceUsage = true

        return cc</span>
}

type hugoBuilderCommon struct {
        source      string
        baseURL     string
        environment string

        buildWatch bool
        poll       string

        gc bool

        // Profile flags (for debugging of performance problems)
        cpuprofile   string
        memprofile   string
        mutexprofile string
        traceprofile string
        printm       bool

        // TODO(bep) var vs string
        logging    bool
        verbose    bool
        verboseLog bool
        debug      bool
        quiet      bool

        cfgFile string
        cfgDir  string
        logFile string
}

func (cc *hugoBuilderCommon) timeTrack(start time.Time, name string) <span class="cov8" title="1">{
        if cc.quiet </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">elapsed := time.Since(start)
        fmt.Printf("%s in %v ms\n", name, int(1000*elapsed.Seconds()))</span>
}

func (cc *hugoBuilderCommon) getConfigDir(baseDir string) string <span class="cov8" title="1">{
        if cc.cfgDir != "" </span><span class="cov8" title="1">{
                return paths.AbsPathify(baseDir, cc.cfgDir)
        }</span>

        <span class="cov8" title="1">if v, found := os.LookupEnv("HUGO_CONFIGDIR"); found </span><span class="cov0" title="0">{
                return paths.AbsPathify(baseDir, v)
        }</span>

        <span class="cov8" title="1">return paths.AbsPathify(baseDir, "config")</span>
}

func (cc *hugoBuilderCommon) getEnvironment(isServer bool) string <span class="cov8" title="1">{
        if cc.environment != "" </span><span class="cov8" title="1">{
                return cc.environment
        }</span>

        <span class="cov8" title="1">if v, found := os.LookupEnv("HUGO_ENVIRONMENT"); found </span><span class="cov0" title="0">{
                return v
        }</span>

        //  Used by Netlify and Forestry
        <span class="cov8" title="1">if v, found := os.LookupEnv("HUGO_ENV"); found </span><span class="cov0" title="0">{
                return v
        }</span>

        <span class="cov8" title="1">if isServer </span><span class="cov8" title="1">{
                return hugo.EnvironmentDevelopment
        }</span>

        <span class="cov8" title="1">return hugo.EnvironmentProduction</span>
}

func (cc *hugoBuilderCommon) handleCommonBuilderFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cmd.PersistentFlags().StringVarP(&amp;cc.source, "source", "s", "", "filesystem path to read files relative from")
        cmd.PersistentFlags().SetAnnotation("source", cobra.BashCompSubdirsInDir, []string{})
        cmd.PersistentFlags().StringVarP(&amp;cc.environment, "environment", "e", "", "build environment")
        cmd.PersistentFlags().StringP("themesDir", "", "", "filesystem path to themes directory")
        cmd.PersistentFlags().StringP("ignoreVendorPaths", "", "", "ignores any _vendor for module paths matching the given Glob pattern")
}</span>

func (cc *hugoBuilderCommon) handleFlags(cmd *cobra.Command) <span class="cov8" title="1">{
        cc.handleCommonBuilderFlags(cmd)
        cmd.Flags().Bool("cleanDestinationDir", false, "remove files from destination not found in static directories")
        cmd.Flags().BoolP("buildDrafts", "D", false, "include content marked as draft")
        cmd.Flags().BoolP("buildFuture", "F", false, "include content with publishdate in the future")
        cmd.Flags().BoolP("buildExpired", "E", false, "include expired content")
        cmd.Flags().StringP("contentDir", "c", "", "filesystem path to content directory")
        cmd.Flags().StringP("layoutDir", "l", "", "filesystem path to layout directory")
        cmd.Flags().StringP("cacheDir", "", "", "filesystem path to cache directory. Defaults: $TMPDIR/hugo_cache/")
        cmd.Flags().BoolP("ignoreCache", "", false, "ignores the cache directory")
        cmd.Flags().StringP("destination", "d", "", "filesystem path to write files to")
        cmd.Flags().StringSliceP("theme", "t", []string{}, "themes to use (located in /themes/THEMENAME/)")
        cmd.Flags().StringVarP(&amp;cc.baseURL, "baseURL", "b", "", "hostname (and path) to the root, e.g. http://spf13.com/")
        cmd.Flags().Bool("enableGitInfo", false, "add Git revision, date and author info to the pages")
        cmd.Flags().BoolVar(&amp;cc.gc, "gc", false, "enable to run some cleanup tasks (remove unused cache files) after the build")
        cmd.Flags().StringVar(&amp;cc.poll, "poll", "", "set this to a poll interval, e.g --poll 700ms, to use a poll based approach to watch for file system changes")
        cmd.Flags().BoolVar(&amp;loggers.PanicOnWarning, "panicOnWarning", false, "panic on first WARNING log")
        cmd.Flags().Bool("templateMetrics", false, "display metrics about template executions")
        cmd.Flags().Bool("templateMetricsHints", false, "calculate some improvement hints when combined with --templateMetrics")
        cmd.Flags().BoolP("forceSyncStatic", "", false, "copy all files when static is changed.")
        cmd.Flags().BoolP("noTimes", "", false, "don't sync modification time of files")
        cmd.Flags().BoolP("noChmod", "", false, "don't sync permission mode of files")
        cmd.Flags().BoolP("printI18nWarnings", "", false, "print missing translations")
        cmd.Flags().BoolP("printPathWarnings", "", false, "print warnings on duplicate target paths etc.")
        cmd.Flags().StringVarP(&amp;cc.cpuprofile, "profile-cpu", "", "", "write cpu profile to `file`")
        cmd.Flags().StringVarP(&amp;cc.memprofile, "profile-mem", "", "", "write memory profile to `file`")
        cmd.Flags().BoolVarP(&amp;cc.printm, "printMemoryUsage", "", false, "print memory usage to screen at intervals")
        cmd.Flags().StringVarP(&amp;cc.mutexprofile, "profile-mutex", "", "", "write Mutex profile to `file`")
        cmd.Flags().StringVarP(&amp;cc.traceprofile, "trace", "", "", "write trace to `file` (not useful in general)")

        // Hide these for now.
        cmd.Flags().MarkHidden("profile-cpu")
        cmd.Flags().MarkHidden("profile-mem")
        cmd.Flags().MarkHidden("profile-mutex")

        cmd.Flags().StringSlice("disableKinds", []string{}, "disable different kind of pages (home, RSS etc.)")

        cmd.Flags().Bool("minify", false, "minify any supported output format (HTML, XML etc.)")

        // Set bash-completion.
        // Each flag must first be defined before using the SetAnnotation() call.
        _ = cmd.Flags().SetAnnotation("source", cobra.BashCompSubdirsInDir, []string{})
        _ = cmd.Flags().SetAnnotation("cacheDir", cobra.BashCompSubdirsInDir, []string{})
        _ = cmd.Flags().SetAnnotation("destination", cobra.BashCompSubdirsInDir, []string{})
        _ = cmd.Flags().SetAnnotation("theme", cobra.BashCompSubdirsInDir, []string{"themes"})
}</span>

func checkErr(logger loggers.Logger, err error, s ...string) <span class="cov0" title="0">{
        if err == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for _, message := range s </span><span class="cov0" title="0">{
                logger.Errorln(message)
        }</span>
        <span class="cov0" title="0">logger.Errorln(err)</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.Print the version number of Hug

package commands

import (
        "encoding/json"
        "fmt"
        "os"
        "reflect"
        "regexp"
        "sort"
        "strings"
        "time"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/parser"
        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/gohugoio/hugo/modules"

        "github.com/spf13/cobra"
)

var _ cmder = (*configCmd)(nil)

type configCmd struct {
        *baseBuilderCmd
}

func (b *commandsBuilder) newConfigCmd() *configCmd <span class="cov8" title="1">{
        cc := &amp;configCmd{}
        cmd := &amp;cobra.Command{
                Use:   "config",
                Short: "Print the site configuration",
                Long:  `Print the site configuration, both default and custom settings.`,
                RunE:  cc.printConfig,
        }

        printMountsCmd := &amp;cobra.Command{
                Use:   "mounts",
                Short: "Print the configured file mounts",
                RunE:  cc.printMounts,
        }

        cmd.AddCommand(printMountsCmd)

        cc.baseBuilderCmd = b.newBuilderBasicCmd(cmd)

        return cc
}</span>

func (c *configCmd) printMounts(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        cfg, err := initializeConfig(true, false, false, &amp;c.hugoBuilderCommon, c, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">allModules := cfg.Cfg.Get("allmodules").(modules.Modules)

        for _, m := range allModules </span><span class="cov0" title="0">{
                if err := parser.InterfaceToConfig(&amp;modMounts{m: m, verbose: c.verbose}, metadecoders.JSON, os.Stdout); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (c *configCmd) printConfig(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        cfg, err := initializeConfig(true, false, false, &amp;c.hugoBuilderCommon, c, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">allSettings := cfg.Cfg.Get("").(maps.Params)

        // We need to clean up this, but we store objects in the config that
        // isn't really interesting to the end user, so filter these.
        ignoreKeysRe := regexp.MustCompile("client|sorted|filecacheconfigs|allmodules|multilingual")

        separator := ": "

        if len(cfg.configFiles) &gt; 0 &amp;&amp; strings.HasSuffix(cfg.configFiles[0], ".toml") </span><span class="cov8" title="1">{
                separator = " = "
        }</span>

        <span class="cov8" title="1">var keys []string
        for k := range allSettings </span><span class="cov8" title="1">{
                if ignoreKeysRe.MatchString(k) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">keys = append(keys, k)</span>
        }
        <span class="cov8" title="1">sort.Strings(keys)
        for _, k := range keys </span><span class="cov8" title="1">{
                kv := reflect.ValueOf(allSettings[k])
                if kv.Kind() == reflect.String </span><span class="cov8" title="1">{
                        fmt.Printf("%s%s\"%+v\"\n", k, separator, allSettings[k])
                }</span> else<span class="cov8" title="1"> {
                        fmt.Printf("%s%s%+v\n", k, separator, allSettings[k])
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

type modMounts struct {
        verbose bool
        m       modules.Module
}

type modMount struct {
        Source string `json:"source"`
        Target string `json:"target"`
        Lang   string `json:"lang,omitempty"`
}

func (m *modMounts) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        var mounts []modMount

        for _, mount := range m.m.Mounts() </span><span class="cov0" title="0">{
                mounts = append(mounts, modMount{
                        Source: mount.Source,
                        Target: mount.Target,
                        Lang:   mount.Lang,
                })
        }</span>

        <span class="cov0" title="0">var ownerPath string
        if m.m.Owner() != nil </span><span class="cov0" title="0">{
                ownerPath = m.m.Owner().Path()
        }</span>

        <span class="cov0" title="0">if m.verbose </span><span class="cov0" title="0">{
                config := m.m.Config()
                return json.Marshal(&amp;struct {
                        Path        string                 `json:"path"`
                        Version     string                 `json:"version"`
                        Time        time.Time              `json:"time"`
                        Owner       string                 `json:"owner"`
                        Dir         string                 `json:"dir"`
                        Meta        map[string]interface{} `json:"meta"`
                        HugoVersion modules.HugoVersion    `json:"hugoVersion"`

                        Mounts []modMount `json:"mounts"`
                }{
                        Path:        m.m.Path(),
                        Version:     m.m.Version(),
                        Time:        m.m.Time(),
                        Owner:       ownerPath,
                        Dir:         m.m.Dir(),
                        Meta:        config.Params,
                        HugoVersion: config.HugoVersion,
                        Mounts:      mounts,
                })
        }</span>

        <span class="cov0" title="0">return json.Marshal(&amp;struct {
                Path    string     `json:"path"`
                Version string     `json:"version"`
                Time    time.Time  `json:"time"`
                Owner   string     `json:"owner"`
                Dir     string     `json:"dir"`
                Mounts  []modMount `json:"mounts"`
        }{
                Path:    m.m.Path(),
                Version: m.m.Version(),
                Time:    m.m.Time(),
                Owner:   ownerPath,
                Dir:     m.m.Dir(),
                Mounts:  mounts,
        })</span>

}
</pre>
		
		<pre class="file" id="file9" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "fmt"
        "path/filepath"
        "strings"
        "time"

        "github.com/gohugoio/hugo/parser/pageparser"

        "github.com/gohugoio/hugo/resources/page"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/parser"
        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/hugolib"

        "github.com/spf13/cobra"
)

var _ cmder = (*convertCmd)(nil)

type convertCmd struct {
        outputDir string
        unsafe    bool

        *baseBuilderCmd
}

func (b *commandsBuilder) newConvertCmd() *convertCmd <span class="cov8" title="1">{
        cc := &amp;convertCmd{}

        cmd := &amp;cobra.Command{
                Use:   "convert",
                Short: "Convert your content to different formats",
                Long: `Convert your content (e.g. front matter) to different formats.

See convert's subcommands toJSON, toTOML and toYAML for more information.`,
                RunE: nil,
        }

        cmd.AddCommand(
                &amp;cobra.Command{
                        Use:   "toJSON",
                        Short: "Convert front matter to JSON",
                        Long: `toJSON converts all front matter in the content directory
to use JSON for the front matter.`,
                        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                                return cc.convertContents(metadecoders.JSON)
                        }</span>,
                },
                &amp;cobra.Command{
                        Use:   "toTOML",
                        Short: "Convert front matter to TOML",
                        Long: `toTOML converts all front matter in the content directory
to use TOML for the front matter.`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                                return cc.convertContents(metadecoders.TOML)
                        }</span>,
                },
                &amp;cobra.Command{
                        Use:   "toYAML",
                        Short: "Convert front matter to YAML",
                        Long: `toYAML converts all front matter in the content directory
to use YAML for the front matter.`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                                return cc.convertContents(metadecoders.YAML)
                        }</span>,
                },
        )

        <span class="cov8" title="1">cmd.PersistentFlags().StringVarP(&amp;cc.outputDir, "output", "o", "", "filesystem path to write files to")
        cmd.PersistentFlags().BoolVar(&amp;cc.unsafe, "unsafe", false, "enable less safe operations, please backup first")

        cc.baseBuilderCmd = b.newBuilderBasicCmd(cmd)

        return cc</span>
}

func (cc *convertCmd) convertContents(format metadecoders.Format) error <span class="cov8" title="1">{
        if cc.outputDir == "" &amp;&amp; !cc.unsafe </span><span class="cov0" title="0">{
                return newUserError("Unsafe operation not allowed, use --unsafe or set a different output path")
        }</span>

        <span class="cov8" title="1">c, err := initializeConfig(true, false, false, &amp;cc.hugoBuilderCommon, cc, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">c.Cfg.Set("buildDrafts", true)

        h, err := hugolib.NewHugoSites(*c.DepsCfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := h.Build(hugolib.BuildCfg{SkipRender: true}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">site := h.Sites[0]

        site.Log.Println("processing", len(site.AllPages()), "content files")
        for _, p := range site.AllPages() </span><span class="cov8" title="1">{
                if err := cc.convertAndSavePage(p, site, format); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (cc *convertCmd) convertAndSavePage(p page.Page, site *hugolib.Site, targetFormat metadecoders.Format) error <span class="cov8" title="1">{
        // The resources are not in .Site.AllPages.
        for _, r := range p.Resources().ByType("page") </span><span class="cov0" title="0">{
                if err := cc.convertAndSavePage(r.(page.Page), site, targetFormat); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if p.File().IsZero() </span><span class="cov8" title="1">{
                // No content file.
                return nil
        }</span>

        <span class="cov8" title="1">errMsg := fmt.Errorf("Error processing file %q", p.File().Path())

        site.Log.Infoln("Attempting to convert", p.File().Filename())

        f := p.File()
        file, err := f.FileInfo().Meta().Open()
        if err != nil </span><span class="cov0" title="0">{
                site.Log.Errorln(errMsg)
                file.Close()
                return nil
        }</span>

        <span class="cov8" title="1">pf, err := pageparser.ParseFrontMatterAndContent(file)
        if err != nil </span><span class="cov0" title="0">{
                site.Log.Errorln(errMsg)
                file.Close()
                return err
        }</span>

        <span class="cov8" title="1">file.Close()

        // better handling of dates in formats that don't have support for them
        if pf.FrontMatterFormat == metadecoders.JSON || pf.FrontMatterFormat == metadecoders.YAML || pf.FrontMatterFormat == metadecoders.TOML </span><span class="cov8" title="1">{
                for k, v := range pf.FrontMatter </span><span class="cov8" title="1">{
                        switch vv := v.(type) </span>{
                        case time.Time:<span class="cov0" title="0">
                                pf.FrontMatter[k] = vv.Format(time.RFC3339)</span>
                        }
                }
        }

        <span class="cov8" title="1">var newContent bytes.Buffer
        err = parser.InterfaceToFrontMatter(pf.FrontMatter, targetFormat, &amp;newContent)
        if err != nil </span><span class="cov0" title="0">{
                site.Log.Errorln(errMsg)
                return err
        }</span>

        <span class="cov8" title="1">newContent.Write(pf.Content)

        newFilename := p.File().Filename()

        if cc.outputDir != "" </span><span class="cov8" title="1">{
                contentDir := strings.TrimSuffix(newFilename, p.File().Path())
                contentDir = filepath.Base(contentDir)

                newFilename = filepath.Join(cc.outputDir, contentDir, p.File().Path())
        }</span>

        <span class="cov8" title="1">fs := hugofs.Os
        if err := helpers.WriteToDisk(newFilename, &amp;newContent, fs); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "Failed to save file %q:", newFilename)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

type parsedFile struct {
        frontMatterFormat metadecoders.Format
        frontMatterSource []byte
        frontMatter       map[string]interface{}

        // Everything after Front Matter
        content []byte
}
</pre>
		
		<pre class="file" id="file10" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +build !nodeploy

package commands

import (
        "context"

        "github.com/gohugoio/hugo/deploy"
        "github.com/spf13/cobra"
)

var _ cmder = (*deployCmd)(nil)

// deployCmd supports deploying sites to Cloud providers.
type deployCmd struct {
        *baseBuilderCmd

        invalidateCDN bool
        maxDeletes    int
}

// TODO: In addition to the "deploy" command, consider adding a "--deploy"
// flag for the default command; this would build the site and then deploy it.
// It's not obvious how to do this; would all of the deploy-specific flags
// have to exist at the top level as well?

// TODO:  The output files change every time "hugo" is executed, it looks
// like because of map order randomization. This means that you can
// run "hugo &amp;&amp; hugo deploy" again and again and upload new stuff every time. Is
// this intended?

func (b *commandsBuilder) newDeployCmd() *deployCmd <span class="cov8" title="1">{
        cc := &amp;deployCmd{}

        cmd := &amp;cobra.Command{
                Use:   "deploy",
                Short: "Deploy your site to a Cloud provider.",
                Long: `Deploy your site to a Cloud provider.

See https://gohugo.io/hosting-and-deployment/hugo-deploy/ for detailed
documentation.
`,

                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        cfgInit := func(c *commandeer) error </span><span class="cov8" title="1">{
                                c.Set("invalidateCDN", cc.invalidateCDN)
                                c.Set("maxDeletes", cc.maxDeletes)
                                return nil
                        }</span>
                        <span class="cov8" title="1">comm, err := initializeConfig(true, true, false, &amp;cc.hugoBuilderCommon, cc, cfgInit)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">deployer, err := deploy.New(comm.Cfg, comm.hugo().PathSpec.PublishFs)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">return deployer.Deploy(context.Background())</span>
                },
        }

        <span class="cov8" title="1">cmd.Flags().String("target", "", "target deployment from deployments section in config file; defaults to the first one")
        cmd.Flags().Bool("confirm", false, "ask for confirmation before making changes to the target")
        cmd.Flags().Bool("dryRun", false, "dry run")
        cmd.Flags().Bool("force", false, "force upload of all files")
        cmd.Flags().BoolVar(&amp;cc.invalidateCDN, "invalidateCDN", true, "invalidate the CDN cache listed in the deployment target")
        cmd.Flags().IntVar(&amp;cc.maxDeletes, "maxDeletes", 256, "maximum # of files to delete, or -1 to disable")

        cc.baseBuilderCmd = b.newBuilderBasicCmd(cmd)

        return cc</span>
}
</pre>
		
		<pre class="file" id="file11" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "runtime"

        "github.com/gohugoio/hugo/common/hugo"

        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*envCmd)(nil)

type envCmd struct {
        *baseCmd
}

func newEnvCmd() *envCmd <span class="cov8" title="1">{
        return &amp;envCmd{
                baseCmd: newBaseCmd(&amp;cobra.Command{
                        Use:   "env",
                        Short: "Print Hugo version and environment info",
                        Long: `Print Hugo version and environment info. This is useful in Hugo bug reports.

If you add the -v flag, you will get a full dependency list.
`,
                        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                                printHugoVersion()
                                jww.FEEDBACK.Printf("GOOS=%q\n", runtime.GOOS)
                                jww.FEEDBACK.Printf("GOARCH=%q\n", runtime.GOARCH)
                                jww.FEEDBACK.Printf("GOVERSION=%q\n", runtime.Version())

                                isVerbose, _ := cmd.Flags().GetBool("verbose")

                                if isVerbose </span><span class="cov0" title="0">{
                                        deps := hugo.GetDependencyList()
                                        for _, dep := range deps </span><span class="cov0" title="0">{
                                                jww.FEEDBACK.Printf("%s\n", dep)
                                        }</span>
                                }

                                <span class="cov8" title="1">return nil</span>
                        },
                }),
        }

}
</pre>
		
		<pre class="file" id="file12" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "github.com/spf13/cobra"
)

var _ cmder = (*genCmd)(nil)

type genCmd struct {
        *baseCmd
}

func newGenCmd() *genCmd <span class="cov8" title="1">{
        cc := &amp;genCmd{}
        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "gen",
                Short: "A collection of several useful generators.",
        })

        cc.cmd.AddCommand(
                newGenDocCmd().getCommand(),
                newGenManCmd().getCommand(),
                createGenDocsHelper().getCommand(),
                createGenChromaStyles().getCommand())

        return cc
}</span>
</pre>
		
		<pre class="file" id="file13" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "os"

        "github.com/alecthomas/chroma"
        "github.com/alecthomas/chroma/formatters/html"
        "github.com/alecthomas/chroma/styles"
        "github.com/spf13/cobra"
)

var _ cmder = (*genChromaStyles)(nil)

type genChromaStyles struct {
        style          string
        highlightStyle string
        linesStyle     string
        *baseCmd
}

// TODO(bep) highlight
func createGenChromaStyles() *genChromaStyles <span class="cov8" title="1">{
        g := &amp;genChromaStyles{
                baseCmd: newBaseCmd(&amp;cobra.Command{
                        Use:   "chromastyles",
                        Short: "Generate CSS stylesheet for the Chroma code highlighter",
                        Long: `Generate CSS stylesheet for the Chroma code highlighter for a given style. This stylesheet is needed if markup.highlight.noClasses is disabled in config.

See https://xyproto.github.io/splash/docs/all.html for a preview of the available styles`,
                }),
        }

        g.cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                return g.generate()
        }</span>

        <span class="cov8" title="1">g.cmd.PersistentFlags().StringVar(&amp;g.style, "style", "friendly", "highlighter style (see https://xyproto.github.io/splash/docs/)")
        g.cmd.PersistentFlags().StringVar(&amp;g.highlightStyle, "highlightStyle", "bg:#ffffcc", "style used for highlighting lines (see https://github.com/alecthomas/chroma)")
        g.cmd.PersistentFlags().StringVar(&amp;g.linesStyle, "linesStyle", "", "style used for line numbers (see https://github.com/alecthomas/chroma)")

        return g</span>
}

func (g *genChromaStyles) generate() error <span class="cov8" title="1">{
        builder := styles.Get(g.style).Builder()
        if g.highlightStyle != "" </span><span class="cov8" title="1">{
                builder.Add(chroma.LineHighlight, g.highlightStyle)
        }</span>
        <span class="cov8" title="1">if g.linesStyle != "" </span><span class="cov0" title="0">{
                builder.Add(chroma.LineNumbers, g.linesStyle)
        }</span>
        <span class="cov8" title="1">style, err := builder.Build()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">formatter := html.New(html.WithAllClasses(true))
        formatter.WriteCSS(os.Stdout, style)
        return nil</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "fmt"
        "path"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/spf13/cobra"
        "github.com/spf13/cobra/doc"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*genDocCmd)(nil)

type genDocCmd struct {
        gendocdir string
        *baseCmd
}

func newGenDocCmd() *genDocCmd <span class="cov8" title="1">{
        const gendocFrontmatterTemplate = `---
title: "%s"
slug: %s
url: %s
---
`

        cc := &amp;genDocCmd{}

        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "doc",
                Short: "Generate Markdown documentation for the Hugo CLI.",
                Long: `Generate Markdown documentation for the Hugo CLI.

This command is, mostly, used to create up-to-date documentation
of Hugo's command-line interface for http://gohugo.io/.

It creates one Markdown file per command with front matter suitable
for rendering in Hugo.`,

                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        cmd.VisitParents(func(c *cobra.Command) </span><span class="cov8" title="1">{
                                // Disable the "Auto generated by spf13/cobra on DATE"
                                // as it creates a lot of diffs.
                                c.DisableAutoGenTag = true
                        }</span>)

                        <span class="cov8" title="1">if !strings.HasSuffix(cc.gendocdir, helpers.FilePathSeparator) </span><span class="cov8" title="1">{
                                cc.gendocdir += helpers.FilePathSeparator
                        }</span>
                        <span class="cov8" title="1">if found, _ := helpers.Exists(cc.gendocdir, hugofs.Os); !found </span><span class="cov8" title="1">{
                                jww.FEEDBACK.Println("Directory", cc.gendocdir, "does not exist, creating...")
                                if err := hugofs.Os.MkdirAll(cc.gendocdir, 0777); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">prepender := func(filename string) string </span><span class="cov8" title="1">{
                                name := filepath.Base(filename)
                                base := strings.TrimSuffix(name, path.Ext(name))
                                url := "/commands/" + strings.ToLower(base) + "/"
                                return fmt.Sprintf(gendocFrontmatterTemplate, strings.Replace(base, "_", " ", -1), base, url)
                        }</span>

                        <span class="cov8" title="1">linkHandler := func(name string) string </span><span class="cov8" title="1">{
                                base := strings.TrimSuffix(name, path.Ext(name))
                                return "/commands/" + strings.ToLower(base) + "/"
                        }</span>
                        <span class="cov8" title="1">jww.FEEDBACK.Println("Generating Hugo command-line documentation in", cc.gendocdir, "...")
                        doc.GenMarkdownTreeCustom(cmd.Root(), cc.gendocdir, prepender, linkHandler)
                        jww.FEEDBACK.Println("Done.")

                        return nil</span>
                },
        })

        <span class="cov8" title="1">cc.cmd.PersistentFlags().StringVar(&amp;cc.gendocdir, "dir", "/tmp/hugodoc/", "the directory to write the doc.")

        // For bash-completion
        cc.cmd.PersistentFlags().SetAnnotation("dir", cobra.BashCompSubdirsInDir, []string{})

        return cc</span>
}
</pre>
		
		<pre class="file" id="file15" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"

        "github.com/gohugoio/hugo/docshelper"
        "github.com/spf13/cobra"
)

var _ cmder = (*genDocsHelper)(nil)

type genDocsHelper struct {
        target string
        *baseCmd
}

func createGenDocsHelper() *genDocsHelper <span class="cov8" title="1">{
        g := &amp;genDocsHelper{
                baseCmd: newBaseCmd(&amp;cobra.Command{
                        Use:    "docshelper",
                        Short:  "Generate some data files for the Hugo docs.",
                        Hidden: true,
                }),
        }

        g.cmd.RunE = func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                return g.generate()
        }</span>

        <span class="cov8" title="1">g.cmd.PersistentFlags().StringVarP(&amp;g.target, "dir", "", "docs/data", "data dir")

        return g</span>
}

func (g *genDocsHelper) generate() error <span class="cov0" title="0">{
        fmt.Println("Generate docs data to", g.target)

        targetFile := filepath.Join(g.target, "docs.json")

        f, err := os.Create(targetFile)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        enc := json.NewEncoder(f)
        enc.SetIndent("", "  ")

        if err := enc.Encode(docshelper.GetDocProvider()); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fmt.Println("Done!")
        return nil</span>
}
</pre>
		
		<pre class="file" id="file16" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "fmt"
        "strings"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/spf13/cobra"
        "github.com/spf13/cobra/doc"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*genManCmd)(nil)

type genManCmd struct {
        genmandir string
        *baseCmd
}

func newGenManCmd() *genManCmd <span class="cov8" title="1">{
        cc := &amp;genManCmd{}

        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "man",
                Short: "Generate man pages for the Hugo CLI",
                Long: `This command automatically generates up-to-date man pages of Hugo's
command-line interface.  By default, it creates the man page files
in the "man" directory under the current directory.`,

                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                        header := &amp;doc.GenManHeader{
                                Section: "1",
                                Manual:  "Hugo Manual",
                                Source:  fmt.Sprintf("Hugo %s", hugo.CurrentVersion),
                        }
                        if !strings.HasSuffix(cc.genmandir, helpers.FilePathSeparator) </span><span class="cov8" title="1">{
                                cc.genmandir += helpers.FilePathSeparator
                        }</span>
                        <span class="cov8" title="1">if found, _ := helpers.Exists(cc.genmandir, hugofs.Os); !found </span><span class="cov8" title="1">{
                                jww.FEEDBACK.Println("Directory", cc.genmandir, "does not exist, creating...")
                                if err := hugofs.Os.MkdirAll(cc.genmandir, 0777); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">cmd.Root().DisableAutoGenTag = true

                        jww.FEEDBACK.Println("Generating Hugo man pages in", cc.genmandir, "...")
                        doc.GenManTree(cmd.Root(), header, cc.genmandir)

                        jww.FEEDBACK.Println("Done.")

                        return nil</span>
                },
        })

        <span class="cov8" title="1">cc.cmd.PersistentFlags().StringVar(&amp;cc.genmandir, "dir", "man/", "the directory to write the man pages.")

        // For bash-completion
        cc.cmd.PersistentFlags().SetAnnotation("dir", cobra.BashCompSubdirsInDir, []string{})

        return cc</span>
}
</pre>
		
		<pre class="file" id="file17" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package commands defines and implements command-line commands and flags
// used by Hugo. Commands and flags are implemented using Cobra.
package commands

import (
        "fmt"
        "regexp"

        "github.com/gohugoio/hugo/config"
        "github.com/spf13/cobra"
)

const (
        ansiEsc    = "\u001B"
        clearLine  = "\r\033[K"
        hideCursor = ansiEsc + "[?25l"
        showCursor = ansiEsc + "[?25h"
)

type flagsToConfigHandler interface {
        flagsToConfig(cfg config.Provider)
}

type cmder interface {
        flagsToConfigHandler
        getCommand() *cobra.Command
}

// commandError is an error used to signal different error situations in command handling.
type commandError struct {
        s         string
        userError bool
}

func (c commandError) Error() string <span class="cov0" title="0">{
        return c.s
}</span>

func (c commandError) isUserError() bool <span class="cov0" title="0">{
        return c.userError
}</span>

func newUserError(a ...interface{}) commandError <span class="cov0" title="0">{
        return commandError{s: fmt.Sprintln(a...), userError: true}
}</span>

func newSystemError(a ...interface{}) commandError <span class="cov0" title="0">{
        return commandError{s: fmt.Sprintln(a...), userError: false}
}</span>

func newSystemErrorF(format string, a ...interface{}) commandError <span class="cov0" title="0">{
        return commandError{s: fmt.Sprintf(format, a...), userError: false}
}</span>

// Catch some of the obvious user errors from Cobra.
// We don't want to show the usage message for every error.
// The below may be to generic. Time will show.
var userErrorRegexp = regexp.MustCompile("unknown flag")

func isUserError(err error) bool <span class="cov0" title="0">{
        if cErr, ok := err.(commandError); ok &amp;&amp; cErr.isUserError() </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">return userErrorRegexp.MatchString(err.Error())</span>
}
</pre>
		
		<pre class="file" id="file18" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package commands defines and implements command-line commands and flags
// used by Hugo. Commands and flags are implemented using Cobra.
package commands

import (
        "context"
        "fmt"
        "io/ioutil"
        "os"
        "os/signal"
        "path/filepath"
        "runtime"
        "runtime/pprof"
        "runtime/trace"
        "strings"
        "sync/atomic"
        "syscall"
        "time"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/common/types"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/resources/page"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/common/terminal"

        "github.com/gohugoio/hugo/hugolib/filesystems"

        "golang.org/x/sync/errgroup"

        "github.com/gohugoio/hugo/config"

        flag "github.com/spf13/pflag"

        "github.com/fsnotify/fsnotify"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugolib"
        "github.com/gohugoio/hugo/livereload"
        "github.com/gohugoio/hugo/watcher"
        "github.com/spf13/afero"
        "github.com/spf13/cobra"
        "github.com/spf13/fsync"
        jww "github.com/spf13/jwalterweatherman"
)

// The Response value from Execute.
type Response struct {
        // The build Result will only be set in the hugo build command.
        Result *hugolib.HugoSites

        // Err is set when the command failed to execute.
        Err error

        // The command that was executed.
        Cmd *cobra.Command
}

// IsUserError returns true is the Response error is a user error rather than a
// system error.
func (r Response) IsUserError() bool <span class="cov0" title="0">{
        return r.Err != nil &amp;&amp; isUserError(r.Err)
}</span>

// Execute adds all child commands to the root command HugoCmd and sets flags appropriately.
// The args are usually filled with os.Args[1:].
func Execute(args []string) Response <span class="cov8" title="1">{
        hugoCmd := newCommandsBuilder().addAll().build()
        cmd := hugoCmd.getCommand()
        cmd.SetArgs(args)

        c, err := cmd.ExecuteC()

        var resp Response

        if c == cmd &amp;&amp; hugoCmd.c != nil </span><span class="cov8" title="1">{
                // Root command executed
                resp.Result = hugoCmd.c.hugo()
        }</span>

        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                errCount := int(loggers.GlobalErrorCounter.Count())
                if errCount &gt; 0 </span><span class="cov0" title="0">{
                        err = fmt.Errorf("logged %d errors", errCount)
                }</span> else<span class="cov8" title="1"> if resp.Result != nil </span><span class="cov8" title="1">{
                        errCount = resp.Result.NumLogErrors()
                        if errCount &gt; 0 </span><span class="cov0" title="0">{
                                err = fmt.Errorf("logged %d errors", errCount)
                        }</span>
                }

        }

        <span class="cov8" title="1">resp.Err = err
        resp.Cmd = c

        return resp</span>
}

// InitializeConfig initializes a config file with sensible default configuration flags.
func initializeConfig(mustHaveConfigFile, failOnInitErr, running bool,
        h *hugoBuilderCommon,
        f flagsToConfigHandler,
        cfgInit func(c *commandeer) error) (*commandeer, error) <span class="cov8" title="1">{
        c, err := newCommandeer(mustHaveConfigFile, failOnInitErr, running, h, f, cfgInit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return c, nil</span>
}

func (c *commandeer) createLogger(cfg config.Provider) (loggers.Logger, error) <span class="cov8" title="1">{
        var (
                logHandle       = ioutil.Discard
                logThreshold    = jww.LevelWarn
                logFile         = cfg.GetString("logFile")
                outHandle       = ioutil.Discard
                stdoutThreshold = jww.LevelWarn
        )

        if !c.h.quiet </span><span class="cov8" title="1">{
                outHandle = os.Stdout
        }</span>

        <span class="cov8" title="1">if c.h.verboseLog || c.h.logging || (c.h.logFile != "") </span><span class="cov0" title="0">{
                var err error
                if logFile != "" </span><span class="cov0" title="0">{
                        logHandle, err = os.OpenFile(logFile, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0666)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, newSystemError("Failed to open log file:", logFile, err)
                        }</span>
                } else<span class="cov0" title="0"> {
                        logHandle, err = ioutil.TempFile("", "hugo")
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, newSystemError(err)
                        }</span>
                }
        } else<span class="cov8" title="1"> if !c.h.quiet &amp;&amp; cfg.GetBool("verbose") </span><span class="cov0" title="0">{
                stdoutThreshold = jww.LevelInfo
        }</span>

        <span class="cov8" title="1">if cfg.GetBool("debug") </span><span class="cov0" title="0">{
                stdoutThreshold = jww.LevelDebug
        }</span>

        <span class="cov8" title="1">if c.h.verboseLog </span><span class="cov0" title="0">{
                logThreshold = jww.LevelInfo
                if cfg.GetBool("debug") </span><span class="cov0" title="0">{
                        logThreshold = jww.LevelDebug
                }</span>
        }

        <span class="cov8" title="1">loggers.InitGlobalLogger(stdoutThreshold, logThreshold, outHandle, logHandle)
        helpers.InitLoggers()

        return loggers.NewLogger(stdoutThreshold, logThreshold, outHandle, logHandle, c.running), nil</span>
}

func initializeFlags(cmd *cobra.Command, cfg config.Provider) <span class="cov8" title="1">{
        persFlagKeys := []string{
                "debug",
                "verbose",
                "logFile",
                // Moved from vars
        }
        flagKeys := []string{
                "cleanDestinationDir",
                "buildDrafts",
                "buildFuture",
                "buildExpired",
                "uglyURLs",
                "canonifyURLs",
                "enableRobotsTXT",
                "enableGitInfo",
                "pluralizeListTitles",
                "preserveTaxonomyNames",
                "ignoreCache",
                "forceSyncStatic",
                "noTimes",
                "noChmod",
                "ignoreVendorPaths",
                "templateMetrics",
                "templateMetricsHints",

                // Moved from vars.
                "baseURL",
                "buildWatch",
                "cacheDir",
                "cfgFile",
                "confirm",
                "contentDir",
                "debug",
                "destination",
                "disableKinds",
                "dryRun",
                "force",
                "gc",
                "printI18nWarnings",
                "invalidateCDN",
                "layoutDir",
                "logFile",
                "maxDeletes",
                "quiet",
                "renderToMemory",
                "source",
                "target",
                "theme",
                "themesDir",
                "verbose",
                "verboseLog",
                "duplicateTargetPaths",
        }

        for _, key := range persFlagKeys </span><span class="cov8" title="1">{
                setValueFromFlag(cmd.PersistentFlags(), key, cfg, "", false)
        }</span>
        <span class="cov8" title="1">for _, key := range flagKeys </span><span class="cov8" title="1">{
                setValueFromFlag(cmd.Flags(), key, cfg, "", false)
        }</span>

        <span class="cov8" title="1">setValueFromFlag(cmd.Flags(), "minify", cfg, "minifyOutput", true)

        // Set some "config aliases"
        setValueFromFlag(cmd.Flags(), "destination", cfg, "publishDir", false)
        setValueFromFlag(cmd.Flags(), "printI18nWarnings", cfg, "logI18nWarnings", false)
        setValueFromFlag(cmd.Flags(), "printPathWarnings", cfg, "logPathWarnings", false)</span>
}

func setValueFromFlag(flags *flag.FlagSet, key string, cfg config.Provider, targetKey string, force bool) <span class="cov8" title="1">{
        key = strings.TrimSpace(key)
        if (force &amp;&amp; flags.Lookup(key) != nil) || flags.Changed(key) </span><span class="cov8" title="1">{
                f := flags.Lookup(key)
                configKey := key
                if targetKey != "" </span><span class="cov8" title="1">{
                        configKey = targetKey
                }</span>
                // Gotta love this API.
                <span class="cov8" title="1">switch f.Value.Type() </span>{
                case "bool":<span class="cov8" title="1">
                        bv, _ := flags.GetBool(key)
                        cfg.Set(configKey, bv)</span>
                case "string":<span class="cov8" title="1">
                        cfg.Set(configKey, f.Value.String())</span>
                case "stringSlice":<span class="cov8" title="1">
                        bv, _ := flags.GetStringSlice(key)
                        cfg.Set(configKey, bv)</span>
                case "int":<span class="cov0" title="0">
                        iv, _ := flags.GetInt(key)
                        cfg.Set(configKey, iv)</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("update switch with %s", f.Value.Type()))</span>
                }

        }
}

func isTerminal() bool <span class="cov8" title="1">{
        return terminal.IsTerminal(os.Stdout)
}</span>

func (c *commandeer) fullBuild(noBuildLock bool) error <span class="cov8" title="1">{
        var (
                g         errgroup.Group
                langCount map[string]uint64
        )

        if !c.h.quiet </span><span class="cov8" title="1">{
                fmt.Println("Start building sites … ")
                fmt.Println(hugo.BuildVersionString())
                if isTerminal() </span><span class="cov0" title="0">{
                        defer func() </span><span class="cov0" title="0">{
                                fmt.Print(showCursor + clearLine)
                        }</span>()
                }
        }

        <span class="cov8" title="1">copyStaticFunc := func() error </span><span class="cov8" title="1">{
                cnt, err := c.copyStatic()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Error copying static files")
                }</span>
                <span class="cov8" title="1">langCount = cnt
                return nil</span>
        }
        <span class="cov8" title="1">buildSitesFunc := func() error </span><span class="cov8" title="1">{
                if err := c.buildSites(noBuildLock); err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "Error building site")
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        // Do not copy static files and build sites in parallel if cleanDestinationDir is enabled.
        // This flag deletes all static resources in /public folder that are missing in /static,
        // and it does so at the end of copyStatic() call.
        <span class="cov8" title="1">if c.Cfg.GetBool("cleanDestinationDir") </span><span class="cov0" title="0">{
                if err := copyStaticFunc(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err := buildSitesFunc(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                g.Go(copyStaticFunc)
                g.Go(buildSitesFunc)
                if err := g.Wait(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">for _, s := range c.hugo().Sites </span><span class="cov8" title="1">{
                s.ProcessingStats.Static = langCount[s.Language().Lang]
        }</span>

        <span class="cov8" title="1">if c.h.gc </span><span class="cov0" title="0">{
                count, err := c.hugo().GC()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">for _, s := range c.hugo().Sites </span><span class="cov0" title="0">{
                        // We have no way of knowing what site the garbage belonged to.
                        s.ProcessingStats.Cleaned = uint64(count)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *commandeer) initCPUProfile() (func(), error) <span class="cov8" title="1">{
        if c.h.cpuprofile == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">f, err := os.Create(c.h.cpuprofile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to create CPU profile")
        }</span>
        <span class="cov0" title="0">if err := pprof.StartCPUProfile(f); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to start CPU profile")
        }</span>
        <span class="cov0" title="0">return func() </span><span class="cov0" title="0">{
                pprof.StopCPUProfile()
                f.Close()
        }</span>, nil
}

func (c *commandeer) initMemProfile() <span class="cov8" title="1">{
        if c.h.memprofile == "" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov0" title="0">f, err := os.Create(c.h.memprofile)
        if err != nil </span><span class="cov0" title="0">{
                c.logger.Errorf("could not create memory profile: ", err)
        }</span>
        <span class="cov0" title="0">defer f.Close()
        runtime.GC() // get up-to-date statistics
        if err := pprof.WriteHeapProfile(f); err != nil </span><span class="cov0" title="0">{
                c.logger.Errorf("could not write memory profile: ", err)
        }</span>
}

func (c *commandeer) initTraceProfile() (func(), error) <span class="cov8" title="1">{
        if c.h.traceprofile == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">f, err := os.Create(c.h.traceprofile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to create trace file")
        }</span>

        <span class="cov0" title="0">if err := trace.Start(f); err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to start trace")
        }</span>

        <span class="cov0" title="0">return func() </span><span class="cov0" title="0">{
                trace.Stop()
                f.Close()
        }</span>, nil
}

func (c *commandeer) initMutexProfile() (func(), error) <span class="cov8" title="1">{
        if c.h.mutexprofile == "" </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">f, err := os.Create(c.h.mutexprofile)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">runtime.SetMutexProfileFraction(1)

        return func() </span><span class="cov0" title="0">{
                pprof.Lookup("mutex").WriteTo(f, 0)
                f.Close()
        }</span>, nil
}

func (c *commandeer) initMemTicker() func() <span class="cov0" title="0">{
        memticker := time.NewTicker(5 * time.Second)
        quit := make(chan struct{})
        printMem := func() </span><span class="cov0" title="0">{
                var m runtime.MemStats
                runtime.ReadMemStats(&amp;m)
                fmt.Printf("\n\nAlloc = %v\nTotalAlloc = %v\nSys = %v\nNumGC = %v\n\n", formatByteCount(m.Alloc), formatByteCount(m.TotalAlloc), formatByteCount(m.Sys), m.NumGC)
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                for </span><span class="cov0" title="0">{
                        select </span>{
                        case &lt;-memticker.C:<span class="cov0" title="0">
                                printMem()</span>
                        case &lt;-quit:<span class="cov0" title="0">
                                memticker.Stop()
                                printMem()
                                return</span>
                        }
                }
        }()

        <span class="cov0" title="0">return func() </span><span class="cov0" title="0">{
                close(quit)
        }</span>
}

func (c *commandeer) initProfiling() (func(), error) <span class="cov8" title="1">{
        stopCPUProf, err := c.initCPUProfile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">stopMutexProf, err := c.initMutexProfile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">stopTraceProf, err := c.initTraceProfile()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var stopMemTicker func()
        if c.h.printm </span><span class="cov0" title="0">{
                stopMemTicker = c.initMemTicker()
        }</span>

        <span class="cov8" title="1">return func() </span><span class="cov8" title="1">{
                c.initMemProfile()

                if stopCPUProf != nil </span><span class="cov0" title="0">{
                        stopCPUProf()
                }</span>
                <span class="cov8" title="1">if stopMutexProf != nil </span><span class="cov0" title="0">{
                        stopMutexProf()
                }</span>

                <span class="cov8" title="1">if stopTraceProf != nil </span><span class="cov0" title="0">{
                        stopTraceProf()
                }</span>

                <span class="cov8" title="1">if stopMemTicker != nil </span><span class="cov0" title="0">{
                        stopMemTicker()
                }</span>
        }, nil
}

func (c *commandeer) build() error <span class="cov8" title="1">{
        stopProfiling, err := c.initProfiling()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if stopProfiling != nil </span><span class="cov8" title="1">{
                        stopProfiling()
                }</span>
        }()

        <span class="cov8" title="1">if err := c.fullBuild(false); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO(bep) Feedback?
        <span class="cov8" title="1">if !c.h.quiet </span><span class="cov8" title="1">{
                fmt.Println()
                c.hugo().PrintProcessingStats(os.Stdout)
                fmt.Println()

                if createCounter, ok := c.destinationFs.(hugofs.DuplicatesReporter); ok </span><span class="cov0" title="0">{
                        dupes := createCounter.ReportDuplicates()
                        if dupes != "" </span><span class="cov0" title="0">{
                                c.logger.Warnln("Duplicate target paths:", dupes)
                        }</span>
                }
        }

        <span class="cov8" title="1">if c.h.buildWatch </span><span class="cov0" title="0">{
                watchDirs, err := c.getDirList()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">baseWatchDir := c.Cfg.GetString("workingDir")
                rootWatchDirs := getRootWatchDirsStr(baseWatchDir, watchDirs)

                c.logger.Printf("Watching for changes in %s%s{%s}\n", baseWatchDir, helpers.FilePathSeparator, rootWatchDirs)
                c.logger.Println("Press Ctrl+C to stop")
                watcher, err := c.newWatcher(c.h.poll, watchDirs...)
                checkErr(c.Logger, err)
                defer watcher.Close()

                sigs := make(chan os.Signal, 1)
                signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

                &lt;-sigs</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *commandeer) serverBuild() error <span class="cov8" title="1">{
        stopProfiling, err := c.initProfiling()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                if stopProfiling != nil </span><span class="cov8" title="1">{
                        stopProfiling()
                }</span>
        }()

        <span class="cov8" title="1">if err := c.fullBuild(false); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO(bep) Feedback?
        <span class="cov8" title="1">if !c.h.quiet </span><span class="cov8" title="1">{
                fmt.Println()
                c.hugo().PrintProcessingStats(os.Stdout)
                fmt.Println()
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (c *commandeer) copyStatic() (map[string]uint64, error) <span class="cov8" title="1">{
        m, err := c.doWithPublishDirs(c.copyStaticTo)
        if err == nil || os.IsNotExist(err) </span><span class="cov8" title="1">{
                return m, nil
        }</span>
        <span class="cov0" title="0">return m, err</span>
}

func (c *commandeer) doWithPublishDirs(f func(sourceFs *filesystems.SourceFilesystem) (uint64, error)) (map[string]uint64, error) <span class="cov8" title="1">{
        langCount := make(map[string]uint64)

        staticFilesystems := c.hugo().BaseFs.SourceFilesystems.Static

        if len(staticFilesystems) == 0 </span><span class="cov0" title="0">{
                c.logger.Infoln("No static directories found to sync")
                return langCount, nil
        }</span>

        <span class="cov8" title="1">for lang, fs := range staticFilesystems </span><span class="cov8" title="1">{
                cnt, err := f(fs)
                if err != nil </span><span class="cov8" title="1">{
                        return langCount, err
                }</span>

                <span class="cov0" title="0">if lang == "" </span><span class="cov0" title="0">{
                        // Not multihost
                        for _, l := range c.languages </span><span class="cov0" title="0">{
                                langCount[l.Lang] = cnt
                        }</span>
                } else<span class="cov0" title="0"> {
                        langCount[lang] = cnt
                }</span>
        }

        <span class="cov0" title="0">return langCount, nil</span>
}

type countingStatFs struct {
        afero.Fs
        statCounter uint64
}

func (fs *countingStatFs) Stat(name string) (os.FileInfo, error) <span class="cov8" title="1">{
        f, err := fs.Fs.Stat(name)
        if err == nil </span><span class="cov0" title="0">{
                if !f.IsDir() </span><span class="cov0" title="0">{
                        atomic.AddUint64(&amp;fs.statCounter, 1)
                }</span>
        }
        <span class="cov8" title="1">return f, err</span>
}

func chmodFilter(dst, src os.FileInfo) bool <span class="cov0" title="0">{
        // Hugo publishes data from multiple sources, potentially
        // with overlapping directory structures. We cannot sync permissions
        // for directories as that would mean that we might end up with write-protected
        // directories inside /public.
        // One example of this would be syncing from the Go Module cache,
        // which have 0555 directories.
        return src.IsDir()
}</span>

func (c *commandeer) copyStaticTo(sourceFs *filesystems.SourceFilesystem) (uint64, error) <span class="cov8" title="1">{
        publishDir := c.hugo().PathSpec.PublishDir
        // If root, remove the second '/'
        if publishDir == "//" </span><span class="cov0" title="0">{
                publishDir = helpers.FilePathSeparator
        }</span>

        <span class="cov8" title="1">if sourceFs.PublishFolder != "" </span><span class="cov0" title="0">{
                publishDir = filepath.Join(publishDir, sourceFs.PublishFolder)
        }</span>

        <span class="cov8" title="1">fs := &amp;countingStatFs{Fs: sourceFs.Fs}

        syncer := fsync.NewSyncer()
        syncer.NoTimes = c.Cfg.GetBool("noTimes")
        syncer.NoChmod = c.Cfg.GetBool("noChmod")
        syncer.ChmodFilter = chmodFilter
        syncer.SrcFs = fs
        syncer.DestFs = c.Fs.Destination
        // Now that we are using a unionFs for the static directories
        // We can effectively clean the publishDir on initial sync
        syncer.Delete = c.Cfg.GetBool("cleanDestinationDir")

        if syncer.Delete </span><span class="cov0" title="0">{
                c.logger.Infoln("removing all files from destination that don't exist in static dirs")

                syncer.DeleteFilter = func(f os.FileInfo) bool </span><span class="cov0" title="0">{
                        return f.IsDir() &amp;&amp; strings.HasPrefix(f.Name(), ".")
                }</span>
        }
        <span class="cov8" title="1">c.logger.Infoln("syncing static files to", publishDir)

        // because we are using a baseFs (to get the union right).
        // set sync src to root
        err := syncer.Sync(publishDir, helpers.FilePathSeparator)
        if err != nil </span><span class="cov8" title="1">{
                return 0, err
        }</span>

        // Sync runs Stat 3 times for every source file (which sounds much)
        <span class="cov0" title="0">numFiles := fs.statCounter / 3

        return numFiles, err</span>
}

func (c *commandeer) firstPathSpec() *helpers.PathSpec <span class="cov0" title="0">{
        return c.hugo().Sites[0].PathSpec
}</span>

func (c *commandeer) timeTrack(start time.Time, name string) <span class="cov8" title="1">{
        elapsed := time.Since(start)
        c.logger.Printf("%s in %v ms", name, int(1000*elapsed.Seconds()))
}</span>

// getDirList provides NewWatcher() with a list of directories to watch for changes.
func (c *commandeer) getDirList() ([]string, error) <span class="cov8" title="1">{
        var filenames []string

        walkFn := func(path string, fi hugofs.FileMetaInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Errorln("walker: ", err)
                        return nil
                }</span>

                <span class="cov8" title="1">if fi.IsDir() </span><span class="cov8" title="1">{
                        if fi.Name() == ".git" ||
                                fi.Name() == "node_modules" || fi.Name() == "bower_components" </span><span class="cov0" title="0">{
                                return filepath.SkipDir
                        }</span>

                        <span class="cov8" title="1">filenames = append(filenames, fi.Meta().Filename)</span>
                }

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">watchFiles := c.hugo().PathSpec.BaseFs.WatchDirs()
        for _, fi := range watchFiles </span><span class="cov8" title="1">{
                if !fi.IsDir() </span><span class="cov0" title="0">{
                        filenames = append(filenames, fi.Meta().Filename)
                        continue</span>
                }

                <span class="cov8" title="1">w := hugofs.NewWalkway(hugofs.WalkwayConfig{Logger: c.logger, Info: fi, WalkFn: walkFn})
                if err := w.Walk(); err != nil </span><span class="cov0" title="0">{
                        c.logger.Errorln("walker: ", err)
                }</span>
        }

        <span class="cov8" title="1">filenames = helpers.UniqueStringsSorted(filenames)

        return filenames, nil</span>
}

func (c *commandeer) buildSites(noBuildLock bool) (err error) <span class="cov8" title="1">{
        return c.hugo().Build(hugolib.BuildCfg{NoBuildLock: noBuildLock})
}</span>

func (c *commandeer) handleBuildErr(err error, msg string) <span class="cov0" title="0">{
        c.buildErr = err

        c.logger.Errorln(msg + ":\n")
        c.logger.Errorln(helpers.FirstUpper(err.Error()))
        if !c.h.quiet &amp;&amp; c.h.verbose </span><span class="cov0" title="0">{
                herrors.PrintStackTraceFromErr(err)
        }</span>
}

func (c *commandeer) rebuildSites(events []fsnotify.Event) error <span class="cov0" title="0">{
        c.buildErr = nil
        visited := c.visitedURLs.PeekAllSet()
        if c.fastRenderMode </span><span class="cov0" title="0">{
                // Make sure we always render the home pages
                for _, l := range c.languages </span><span class="cov0" title="0">{
                        langPath := c.hugo().PathSpec.GetLangSubDir(l.Lang)
                        if langPath != "" </span><span class="cov0" title="0">{
                                langPath = langPath + "/"
                        }</span>
                        <span class="cov0" title="0">home := c.hugo().PathSpec.PrependBasePath("/"+langPath, false)
                        visited[home] = true</span>
                }
        }
        <span class="cov0" title="0">return c.hugo().Build(hugolib.BuildCfg{NoBuildLock: true, RecentlyVisited: visited, ErrRecovery: c.wasError}, events...)</span>
}

func (c *commandeer) partialReRender(urls ...string) error <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                c.wasError = false
        }</span>()
        <span class="cov8" title="1">c.buildErr = nil
        visited := make(map[string]bool)
        for _, url := range urls </span><span class="cov8" title="1">{
                visited[url] = true
        }</span>

        // Note: We do not set NoBuildLock as the file lock is not acquired at this stage.
        <span class="cov8" title="1">return c.hugo().Build(hugolib.BuildCfg{NoBuildLock: false, RecentlyVisited: visited, PartialReRender: true, ErrRecovery: c.wasError})</span>
}

func (c *commandeer) fullRebuild(changeType string) <span class="cov0" title="0">{
        if changeType == configChangeGoMod </span><span class="cov0" title="0">{
                // go.mod may be changed during the build itself, and
                // we really want to prevent superfluous builds.
                if !c.fullRebuildSem.TryAcquire(1) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">c.fullRebuildSem.Release(1)</span>
        }

        <span class="cov0" title="0">c.fullRebuildSem.Acquire(context.Background(), 1)

        go func() </span><span class="cov0" title="0">{
                defer c.fullRebuildSem.Release(1)

                c.printChangeDetected(changeType)

                defer func() </span><span class="cov0" title="0">{
                        // Allow any file system events to arrive back.
                        // This will block any rebuild on config changes for the
                        // duration of the sleep.
                        time.Sleep(2 * time.Second)
                }</span>()

                <span class="cov0" title="0">defer c.timeTrack(time.Now(), "Rebuilt")

                c.commandeerHugoState = newCommandeerHugoState()
                err := c.loadConfig()
                if err != nil </span><span class="cov0" title="0">{
                        // Set the processing on pause until the state is recovered.
                        c.paused = true
                        c.handleBuildErr(err, "Failed to reload config")

                }</span> else<span class="cov0" title="0"> {
                        c.paused = false
                }</span>

                <span class="cov0" title="0">if !c.paused </span><span class="cov0" title="0">{
                        _, err := c.copyStatic()
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.Errorln(err)
                                return
                        }</span>

                        <span class="cov0" title="0">err = c.buildSites(true)
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.Errorln(err)
                        }</span> else<span class="cov0" title="0"> if !c.h.buildWatch &amp;&amp; !c.Cfg.GetBool("disableLiveReload") </span><span class="cov0" title="0">{
                                livereload.ForceRefresh()
                        }</span>
                }
        }()
}

// newWatcher creates a new watcher to watch filesystem events.
func (c *commandeer) newWatcher(pollIntervalStr string, dirList ...string) (*watcher.Batcher, error) <span class="cov8" title="1">{
        if runtime.GOOS == "darwin" </span><span class="cov0" title="0">{
                tweakLimit()
        }</span>

        <span class="cov8" title="1">staticSyncer, err := newStaticSyncer(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var pollInterval time.Duration
        poll := pollIntervalStr != ""
        if poll </span><span class="cov0" title="0">{
                pollInterval, err = types.ToDurationE(pollIntervalStr)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid value for flag poll: %s", err)
                }</span>
                <span class="cov0" title="0">c.logger.Printf("Use watcher with poll interval %v", pollInterval)</span>
        }

        <span class="cov8" title="1">if pollInterval == 0 </span><span class="cov8" title="1">{
                pollInterval = 500 * time.Millisecond
        }</span>

        <span class="cov8" title="1">watcher, err := watcher.New(500*time.Millisecond, pollInterval, poll)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for _, d := range dirList </span><span class="cov8" title="1">{
                if d != "" </span><span class="cov8" title="1">{
                        _ = watcher.Add(d)
                }</span>
        }

        // Identifies changes to config (config.toml) files.
        <span class="cov8" title="1">configSet := make(map[string]bool)

        c.logger.Println("Watching for config changes in", strings.Join(c.configFiles, ", "))
        for _, configFile := range c.configFiles </span><span class="cov8" title="1">{
                watcher.Add(configFile)
                configSet[configFile] = true
        }</span>

        <span class="cov8" title="1">go func() </span><span class="cov8" title="1">{
                for </span><span class="cov8" title="1">{
                        select </span>{
                        case evs := &lt;-watcher.Events:<span class="cov0" title="0">
                                unlock, err := c.buildLock()
                                if err != nil </span><span class="cov0" title="0">{
                                        c.logger.Errorln("Failed to acquire a build lock: %s", err)
                                        return
                                }</span>
                                <span class="cov0" title="0">c.handleEvents(watcher, staticSyncer, evs, configSet)
                                if c.showErrorInBrowser &amp;&amp; c.errCount() &gt; 0 </span><span class="cov0" title="0">{
                                        // Need to reload browser to show the error
                                        livereload.ForceRefresh()
                                }</span>
                                <span class="cov0" title="0">unlock()</span>
                        case err := &lt;-watcher.Errors():<span class="cov8" title="1">
                                if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        c.logger.Errorln("Error while watching:", err)
                                }</span>
                        }
                }
        }()

        <span class="cov8" title="1">return watcher, nil</span>
}

func (c *commandeer) printChangeDetected(typ string) <span class="cov0" title="0">{
        msg := "\nChange"
        if typ != "" </span><span class="cov0" title="0">{
                msg += " of " + typ
        }</span>
        <span class="cov0" title="0">msg += " detected, rebuilding site."

        c.logger.Println(msg)
        const layout = "2006-01-02 15:04:05.000 -0700"
        c.logger.Println(time.Now().Format(layout))</span>
}

const (
        configChangeConfig = "config file"
        configChangeGoMod  = "go.mod file"
)

func (c *commandeer) handleEvents(watcher *watcher.Batcher,
        staticSyncer *staticSyncer,
        evs []fsnotify.Event,
        configSet map[string]bool) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                c.wasError = false
        }</span>()

        <span class="cov0" title="0">var isHandled bool

        for _, ev := range evs </span><span class="cov0" title="0">{
                isConfig := configSet[ev.Name]
                configChangeType := configChangeConfig
                if isConfig </span><span class="cov0" title="0">{
                        if strings.Contains(ev.Name, "go.mod") </span><span class="cov0" title="0">{
                                configChangeType = configChangeGoMod
                        }</span>
                }
                <span class="cov0" title="0">if !isConfig </span><span class="cov0" title="0">{
                        // It may be one of the /config folders
                        dirname := filepath.Dir(ev.Name)
                        if dirname != "." &amp;&amp; configSet[dirname] </span><span class="cov0" title="0">{
                                isConfig = true
                        }</span>
                }

                <span class="cov0" title="0">if isConfig </span><span class="cov0" title="0">{
                        isHandled = true

                        if ev.Op&amp;fsnotify.Chmod == fsnotify.Chmod </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">if ev.Op&amp;fsnotify.Remove == fsnotify.Remove || ev.Op&amp;fsnotify.Rename == fsnotify.Rename </span><span class="cov0" title="0">{
                                for _, configFile := range c.configFiles </span><span class="cov0" title="0">{
                                        counter := 0
                                        for watcher.Add(configFile) != nil </span><span class="cov0" title="0">{
                                                counter++
                                                if counter &gt;= 100 </span><span class="cov0" title="0">{
                                                        break</span>
                                                }
                                                <span class="cov0" title="0">time.Sleep(100 * time.Millisecond)</span>
                                        }
                                }
                        }

                        // Config file(s) changed. Need full rebuild.
                        <span class="cov0" title="0">c.fullRebuild(configChangeType)

                        return</span>
                }
        }

        <span class="cov0" title="0">if isHandled </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">if c.paused </span><span class="cov0" title="0">{
                // Wait for the server to get into a consistent state before
                // we continue with processing.
                return
        }</span>

        <span class="cov0" title="0">if len(evs) &gt; 50 </span><span class="cov0" title="0">{
                // This is probably a mass edit of the content dir.
                // Schedule a full rebuild for when it slows down.
                c.debounce(func() </span><span class="cov0" title="0">{
                        c.fullRebuild("")
                }</span>)
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">c.logger.Infoln("Received System Events:", evs)

        staticEvents := []fsnotify.Event{}
        dynamicEvents := []fsnotify.Event{}

        filtered := []fsnotify.Event{}
        for _, ev := range evs </span><span class="cov0" title="0">{
                if c.hugo().ShouldSkipFileChangeEvent(ev) </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Check the most specific first, i.e. files.
                <span class="cov0" title="0">contentMapped := c.hugo().ContentChanges.GetSymbolicLinkMappings(ev.Name)
                if len(contentMapped) &gt; 0 </span><span class="cov0" title="0">{
                        for _, mapped := range contentMapped </span><span class="cov0" title="0">{
                                filtered = append(filtered, fsnotify.Event{Name: mapped, Op: ev.Op})
                        }</span>
                        <span class="cov0" title="0">continue</span>
                }

                // Check for any symbolic directory mapping.

                <span class="cov0" title="0">dir, name := filepath.Split(ev.Name)

                contentMapped = c.hugo().ContentChanges.GetSymbolicLinkMappings(dir)

                if len(contentMapped) == 0 </span><span class="cov0" title="0">{
                        filtered = append(filtered, ev)
                        continue</span>
                }

                <span class="cov0" title="0">for _, mapped := range contentMapped </span><span class="cov0" title="0">{
                        mappedFilename := filepath.Join(mapped, name)
                        filtered = append(filtered, fsnotify.Event{Name: mappedFilename, Op: ev.Op})
                }</span>
        }

        <span class="cov0" title="0">evs = filtered

        for _, ev := range evs </span><span class="cov0" title="0">{
                ext := filepath.Ext(ev.Name)
                baseName := filepath.Base(ev.Name)
                istemp := strings.HasSuffix(ext, "~") ||
                        (ext == ".swp") || // vim
                        (ext == ".swx") || // vim
                        (ext == ".tmp") || // generic temp file
                        (ext == ".DS_Store") || // OSX Thumbnail
                        baseName == "4913" || // vim
                        strings.HasPrefix(ext, ".goutputstream") || // gnome
                        strings.HasSuffix(ext, "jb_old___") || // intelliJ
                        strings.HasSuffix(ext, "jb_tmp___") || // intelliJ
                        strings.HasSuffix(ext, "jb_bak___") || // intelliJ
                        strings.HasPrefix(ext, ".sb-") || // byword
                        strings.HasPrefix(baseName, ".#") || // emacs
                        strings.HasPrefix(baseName, "#") // emacs
                if istemp </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if c.hugo().Deps.SourceSpec.IgnoreFile(ev.Name) </span><span class="cov0" title="0">{
                        continue</span>
                }
                // Sometimes during rm -rf operations a '"": REMOVE' is triggered. Just ignore these
                <span class="cov0" title="0">if ev.Name == "" </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Write and rename operations are often followed by CHMOD.
                // There may be valid use cases for rebuilding the site on CHMOD,
                // but that will require more complex logic than this simple conditional.
                // On OS X this seems to be related to Spotlight, see:
                // https://github.com/go-fsnotify/fsnotify/issues/15
                // A workaround is to put your site(s) on the Spotlight exception list,
                // but that may be a little mysterious for most end users.
                // So, for now, we skip reload on CHMOD.
                // We do have to check for WRITE though. On slower laptops a Chmod
                // could be aggregated with other important events, and we still want
                // to rebuild on those
                <span class="cov0" title="0">if ev.Op&amp;(fsnotify.Chmod|fsnotify.Write|fsnotify.Create) == fsnotify.Chmod </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">walkAdder := func(path string, f hugofs.FileMetaInfo, err error) error </span><span class="cov0" title="0">{
                        if f.IsDir() </span><span class="cov0" title="0">{
                                c.logger.Println("adding created directory to watchlist", path)
                                if err := watcher.Add(path); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        } else<span class="cov0" title="0"> if !staticSyncer.isStatic(path) </span><span class="cov0" title="0">{
                                // Hugo's rebuilding logic is entirely file based. When you drop a new folder into
                                // /content on OSX, the above logic will handle future watching of those files,
                                // but the initial CREATE is lost.
                                dynamicEvents = append(dynamicEvents, fsnotify.Event{Name: path, Op: fsnotify.Create})
                        }</span>
                        <span class="cov0" title="0">return nil</span>
                }

                // recursively add new directories to watch list
                // When mkdir -p is used, only the top directory triggers an event (at least on OSX)
                <span class="cov0" title="0">if ev.Op&amp;fsnotify.Create == fsnotify.Create </span><span class="cov0" title="0">{
                        if s, err := c.Fs.Source.Stat(ev.Name); err == nil &amp;&amp; s.Mode().IsDir() </span><span class="cov0" title="0">{
                                _ = helpers.SymbolicWalk(c.Fs.Source, ev.Name, walkAdder)
                        }</span>
                }

                <span class="cov0" title="0">if staticSyncer.isStatic(ev.Name) </span><span class="cov0" title="0">{
                        staticEvents = append(staticEvents, ev)
                }</span> else<span class="cov0" title="0"> {
                        dynamicEvents = append(dynamicEvents, ev)
                }</span>
        }

        <span class="cov0" title="0">if len(staticEvents) &gt; 0 </span><span class="cov0" title="0">{
                c.printChangeDetected("Static files")

                if c.Cfg.GetBool("forceSyncStatic") </span><span class="cov0" title="0">{
                        c.logger.Printf("Syncing all static files\n")
                        _, err := c.copyStatic()
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.Errorln("Error copying static files to publish dir:", err)
                                return
                        }</span>
                } else<span class="cov0" title="0"> {
                        if err := staticSyncer.syncsStaticEvents(staticEvents); err != nil </span><span class="cov0" title="0">{
                                c.logger.Errorln("Error syncing static files to publish dir:", err)
                                return
                        }</span>
                }

                <span class="cov0" title="0">if !c.h.buildWatch &amp;&amp; !c.Cfg.GetBool("disableLiveReload") </span><span class="cov0" title="0">{
                        // Will block forever trying to write to a channel that nobody is reading if livereload isn't initialized

                        // force refresh when more than one file
                        if !c.wasError &amp;&amp; len(staticEvents) == 1 </span><span class="cov0" title="0">{
                                ev := staticEvents[0]
                                path := c.hugo().BaseFs.SourceFilesystems.MakeStaticPathRelative(ev.Name)
                                path = c.firstPathSpec().RelURL(helpers.ToSlashTrimLeading(path), false)

                                livereload.RefreshPath(path)
                        }</span> else<span class="cov0" title="0"> {
                                livereload.ForceRefresh()
                        }</span>
                }
        }

        <span class="cov0" title="0">if len(dynamicEvents) &gt; 0 </span><span class="cov0" title="0">{
                partitionedEvents := partitionDynamicEvents(
                        c.firstPathSpec().BaseFs.SourceFilesystems,
                        dynamicEvents)

                doLiveReload := !c.h.buildWatch &amp;&amp; !c.Cfg.GetBool("disableLiveReload")
                onePageName := pickOneWriteOrCreatePath(partitionedEvents.ContentEvents)

                c.printChangeDetected("")
                c.changeDetector.PrepareNew()

                func() </span><span class="cov0" title="0">{
                        defer c.timeTrack(time.Now(), "Total")
                        if err := c.rebuildSites(dynamicEvents); err != nil </span><span class="cov0" title="0">{
                                c.handleBuildErr(err, "Rebuild failed")
                        }</span>
                }()

                <span class="cov0" title="0">if doLiveReload </span><span class="cov0" title="0">{
                        if len(partitionedEvents.ContentEvents) == 0 &amp;&amp; len(partitionedEvents.AssetEvents) &gt; 0 </span><span class="cov0" title="0">{
                                if c.wasError </span><span class="cov0" title="0">{
                                        livereload.ForceRefresh()
                                        return
                                }</span>
                                <span class="cov0" title="0">changed := c.changeDetector.changed()
                                if c.changeDetector != nil &amp;&amp; len(changed) == 0 </span><span class="cov0" title="0">{
                                        // Nothing has changed.
                                        return
                                }</span> else<span class="cov0" title="0"> if len(changed) == 1 </span><span class="cov0" title="0">{
                                        pathToRefresh := c.firstPathSpec().RelURL(helpers.ToSlashTrimLeading(changed[0]), false)
                                        livereload.RefreshPath(pathToRefresh)
                                }</span> else<span class="cov0" title="0"> {
                                        livereload.ForceRefresh()
                                }</span>
                        }

                        <span class="cov0" title="0">if len(partitionedEvents.ContentEvents) &gt; 0 </span><span class="cov0" title="0">{

                                navigate := c.Cfg.GetBool("navigateToChanged")
                                // We have fetched the same page above, but it may have
                                // changed.
                                var p page.Page

                                if navigate </span><span class="cov0" title="0">{
                                        if onePageName != "" </span><span class="cov0" title="0">{
                                                p = c.hugo().GetContentPage(onePageName)
                                        }</span>
                                }

                                <span class="cov0" title="0">if p != nil </span><span class="cov0" title="0">{
                                        livereload.NavigateToPathForPort(p.RelPermalink(), p.Site().ServerPort())
                                }</span> else<span class="cov0" title="0"> {
                                        livereload.ForceRefresh()
                                }</span>
                        }
                }
        }
}

// dynamicEvents contains events that is considered dynamic, as in "not static".
// Both of these categories will trigger a new build, but the asset events
// does not fit into the "navigate to changed" logic.
type dynamicEvents struct {
        ContentEvents []fsnotify.Event
        AssetEvents   []fsnotify.Event
}

func partitionDynamicEvents(sourceFs *filesystems.SourceFilesystems, events []fsnotify.Event) (de dynamicEvents) <span class="cov0" title="0">{
        for _, e := range events </span><span class="cov0" title="0">{
                if sourceFs.IsAsset(e.Name) </span><span class="cov0" title="0">{
                        de.AssetEvents = append(de.AssetEvents, e)
                }</span> else<span class="cov0" title="0"> {
                        de.ContentEvents = append(de.ContentEvents, e)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}

func pickOneWriteOrCreatePath(events []fsnotify.Event) string <span class="cov0" title="0">{
        name := ""

        for _, ev := range events </span><span class="cov0" title="0">{
                if ev.Op&amp;fsnotify.Write == fsnotify.Write || ev.Op&amp;fsnotify.Create == fsnotify.Create </span><span class="cov0" title="0">{
                        if files.IsIndexContentFile(ev.Name) </span><span class="cov0" title="0">{
                                return ev.Name
                        }</span>

                        <span class="cov0" title="0">if files.IsContentFile(ev.Name) </span><span class="cov0" title="0">{
                                name = ev.Name
                        }</span>

                }
        }

        <span class="cov0" title="0">return name</span>
}

func formatByteCount(b uint64) string <span class="cov0" title="0">{
        const unit = 1000
        if b &lt; unit </span><span class="cov0" title="0">{
                return fmt.Sprintf("%d B", b)
        }</span>
        <span class="cov0" title="0">div, exp := int64(unit), 0
        for n := b / unit; n &gt;= unit; n /= unit </span><span class="cov0" title="0">{
                div *= unit
                exp++
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%.1f %cB",
                float64(b)/float64(div), "kMGTPE"[exp])</span>
}
</pre>
		
		<pre class="file" id="file19" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "errors"
        "fmt"
        "io/ioutil"
        "os"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "time"
        "unicode"

        "github.com/gohugoio/hugo/parser/pageparser"

        "github.com/gohugoio/hugo/common/hugio"

        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/hugolib"
        "github.com/gohugoio/hugo/parser"
        "github.com/spf13/afero"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*importCmd)(nil)

type importCmd struct {
        *baseCmd
}

func newImportCmd() *importCmd <span class="cov8" title="1">{
        cc := &amp;importCmd{}

        cc.baseCmd = newBaseCmd(&amp;cobra.Command{
                Use:   "import",
                Short: "Import your site from others.",
                Long: `Import your site from other web site generators like Jekyll.

Import requires a subcommand, e.g. ` + "`hugo import jekyll jekyll_root_path target_path`.",
                RunE: nil,
        })

        importJekyllCmd := &amp;cobra.Command{
                Use:   "jekyll",
                Short: "hugo import from Jekyll",
                Long: `hugo import from Jekyll.

Import from Jekyll requires two paths, e.g. ` + "`hugo import jekyll jekyll_root_path target_path`.",
                RunE: cc.importFromJekyll,
        }

        importJekyllCmd.Flags().Bool("force", false, "allow import into non-empty target directory")

        cc.cmd.AddCommand(importJekyllCmd)

        return cc
}</span>

func (i *importCmd) importFromJekyll(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return newUserError(`import from jekyll requires two paths, e.g. ` + "`hugo import jekyll jekyll_root_path target_path`.")
        }</span>

        <span class="cov0" title="0">jekyllRoot, err := filepath.Abs(filepath.Clean(args[0]))
        if err != nil </span><span class="cov0" title="0">{
                return newUserError("path error:", args[0])
        }</span>

        <span class="cov0" title="0">targetDir, err := filepath.Abs(filepath.Clean(args[1]))
        if err != nil </span><span class="cov0" title="0">{
                return newUserError("path error:", args[1])
        }</span>

        <span class="cov0" title="0">jww.INFO.Println("Import Jekyll from:", jekyllRoot, "to:", targetDir)

        if strings.HasPrefix(filepath.Dir(targetDir), jekyllRoot) </span><span class="cov0" title="0">{
                return newUserError("abort: target path should not be inside the Jekyll root")
        }</span>

        <span class="cov0" title="0">forceImport, _ := cmd.Flags().GetBool("force")

        fs := afero.NewOsFs()
        jekyllPostDirs, hasAnyPost := i.getJekyllDirInfo(fs, jekyllRoot)
        if !hasAnyPost </span><span class="cov0" title="0">{
                return errors.New("abort: jekyll root contains neither posts nor drafts")
        }</span>

        <span class="cov0" title="0">err = i.createSiteFromJekyll(jekyllRoot, targetDir, jekyllPostDirs, forceImport)

        if err != nil </span><span class="cov0" title="0">{
                return newUserError(err)
        }</span>

        <span class="cov0" title="0">jww.FEEDBACK.Println("Importing...")

        fileCount := 0
        callback := func(path string, fi hugofs.FileMetaInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">relPath, err := filepath.Rel(jekyllRoot, path)
                if err != nil </span><span class="cov0" title="0">{
                        return newUserError("get rel path error:", path)
                }</span>

                <span class="cov0" title="0">relPath = filepath.ToSlash(relPath)
                draft := false

                switch </span>{
                case strings.Contains(relPath, "_posts/"):<span class="cov0" title="0">
                        relPath = filepath.Join("content/post", strings.Replace(relPath, "_posts/", "", -1))</span>
                case strings.Contains(relPath, "_drafts/"):<span class="cov0" title="0">
                        relPath = filepath.Join("content/draft", strings.Replace(relPath, "_drafts/", "", -1))
                        draft = true</span>
                default:<span class="cov0" title="0">
                        return nil</span>
                }

                <span class="cov0" title="0">fileCount++
                return convertJekyllPost(path, relPath, targetDir, draft)</span>
        }

        <span class="cov0" title="0">for jekyllPostDir, hasAnyPostInDir := range jekyllPostDirs </span><span class="cov0" title="0">{
                if hasAnyPostInDir </span><span class="cov0" title="0">{
                        if err = helpers.SymbolicWalk(hugofs.Os, filepath.Join(jekyllRoot, jekyllPostDir), callback); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">jww.FEEDBACK.Println("Congratulations!", fileCount, "post(s) imported!")
        jww.FEEDBACK.Println("Now, start Hugo by yourself:\n" +
                "$ git clone https://github.com/spf13/herring-cove.git " + args[1] + "/themes/herring-cove")
        jww.FEEDBACK.Println("$ cd " + args[1] + "\n$ hugo server --theme=herring-cove")

        return nil</span>
}

func (i *importCmd) getJekyllDirInfo(fs afero.Fs, jekyllRoot string) (map[string]bool, bool) <span class="cov0" title="0">{
        postDirs := make(map[string]bool)
        hasAnyPost := false
        if entries, err := ioutil.ReadDir(jekyllRoot); err == nil </span><span class="cov0" title="0">{
                for _, entry := range entries </span><span class="cov0" title="0">{
                        if entry.IsDir() </span><span class="cov0" title="0">{
                                subDir := filepath.Join(jekyllRoot, entry.Name())
                                if isPostDir, hasAnyPostInDir := i.retrieveJekyllPostDir(fs, subDir); isPostDir </span><span class="cov0" title="0">{
                                        postDirs[entry.Name()] = hasAnyPostInDir
                                        if hasAnyPostInDir </span><span class="cov0" title="0">{
                                                hasAnyPost = true
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov0" title="0">return postDirs, hasAnyPost</span>
}

func (i *importCmd) retrieveJekyllPostDir(fs afero.Fs, dir string) (bool, bool) <span class="cov0" title="0">{
        if strings.HasSuffix(dir, "_posts") || strings.HasSuffix(dir, "_drafts") </span><span class="cov0" title="0">{
                isEmpty, _ := helpers.IsEmpty(dir, fs)
                return true, !isEmpty
        }</span>

        <span class="cov0" title="0">if entries, err := ioutil.ReadDir(dir); err == nil </span><span class="cov0" title="0">{
                for _, entry := range entries </span><span class="cov0" title="0">{
                        if entry.IsDir() </span><span class="cov0" title="0">{
                                subDir := filepath.Join(dir, entry.Name())
                                if isPostDir, hasAnyPost := i.retrieveJekyllPostDir(fs, subDir); isPostDir </span><span class="cov0" title="0">{
                                        return isPostDir, hasAnyPost
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">return false, true</span>
}

func (i *importCmd) createSiteFromJekyll(jekyllRoot, targetDir string, jekyllPostDirs map[string]bool, force bool) error <span class="cov0" title="0">{
        s, err := hugolib.NewSiteDefaultLang()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">fs := s.Fs.Source
        if exists, _ := helpers.Exists(targetDir, fs); exists </span><span class="cov0" title="0">{
                if isDir, _ := helpers.IsDir(targetDir, fs); !isDir </span><span class="cov0" title="0">{
                        return errors.New("target path \"" + targetDir + "\" exists but is not a directory")
                }</span>

                <span class="cov0" title="0">isEmpty, _ := helpers.IsEmpty(targetDir, fs)

                if !isEmpty &amp;&amp; !force </span><span class="cov0" title="0">{
                        return errors.New("target path \"" + targetDir + "\" exists and is not empty")
                }</span>
        }

        <span class="cov0" title="0">jekyllConfig := i.loadJekyllConfig(fs, jekyllRoot)

        mkdir(targetDir, "layouts")
        mkdir(targetDir, "content")
        mkdir(targetDir, "archetypes")
        mkdir(targetDir, "static")
        mkdir(targetDir, "data")
        mkdir(targetDir, "themes")

        i.createConfigFromJekyll(fs, targetDir, "yaml", jekyllConfig)

        i.copyJekyllFilesAndFolders(jekyllRoot, filepath.Join(targetDir, "static"), jekyllPostDirs)

        return nil</span>
}

func (i *importCmd) loadJekyllConfig(fs afero.Fs, jekyllRoot string) map[string]interface{} <span class="cov0" title="0">{
        path := filepath.Join(jekyllRoot, "_config.yml")

        exists, err := helpers.Exists(path, fs)

        if err != nil || !exists </span><span class="cov0" title="0">{
                jww.WARN.Println("_config.yaml not found: Is the specified Jekyll root correct?")
                return nil
        }</span>

        <span class="cov0" title="0">f, err := fs.Open(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">defer f.Close()

        b, err := ioutil.ReadAll(f)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">c, err := metadecoders.Default.UnmarshalToMap(b, metadecoders.YAML)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return c</span>
}

func (i *importCmd) createConfigFromJekyll(fs afero.Fs, inpath string, kind metadecoders.Format, jekyllConfig map[string]interface{}) (err error) <span class="cov0" title="0">{
        title := "My New Hugo Site"
        baseURL := "http://example.org/"

        for key, value := range jekyllConfig </span><span class="cov0" title="0">{
                lowerKey := strings.ToLower(key)

                switch lowerKey </span>{
                case "title":<span class="cov0" title="0">
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                title = str
                        }</span>

                case "url":<span class="cov0" title="0">
                        if str, ok := value.(string); ok </span><span class="cov0" title="0">{
                                baseURL = str
                        }</span>
                }
        }

        <span class="cov0" title="0">in := map[string]interface{}{
                "baseURL":            baseURL,
                "title":              title,
                "languageCode":       "en-us",
                "disablePathToLower": true,
        }

        var buf bytes.Buffer
        err = parser.InterfaceToConfig(in, kind, &amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return helpers.WriteToDisk(filepath.Join(inpath, "config."+string(kind)), &amp;buf, fs)</span>
}

func (i *importCmd) copyJekyllFilesAndFolders(jekyllRoot, dest string, jekyllPostDirs map[string]bool) (err error) <span class="cov0" title="0">{
        fs := hugofs.Os

        fi, err := fs.Stat(jekyllRoot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if !fi.IsDir() </span><span class="cov0" title="0">{
                return errors.New(jekyllRoot + " is not a directory")
        }</span>
        <span class="cov0" title="0">err = os.MkdirAll(dest, fi.Mode())
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">entries, err := ioutil.ReadDir(jekyllRoot)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, entry := range entries </span><span class="cov0" title="0">{
                sfp := filepath.Join(jekyllRoot, entry.Name())
                dfp := filepath.Join(dest, entry.Name())
                if entry.IsDir() </span><span class="cov0" title="0">{
                        if entry.Name()[0] != '_' &amp;&amp; entry.Name()[0] != '.' </span><span class="cov0" title="0">{
                                if _, ok := jekyllPostDirs[entry.Name()]; !ok </span><span class="cov0" title="0">{
                                        err = hugio.CopyDir(fs, sfp, dfp, nil)
                                        if err != nil </span><span class="cov0" title="0">{
                                                jww.ERROR.Println(err)
                                        }</span>
                                }
                        }
                } else<span class="cov0" title="0"> {
                        lowerEntryName := strings.ToLower(entry.Name())
                        exceptSuffix := []string{
                                ".md", ".markdown", ".html", ".htm",
                                ".xml", ".textile", "rakefile", "gemfile", ".lock",
                        }
                        isExcept := false
                        for _, suffix := range exceptSuffix </span><span class="cov0" title="0">{
                                if strings.HasSuffix(lowerEntryName, suffix) </span><span class="cov0" title="0">{
                                        isExcept = true
                                        break</span>
                                }
                        }

                        <span class="cov0" title="0">if !isExcept &amp;&amp; entry.Name()[0] != '.' &amp;&amp; entry.Name()[0] != '_' </span><span class="cov0" title="0">{
                                err = hugio.CopyFile(fs, sfp, dfp)
                                if err != nil </span><span class="cov0" title="0">{
                                        jww.ERROR.Println(err)
                                }</span>
                        }
                }

        }
        <span class="cov0" title="0">return nil</span>
}

func parseJekyllFilename(filename string) (time.Time, string, error) <span class="cov8" title="1">{
        re := regexp.MustCompile(`(\d+-\d+-\d+)-(.+)\..*`)
        r := re.FindAllStringSubmatch(filename, -1)
        if len(r) == 0 </span><span class="cov0" title="0">{
                return time.Now(), "", errors.New("filename not match")
        }</span>

        <span class="cov8" title="1">postDate, err := time.Parse("2006-1-2", r[0][1])
        if err != nil </span><span class="cov0" title="0">{
                return time.Now(), "", err
        }</span>

        <span class="cov8" title="1">postName := r[0][2]

        return postDate, postName, nil</span>
}

func convertJekyllPost(path, relPath, targetDir string, draft bool) error <span class="cov0" title="0">{
        jww.TRACE.Println("Converting", path)

        filename := filepath.Base(path)
        postDate, postName, err := parseJekyllFilename(filename)
        if err != nil </span><span class="cov0" title="0">{
                jww.WARN.Printf("Failed to parse filename '%s': %s. Skipping.", filename, err)
                return nil
        }</span>

        <span class="cov0" title="0">jww.TRACE.Println(filename, postDate, postName)

        targetFile := filepath.Join(targetDir, relPath)
        targetParentDir := filepath.Dir(targetFile)
        os.MkdirAll(targetParentDir, 0777)

        contentBytes, err := ioutil.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Println("Read file error:", path)
                return err
        }</span>

        <span class="cov0" title="0">pf, err := pageparser.ParseFrontMatterAndContent(bytes.NewReader(contentBytes))
        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Println("Parse file error:", path)
                return err
        }</span>

        <span class="cov0" title="0">newmetadata, err := convertJekyllMetaData(pf.FrontMatter, postName, postDate, draft)
        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Println("Convert metadata error:", path)
                return err
        }</span>

        <span class="cov0" title="0">content, err := convertJekyllContent(newmetadata, string(pf.Content))
        if err != nil </span><span class="cov0" title="0">{
                jww.ERROR.Println("Converting Jekyll error:", path)
                return err
        }</span>

        <span class="cov0" title="0">fs := hugofs.Os
        if err := helpers.WriteToDisk(targetFile, strings.NewReader(content), fs); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to save file %q: %s", filename, err)
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func convertJekyllMetaData(m interface{}, postName string, postDate time.Time, draft bool) (interface{}, error) <span class="cov8" title="1">{
        metadata, err := maps.ToStringMapE(m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if draft </span><span class="cov8" title="1">{
                metadata["draft"] = true
        }</span>

        <span class="cov8" title="1">for key, value := range metadata </span><span class="cov8" title="1">{
                lowerKey := strings.ToLower(key)

                switch lowerKey </span>{
                case "layout":<span class="cov8" title="1">
                        delete(metadata, key)</span>
                case "permalink":<span class="cov8" title="1">
                        if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                                metadata["url"] = str
                        }</span>
                        <span class="cov8" title="1">delete(metadata, key)</span>
                case "category":<span class="cov8" title="1">
                        if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                                metadata["categories"] = []string{str}
                        }</span>
                        <span class="cov8" title="1">delete(metadata, key)</span>
                case "excerpt_separator":<span class="cov8" title="1">
                        if key != lowerKey </span><span class="cov8" title="1">{
                                delete(metadata, key)
                                metadata[lowerKey] = value
                        }</span>
                case "date":<span class="cov8" title="1">
                        if str, ok := value.(string); ok </span><span class="cov8" title="1">{
                                re := regexp.MustCompile(`(\d+):(\d+):(\d+)`)
                                r := re.FindAllStringSubmatch(str, -1)
                                if len(r) &gt; 0 </span><span class="cov8" title="1">{
                                        hour, _ := strconv.Atoi(r[0][1])
                                        minute, _ := strconv.Atoi(r[0][2])
                                        second, _ := strconv.Atoi(r[0][3])
                                        postDate = time.Date(postDate.Year(), postDate.Month(), postDate.Day(), hour, minute, second, 0, time.UTC)
                                }</span>
                        }
                        <span class="cov8" title="1">delete(metadata, key)</span>
                }

        }

        <span class="cov8" title="1">metadata["date"] = postDate.Format(time.RFC3339)

        return metadata, nil</span>
}

func convertJekyllContent(m interface{}, content string) (string, error) <span class="cov8" title="1">{
        metadata, _ := maps.ToStringMapE(m)

        lines := strings.Split(content, "\n")
        var resultLines []string
        for _, line := range lines </span><span class="cov8" title="1">{
                resultLines = append(resultLines, strings.Trim(line, "\r\n"))
        }</span>

        <span class="cov8" title="1">content = strings.Join(resultLines, "\n")

        excerptSep := "&lt;!--more--&gt;"
        if value, ok := metadata["excerpt_separator"]; ok </span><span class="cov8" title="1">{
                if str, strOk := value.(string); strOk </span><span class="cov8" title="1">{
                        content = strings.Replace(content, strings.TrimSpace(str), excerptSep, -1)
                }</span>
        }

        <span class="cov8" title="1">replaceList := []struct {
                re      *regexp.Regexp
                replace string
        }{
                {regexp.MustCompile("(?i)&lt;!-- more --&gt;"), "&lt;!--more--&gt;"},
                {regexp.MustCompile(`\{%\s*raw\s*%\}\s*(.*?)\s*\{%\s*endraw\s*%\}`), "$1"},
                {regexp.MustCompile(`{%\s*endhighlight\s*%}`), "{{&lt; / highlight &gt;}}"},
        }

        for _, replace := range replaceList </span><span class="cov8" title="1">{
                content = replace.re.ReplaceAllString(content, replace.replace)
        }</span>

        <span class="cov8" title="1">replaceListFunc := []struct {
                re      *regexp.Regexp
                replace func(string) string
        }{
                // Octopress image tag: http://octopress.org/docs/plugins/image-tag/
                {regexp.MustCompile(`{%\s+img\s*(.*?)\s*%}`), replaceImageTag},
                {regexp.MustCompile(`{%\s*highlight\s*(.*?)\s*%}`), replaceHighlightTag},
        }

        for _, replace := range replaceListFunc </span><span class="cov8" title="1">{
                content = replace.re.ReplaceAllStringFunc(content, replace.replace)
        }</span>

        <span class="cov8" title="1">var buf bytes.Buffer
        if len(metadata) != 0 </span><span class="cov8" title="1">{
                err := parser.InterfaceToFrontMatter(m, metadecoders.YAML, &amp;buf)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }
        <span class="cov8" title="1">buf.WriteString(content)

        return buf.String(), nil</span>
}

func replaceHighlightTag(match string) string <span class="cov8" title="1">{
        r := regexp.MustCompile(`{%\s*highlight\s*(.*?)\s*%}`)
        parts := r.FindStringSubmatch(match)
        lastQuote := rune(0)
        f := func(c rune) bool </span><span class="cov8" title="1">{
                switch </span>{
                case c == lastQuote:<span class="cov8" title="1">
                        lastQuote = rune(0)
                        return false</span>
                case lastQuote != rune(0):<span class="cov8" title="1">
                        return false</span>
                case unicode.In(c, unicode.Quotation_Mark):<span class="cov8" title="1">
                        lastQuote = c
                        return false</span>
                default:<span class="cov8" title="1">
                        return unicode.IsSpace(c)</span>
                }
        }
        // splitting string by space but considering quoted section
        <span class="cov8" title="1">items := strings.FieldsFunc(parts[1], f)

        result := bytes.NewBufferString("{{&lt; highlight ")
        result.WriteString(items[0]) // language
        options := items[1:]
        for i, opt := range options </span><span class="cov8" title="1">{
                opt = strings.Replace(opt, "\"", "", -1)
                if opt == "linenos" </span><span class="cov8" title="1">{
                        opt = "linenos=table"
                }</span>
                <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                        opt = " \"" + opt
                }</span>
                <span class="cov8" title="1">if i &lt; len(options)-1 </span><span class="cov8" title="1">{
                        opt += ","
                }</span> else<span class="cov8" title="1"> if i == len(options)-1 </span><span class="cov8" title="1">{
                        opt += "\""
                }</span>
                <span class="cov8" title="1">result.WriteString(opt)</span>
        }

        <span class="cov8" title="1">result.WriteString(" &gt;}}")
        return result.String()</span>
}

func replaceImageTag(match string) string <span class="cov8" title="1">{
        r := regexp.MustCompile(`{%\s+img\s*(\p{L}*)\s+([\S]*/[\S]+)\s+(\d*)\s*(\d*)\s*(.*?)\s*%}`)
        result := bytes.NewBufferString("{{&lt; figure ")
        parts := r.FindStringSubmatch(match)
        // Index 0 is the entire string, ignore
        replaceOptionalPart(result, "class", parts[1])
        replaceOptionalPart(result, "src", parts[2])
        replaceOptionalPart(result, "width", parts[3])
        replaceOptionalPart(result, "height", parts[4])
        // title + alt
        part := parts[5]
        if len(part) &gt; 0 </span><span class="cov8" title="1">{
                splits := strings.Split(part, "'")
                lenSplits := len(splits)
                if lenSplits == 1 </span><span class="cov8" title="1">{
                        replaceOptionalPart(result, "title", splits[0])
                }</span> else<span class="cov8" title="1"> if lenSplits == 3 </span><span class="cov8" title="1">{
                        replaceOptionalPart(result, "title", splits[1])
                }</span> else<span class="cov8" title="1"> if lenSplits == 5 </span><span class="cov8" title="1">{
                        replaceOptionalPart(result, "title", splits[1])
                        replaceOptionalPart(result, "alt", splits[3])
                }</span>
        }
        <span class="cov8" title="1">result.WriteString("&gt;}}")
        return result.String()</span>
}

func replaceOptionalPart(buffer *bytes.Buffer, partName string, part string) <span class="cov8" title="1">{
        if len(part) &gt; 0 </span><span class="cov8" title="1">{
                buffer.WriteString(partName + "=\"" + part + "\" ")
        }</span>
}
</pre>
		
		<pre class="file" id="file20" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +build !darwin

package commands

func tweakLimit() {<span class="cov0" title="0">
        // nothing to do
}</span>
</pre>
		
		<pre class="file" id="file21" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "encoding/csv"
        "os"
        "strconv"
        "strings"
        "time"

        "github.com/gohugoio/hugo/hugolib"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*listCmd)(nil)

type listCmd struct {
        *baseBuilderCmd
}

func (lc *listCmd) buildSites(config map[string]interface{}) (*hugolib.HugoSites, error) <span class="cov8" title="1">{
        cfgInit := func(c *commandeer) error </span><span class="cov8" title="1">{
                for key, value := range config </span><span class="cov8" title="1">{
                        c.Set(key, value)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">c, err := initializeConfig(true, true, false, &amp;lc.hugoBuilderCommon, lc, cfgInit)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">sites, err := hugolib.NewHugoSites(*c.DepsCfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, newSystemError("Error creating sites", err)
        }</span>

        <span class="cov8" title="1">if err := sites.Build(hugolib.BuildCfg{SkipRender: true}); err != nil </span><span class="cov0" title="0">{
                return nil, newSystemError("Error Processing Source Content", err)
        }</span>

        <span class="cov8" title="1">return sites, nil</span>
}

func (b *commandsBuilder) newListCmd() *listCmd <span class="cov8" title="1">{
        cc := &amp;listCmd{}

        cmd := &amp;cobra.Command{
                Use:   "list",
                Short: "Listing out various types of content",
                Long: `Listing out various types of content.

List requires a subcommand, e.g. ` + "`hugo list drafts`.",
                RunE: nil,
        }

        cmd.AddCommand(
                &amp;cobra.Command{
                        Use:   "drafts",
                        Short: "List all drafts",
                        Long:  `List all of the drafts in your content directory.`,
                        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                                sites, err := cc.buildSites(map[string]interface{}{"buildDrafts": true})
                                if err != nil </span><span class="cov0" title="0">{
                                        return newSystemError("Error building sites", err)
                                }</span>

                                <span class="cov8" title="1">for _, p := range sites.Pages() </span><span class="cov8" title="1">{
                                        if p.Draft() </span><span class="cov0" title="0">{
                                                jww.FEEDBACK.Println(strings.TrimPrefix(p.File().Filename(), sites.WorkingDir+string(os.PathSeparator)))
                                        }</span>
                                }

                                <span class="cov8" title="1">return nil</span>
                        },
                },
                &amp;cobra.Command{
                        Use:   "future",
                        Short: "List all posts dated in the future",
                        Long:  `List all of the posts in your content directory which will be posted in the future.`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                                sites, err := cc.buildSites(map[string]interface{}{"buildFuture": true})
                                if err != nil </span><span class="cov0" title="0">{
                                        return newSystemError("Error building sites", err)
                                }</span>

                                <span class="cov8" title="1">writer := csv.NewWriter(os.Stdout)
                                defer writer.Flush()

                                for _, p := range sites.Pages() </span><span class="cov8" title="1">{
                                        if resource.IsFuture(p) </span><span class="cov0" title="0">{
                                                err := writer.Write([]string{
                                                        strings.TrimPrefix(p.File().Filename(), sites.WorkingDir+string(os.PathSeparator)),
                                                        p.PublishDate().Format(time.RFC3339),
                                                })
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return newSystemError("Error writing future posts to stdout", err)
                                                }</span>
                                        }
                                }

                                <span class="cov8" title="1">return nil</span>
                        },
                },
                &amp;cobra.Command{
                        Use:   "expired",
                        Short: "List all posts already expired",
                        Long:  `List all of the posts in your content directory which has already expired.`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                                sites, err := cc.buildSites(map[string]interface{}{"buildExpired": true})
                                if err != nil </span><span class="cov0" title="0">{
                                        return newSystemError("Error building sites", err)
                                }</span>

                                <span class="cov8" title="1">writer := csv.NewWriter(os.Stdout)
                                defer writer.Flush()

                                for _, p := range sites.Pages() </span><span class="cov8" title="1">{
                                        if resource.IsExpired(p) </span><span class="cov0" title="0">{
                                                err := writer.Write([]string{
                                                        strings.TrimPrefix(p.File().Filename(), sites.WorkingDir+string(os.PathSeparator)),
                                                        p.ExpiryDate().Format(time.RFC3339),
                                                })
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return newSystemError("Error writing expired posts to stdout", err)
                                                }</span>
                                        }
                                }

                                <span class="cov8" title="1">return nil</span>
                        },
                },
                &amp;cobra.Command{
                        Use:   "all",
                        Short: "List all posts",
                        Long:  `List all of the posts in your content directory, include drafts, future and expired pages.`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
                                sites, err := cc.buildSites(map[string]interface{}{
                                        "buildExpired": true,
                                        "buildDrafts":  true,
                                        "buildFuture":  true,
                                })
                                if err != nil </span><span class="cov0" title="0">{
                                        return newSystemError("Error building sites", err)
                                }</span>

                                <span class="cov8" title="1">writer := csv.NewWriter(os.Stdout)
                                defer writer.Flush()

                                writer.Write([]string{
                                        "path",
                                        "slug",
                                        "title",
                                        "date",
                                        "expiryDate",
                                        "publishDate",
                                        "draft",
                                        "permalink",
                                })
                                for _, p := range sites.Pages() </span><span class="cov8" title="1">{
                                        if !p.IsPage() </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">err := writer.Write([]string{
                                                strings.TrimPrefix(p.File().Filename(), sites.WorkingDir+string(os.PathSeparator)),
                                                p.Slug(),
                                                p.Title(),
                                                p.Date().Format(time.RFC3339),
                                                p.ExpiryDate().Format(time.RFC3339),
                                                p.PublishDate().Format(time.RFC3339),
                                                strconv.FormatBool(p.Draft()),
                                                p.Permalink(),
                                        })
                                        if err != nil </span><span class="cov0" title="0">{
                                                return newSystemError("Error writing posts to stdout", err)
                                        }</span>
                                }

                                <span class="cov8" title="1">return nil</span>
                        },
                },
        )

        <span class="cov8" title="1">cc.baseBuilderCmd = b.newBuilderBasicCmd(cmd)

        return cc</span>
}
</pre>
		
		<pre class="file" id="file22" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "regexp"

        "github.com/gohugoio/hugo/hugolib"

        "github.com/gohugoio/hugo/modules"
        "github.com/spf13/cobra"
)

var _ cmder = (*modCmd)(nil)

type modCmd struct {
        *baseBuilderCmd
}

func (c *modCmd) newVerifyCmd() *cobra.Command <span class="cov8" title="1">{
        var clean bool

        verifyCmd := &amp;cobra.Command{
                Use:   "verify",
                Short: "Verify dependencies.",
                Long: `Verify checks that the dependencies of the current module, which are stored in a local downloaded source cache, have not been modified since being downloaded.
`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.withModsClient(true, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                return c.Verify(clean)
                        }</span>)
                },
        }

        <span class="cov8" title="1">verifyCmd.Flags().BoolVarP(&amp;clean, "clean", "", false, "delete module cache for dependencies that fail verification")

        return verifyCmd</span>
}

var moduleNotFoundRe = regexp.MustCompile("module.*not found")

func (c *modCmd) newCleanCmd() *cobra.Command <span class="cov8" title="1">{
        var pattern string
        var all bool
        cmd := &amp;cobra.Command{
                Use:   "clean",
                Short: "Delete the Hugo Module cache for the current project.",
                Long: `Delete the Hugo Module cache for the current project.

Note that after you run this command, all of your dependencies will be re-downloaded next time you run "hugo".

Also note that if you configure a positive maxAge for the "modules" file cache, it will also be cleaned as part of "hugo --gc".
 
`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        if all </span><span class="cov0" title="0">{
                                com, err := c.initConfig(false)

                                if err != nil &amp;&amp; com == nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>

                                <span class="cov0" title="0">count, err := com.hugo().FileCaches.ModulesCache().Prune(true)
                                com.logger.Printf("Deleted %d files from module cache.", count)
                                return err</span>
                        }
                        <span class="cov0" title="0">return c.withModsClient(true, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                return c.Clean(pattern)
                        }</span>)
                },
        }

        <span class="cov8" title="1">cmd.Flags().StringVarP(&amp;pattern, "pattern", "", "", `pattern matching module paths to clean (all if not set), e.g. "**hugo*"`)
        cmd.Flags().BoolVarP(&amp;all, "all", "", false, "clean entire module cache")

        return cmd</span>
}

func (b *commandsBuilder) newModCmd() *modCmd <span class="cov8" title="1">{
        c := &amp;modCmd{}

        const commonUsage = `
Note that Hugo will always start out by resolving the components defined in the site
configuration, provided by a _vendor directory (if no --ignoreVendorPaths flag provided),
Go Modules, or a folder inside the themes directory, in that order.

See https://gohugo.io/hugo-modules/ for more information.

`

        cmd := &amp;cobra.Command{
                Use:   "mod",
                Short: "Various Hugo Modules helpers.",
                Long: `Various helpers to help manage the modules in your project's dependency graph.

Most operations here requires a Go version installed on your system (&gt;= Go 1.12) and the relevant VCS client (typically Git).
This is not needed if you only operate on modules inside /themes or if you have vendored them via "hugo mod vendor".

` + commonUsage,

                RunE: nil,
        }

        cmd.AddCommand(newModNPMCmd(c))

        cmd.AddCommand(
                &amp;cobra.Command{
                        Use:                "get",
                        DisableFlagParsing: true,
                        Short:              "Resolves dependencies in your current Hugo Project.",
                        Long: `
Resolves dependencies in your current Hugo Project.

Some examples:

Install the latest version possible for a given module:

    hugo mod get github.com/gohugoio/testshortcodes
    
Install a specific version:

    hugo mod get github.com/gohugoio/testshortcodes@v0.3.0

Install the latest versions of all module dependencies:

    hugo mod get -u
    hugo mod get -u ./... (recursive)

Run "go help get" for more information. All flags available for "go get" is also relevant here.
` + commonUsage,
                        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                                // We currently just pass on the flags we get to Go and
                                // need to do the flag handling manually.
                                if len(args) == 1 &amp;&amp; args[0] == "-h" </span><span class="cov0" title="0">{
                                        return cmd.Help()
                                }</span>

                                <span class="cov0" title="0">var lastArg string
                                if len(args) != 0 </span><span class="cov0" title="0">{
                                        lastArg = args[len(args)-1]
                                }</span>

                                <span class="cov0" title="0">if lastArg == "./..." </span><span class="cov0" title="0">{
                                        args = args[:len(args)-1]
                                        // Do a recursive update.
                                        dirname, err := os.Getwd()
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>

                                        // Sanity check. We do recursive walking and want to avoid
                                        // accidents.
                                        <span class="cov0" title="0">if len(dirname) &lt; 5 </span><span class="cov0" title="0">{
                                                return errors.New("must not be run from the file system root")
                                        }</span>

                                        <span class="cov0" title="0">filepath.Walk(dirname, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                                                if info.IsDir() </span><span class="cov0" title="0">{
                                                        return nil
                                                }</span>

                                                <span class="cov0" title="0">if info.Name() == "go.mod" </span><span class="cov0" title="0">{
                                                        // Found a module.
                                                        dir := filepath.Dir(path)
                                                        fmt.Println("Update module in", dir)
                                                        c.source = dir
                                                        err := c.withModsClient(false, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                                                if len(args) == 1 &amp;&amp; args[0] == "-h" </span><span class="cov0" title="0">{
                                                                        return cmd.Help()
                                                                }</span>
                                                                <span class="cov0" title="0">return c.Get(args...)</span>
                                                        })
                                                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                                                return err
                                                        }</span>

                                                }

                                                <span class="cov0" title="0">return nil</span>
                                        })

                                        <span class="cov0" title="0">return nil</span>
                                }

                                <span class="cov0" title="0">return c.withModsClient(false, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                        return c.Get(args...)
                                }</span>)
                        },
                },
                &amp;cobra.Command{
                        Use:   "graph",
                        Short: "Print a module dependency graph.",
                        Long: `Print a module dependency graph with information about module status (disabled, vendored).
Note that for vendored modules, that is the version listed and not the one from go.mod.
`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                return c.withModsClient(true, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                        return c.Graph(os.Stdout)
                                }</span>)
                        },
                },
                &amp;cobra.Command{
                        Use:   "init",
                        Short: "Initialize this project as a Hugo Module.",
                        Long: `Initialize this project as a Hugo Module.
It will try to guess the module path, but you may help by passing it as an argument, e.g:

    hugo mod init github.com/gohugoio/testshortcodes

Note that Hugo Modules supports multi-module projects, so you can initialize a Hugo Module
inside a subfolder on GitHub, as one example.
`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                var path string
                                if len(args) &gt;= 1 </span><span class="cov0" title="0">{
                                        path = args[0]
                                }</span>
                                <span class="cov0" title="0">return c.withModsClient(false, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                        return c.Init(path)
                                }</span>)
                        },
                },
                &amp;cobra.Command{
                        Use:   "vendor",
                        Short: "Vendor all module dependencies into the _vendor directory.",
                        Long: `Vendor all module dependencies into the _vendor directory.

If a module is vendored, that is where Hugo will look for it's dependencies.
`,
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                return c.withModsClient(true, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                        return c.Vendor()
                                }</span>)
                        },
                },
                c.newVerifyCmd(),
                &amp;cobra.Command{
                        Use:   "tidy",
                        Short: "Remove unused entries in go.mod and go.sum.",
                        RunE: func(cmd *cobra.Command, args []string) error <span class="cov0" title="0">{
                                return c.withModsClient(true, func(c *modules.Client) error </span><span class="cov0" title="0">{
                                        return c.Tidy()
                                }</span>)
                        },
                },
                c.newCleanCmd(),
        )

        <span class="cov8" title="1">c.baseBuilderCmd = b.newBuilderCmd(cmd)

        return c</span>
}

func (c *modCmd) withModsClient(failOnMissingConfig bool, f func(*modules.Client) error) error <span class="cov0" title="0">{
        com, err := c.initConfig(failOnMissingConfig)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return f(com.hugo().ModulesClient)</span>
}

func (c *modCmd) withHugo(f func(*hugolib.HugoSites) error) error <span class="cov0" title="0">{
        com, err := c.initConfig(true)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return f(com.hugo())</span>
}

func (c *modCmd) initConfig(failOnNoConfig bool) (*commandeer, error) <span class="cov0" title="0">{
        com, err := initializeConfig(failOnNoConfig, false, false, &amp;c.hugoBuilderCommon, c, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return com, nil</span>
}
</pre>
		
		<pre class="file" id="file23" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "github.com/gohugoio/hugo/hugolib"
        "github.com/gohugoio/hugo/modules/npm"
        "github.com/spf13/cobra"
)

func newModNPMCmd(c *modCmd) *cobra.Command <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "npm",
                Short: "Various npm helpers.",
                Long:  `Various npm (Node package manager) helpers.`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.withHugo(func(h *hugolib.HugoSites) error </span><span class="cov0" title="0">{
                                return nil
                        }</span>)
                },
        }

        <span class="cov8" title="1">cmd.AddCommand(&amp;cobra.Command{
                Use:   "pack",
                Short: "Experimental: Prepares and writes a composite package.json file for your project.",
                Long: `Prepares and writes a composite package.json file for your project.

On first run it creates a "package.hugo.json" in the project root if not already there. This file will be used as a template file
with the base dependency set. 

This set will be merged with all "package.hugo.json" files found in the dependency tree, picking the version closest to the project.

This command is marked as 'Experimental'. We think it's a great idea, so it's not likely to be
removed from Hugo, but we need to test this out in "real life" to get a feel of it,
so this may/will change in future versions of Hugo.
`,
                RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov0" title="0">{
                        return c.withHugo(func(h *hugolib.HugoSites) error </span><span class="cov0" title="0">{
                                return npm.Pack(h.BaseFs.SourceFs, h.BaseFs.Assets.Dirs)
                        }</span>)
                },
        })

        <span class="cov8" title="1">return cmd</span>
}
</pre>
		
		<pre class="file" id="file24" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "os"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/create"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugolib"
        "github.com/spf13/afero"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*newCmd)(nil)

type newCmd struct {
        contentEditor string
        contentType   string

        *baseBuilderCmd
}

func (b *commandsBuilder) newNewCmd() *newCmd <span class="cov8" title="1">{
        cmd := &amp;cobra.Command{
                Use:   "new [path]",
                Short: "Create new content for your site",
                Long: `Create a new content file and automatically set the date and title.
It will guess which kind of file to create based on the path provided.

You can also specify the kind with ` + "`-k KIND`" + `.

If archetypes are provided in your theme or site, they will be used.

Ensure you run this within the root directory of your site.`,
        }

        cc := &amp;newCmd{baseBuilderCmd: b.newBuilderCmd(cmd)}

        cmd.Flags().StringVarP(&amp;cc.contentType, "kind", "k", "", "content type to create")
        cmd.Flags().StringVar(&amp;cc.contentEditor, "editor", "", "edit new content with this editor, if provided")

        cmd.AddCommand(b.newNewSiteCmd().getCommand())
        cmd.AddCommand(b.newNewThemeCmd().getCommand())

        cmd.RunE = cc.newContent

        return cc
}</span>

func (n *newCmd) newContent(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        cfgInit := func(c *commandeer) error </span><span class="cov8" title="1">{
                if cmd.Flags().Changed("editor") </span><span class="cov0" title="0">{
                        c.Set("newContentEditor", n.contentEditor)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">c, err := initializeConfig(true, true, false, &amp;n.hugoBuilderCommon, n, cfgInit)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return newUserError("path needs to be provided")
        }</span>

        <span class="cov8" title="1">return create.NewContent(c.hugo(), n.contentType, args[0])</span>
}

func mkdir(x ...string) <span class="cov8" title="1">{
        p := filepath.Join(x...)

        err := os.MkdirAll(p, 0777) // before umask
        if err != nil </span><span class="cov0" title="0">{
                jww.FATAL.Fatalln(err)
        }</span>
}

func touchFile(fs afero.Fs, x ...string) <span class="cov8" title="1">{
        inpath := filepath.Join(x...)
        mkdir(filepath.Dir(inpath))
        err := helpers.WriteToDisk(inpath, bytes.NewReader([]byte{}), fs)
        if err != nil </span><span class="cov0" title="0">{
                jww.FATAL.Fatalln(err)
        }</span>
}

func newContentPathSection(h *hugolib.HugoSites, path string) (string, string) <span class="cov8" title="1">{
        // Forward slashes is used in all examples. Convert if needed.
        // Issue #1133
        createpath := filepath.FromSlash(path)

        if h != nil </span><span class="cov0" title="0">{
                for _, dir := range h.BaseFs.Content.Dirs </span><span class="cov0" title="0">{
                        createpath = strings.TrimPrefix(createpath, dir.Meta().Filename)
                }</span>
        }

        <span class="cov8" title="1">var section string
        // assume the first directory is the section (kind)
        if strings.Contains(createpath[1:], helpers.FilePathSeparator) </span><span class="cov8" title="1">{
                parts := strings.Split(strings.TrimPrefix(createpath, helpers.FilePathSeparator), helpers.FilePathSeparator)
                if len(parts) &gt; 0 </span><span class="cov8" title="1">{
                        section = parts[0]
                }</span>

        }

        <span class="cov8" title="1">return createpath, section</span>
}
</pre>
		
		<pre class="file" id="file25" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "errors"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/parser/metadecoders"

        _errors "github.com/pkg/errors"

        "github.com/gohugoio/hugo/create"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/parser"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*newSiteCmd)(nil)

type newSiteCmd struct {
        configFormat string

        *baseBuilderCmd
}

func (b *commandsBuilder) newNewSiteCmd() *newSiteCmd <span class="cov8" title="1">{
        cc := &amp;newSiteCmd{}

        cmd := &amp;cobra.Command{
                Use:   "site [path]",
                Short: "Create a new site (skeleton)",
                Long: `Create a new site in the provided directory.
The new site will have the correct structure, but no content or theme yet.
Use ` + "`hugo new [contentPath]`" + ` to create new content.`,
                RunE: cc.newSite,
        }

        cmd.Flags().StringVarP(&amp;cc.configFormat, "format", "f", "toml", "config file format")
        cmd.Flags().Bool("force", false, "init inside non-empty directory")

        cc.baseBuilderCmd = b.newBuilderBasicCmd(cmd)

        return cc
}</span>

func (n *newSiteCmd) doNewSite(fs *hugofs.Fs, basepath string, force bool) error <span class="cov8" title="1">{
        archeTypePath := filepath.Join(basepath, "archetypes")
        dirs := []string{
                filepath.Join(basepath, "layouts"),
                filepath.Join(basepath, "content"),
                archeTypePath,
                filepath.Join(basepath, "static"),
                filepath.Join(basepath, "data"),
                filepath.Join(basepath, "themes"),
        }

        if exists, _ := helpers.Exists(basepath, fs.Source); exists </span><span class="cov0" title="0">{
                if isDir, _ := helpers.IsDir(basepath, fs.Source); !isDir </span><span class="cov0" title="0">{
                        return errors.New(basepath + " already exists but not a directory")
                }</span>

                <span class="cov0" title="0">isEmpty, _ := helpers.IsEmpty(basepath, fs.Source)

                switch </span>{
                case !isEmpty &amp;&amp; !force:<span class="cov0" title="0">
                        return errors.New(basepath + " already exists and is not empty. See --force.")</span>

                case !isEmpty &amp;&amp; force:<span class="cov0" title="0">
                        all := append(dirs, filepath.Join(basepath, "config."+n.configFormat))
                        for _, path := range all </span><span class="cov0" title="0">{
                                if exists, _ := helpers.Exists(path, fs.Source); exists </span><span class="cov0" title="0">{
                                        return errors.New(path + " already exists")
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">for _, dir := range dirs </span><span class="cov8" title="1">{
                if err := fs.Source.MkdirAll(dir, 0777); err != nil </span><span class="cov0" title="0">{
                        return _errors.Wrap(err, "Failed to create dir")
                }</span>
        }

        <span class="cov8" title="1">createConfig(fs, basepath, n.configFormat)

        // Create a default archetype file.
        helpers.SafeWriteToDisk(filepath.Join(archeTypePath, "default.md"),
                strings.NewReader(create.DefaultArchetypeTemplateTemplate), fs.Source)

        jww.FEEDBACK.Printf("Congratulations! Your new Hugo site is created in %s.\n\n", basepath)
        jww.FEEDBACK.Println(nextStepsText())

        return nil</span>
}

// newSite creates a new Hugo site and initializes a structured Hugo directory.
func (n *newSiteCmd) newSite(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return newUserError("path needs to be provided")
        }</span>

        <span class="cov8" title="1">createpath, err := filepath.Abs(filepath.Clean(args[0]))
        if err != nil </span><span class="cov0" title="0">{
                return newUserError(err)
        }</span>

        <span class="cov8" title="1">forceNew, _ := cmd.Flags().GetBool("force")

        return n.doNewSite(hugofs.NewDefault(config.New()), createpath, forceNew)</span>
}

func createConfig(fs *hugofs.Fs, inpath string, kind string) (err error) <span class="cov8" title="1">{
        in := map[string]string{
                "baseURL":      "http://example.org/",
                "title":        "My New Hugo Site",
                "languageCode": "en-us",
        }

        var buf bytes.Buffer
        err = parser.InterfaceToConfig(in, metadecoders.FormatFromString(kind), &amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return helpers.WriteToDisk(filepath.Join(inpath, "config."+kind), &amp;buf, fs.Source)</span>
}

func nextStepsText() string <span class="cov8" title="1">{
        var nextStepsText bytes.Buffer

        nextStepsText.WriteString(`Just a few more steps and you're ready to go:

1. Download a theme into the same-named folder.
   Choose a theme from https://themes.gohugo.io/ or
   create your own with the "hugo new theme &lt;THEMENAME&gt;" command.
2. Perhaps you want to add some content. You can add single files
   with "hugo new `)

        nextStepsText.WriteString(filepath.Join("&lt;SECTIONNAME&gt;", "&lt;FILENAME&gt;.&lt;FORMAT&gt;"))

        nextStepsText.WriteString(`".
3. Start the built-in live server via "hugo server".

Visit https://gohugo.io/ for quickstart guide and full documentation.`)

        return nextStepsText.String()
}</span>
</pre>
		
		<pre class="file" id="file26" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "errors"
        "path/filepath"
        "strings"
        "time"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*newThemeCmd)(nil)

type newThemeCmd struct {
        *baseBuilderCmd
}

func (b *commandsBuilder) newNewThemeCmd() *newThemeCmd <span class="cov8" title="1">{
        cc := &amp;newThemeCmd{}

        cmd := &amp;cobra.Command{
                Use:   "theme [name]",
                Short: "Create a new theme",
                Long: `Create a new theme (skeleton) called [name] in ./themes.
New theme is a skeleton. Please add content to the touched files. Add your
name to the copyright line in the license and adjust the theme.toml file
as you see fit.`,
                RunE: cc.newTheme,
        }

        cc.baseBuilderCmd = b.newBuilderBasicCmd(cmd)

        return cc
}</span>

// newTheme creates a new Hugo theme template
func (n *newThemeCmd) newTheme(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        c, err := initializeConfig(false, false, false, &amp;n.hugoBuilderCommon, n, nil)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(args) &lt; 1 </span><span class="cov0" title="0">{
                return newUserError("theme name needs to be provided")
        }</span>

        <span class="cov8" title="1">createpath := c.hugo().PathSpec.AbsPathify(filepath.Join(c.Cfg.GetString("themesDir"), args[0]))
        jww.FEEDBACK.Println("Creating theme at", createpath)

        cfg := c.DepsCfg

        if x, _ := helpers.Exists(createpath, cfg.Fs.Source); x </span><span class="cov0" title="0">{
                return errors.New(createpath + " already exists")
        }</span>

        <span class="cov8" title="1">mkdir(createpath, "layouts", "_default")
        mkdir(createpath, "layouts", "partials")

        touchFile(cfg.Fs.Source, createpath, "layouts", "index.html")
        touchFile(cfg.Fs.Source, createpath, "layouts", "404.html")
        touchFile(cfg.Fs.Source, createpath, "layouts", "_default", "list.html")
        touchFile(cfg.Fs.Source, createpath, "layouts", "_default", "single.html")

        baseofDefault := []byte(`&lt;!DOCTYPE html&gt;
&lt;html&gt;
    {{- partial "head.html" . -}}
    &lt;body&gt;
        {{- partial "header.html" . -}}
        &lt;div id="content"&gt;
        {{- block "main" . }}{{- end }}
        &lt;/div&gt;
        {{- partial "footer.html" . -}}
    &lt;/body&gt;
&lt;/html&gt;
`)
        err = helpers.WriteToDisk(filepath.Join(createpath, "layouts", "_default", "baseof.html"), bytes.NewReader(baseofDefault), cfg.Fs.Source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">touchFile(cfg.Fs.Source, createpath, "layouts", "partials", "head.html")
        touchFile(cfg.Fs.Source, createpath, "layouts", "partials", "header.html")
        touchFile(cfg.Fs.Source, createpath, "layouts", "partials", "footer.html")

        mkdir(createpath, "archetypes")

        archDefault := []byte("+++\n+++\n")

        err = helpers.WriteToDisk(filepath.Join(createpath, "archetypes", "default.md"), bytes.NewReader(archDefault), cfg.Fs.Source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">mkdir(createpath, "static", "js")
        mkdir(createpath, "static", "css")

        by := []byte(`The MIT License (MIT)

Copyright (c) ` + time.Now().Format("2006") + ` YOUR_NAME_HERE

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.
`)

        err = helpers.WriteToDisk(filepath.Join(createpath, "LICENSE"), bytes.NewReader(by), cfg.Fs.Source)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">n.createThemeMD(cfg.Fs, createpath)

        return nil</span>
}

func (n *newThemeCmd) createThemeMD(fs *hugofs.Fs, inpath string) (err error) <span class="cov8" title="1">{
        by := []byte(`# theme.toml template for a Hugo theme
# See https://github.com/gohugoio/hugoThemes#themetoml for an example

name = "` + strings.Title(helpers.MakeTitle(filepath.Base(inpath))) + `"
license = "MIT"
licenselink = "https://github.com/yourname/yourtheme/blob/master/LICENSE"
description = ""
homepage = "http://example.com/"
tags = []
features = []
min_version = "0.41.0"

[author]
  name = ""
  homepage = ""

# If porting an existing theme
[original]
  name = ""
  homepage = ""
  repo = ""
`)

        err = helpers.WriteToDisk(filepath.Join(inpath, "theme.toml"), bytes.NewReader(by), fs.Source)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file27" style="display: none">// +build !release

// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

func createReleaser() cmder <span class="cov8" title="1">{
        return &amp;nilCommand{}
}</span>
</pre>
		
		<pre class="file" id="file28" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "fmt"
        "io"
        "net"
        "net/http"
        "net/url"
        "os"
        "os/signal"
        "path/filepath"
        "regexp"
        "runtime"
        "strconv"
        "strings"
        "sync"
        "syscall"
        "time"

        "github.com/gohugoio/hugo/common/paths"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/livereload"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/afero"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

type serverCmd struct {
        // Can be used to stop the server. Useful in tests
        stop &lt;-chan bool

        disableLiveReload bool
        navigateToChanged bool
        renderToDisk      bool
        serverAppend      bool
        serverInterface   string
        serverPort        int
        liveReloadPort    int
        serverWatch       bool
        noHTTPCache       bool

        disableFastRender   bool
        disableBrowserError bool

        *baseBuilderCmd
}

func (b *commandsBuilder) newServerCmd() *serverCmd <span class="cov8" title="1">{
        return b.newServerCmdSignaled(nil)
}</span>

func (b *commandsBuilder) newServerCmdSignaled(stop &lt;-chan bool) *serverCmd <span class="cov8" title="1">{
        cc := &amp;serverCmd{stop: stop}

        cc.baseBuilderCmd = b.newBuilderCmd(&amp;cobra.Command{
                Use:     "server",
                Aliases: []string{"serve"},
                Short:   "A high performance webserver",
                Long: `Hugo provides its own webserver which builds and serves the site.
While hugo server is high performance, it is a webserver with limited options.
Many run it in production, but the standard behavior is for people to use it
in development and use a more full featured server such as Nginx or Caddy.

'hugo server' will avoid writing the rendered and served content to disk,
preferring to store it in memory.

By default hugo will also watch your files for any changes you make and
automatically rebuild the site. It will then live reload any open browser pages
and push the latest content to them. As most Hugo sites are built in a fraction
of a second, you will be able to save and see your changes nearly instantly.`,
                RunE: cc.server,
        })

        cc.cmd.Flags().IntVarP(&amp;cc.serverPort, "port", "p", 1313, "port on which the server will listen")
        cc.cmd.Flags().IntVar(&amp;cc.liveReloadPort, "liveReloadPort", -1, "port for live reloading (i.e. 443 in HTTPS proxy situations)")
        cc.cmd.Flags().StringVarP(&amp;cc.serverInterface, "bind", "", "127.0.0.1", "interface to which the server will bind")
        cc.cmd.Flags().BoolVarP(&amp;cc.serverWatch, "watch", "w", true, "watch filesystem for changes and recreate as needed")
        cc.cmd.Flags().BoolVar(&amp;cc.noHTTPCache, "noHTTPCache", false, "prevent HTTP caching")
        cc.cmd.Flags().BoolVarP(&amp;cc.serverAppend, "appendPort", "", true, "append port to baseURL")
        cc.cmd.Flags().BoolVar(&amp;cc.disableLiveReload, "disableLiveReload", false, "watch without enabling live browser reload on rebuild")
        cc.cmd.Flags().BoolVar(&amp;cc.navigateToChanged, "navigateToChanged", false, "navigate to changed content file on live browser reload")
        cc.cmd.Flags().BoolVar(&amp;cc.renderToDisk, "renderToDisk", false, "render to Destination path (default is render to memory &amp; serve from there)")
        cc.cmd.Flags().BoolVar(&amp;cc.disableFastRender, "disableFastRender", false, "enables full re-renders on changes")
        cc.cmd.Flags().BoolVar(&amp;cc.disableBrowserError, "disableBrowserError", false, "do not show build errors in the browser")

        cc.cmd.Flags().String("memstats", "", "log memory usage to this file")
        cc.cmd.Flags().String("meminterval", "100ms", "interval to poll memory usage (requires --memstats), valid time units are \"ns\", \"us\" (or \"µs\"), \"ms\", \"s\", \"m\", \"h\".")

        return cc
}</span>

type filesOnlyFs struct {
        fs http.FileSystem
}

type noDirFile struct {
        http.File
}

func (fs filesOnlyFs) Open(name string) (http.File, error) <span class="cov8" title="1">{
        f, err := fs.fs.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return noDirFile{f}, nil</span>
}

func (f noDirFile) Readdir(count int) ([]os.FileInfo, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

var serverPorts []int

func (sc *serverCmd) server(cmd *cobra.Command, args []string) error <span class="cov8" title="1">{
        // If a Destination is provided via flag write to disk
        destination, _ := cmd.Flags().GetString("destination")
        if destination != "" </span><span class="cov0" title="0">{
                sc.renderToDisk = true
        }</span>

        <span class="cov8" title="1">var serverCfgInit sync.Once

        cfgInit := func(c *commandeer) error </span><span class="cov8" title="1">{
                c.Set("renderToMemory", !sc.renderToDisk)
                if cmd.Flags().Changed("navigateToChanged") </span><span class="cov0" title="0">{
                        c.Set("navigateToChanged", sc.navigateToChanged)
                }</span>
                <span class="cov8" title="1">if cmd.Flags().Changed("disableLiveReload") </span><span class="cov0" title="0">{
                        c.Set("disableLiveReload", sc.disableLiveReload)
                }</span>
                <span class="cov8" title="1">if cmd.Flags().Changed("disableFastRender") </span><span class="cov0" title="0">{
                        c.Set("disableFastRender", sc.disableFastRender)
                }</span>
                <span class="cov8" title="1">if cmd.Flags().Changed("disableBrowserError") </span><span class="cov0" title="0">{
                        c.Set("disableBrowserError", sc.disableBrowserError)
                }</span>
                <span class="cov8" title="1">if sc.serverWatch </span><span class="cov8" title="1">{
                        c.Set("watch", true)
                }</span>

                // TODO(bep) yes, we should fix.
                <span class="cov8" title="1">if !c.languagesConfigured </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">var err error

                // We can only do this once.
                serverCfgInit.Do(func() </span><span class="cov8" title="1">{
                        serverPorts = make([]int, 1)

                        if c.languages.IsMultihost() </span><span class="cov0" title="0">{
                                if !sc.serverAppend </span><span class="cov0" title="0">{
                                        err = newSystemError("--appendPort=false not supported when in multihost mode")
                                }</span>
                                <span class="cov0" title="0">serverPorts = make([]int, len(c.languages))</span>
                        }

                        <span class="cov8" title="1">currentServerPort := sc.serverPort

                        for i := 0; i &lt; len(serverPorts); i++ </span><span class="cov8" title="1">{
                                l, err := net.Listen("tcp", net.JoinHostPort(sc.serverInterface, strconv.Itoa(currentServerPort)))
                                if err == nil </span><span class="cov8" title="1">{
                                        l.Close()
                                        serverPorts[i] = currentServerPort
                                }</span> else<span class="cov0" title="0"> {
                                        if i == 0 &amp;&amp; sc.cmd.Flags().Changed("port") </span><span class="cov0" title="0">{
                                                // port set explicitly by user -- he/she probably meant it!
                                                err = newSystemErrorF("Server startup failed: %s", err)
                                        }</span>
                                        <span class="cov0" title="0">c.logger.Println("port", sc.serverPort, "already in use, attempting to use an available port")
                                        sp, err := helpers.FindAvailablePort()
                                        if err != nil </span><span class="cov0" title="0">{
                                                err = newSystemError("Unable to find alternative port to use:", err)
                                        }</span>
                                        <span class="cov0" title="0">serverPorts[i] = sp.Port</span>
                                }

                                <span class="cov8" title="1">currentServerPort = serverPorts[i] + 1</span>
                        }
                })

                <span class="cov8" title="1">c.serverPorts = serverPorts

                c.Set("port", sc.serverPort)
                if sc.liveReloadPort != -1 </span><span class="cov0" title="0">{
                        c.Set("liveReloadPort", sc.liveReloadPort)
                }</span> else<span class="cov8" title="1"> {
                        c.Set("liveReloadPort", serverPorts[0])
                }</span>

                <span class="cov8" title="1">isMultiHost := c.languages.IsMultihost()
                for i, language := range c.languages </span><span class="cov8" title="1">{
                        var serverPort int
                        if isMultiHost </span><span class="cov0" title="0">{
                                serverPort = serverPorts[i]
                        }</span> else<span class="cov8" title="1"> {
                                serverPort = serverPorts[0]
                        }</span>

                        <span class="cov8" title="1">baseURL, err := sc.fixURL(language, sc.baseURL, serverPort)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">if isMultiHost </span><span class="cov0" title="0">{
                                language.Set("baseURL", baseURL)
                        }</span>
                        <span class="cov8" title="1">if i == 0 </span><span class="cov8" title="1">{
                                c.Set("baseURL", baseURL)
                        }</span>
                }

                <span class="cov8" title="1">return err</span>
        }

        <span class="cov8" title="1">if err := memStats(); err != nil </span><span class="cov0" title="0">{
                jww.WARN.Println("memstats error:", err)
        }</span>

        // silence errors in cobra so we can handle them here
        <span class="cov8" title="1">cmd.SilenceErrors = true

        c, err := initializeConfig(true, true, true, &amp;sc.hugoBuilderCommon, sc, cfgInit)
        if err != nil </span><span class="cov0" title="0">{
                cmd.PrintErrln("Error:", err.Error())
                return err
        }</span>

        <span class="cov8" title="1">err = func() error </span><span class="cov8" title="1">{
                defer c.timeTrack(time.Now(), "Built")
                err := c.serverBuild()
                if err != nil </span><span class="cov0" title="0">{
                        cmd.PrintErrln("Error:", err.Error())
                }</span>
                <span class="cov8" title="1">return err</span>
        }()
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, s := range c.hugo().Sites </span><span class="cov8" title="1">{
                s.RegisterMediaTypes()
        }</span>

        // Watch runs its own server as part of the routine
        <span class="cov8" title="1">if sc.serverWatch </span><span class="cov8" title="1">{

                watchDirs, err := c.getDirList()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">watchGroups := helpers.ExtractAndGroupRootPaths(watchDirs)

                for _, group := range watchGroups </span><span class="cov8" title="1">{
                        jww.FEEDBACK.Printf("Watching for changes in %s\n", group)
                }</span>
                <span class="cov8" title="1">watcher, err := c.newWatcher(sc.poll, watchDirs...)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">defer watcher.Close()</span>

        }

        <span class="cov8" title="1">return c.serve(sc)</span>
}

func getRootWatchDirsStr(baseDir string, watchDirs []string) string <span class="cov0" title="0">{
        relWatchDirs := make([]string, len(watchDirs))
        for i, dir := range watchDirs </span><span class="cov0" title="0">{
                relWatchDirs[i], _ = paths.GetRelativePath(dir, baseDir)
        }</span>

        <span class="cov0" title="0">return strings.Join(helpers.UniqueStringsSorted(helpers.ExtractRootPaths(relWatchDirs)), ",")</span>
}

type fileServer struct {
        baseURLs      []string
        roots         []string
        errorTemplate func(err interface{}) (io.Reader, error)
        c             *commandeer
        s             *serverCmd
}

func (f *fileServer) rewriteRequest(r *http.Request, toPath string) *http.Request <span class="cov0" title="0">{
        r2 := new(http.Request)
        *r2 = *r
        r2.URL = new(url.URL)
        *r2.URL = *r.URL
        r2.URL.Path = toPath
        r2.Header.Set("X-Rewrite-Original-URI", r.URL.RequestURI())

        return r2
}</span>

func (f *fileServer) createEndpoint(i int) (*http.ServeMux, string, string, error) <span class="cov8" title="1">{
        baseURL := f.baseURLs[i]
        root := f.roots[i]
        port := f.c.serverPorts[i]

        publishDir := f.c.Cfg.GetString("publishDir")

        if root != "" </span><span class="cov0" title="0">{
                publishDir = filepath.Join(publishDir, root)
        }</span>

        <span class="cov8" title="1">absPublishDir := f.c.hugo().PathSpec.AbsPathify(publishDir)

        jww.FEEDBACK.Printf("Environment: %q", f.c.hugo().Deps.Site.Hugo().Environment)

        if i == 0 </span><span class="cov8" title="1">{
                if f.s.renderToDisk </span><span class="cov0" title="0">{
                        jww.FEEDBACK.Println("Serving pages from " + absPublishDir)
                }</span> else<span class="cov8" title="1"> {
                        jww.FEEDBACK.Println("Serving pages from memory")
                }</span>
        }

        <span class="cov8" title="1">httpFs := afero.NewHttpFs(f.c.destinationFs)
        fs := filesOnlyFs{httpFs.Dir(absPublishDir)}

        if i == 0 &amp;&amp; f.c.fastRenderMode </span><span class="cov8" title="1">{
                jww.FEEDBACK.Println("Running in Fast Render Mode. For full rebuilds on change: hugo server --disableFastRender")
        }</span>

        // We're only interested in the path
        <span class="cov8" title="1">u, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                return nil, "", "", errors.Wrap(err, "Invalid baseURL")
        }</span>

        <span class="cov8" title="1">decorate := func(h http.Handler) http.Handler </span><span class="cov8" title="1">{
                return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) </span><span class="cov8" title="1">{
                        if f.c.showErrorInBrowser </span><span class="cov8" title="1">{
                                // First check the error state
                                err := f.c.getErrorWithContext()
                                if err != nil </span><span class="cov0" title="0">{
                                        f.c.wasError = true
                                        w.WriteHeader(500)
                                        r, err := f.errorTemplate(err)
                                        if err != nil </span><span class="cov0" title="0">{
                                                f.c.logger.Errorln(err)
                                        }</span>

                                        <span class="cov0" title="0">port = 1313
                                        if !f.c.paused </span><span class="cov0" title="0">{
                                                port = f.c.Cfg.GetInt("liveReloadPort")
                                        }</span>
                                        <span class="cov0" title="0">lr := *u
                                        lr.Host = fmt.Sprintf("%s:%d", lr.Hostname(), port)
                                        fmt.Fprint(w, injectLiveReloadScript(r, lr))

                                        return</span>
                                }
                        }

                        <span class="cov8" title="1">if f.s.noHTTPCache </span><span class="cov0" title="0">{
                                w.Header().Set("Cache-Control", "no-store, no-cache, must-revalidate, max-age=0")
                                w.Header().Set("Pragma", "no-cache")
                        }</span>

                        // Ignore any query params for the operations below.
                        <span class="cov8" title="1">requestURI := strings.TrimSuffix(r.RequestURI, "?"+r.URL.RawQuery)

                        for _, header := range f.c.serverConfig.MatchHeaders(requestURI) </span><span class="cov0" title="0">{
                                w.Header().Set(header.Key, header.Value)
                        }</span>

                        <span class="cov8" title="1">if redirect := f.c.serverConfig.MatchRedirect(requestURI); !redirect.IsZero() </span><span class="cov0" title="0">{
                                doRedirect := true
                                // This matches Netlify's behaviour and is needed for SPA behaviour.
                                // See https://docs.netlify.com/routing/redirects/rewrites-proxies/
                                if !redirect.Force </span><span class="cov0" title="0">{
                                        path := filepath.Clean(strings.TrimPrefix(requestURI, u.Path))
                                        fi, err := f.c.hugo().BaseFs.PublishFs.Stat(path)
                                        if err == nil </span><span class="cov0" title="0">{
                                                if fi.IsDir() </span><span class="cov0" title="0">{
                                                        // There will be overlapping directories, so we
                                                        // need to check for a file.
                                                        _, err = f.c.hugo().BaseFs.PublishFs.Stat(filepath.Join(path, "index.html"))
                                                        doRedirect = err != nil
                                                }</span> else<span class="cov0" title="0"> {
                                                        doRedirect = false
                                                }</span>
                                        }
                                }

                                <span class="cov0" title="0">if doRedirect </span><span class="cov0" title="0">{
                                        if redirect.Status == 200 </span><span class="cov0" title="0">{
                                                if r2 := f.rewriteRequest(r, strings.TrimPrefix(redirect.To, u.Path)); r2 != nil </span><span class="cov0" title="0">{
                                                        requestURI = redirect.To
                                                        r = r2
                                                }</span>
                                        } else<span class="cov0" title="0"> {
                                                w.Header().Set("Content-Type", "")
                                                http.Redirect(w, r, redirect.To, redirect.Status)
                                                return
                                        }</span>
                                }

                        }

                        <span class="cov8" title="1">if f.c.fastRenderMode &amp;&amp; f.c.buildErr == nil </span><span class="cov8" title="1">{
                                if strings.HasSuffix(requestURI, "/") || strings.HasSuffix(requestURI, "html") || strings.HasSuffix(requestURI, "htm") </span><span class="cov8" title="1">{
                                        if !f.c.visitedURLs.Contains(requestURI) </span><span class="cov8" title="1">{
                                                // If not already on stack, re-render that single page.
                                                if err := f.c.partialReRender(requestURI); err != nil </span><span class="cov0" title="0">{
                                                        f.c.handleBuildErr(err, fmt.Sprintf("Failed to render %q", requestURI))
                                                        if f.c.showErrorInBrowser </span><span class="cov0" title="0">{
                                                                http.Redirect(w, r, requestURI, http.StatusMovedPermanently)
                                                                return
                                                        }</span>
                                                }
                                        }

                                        <span class="cov8" title="1">f.c.visitedURLs.Add(requestURI)</span>

                                }
                        }

                        <span class="cov8" title="1">h.ServeHTTP(w, r)</span>
                })
        }

        <span class="cov8" title="1">fileserver := decorate(http.FileServer(fs))
        mu := http.NewServeMux()
        if u.Path == "" || u.Path == "/" </span><span class="cov8" title="1">{
                mu.Handle("/", fileserver)
        }</span> else<span class="cov0" title="0"> {
                mu.Handle(u.Path, http.StripPrefix(u.Path, fileserver))
        }</span>

        <span class="cov8" title="1">endpoint := net.JoinHostPort(f.s.serverInterface, strconv.Itoa(port))

        return mu, u.String(), endpoint, nil</span>
}

var logErrorRe = regexp.MustCompile(`(?s)ERROR \d{4}/\d{2}/\d{2} \d{2}:\d{2}:\d{2} `)

func removeErrorPrefixFromLog(content string) string <span class="cov8" title="1">{
        return logErrorRe.ReplaceAllLiteralString(content, "")
}</span>

func (c *commandeer) serve(s *serverCmd) error <span class="cov8" title="1">{
        isMultiHost := c.hugo().IsMultihost()

        var (
                baseURLs []string
                roots    []string
        )

        if isMultiHost </span><span class="cov0" title="0">{
                for _, s := range c.hugo().Sites </span><span class="cov0" title="0">{
                        baseURLs = append(baseURLs, s.BaseURL.String())
                        roots = append(roots, s.Language().Lang)
                }</span>
        } else<span class="cov8" title="1"> {
                s := c.hugo().Sites[0]
                baseURLs = []string{s.BaseURL.String()}
                roots = []string{""}
        }</span>

        <span class="cov8" title="1">templ, err := c.hugo().TextTmpl().Parse("__default_server_error", buildErrorTemplate)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">srv := &amp;fileServer{
                baseURLs: baseURLs,
                roots:    roots,
                c:        c,
                s:        s,
                errorTemplate: func(ctx interface{}) (io.Reader, error) </span><span class="cov0" title="0">{
                        b := &amp;bytes.Buffer{}
                        err := c.hugo().Tmpl().Execute(templ, b, ctx)
                        return b, err
                }</span>,
        }

        <span class="cov8" title="1">doLiveReload := !c.Cfg.GetBool("disableLiveReload")

        if doLiveReload </span><span class="cov8" title="1">{
                livereload.Initialize()
        }</span>

        <span class="cov8" title="1">sigs := make(chan os.Signal, 1)
        signal.Notify(sigs, syscall.SIGINT, syscall.SIGTERM)

        for i := range baseURLs </span><span class="cov8" title="1">{
                mu, serverURL, endpoint, err := srv.createEndpoint(i)

                if doLiveReload </span><span class="cov8" title="1">{
                        u, err := url.Parse(helpers.SanitizeURL(baseURLs[i]))
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">mu.HandleFunc(u.Path+"/livereload.js", livereload.ServeJS)
                        mu.HandleFunc(u.Path+"/livereload", livereload.Handler)</span>
                }
                <span class="cov8" title="1">jww.FEEDBACK.Printf("Web Server is available at %s (bind address %s)\n", serverURL, s.serverInterface)
                go func() </span><span class="cov8" title="1">{
                        err = http.ListenAndServe(endpoint, mu)
                        if err != nil </span><span class="cov0" title="0">{
                                c.logger.Errorf("Error: %s\n", err.Error())
                                os.Exit(1)
                        }</span>
                }()
        }

        <span class="cov8" title="1">jww.FEEDBACK.Println("Press Ctrl+C to stop")

        if s.stop != nil </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-sigs:<span class="cov0" title="0"></span>
                case &lt;-s.stop:<span class="cov8" title="1"></span>
                }
        } else<span class="cov0" title="0"> {
                &lt;-sigs
        }</span>

        <span class="cov8" title="1">c.hugo().Close()

        return nil</span>
}

// fixURL massages the baseURL into a form needed for serving
// all pages correctly.
func (sc *serverCmd) fixURL(cfg config.Provider, s string, port int) (string, error) <span class="cov8" title="1">{
        useLocalhost := false
        if s == "" </span><span class="cov8" title="1">{
                s = cfg.GetString("baseURL")
                useLocalhost = true
        }</span>

        <span class="cov8" title="1">if !strings.HasSuffix(s, "/") </span><span class="cov8" title="1">{
                s = s + "/"
        }</span>

        // do an initial parse of the input string
        <span class="cov8" title="1">u, err := url.Parse(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // if no Host is defined, then assume that no schema or double-slash were
        // present in the url.  Add a double-slash and make a best effort attempt.
        <span class="cov8" title="1">if u.Host == "" &amp;&amp; s != "/" </span><span class="cov8" title="1">{
                s = "//" + s

                u, err = url.Parse(s)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov8" title="1">if useLocalhost </span><span class="cov8" title="1">{
                if u.Scheme == "https" </span><span class="cov8" title="1">{
                        u.Scheme = "http"
                }</span>
                <span class="cov8" title="1">u.Host = "localhost"</span>
        }

        <span class="cov8" title="1">if sc.serverAppend </span><span class="cov8" title="1">{
                if strings.Contains(u.Host, ":") </span><span class="cov0" title="0">{
                        u.Host, _, err = net.SplitHostPort(u.Host)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", errors.Wrap(err, "Failed to split baseURL hostpost")
                        }</span>
                }
                <span class="cov8" title="1">u.Host += fmt.Sprintf(":%d", port)</span>
        }

        <span class="cov8" title="1">return u.String(), nil</span>
}

func memStats() error <span class="cov8" title="1">{
        b := newCommandsBuilder()
        sc := b.newServerCmd().getCommand()
        memstats := sc.Flags().Lookup("memstats").Value.String()
        if memstats != "" </span><span class="cov0" title="0">{
                interval, err := time.ParseDuration(sc.Flags().Lookup("meminterval").Value.String())
                if err != nil </span><span class="cov0" title="0">{
                        interval, _ = time.ParseDuration("100ms")
                }</span>

                <span class="cov0" title="0">fileMemStats, err := os.Create(memstats)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">fileMemStats.WriteString("# Time\tHeapSys\tHeapAlloc\tHeapIdle\tHeapReleased\n")

                go func() </span><span class="cov0" title="0">{
                        var stats runtime.MemStats

                        start := time.Now().UnixNano()

                        for </span><span class="cov0" title="0">{
                                runtime.ReadMemStats(&amp;stats)
                                if fileMemStats != nil </span><span class="cov0" title="0">{
                                        fileMemStats.WriteString(fmt.Sprintf("%d\t%d\t%d\t%d\t%d\n",
                                                (time.Now().UnixNano()-start)/1000000, stats.HeapSys, stats.HeapAlloc, stats.HeapIdle, stats.HeapReleased))
                                        time.Sleep(interval)
                                }</span> else<span class="cov0" title="0"> {
                                        break</span>
                                }
                        }
                }()
        }
        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file29" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "bytes"
        "io"
        "net/url"

        "github.com/gohugoio/hugo/transform"
        "github.com/gohugoio/hugo/transform/livereloadinject"
)

var buildErrorTemplate = `&lt;!doctype html&gt;
&lt;html class="no-js" lang=""&gt;
        &lt;head&gt;
                &lt;meta charset="utf-8"&gt;
                &lt;title&gt;Hugo Server: Error&lt;/title&gt;
                &lt;style type="text/css"&gt;
                body {
                        font-family: "Muli",avenir, -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif, "Apple Color Emoji", "Segoe UI Emoji", "Segoe UI Symbol";
                        font-size: 16px;
                        background-color: #2f1e2e;
                }
                main {
                        margin: auto;
                        width: 95%;
                        padding: 1rem;
                }                
                .version {
                        color: #ccc;
                        padding: 1rem 0;
                }
                .stack {
                        margin-top: 4rem;
                }
                pre {
                        white-space: pre-wrap;      
                        white-space: -moz-pre-wrap;  
                        white-space: -pre-wrap;     
                        white-space: -o-pre-wrap;    
                        word-wrap: break-word;     
                }
                .highlight {
                        overflow-x: auto;
                        margin-bottom: 1rem;
                }
                a {
                        color: #0594cb;
                        text-decoration: none;
                }
                a:hover {
                        color: #ccc;
                }
                &lt;/style&gt;
        &lt;/head&gt;
        &lt;body&gt;
                &lt;main&gt;
                        {{ highlight .Error "apl" "linenos=false,noclasses=true,style=paraiso-dark" }}
                        {{ with .File }}
                        {{ $params := printf "noclasses=true,style=paraiso-dark,linenos=table,hl_lines=%d,linenostart=%d" (add .LinesPos 1) (sub .Position.LineNumber .LinesPos) }}
                        {{ $lexer := .ChromaLexer | default "go-html-template" }}
                        {{  highlight (delimit .Lines "\n") $lexer $params }}
                        {{ end }}
                        {{ with .StackTrace }}
                        {{ highlight . "apl" "noclasses=true,style=paraiso-dark" }}
                        {{ end }}
                        &lt;p class="version"&gt;{{ .Version }}&lt;/p&gt;
                        &lt;a href=""&gt;Reload Page&lt;/a&gt;
                &lt;/main&gt;
&lt;/body&gt;
&lt;/html&gt;
`

func injectLiveReloadScript(src io.Reader, baseURL url.URL) string <span class="cov0" title="0">{
        var b bytes.Buffer
        chain := transform.Chain{livereloadinject.New(baseURL)}
        chain.Apply(&amp;b, src)

        return b.String()
}</span>
</pre>
		
		<pre class="file" id="file30" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "os"
        "path/filepath"

        "github.com/gohugoio/hugo/hugolib/filesystems"

        "github.com/fsnotify/fsnotify"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/fsync"
)

type staticSyncer struct {
        c *commandeer
}

func newStaticSyncer(c *commandeer) (*staticSyncer, error) <span class="cov8" title="1">{
        return &amp;staticSyncer{c: c}, nil
}</span>

func (s *staticSyncer) isStatic(filename string) bool <span class="cov0" title="0">{
        return s.c.hugo().BaseFs.SourceFilesystems.IsStatic(filename)
}</span>

func (s *staticSyncer) syncsStaticEvents(staticEvents []fsnotify.Event) error <span class="cov0" title="0">{
        c := s.c

        syncFn := func(sourceFs *filesystems.SourceFilesystem) (uint64, error) </span><span class="cov0" title="0">{
                publishDir := c.hugo().PathSpec.PublishDir
                // If root, remove the second '/'
                if publishDir == "//" </span><span class="cov0" title="0">{
                        publishDir = helpers.FilePathSeparator
                }</span>

                <span class="cov0" title="0">if sourceFs.PublishFolder != "" </span><span class="cov0" title="0">{
                        publishDir = filepath.Join(publishDir, sourceFs.PublishFolder)
                }</span>

                <span class="cov0" title="0">syncer := fsync.NewSyncer()
                syncer.NoTimes = c.Cfg.GetBool("noTimes")
                syncer.NoChmod = c.Cfg.GetBool("noChmod")
                syncer.ChmodFilter = chmodFilter
                syncer.SrcFs = sourceFs.Fs
                syncer.DestFs = c.Fs.Destination

                // prevent spamming the log on changes
                logger := helpers.NewDistinctErrorLogger()

                for _, ev := range staticEvents </span><span class="cov0" title="0">{
                        // Due to our approach of layering both directories and the content's rendered output
                        // into one we can't accurately remove a file not in one of the source directories.
                        // If a file is in the local static dir and also in the theme static dir and we remove
                        // it from one of those locations we expect it to still exist in the destination
                        //
                        // If Hugo generates a file (from the content dir) over a static file
                        // the content generated file should take precedence.
                        //
                        // Because we are now watching and handling individual events it is possible that a static
                        // event that occupies the same path as a content generated file will take precedence
                        // until a regeneration of the content takes places.
                        //
                        // Hugo assumes that these cases are very rare and will permit this bad behavior
                        // The alternative is to track every single file and which pipeline rendered it
                        // and then to handle conflict resolution on every event.

                        fromPath := ev.Name

                        relPath, found := sourceFs.MakePathRelative(fromPath)

                        if !found </span><span class="cov0" title="0">{
                                // Not member of this virtual host.
                                continue</span>
                        }

                        // Remove || rename is harder and will require an assumption.
                        // Hugo takes the following approach:
                        // If the static file exists in any of the static source directories after this event
                        // Hugo will re-sync it.
                        // If it does not exist in all of the static directories Hugo will remove it.
                        //
                        // This assumes that Hugo has not generated content on top of a static file and then removed
                        // the source of that static file. In this case Hugo will incorrectly remove that file
                        // from the published directory.
                        <span class="cov0" title="0">if ev.Op&amp;fsnotify.Rename == fsnotify.Rename || ev.Op&amp;fsnotify.Remove == fsnotify.Remove </span><span class="cov0" title="0">{
                                if _, err := sourceFs.Fs.Stat(relPath); os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        // If file doesn't exist in any static dir, remove it
                                        toRemove := filepath.Join(publishDir, relPath)

                                        logger.Println("File no longer exists in static dir, removing", toRemove)
                                        _ = c.Fs.Destination.RemoveAll(toRemove)
                                }</span> else<span class="cov0" title="0"> if err == nil </span><span class="cov0" title="0">{
                                        // If file still exists, sync it
                                        logger.Println("Syncing", relPath, "to", publishDir)

                                        if err := syncer.Sync(filepath.Join(publishDir, relPath), relPath); err != nil </span><span class="cov0" title="0">{
                                                c.logger.Errorln(err)
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        c.logger.Errorln(err)
                                }</span>

                                <span class="cov0" title="0">continue</span>
                        }

                        // For all other event operations Hugo will sync static.
                        <span class="cov0" title="0">logger.Println("Syncing", relPath, "to", publishDir)
                        if err := syncer.Sync(filepath.Join(publishDir, relPath), relPath); err != nil </span><span class="cov0" title="0">{
                                c.logger.Errorln(err)
                        }</span>
                }

                <span class="cov0" title="0">return 0, nil</span>
        }

        <span class="cov0" title="0">_, err := c.doWithPublishDirs(syncFn)
        return err</span>
}
</pre>
		
		<pre class="file" id="file31" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package commands

import (
        "github.com/gohugoio/hugo/common/hugo"
        "github.com/spf13/cobra"
        jww "github.com/spf13/jwalterweatherman"
)

var _ cmder = (*versionCmd)(nil)

type versionCmd struct {
        *baseCmd
}

func newVersionCmd() *versionCmd <span class="cov8" title="1">{
        return &amp;versionCmd{
                newBaseCmd(&amp;cobra.Command{
                        Use:   "version",
                        Short: "Print the version number of Hugo",
                        Long:  `All software has versions. This is Hugo's.`,
                        RunE: func(cmd *cobra.Command, args []string) error </span><span class="cov8" title="1">{
                                printHugoVersion()
                                return nil
                        }</span>,
                }),
        }
}

func printHugoVersion() <span class="cov8" title="1">{
        jww.FEEDBACK.Println(hugo.BuildVersionString())
}</span>
</pre>
		
		<pre class="file" id="file32" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "fmt"
        "reflect"
)

// Append appends from to a slice to and returns the resulting slice.
// If length of from is one and the only element is a slice of same type as to,
// it will be appended.
func Append(to interface{}, from ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        tov, toIsNil := indirect(reflect.ValueOf(to))

        toIsNil = toIsNil || to == nil
        var tot reflect.Type

        if !toIsNil </span><span class="cov8" title="1">{
                if tov.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("expected a slice, got %T", to)
                }</span>

                <span class="cov8" title="1">tot = tov.Type().Elem()
                toIsNil = tov.Len() == 0

                if len(from) == 1 </span><span class="cov8" title="1">{
                        fromv := reflect.ValueOf(from[0])
                        if fromv.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                                if toIsNil </span><span class="cov8" title="1">{
                                        // If we get nil []string, we just return the []string
                                        return from[0], nil
                                }</span>

                                <span class="cov8" title="1">fromt := reflect.TypeOf(from[0]).Elem()

                                // If we get []string []string, we append the from slice to to
                                if tot == fromt </span><span class="cov8" title="1">{
                                        return reflect.AppendSlice(tov, fromv).Interface(), nil
                                }</span> else<span class="cov8" title="1"> if !fromt.AssignableTo(tot) </span><span class="cov8" title="1">{
                                        // Fall back to a []interface{} slice.
                                        return appendToInterfaceSliceFromValues(tov, fromv)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if toIsNil </span><span class="cov8" title="1">{
                return Slice(from...), nil
        }</span>

        <span class="cov8" title="1">for _, f := range from </span><span class="cov8" title="1">{
                fv := reflect.ValueOf(f)
                if !fv.Type().AssignableTo(tot) </span><span class="cov8" title="1">{
                        // Fall back to a []interface{} slice.
                        tov, _ := indirect(reflect.ValueOf(to))
                        return appendToInterfaceSlice(tov, from...)
                }</span>
                <span class="cov8" title="1">tov = reflect.Append(tov, fv)</span>
        }

        <span class="cov8" title="1">return tov.Interface(), nil</span>
}

func appendToInterfaceSliceFromValues(slice1, slice2 reflect.Value) ([]interface{}, error) <span class="cov8" title="1">{
        var tos []interface{}

        for _, slice := range []reflect.Value{slice1, slice2} </span><span class="cov8" title="1">{
                for i := 0; i &lt; slice.Len(); i++ </span><span class="cov8" title="1">{
                        tos = append(tos, slice.Index(i).Interface())
                }</span>
        }

        <span class="cov8" title="1">return tos, nil</span>
}

func appendToInterfaceSlice(tov reflect.Value, from ...interface{}) ([]interface{}, error) <span class="cov8" title="1">{
        var tos []interface{}

        for i := 0; i &lt; tov.Len(); i++ </span><span class="cov8" title="1">{
                tos = append(tos, tov.Index(i).Interface())
        }</span>

        <span class="cov8" title="1">tos = append(tos, from...)

        return tos, nil</span>
}

// indirect is borrowed from the Go stdlib: 'text/template/exec.go'
// TODO(bep) consolidate
func indirect(v reflect.Value) (rv reflect.Value, isNil bool) <span class="cov8" title="1">{
        for ; v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface; v = v.Elem() </span><span class="cov8" title="1">{
                if v.IsNil() </span><span class="cov0" title="0">{
                        return v, true
                }</span>
                <span class="cov8" title="1">if v.Kind() == reflect.Interface &amp;&amp; v.NumMethod() &gt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return v, false</span>
}
</pre>
		
		<pre class="file" id="file33" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "reflect"
)

// Slicer defines a very generic way to create a typed slice. This is used
// in collections.Slice template func to get types such as Pages, PageGroups etc.
// instead of the less useful []interface{}.
type Slicer interface {
        Slice(items interface{}) (interface{}, error)
}

// Slice returns a slice of all passed arguments.
func Slice(args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return args
        }</span>

        <span class="cov8" title="1">first := args[0]
        firstType := reflect.TypeOf(first)

        if firstType == nil </span><span class="cov8" title="1">{
                return args
        }</span>

        <span class="cov8" title="1">if g, ok := first.(Slicer); ok </span><span class="cov8" title="1">{
                v, err := g.Slice(args)
                if err == nil </span><span class="cov8" title="1">{
                        return v
                }</span>

                // If Slice fails, the items are not of the same type and
                // []interface{} is the best we can do.
                <span class="cov8" title="1">return args</span>
        }

        <span class="cov8" title="1">if len(args) &gt; 1 </span><span class="cov8" title="1">{
                // This can be a mix of types.
                for i := 1; i &lt; len(args); i++ </span><span class="cov8" title="1">{
                        if firstType != reflect.TypeOf(args[i]) </span><span class="cov8" title="1">{
                                // []interface{} is the best we can do
                                return args
                        }</span>
                }
        }

        <span class="cov8" title="1">slice := reflect.MakeSlice(reflect.SliceOf(firstType), len(args), len(args))
        for i, arg := range args </span><span class="cov8" title="1">{
                slice.Index(i).Set(reflect.ValueOf(arg))
        }</span>
        <span class="cov8" title="1">return slice.Interface()</span>
}

// StringSliceToInterfaceSlice converts ss to []interface{}.
func StringSliceToInterfaceSlice(ss []string) []interface{} <span class="cov0" title="0">{
        result := make([]interface{}, len(ss))
        for i, s := range ss </span><span class="cov0" title="0">{
                result[i] = s
        }</span>
        <span class="cov0" title="0">return result</span>

}
</pre>
		
		<pre class="file" id="file34" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package herrors contains common Hugo errors and error related utilities.
package herrors

import (
        "io"
        "io/ioutil"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/text"

        "github.com/spf13/afero"
)

// LineMatcher contains the elements used to match an error to a line
type LineMatcher struct {
        Position text.Position
        Error    error

        LineNumber int
        Offset     int
        Line       string
}

// LineMatcherFn is used to match a line with an error.
type LineMatcherFn func(m LineMatcher) bool

// SimpleLineMatcher simply matches by line number.
var SimpleLineMatcher = func(m LineMatcher) bool <span class="cov0" title="0">{
        return m.Position.LineNumber == m.LineNumber
}</span>

var _ text.Positioner = ErrorContext{}

// ErrorContext contains contextual information about an error. This will
// typically be the lines surrounding some problem in a file.
type ErrorContext struct {

        // If a match will contain the matched line and up to 2 lines before and after.
        // Will be empty if no match.
        Lines []string

        // The position of the error in the Lines above. 0 based.
        LinesPos int

        position text.Position

        // The lexer to use for syntax highlighting.
        // https://gohugo.io/content-management/syntax-highlighting/#list-of-chroma-highlighting-languages
        ChromaLexer string
}

// Position returns the text position of this error.
func (e ErrorContext) Position() text.Position <span class="cov8" title="1">{
        return e.position
}</span>

var _ causer = (*ErrorWithFileContext)(nil)

// ErrorWithFileContext is an error with some additional file context related
// to that error.
type ErrorWithFileContext struct {
        cause error
        ErrorContext
}

func (e *ErrorWithFileContext) Error() string <span class="cov0" title="0">{
        pos := e.Position()
        if pos.IsValid() </span><span class="cov0" title="0">{
                return pos.String() + ": " + e.cause.Error()
        }</span>
        <span class="cov0" title="0">return e.cause.Error()</span>
}

func (e *ErrorWithFileContext) Cause() error <span class="cov0" title="0">{
        return e.cause
}</span>

// WithFileContextForFile will try to add a file context with lines matching the given matcher.
// If no match could be found, the original error is returned with false as the second return value.
func WithFileContextForFile(e error, realFilename, filename string, fs afero.Fs, matcher LineMatcherFn) (error, bool) <span class="cov0" title="0">{
        f, err := fs.Open(filename)
        if err != nil </span><span class="cov0" title="0">{
                return e, false
        }</span>
        <span class="cov0" title="0">defer f.Close()
        return WithFileContext(e, realFilename, f, matcher)</span>
}

// WithFileContextForFileDefault tries to add file context using the default line matcher.
func WithFileContextForFileDefault(err error, filename string, fs afero.Fs) error <span class="cov0" title="0">{
        err, _ = WithFileContextForFile(
                err,
                filename,
                filename,
                fs,
                SimpleLineMatcher)
        return err
}</span>

// WithFileContextForFile will try to add a file context with lines matching the given matcher.
// If no match could be found, the original error is returned with false as the second return value.
func WithFileContext(e error, realFilename string, r io.Reader, matcher LineMatcherFn) (error, bool) <span class="cov0" title="0">{
        if e == nil </span><span class="cov0" title="0">{
                panic("error missing")</span>
        }
        <span class="cov0" title="0">le := UnwrapFileError(e)

        if le == nil </span><span class="cov0" title="0">{
                var ok bool
                if le, ok = ToFileError("", e).(FileError); !ok </span><span class="cov0" title="0">{
                        return e, false
                }</span>
        }

        <span class="cov0" title="0">var errCtx ErrorContext

        posle := le.Position()

        if posle.Offset != -1 </span><span class="cov0" title="0">{
                errCtx = locateError(r, le, func(m LineMatcher) bool </span><span class="cov0" title="0">{
                        if posle.Offset &gt;= m.Offset &amp;&amp; posle.Offset &lt; m.Offset+len(m.Line) </span><span class="cov0" title="0">{
                                lno := posle.LineNumber - m.Position.LineNumber + m.LineNumber
                                m.Position = text.Position{LineNumber: lno}
                        }</span>
                        <span class="cov0" title="0">return matcher(m)</span>
                })
        } else<span class="cov0" title="0"> {
                errCtx = locateError(r, le, matcher)
        }</span>

        <span class="cov0" title="0">pos := &amp;errCtx.position

        if pos.LineNumber == -1 </span><span class="cov0" title="0">{
                return e, false
        }</span>

        <span class="cov0" title="0">pos.Filename = realFilename

        if le.Type() != "" </span><span class="cov0" title="0">{
                errCtx.ChromaLexer = chromaLexerFromType(le.Type())
        }</span> else<span class="cov0" title="0"> {
                errCtx.ChromaLexer = chromaLexerFromFilename(realFilename)
        }</span>

        <span class="cov0" title="0">return &amp;ErrorWithFileContext{cause: e, ErrorContext: errCtx}, true</span>
}

// UnwrapErrorWithFileContext tries to unwrap an ErrorWithFileContext from err.
// It returns nil if this is not possible.
func UnwrapErrorWithFileContext(err error) *ErrorWithFileContext <span class="cov0" title="0">{
        for err != nil </span><span class="cov0" title="0">{
                switch v := err.(type) </span>{
                case *ErrorWithFileContext:<span class="cov0" title="0">
                        return v</span>
                case causer:<span class="cov0" title="0">
                        err = v.Cause()</span>
                default:<span class="cov0" title="0">
                        return nil</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func chromaLexerFromType(fileType string) string <span class="cov0" title="0">{
        switch fileType </span>{
        case "html", "htm":<span class="cov0" title="0">
                return "go-html-template"</span>
        }
        <span class="cov0" title="0">return fileType</span>
}

func extNoDelimiter(filename string) string <span class="cov0" title="0">{
        return strings.TrimPrefix(filepath.Ext(filename), ".")
}</span>

func chromaLexerFromFilename(filename string) string <span class="cov0" title="0">{
        if strings.Contains(filename, "layouts") </span><span class="cov0" title="0">{
                return "go-html-template"
        }</span>

        <span class="cov0" title="0">ext := extNoDelimiter(filename)
        return chromaLexerFromType(ext)</span>
}

func locateErrorInString(src string, matcher LineMatcherFn) ErrorContext <span class="cov8" title="1">{
        return locateError(strings.NewReader(src), &amp;fileError{}, matcher)
}</span>

func locateError(r io.Reader, le FileError, matches LineMatcherFn) ErrorContext <span class="cov8" title="1">{
        if le == nil </span><span class="cov0" title="0">{
                panic("must provide an error")</span>
        }

        <span class="cov8" title="1">errCtx := ErrorContext{position: text.Position{LineNumber: -1, ColumnNumber: 1, Offset: -1}, LinesPos: -1}

        b, err := ioutil.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return errCtx
        }</span>

        <span class="cov8" title="1">pos := &amp;errCtx.position
        lepos := le.Position()

        lines := strings.Split(string(b), "\n")

        if lepos.ColumnNumber &gt;= 0 </span><span class="cov8" title="1">{
                pos.ColumnNumber = lepos.ColumnNumber
        }</span>

        <span class="cov8" title="1">lineNo := 0
        posBytes := 0

        for li, line := range lines </span><span class="cov8" title="1">{
                lineNo = li + 1
                m := LineMatcher{
                        Position:   le.Position(),
                        Error:      le,
                        LineNumber: lineNo,
                        Offset:     posBytes,
                        Line:       line,
                }
                if errCtx.LinesPos == -1 &amp;&amp; matches(m) </span><span class="cov8" title="1">{
                        pos.LineNumber = lineNo
                        break</span>
                }

                <span class="cov8" title="1">posBytes += len(line)</span>
        }

        <span class="cov8" title="1">if pos.LineNumber != -1 </span><span class="cov8" title="1">{
                low := pos.LineNumber - 3
                if low &lt; 0 </span><span class="cov8" title="1">{
                        low = 0
                }</span>

                <span class="cov8" title="1">if pos.LineNumber &gt; 2 </span><span class="cov8" title="1">{
                        errCtx.LinesPos = 2
                }</span> else<span class="cov8" title="1"> {
                        errCtx.LinesPos = pos.LineNumber - 1
                }</span>

                <span class="cov8" title="1">high := pos.LineNumber + 2
                if high &gt; len(lines) </span><span class="cov8" title="1">{
                        high = len(lines)
                }</span>

                <span class="cov8" title="1">errCtx.Lines = lines[low:high]</span>

        }

        <span class="cov8" title="1">return errCtx</span>
}
</pre>
		
		<pre class="file" id="file35" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package herrors contains common Hugo errors and error related utilities.
package herrors

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "os"
        "runtime"
        "runtime/debug"
        "strconv"

        _errors "github.com/pkg/errors"
)

// As defined in https://godoc.org/github.com/pkg/errors
type causer interface {
        Cause() error
}

type stackTracer interface {
        StackTrace() _errors.StackTrace
}

// PrintStackTraceFromErr prints the error's stack trace to stdoud.
func PrintStackTraceFromErr(err error) <span class="cov0" title="0">{
        FprintStackTraceFromErr(os.Stdout, err)
}</span>

// FprintStackTraceFromErr prints the error's stack trace to w.
func FprintStackTraceFromErr(w io.Writer, err error) <span class="cov0" title="0">{
        if err, ok := err.(stackTracer); ok </span><span class="cov0" title="0">{
                for _, f := range err.StackTrace() </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "%+s:%d\n", f, f)
                }</span>
        }
}

// PrintStackTrace prints the current stacktrace to w.
func PrintStackTrace(w io.Writer) <span class="cov0" title="0">{
        buf := make([]byte, 1&lt;&lt;16)
        runtime.Stack(buf, true)
        fmt.Fprintf(w, "%s", buf)
}</span>

// ErrorSender is a, typically, non-blocking error handler.
type ErrorSender interface {
        SendError(err error)
}

// Recover is a helper function that can be used to capture panics.
// Put this at the top of a method/function that crashes in a template:
//     defer herrors.Recover()
func Recover(args ...interface{}) <span class="cov0" title="0">{
        if r := recover(); r != nil </span><span class="cov0" title="0">{
                fmt.Println("ERR:", r)
                args = append(args, "stacktrace from panic: \n"+string(debug.Stack()), "\n")
                fmt.Println(args...)
        }</span>
}

// Get the current goroutine id. Used only for debugging.
func GetGID() uint64 <span class="cov0" title="0">{
        b := make([]byte, 64)
        b = b[:runtime.Stack(b, false)]
        b = bytes.TrimPrefix(b, []byte("goroutine "))
        b = b[:bytes.IndexByte(b, ' ')]
        n, _ := strconv.ParseUint(string(b), 10, 64)
        return n
}</span>

// ErrFeatureNotAvailable denotes that a feature is unavailable.
//
// We will, at least to begin with, make some Hugo features (SCSS with libsass) optional,
// and this error is used to signal those situations.
var ErrFeatureNotAvailable = errors.New("this feature is not available in your current Hugo version, see https://goo.gl/YMrWcn for more information")

// Must panics if err != nil.
func Must(err error) <span class="cov0" title="0">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}
</pre>
		
		<pre class="file" id="file36" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package herrors

import (
        "encoding/json"

        "github.com/gohugoio/hugo/common/text"

        "github.com/pkg/errors"
)

var _ causer = (*fileError)(nil)

// FileError represents an error when handling a file: Parsing a config file,
// execute a template etc.
type FileError interface {
        error

        text.Positioner

        // A string identifying the type of file, e.g. JSON, TOML, markdown etc.
        Type() string
}

var _ FileError = (*fileError)(nil)

type fileError struct {
        position text.Position

        fileType string

        cause error
}

// Position returns the text position of this error.
func (e fileError) Position() text.Position <span class="cov8" title="1">{
        return e.position
}</span>

func (e *fileError) Type() string <span class="cov0" title="0">{
        return e.fileType
}</span>

func (e *fileError) Error() string <span class="cov0" title="0">{
        if e.cause == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return e.cause.Error()</span>
}

func (f *fileError) Cause() error <span class="cov8" title="1">{
        return f.cause
}</span>

// NewFileError creates a new FileError.
func NewFileError(fileType string, offset, lineNumber, columnNumber int, err error) FileError <span class="cov8" title="1">{
        pos := text.Position{Offset: offset, LineNumber: lineNumber, ColumnNumber: columnNumber}
        return &amp;fileError{cause: err, fileType: fileType, position: pos}
}</span>

// UnwrapFileError tries to unwrap a FileError from err.
// It returns nil if this is not possible.
func UnwrapFileError(err error) FileError <span class="cov0" title="0">{
        for err != nil </span><span class="cov0" title="0">{
                switch v := err.(type) </span>{
                case FileError:<span class="cov0" title="0">
                        return v</span>
                case causer:<span class="cov0" title="0">
                        err = v.Cause()</span>
                default:<span class="cov0" title="0">
                        return nil</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// ToFileErrorWithOffset will return a new FileError with a line number
// with the given offset from the original.
func ToFileErrorWithOffset(fe FileError, offset int) FileError <span class="cov0" title="0">{
        pos := fe.Position()
        return ToFileErrorWithLineNumber(fe, pos.LineNumber+offset)
}</span>

// ToFileErrorWithOffset will return a new FileError with the given line number.
func ToFileErrorWithLineNumber(fe FileError, lineNumber int) FileError <span class="cov0" title="0">{
        pos := fe.Position()
        pos.LineNumber = lineNumber
        return &amp;fileError{cause: fe, fileType: fe.Type(), position: pos}
}</span>

// ToFileError will convert the given error to an error supporting
// the FileError interface.
func ToFileError(fileType string, err error) FileError <span class="cov8" title="1">{
        for _, handle := range lineNumberExtractors </span><span class="cov8" title="1">{
                lno, col := handle(err)
                offset, typ := extractOffsetAndType(err)
                if fileType == "" </span><span class="cov0" title="0">{
                        fileType = typ
                }</span>

                <span class="cov8" title="1">if lno &gt; 0 || offset != -1 </span><span class="cov8" title="1">{
                        return NewFileError(fileType, offset, lno, col, err)
                }</span>
        }
        // Fall back to the pointing to line number 1.
        <span class="cov8" title="1">return NewFileError(fileType, -1, 1, 1, err)</span>
}

func extractOffsetAndType(e error) (int, string) <span class="cov8" title="1">{
        e = errors.Cause(e)
        switch v := e.(type) </span>{
        case *json.UnmarshalTypeError:<span class="cov0" title="0">
                return int(v.Offset), "json"</span>
        case *json.SyntaxError:<span class="cov0" title="0">
                return int(v.Offset), "json"</span>
        default:<span class="cov8" title="1">
                return -1, ""</span>
        }
}
</pre>
		
		<pre class="file" id="file37" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package herrors

import (
        "regexp"
        "strconv"

        "github.com/pkg/errors"

        "github.com/pelletier/go-toml/v2"
)

var lineNumberExtractors = []lineNumberExtractor{
        // Template/shortcode parse errors
        newLineNumberErrHandlerFromRegexp(".*:(\\d+):(\\d*):"),
        newLineNumberErrHandlerFromRegexp(".*:(\\d+):"),

        // TOML parse errors
        tomlLineNumberExtractor,
        // YAML parse errors
        newLineNumberErrHandlerFromRegexp("line (\\d+):"),

        // i18n bundle errors
        newLineNumberErrHandlerFromRegexp("\\((\\d+),\\s(\\d*)"),
}

type lineNumberExtractor func(e error) (int, int)

var tomlLineNumberExtractor = func(e error) (int, int) <span class="cov8" title="1">{
        e = errors.Cause(e)
        if terr, ok := e.(*toml.DecodeError); ok </span><span class="cov0" title="0">{
                return terr.Position()
        }</span>
        <span class="cov8" title="1">return -1, -1</span>
}

func newLineNumberErrHandlerFromRegexp(expression string) lineNumberExtractor <span class="cov8" title="1">{
        re := regexp.MustCompile(expression)
        return extractLineNo(re)
}</span>

func extractLineNo(re *regexp.Regexp) lineNumberExtractor <span class="cov8" title="1">{
        return func(e error) (int, int) </span><span class="cov8" title="1">{
                if e == nil </span><span class="cov0" title="0">{
                        panic("no error")</span>
                }
                <span class="cov8" title="1">col := 1
                s := e.Error()
                m := re.FindStringSubmatch(s)
                if len(m) &gt;= 2 </span><span class="cov8" title="1">{
                        lno, _ := strconv.Atoi(m[1])
                        if len(m) &gt; 2 </span><span class="cov8" title="1">{
                                col, _ = strconv.Atoi(m[2])
                        }</span>

                        <span class="cov8" title="1">if col &lt;= 0 </span><span class="cov0" title="0">{
                                col = 1
                        }</span>

                        <span class="cov8" title="1">return lno, col</span>
                }

                <span class="cov8" title="1">return -1, col</span>
        }
}
</pre>
		
		<pre class="file" id="file38" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
// Some functions in this file (see comments) is based on the Go source code,
// copyright The Go Authors and  governed by a BSD-style license.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package hreflect contains reflect helpers.
package hreflect

import (
        "reflect"

        "github.com/gohugoio/hugo/common/types"
)

// TODO(bep) replace the private versions in /tpl with these.
// IsNumber returns whether the given kind is a number.
func IsNumber(kind reflect.Kind) bool <span class="cov0" title="0">{
        return IsInt(kind) || IsUint(kind) || IsFloat(kind)
}</span>

// IsInt returns whether the given kind is an int.
func IsInt(kind reflect.Kind) bool <span class="cov0" title="0">{
        switch kind </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsUint returns whether the given kind is an uint.
func IsUint(kind reflect.Kind) bool <span class="cov0" title="0">{
        switch kind </span>{
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsFloat returns whether the given kind is a float.
func IsFloat(kind reflect.Kind) bool <span class="cov0" title="0">{
        switch kind </span>{
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return true</span>
        default:<span class="cov0" title="0">
                return false</span>
        }
}

// IsTruthful returns whether in represents a truthful value.
// See IsTruthfulValue
func IsTruthful(in interface{}) bool <span class="cov8" title="1">{
        switch v := in.(type) </span>{
        case reflect.Value:<span class="cov0" title="0">
                return IsTruthfulValue(v)</span>
        default:<span class="cov8" title="1">
                return IsTruthfulValue(reflect.ValueOf(in))</span>
        }
}

var zeroType = reflect.TypeOf((*types.Zeroer)(nil)).Elem()

// IsTruthfulValue returns whether the given value has a meaningful truth value.
// This is based on template.IsTrue in Go's stdlib, but also considers
// IsZero and any interface value will be unwrapped before it's considered
// for truthfulness.
//
// Based on:
// https://github.com/golang/go/blob/178a2c42254166cffed1b25fb1d3c7a5727cada6/src/text/template/exec.go#L306
func IsTruthfulValue(val reflect.Value) (truth bool) <span class="cov8" title="1">{
        val = indirectInterface(val)

        if !val.IsValid() </span><span class="cov0" title="0">{
                // Something like var x interface{}, never set. It's a form of nil.
                return
        }</span>

        <span class="cov8" title="1">if val.Type().Implements(zeroType) </span><span class="cov8" title="1">{
                return !val.Interface().(types.Zeroer).IsZero()
        }</span>

        <span class="cov8" title="1">switch val.Kind() </span>{
        case reflect.Array, reflect.Map, reflect.Slice, reflect.String:<span class="cov0" title="0">
                truth = val.Len() &gt; 0</span>
        case reflect.Bool:<span class="cov8" title="1">
                truth = val.Bool()</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov0" title="0">
                truth = val.Complex() != 0</span>
        case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Interface:<span class="cov0" title="0">
                truth = !val.IsNil()</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                truth = val.Int() != 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                truth = val.Float() != 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                truth = val.Uint() != 0</span>
        case reflect.Struct:<span class="cov0" title="0">
                truth = true</span> // Struct values are always true.
        default:<span class="cov0" title="0">
                return</span>
        }

        <span class="cov8" title="1">return</span>
}

// Based on: https://github.com/golang/go/blob/178a2c42254166cffed1b25fb1d3c7a5727cada6/src/text/template/exec.go#L931
func indirectInterface(v reflect.Value) reflect.Value <span class="cov8" title="1">{
        if v.Kind() != reflect.Interface </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov0" title="0">if v.IsNil() </span><span class="cov0" title="0">{
                return reflect.Value{}
        }</span>
        <span class="cov0" title="0">return v.Elem()</span>
}
</pre>
		
		<pre class="file" id="file39" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package htime

import (
        "strings"
        "time"

        "github.com/spf13/cast"

        toml "github.com/pelletier/go-toml/v2"

        "github.com/gohugoio/locales"
)

var (
        longDayNames = []string{
                "Sunday",
                "Monday",
                "Tuesday",
                "Wednesday",
                "Thursday",
                "Friday",
                "Saturday",
        }

        shortDayNames = []string{
                "Sun",
                "Mon",
                "Tue",
                "Wed",
                "Thu",
                "Fri",
                "Sat",
        }

        shortMonthNames = []string{
                "Jan",
                "Feb",
                "Mar",
                "Apr",
                "May",
                "Jun",
                "Jul",
                "Aug",
                "Sep",
                "Oct",
                "Nov",
                "Dec",
        }

        longMonthNames = []string{
                "January",
                "February",
                "March",
                "April",
                "May",
                "June",
                "July",
                "August",
                "September",
                "October",
                "November",
                "December",
        }
)

func NewTimeFormatter(ltr locales.Translator) TimeFormatter <span class="cov8" title="1">{
        if ltr == nil </span><span class="cov0" title="0">{
                panic("must provide a locales.Translator")</span>
        }
        <span class="cov8" title="1">return TimeFormatter{
                ltr: ltr,
        }</span>
}

// TimeFormatter is locale aware.
type TimeFormatter struct {
        ltr locales.Translator
}

func (f TimeFormatter) Format(t time.Time, layout string) string <span class="cov8" title="1">{
        if layout == "" </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov8" title="1">if layout[0] == ':' </span><span class="cov8" title="1">{
                // It may be one of Hugo's custom layouts.
                switch strings.ToLower(layout[1:]) </span>{
                case "date_full":<span class="cov8" title="1">
                        return f.ltr.FmtDateFull(t)</span>
                case "date_long":<span class="cov8" title="1">
                        return f.ltr.FmtDateLong(t)</span>
                case "date_medium":<span class="cov8" title="1">
                        return f.ltr.FmtDateMedium(t)</span>
                case "date_short":<span class="cov8" title="1">
                        return f.ltr.FmtDateShort(t)</span>
                case "time_full":<span class="cov8" title="1">
                        return f.ltr.FmtTimeFull(t)</span>
                case "time_long":<span class="cov8" title="1">
                        return f.ltr.FmtTimeLong(t)</span>
                case "time_medium":<span class="cov8" title="1">
                        return f.ltr.FmtTimeMedium(t)</span>
                case "time_short":<span class="cov8" title="1">
                        return f.ltr.FmtTimeShort(t)</span>
                }
        }

        <span class="cov8" title="1">s := t.Format(layout)

        monthIdx := t.Month() - 1 // Month() starts at 1.
        dayIdx := t.Weekday()

        s = strings.ReplaceAll(s, longMonthNames[monthIdx], f.ltr.MonthWide(t.Month()))
        if !strings.Contains(s, f.ltr.MonthWide(t.Month())) </span><span class="cov8" title="1">{
                s = strings.ReplaceAll(s, shortMonthNames[monthIdx], f.ltr.MonthAbbreviated(t.Month()))
        }</span>
        <span class="cov8" title="1">s = strings.ReplaceAll(s, longDayNames[dayIdx], f.ltr.WeekdayWide(t.Weekday()))
        if !strings.Contains(s, f.ltr.WeekdayWide(t.Weekday())) </span><span class="cov8" title="1">{
                s = strings.ReplaceAll(s, shortDayNames[dayIdx], f.ltr.WeekdayAbbreviated(t.Weekday()))
        }</span>

        <span class="cov8" title="1">return s</span>
}

func ToTimeInDefaultLocationE(i interface{}, location *time.Location) (tim time.Time, err error) <span class="cov0" title="0">{
        switch vv := i.(type) </span>{
        case toml.LocalDate:<span class="cov0" title="0">
                return vv.AsTime(location), nil</span>
        case toml.LocalDateTime:<span class="cov0" title="0">
                return vv.AsTime(location), nil</span>
        // issue #8895
        // datetimes parsed by `go-toml` have empty zone name
        // convert back them into string and use `cast`
        case time.Time:<span class="cov0" title="0">
                i = vv.Format(time.RFC3339)</span>
        }
        <span class="cov0" title="0">return cast.ToTimeInDefaultLocationE(i, location)</span>
}
</pre>
		
		<pre class="file" id="file40" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugo

import (
        "fmt"
        "html/template"
        "os"
        "path/filepath"
        "runtime/debug"
        "sort"
        "strings"
        "time"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/hugofs"
)

const (
        EnvironmentDevelopment = "development"
        EnvironmentProduction  = "production"
)

var (
        // commitHash contains the current Git revision.
        // Use mage to build to make sure this gets set.
        commitHash string

        // buildDate contains the date of the current build.
        buildDate string

        // vendorInfo contains vendor notes about the current build.
        vendorInfo string
)

// Info contains information about the current Hugo environment
type Info struct {
        CommitHash string
        BuildDate  string

        // The build environment.
        // Defaults are "production" (hugo) and "development" (hugo server).
        // This can also be set by the user.
        // It can be any string, but it will be all lower case.
        Environment string

        deps []*Dependency
}

// Version returns the current version as a comparable version string.
func (i Info) Version() VersionString <span class="cov8" title="1">{
        return CurrentVersion.Version()
}</span>

// Generator a Hugo meta generator HTML tag.
func (i Info) Generator() template.HTML <span class="cov8" title="1">{
        return template.HTML(fmt.Sprintf(`&lt;meta name="generator" content="Hugo %s" /&gt;`, CurrentVersion.String()))
}</span>

func (i Info) IsProduction() bool <span class="cov8" title="1">{
        return i.Environment == EnvironmentProduction
}</span>

func (i Info) IsExtended() bool <span class="cov8" title="1">{
        return IsExtended
}</span>

// Deps gets a list of dependencies for this Hugo build.
func (i Info) Deps() []*Dependency <span class="cov0" title="0">{
        return i.deps
}</span>

// NewInfo creates a new Hugo Info object.
func NewInfo(environment string, deps []*Dependency) Info <span class="cov8" title="1">{
        if environment == "" </span><span class="cov8" title="1">{
                environment = EnvironmentProduction
        }</span>
        <span class="cov8" title="1">return Info{
                CommitHash:  commitHash,
                BuildDate:   buildDate,
                Environment: environment,
                deps:        deps,
        }</span>
}

// GetExecEnviron creates and gets the common os/exec environment used in the
// external programs we interact with via os/exec, e.g. postcss.
func GetExecEnviron(workDir string, cfg config.Provider, fs afero.Fs) []string <span class="cov0" title="0">{
        var env []string
        nodepath := filepath.Join(workDir, "node_modules")
        if np := os.Getenv("NODE_PATH"); np != "" </span><span class="cov0" title="0">{
                nodepath = workDir + string(os.PathListSeparator) + np
        }</span>
        <span class="cov0" title="0">config.SetEnvVars(&amp;env, "NODE_PATH", nodepath)
        config.SetEnvVars(&amp;env, "PWD", workDir)
        config.SetEnvVars(&amp;env, "HUGO_ENVIRONMENT", cfg.GetString("environment"))
        config.SetEnvVars(&amp;env, "HUGO_ENV", cfg.GetString("environment"))

        if fs != nil </span><span class="cov0" title="0">{
                fis, err := afero.ReadDir(fs, files.FolderJSConfig)
                if err == nil </span><span class="cov0" title="0">{
                        for _, fi := range fis </span><span class="cov0" title="0">{
                                key := fmt.Sprintf("HUGO_FILE_%s", strings.ReplaceAll(strings.ToUpper(fi.Name()), ".", "_"))
                                value := fi.(hugofs.FileMetaInfo).Meta().Filename
                                config.SetEnvVars(&amp;env, key, value)
                        }</span>
                }
        }

        <span class="cov0" title="0">return env</span>
}

// GetDependencyList returns a sorted dependency list on the format package="version".
// It includes both Go dependencies and (a manually maintained) list of C(++) dependencies.
func GetDependencyList() []string <span class="cov0" title="0">{
        var deps []string

        formatDep := func(path, version string) string </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s=%q", path, version)
        }</span>

        <span class="cov0" title="0">if IsExtended </span><span class="cov0" title="0">{
                deps = append(
                        deps,
                        // TODO(bep) consider adding a DepsNonGo() method to these upstream projects.
                        formatDep("github.com/sass/libsass", "3.6.5"),
                        formatDep("github.com/webmproject/libwebp", "v1.2.0"),
                )
        }</span>

        <span class="cov0" title="0">bi, ok := debug.ReadBuildInfo()
        if !ok </span><span class="cov0" title="0">{
                return deps
        }</span>

        <span class="cov0" title="0">for _, dep := range bi.Deps </span><span class="cov0" title="0">{
                deps = append(deps, formatDep(dep.Path, dep.Version))
        }</span>

        <span class="cov0" title="0">sort.Strings(deps)

        return deps</span>
}

// IsRunningAsTest reports whether we are running as a test.
func IsRunningAsTest() bool <span class="cov0" title="0">{
        for _, arg := range os.Args </span><span class="cov0" title="0">{
                if strings.HasPrefix(arg, "-test") </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Dependency is a single dependency, which can be either a Hugo Module or a local theme.
type Dependency struct {
        // Returns the path to this module.
        // This will either be the module path, e.g. "github.com/gohugoio/myshortcodes",
        // or the path below your /theme folder, e.g. "mytheme".
        Path string

        // The module version.
        Version string

        // Whether this dependency is vendored.
        Vendor bool

        // Time version was created.
        Time time.Time

        // In the dependency tree, this is the first module that defines this module
        // as a dependency.
        Owner *Dependency

        // Replaced by this dependency.
        Replace *Dependency
}
</pre>
		
		<pre class="file" id="file41" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugo

import (
        "fmt"
        "io"
        "runtime"
        "strings"

        "github.com/gohugoio/hugo/compare"
        "github.com/spf13/cast"
)

// Version represents the Hugo build version.
type Version struct {
        // Major and minor version.
        Number float32

        // Increment this for bug releases
        PatchLevel int

        // HugoVersionSuffix is the suffix used in the Hugo version string.
        // It will be blank for release versions.
        Suffix string
}

var (
        _ compare.Eqer     = (*VersionString)(nil)
        _ compare.Comparer = (*VersionString)(nil)
)

func (v Version) String() string <span class="cov8" title="1">{
        return version(v.Number, v.PatchLevel, v.Suffix)
}</span>

// Version returns the Hugo version.
func (v Version) Version() VersionString <span class="cov8" title="1">{
        return VersionString(v.String())
}</span>

// VersionString represents a Hugo version string.
type VersionString string

func (h VersionString) String() string <span class="cov8" title="1">{
        return string(h)
}</span>

// Compare implements the compare.Comparer interface.
func (h VersionString) Compare(other interface{}) int <span class="cov0" title="0">{
        v := MustParseVersion(h.String())
        return compareVersionsWithSuffix(v.Number, v.PatchLevel, v.Suffix, other)
}</span>

// Eq implements the compare.Eqer interface.
func (h VersionString) Eq(other interface{}) bool <span class="cov8" title="1">{
        s, err := cast.ToStringE(other)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return s == h.String()</span>
}

var versionSuffixes = []string{"-test", "-DEV"}

// ParseVersion parses a version string.
func ParseVersion(s string) (Version, error) <span class="cov8" title="1">{
        var vv Version
        for _, suffix := range versionSuffixes </span><span class="cov8" title="1">{
                if strings.HasSuffix(s, suffix) </span><span class="cov8" title="1">{
                        vv.Suffix = suffix
                        s = strings.TrimSuffix(s, suffix)
                }</span>
        }

        <span class="cov8" title="1">v, p := parseVersion(s)

        vv.Number = v
        vv.PatchLevel = p

        return vv, nil</span>
}

// MustParseVersion parses a version string
// and panics if any error occurs.
func MustParseVersion(s string) Version <span class="cov8" title="1">{
        vv, err := ParseVersion(s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return vv</span>
}

// ReleaseVersion represents the release version.
func (v Version) ReleaseVersion() Version <span class="cov8" title="1">{
        v.Suffix = ""
        return v
}</span>

// Next returns the next Hugo release version.
func (v Version) Next() Version <span class="cov8" title="1">{
        return Version{Number: v.Number + 0.01}
}</span>

// Prev returns the previous Hugo release version.
func (v Version) Prev() Version <span class="cov0" title="0">{
        return Version{Number: v.Number - 0.01}
}</span>

// NextPatchLevel returns the next patch/bugfix Hugo version.
// This will be a patch increment on the previous Hugo version.
func (v Version) NextPatchLevel(level int) Version <span class="cov8" title="1">{
        return Version{Number: v.Number - 0.01, PatchLevel: level}
}</span>

// BuildVersionString creates a version string. This is what you see when
// running "hugo version".
func BuildVersionString() string <span class="cov0" title="0">{
        // program := "Hugo Static Site Generator"
        program := "hugo"

        version := "v" + CurrentVersion.String()
        if commitHash != "" </span><span class="cov0" title="0">{
                version += "-" + strings.ToUpper(commitHash)
        }</span>
        <span class="cov0" title="0">if IsExtended </span><span class="cov0" title="0">{
                version += "+extended"
        }</span>

        <span class="cov0" title="0">osArch := runtime.GOOS + "/" + runtime.GOARCH

        date := buildDate
        if date == "" </span><span class="cov0" title="0">{
                date = "unknown"
        }</span>

        <span class="cov0" title="0">versionString := fmt.Sprintf("%s %s %s BuildDate=%s",
                program, version, osArch, date)

        if vendorInfo != "" </span><span class="cov0" title="0">{
                versionString += " VendorInfo=" + vendorInfo
        }</span>

        <span class="cov0" title="0">return versionString</span>
}

func version(version float32, patchVersion int, suffix string) string <span class="cov8" title="1">{
        if patchVersion &gt; 0 || version &gt; 0.53 </span><span class="cov8" title="1">{
                return fmt.Sprintf("%.2f.%d%s", version, patchVersion, suffix)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%.2f%s", version, suffix)</span>
}

// CompareVersion compares the given version string or number against the
// running Hugo version.
// It returns -1 if the given version is less than, 0 if equal and 1 if greater than
// the running version.
func CompareVersion(version interface{}) int <span class="cov0" title="0">{
        return compareVersionsWithSuffix(CurrentVersion.Number, CurrentVersion.PatchLevel, CurrentVersion.Suffix, version)
}</span>

func compareVersions(inVersion float32, inPatchVersion int, in interface{}) int <span class="cov8" title="1">{
        return compareVersionsWithSuffix(inVersion, inPatchVersion, "", in)
}</span>

func compareVersionsWithSuffix(inVersion float32, inPatchVersion int, suffix string, in interface{}) int <span class="cov8" title="1">{
        var c int
        switch d := in.(type) </span>{
        case float64:<span class="cov8" title="1">
                c = compareFloatVersions(inVersion, float32(d))</span>
        case float32:<span class="cov8" title="1">
                c = compareFloatVersions(inVersion, d)</span>
        case int:<span class="cov8" title="1">
                c = compareFloatVersions(inVersion, float32(d))</span>
        case int32:<span class="cov8" title="1">
                c = compareFloatVersions(inVersion, float32(d))</span>
        case int64:<span class="cov8" title="1">
                c = compareFloatVersions(inVersion, float32(d))</span>
        default:<span class="cov8" title="1">
                s, err := cast.ToStringE(in)
                if err != nil </span><span class="cov0" title="0">{
                        return -1
                }</span>

                <span class="cov8" title="1">v, err := ParseVersion(s)
                if err != nil </span><span class="cov0" title="0">{
                        return -1
                }</span>

                <span class="cov8" title="1">if v.Number == inVersion &amp;&amp; v.PatchLevel == inPatchVersion </span><span class="cov8" title="1">{
                        return strings.Compare(suffix, v.Suffix)
                }</span>

                <span class="cov8" title="1">if v.Number &lt; inVersion || (v.Number == inVersion &amp;&amp; v.PatchLevel &lt; inPatchVersion) </span><span class="cov8" title="1">{
                        return -1
                }</span>

                <span class="cov8" title="1">return 1</span>
        }

        <span class="cov8" title="1">if c == 0 &amp;&amp; suffix != "" </span><span class="cov0" title="0">{
                return 1
        }</span>

        <span class="cov8" title="1">return c</span>
}

func parseVersion(s string) (float32, int) <span class="cov8" title="1">{
        var (
                v float32
                p int
        )

        if strings.Count(s, ".") == 2 </span><span class="cov8" title="1">{
                li := strings.LastIndex(s, ".")
                p = cast.ToInt(s[li+1:])
                s = s[:li]
        }</span>

        <span class="cov8" title="1">v = float32(cast.ToFloat64(s))

        return v, p</span>
}

func compareFloatVersions(version float32, v float32) int <span class="cov8" title="1">{
        if v == version </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if v &lt; version </span><span class="cov8" title="1">{
                return -1
        }</span>
        <span class="cov8" title="1">return 1</span>
}

func GoMinorVersion() int <span class="cov8" title="1">{
        return goMinorVersion(runtime.Version())
}</span>

func goMinorVersion(version string) int <span class="cov8" title="1">{
        if strings.HasPrefix(version, "devel") </span><span class="cov0" title="0">{
                return 9999 // magic
        }</span>
        <span class="cov8" title="1">var major, minor int
        var trailing string
        n, err := fmt.Sscanf(version, "go%d.%d%s", &amp;major, &amp;minor, &amp;trailing)
        if n == 2 &amp;&amp; err == io.EOF </span><span class="cov0" title="0">{
                // Means there were no trailing characters (i.e., not an alpha/beta)
                err = nil
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return minor</span>
}
</pre>
		
		<pre class="file" id="file42" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package loggers

import (
        "fmt"
        "strings"
)

// IgnorableLogger is a logger that ignores certain log statements.
type IgnorableLogger interface {
        Logger
        Errorsf(statementID, format string, v ...interface{})
        Apply(logger Logger) IgnorableLogger
}

type ignorableLogger struct {
        Logger
        statements map[string]bool
}

// NewIgnorableLogger wraps the given logger and ignores the log statement IDs given.
func NewIgnorableLogger(logger Logger, statements ...string) IgnorableLogger <span class="cov0" title="0">{
        statementsSet := make(map[string]bool)
        for _, s := range statements </span><span class="cov0" title="0">{
                statementsSet[strings.ToLower(s)] = true
        }</span>
        <span class="cov0" title="0">return ignorableLogger{
                Logger:     logger,
                statements: statementsSet,
        }</span>
}

// Errorsf logs statementID as an ERROR if not configured as ignoreable.
func (l ignorableLogger) Errorsf(statementID, format string, v ...interface{}) <span class="cov0" title="0">{
        if l.statements[statementID] </span><span class="cov0" title="0">{
                // Ignore.
                return
        }</span>
        <span class="cov0" title="0">ignoreMsg := fmt.Sprintf(`
If you feel that this should not be logged as an ERROR, you can ignore it by adding this to your site config:
ignoreErrors = [%q]`, statementID)

        format += ignoreMsg

        l.Errorf(format, v...)</span>
}

func (l ignorableLogger) Apply(logger Logger) IgnorableLogger <span class="cov0" title="0">{
        return ignorableLogger{
                Logger:     logger,
                statements: l.statements,
        }
}</span>
</pre>
		
		<pre class="file" id="file43" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package loggers

import (
        "bytes"
        "fmt"
        "io"
        "io/ioutil"
        "log"
        "os"
        "regexp"
        "runtime"
        "time"

        "github.com/gohugoio/hugo/common/terminal"

        jww "github.com/spf13/jwalterweatherman"
)

var (
        // Counts ERROR logs to the global jww logger.
        GlobalErrorCounter *jww.Counter
        PanicOnWarning     bool
)

func init() <span class="cov8" title="1">{
        GlobalErrorCounter = &amp;jww.Counter{}
        jww.SetLogListeners(jww.LogCounter(GlobalErrorCounter, jww.LevelError))
}</span>

func LoggerToWriterWithPrefix(logger *log.Logger, prefix string) io.Writer <span class="cov8" title="1">{
        return prefixWriter{
                logger: logger,
                prefix: prefix,
        }
}</span>

type prefixWriter struct {
        logger *log.Logger
        prefix string
}

func (w prefixWriter) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        w.logger.Printf("%s: %s", w.prefix, p)
        return len(p), nil
}</span>

type Logger interface {
        Printf(format string, v ...interface{})
        Println(v ...interface{})
        PrintTimerIfDelayed(start time.Time, name string)
        Debug() *log.Logger
        Debugf(format string, v ...interface{})
        Debugln(v ...interface{})
        Info() *log.Logger
        Infof(format string, v ...interface{})
        Infoln(v ...interface{})
        Warn() *log.Logger
        Warnf(format string, v ...interface{})
        Warnln(v ...interface{})
        Error() *log.Logger
        Errorf(format string, v ...interface{})
        Errorln(v ...interface{})
        Errors() string

        Out() io.Writer

        Reset()

        // Used in tests.
        LogCounters() *LogCounters
}

type LogCounters struct {
        ErrorCounter *jww.Counter
        WarnCounter  *jww.Counter
}

type logger struct {
        *jww.Notepad

        // The writer that represents stdout.
        // Will be ioutil.Discard when in quiet mode.
        out io.Writer

        logCounters *LogCounters

        // This is only set in server mode.
        errors *bytes.Buffer
}

func (l *logger) Printf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.FEEDBACK.Printf(format, v...)
}</span>

func (l *logger) Println(v ...interface{}) <span class="cov0" title="0">{
        l.FEEDBACK.Println(v...)
}</span>

func (l *logger) Debug() *log.Logger <span class="cov0" title="0">{
        return l.DEBUG
}</span>

func (l *logger) Debugf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.DEBUG.Printf(format, v...)
}</span>

func (l *logger) Debugln(v ...interface{}) <span class="cov0" title="0">{
        l.DEBUG.Println(v...)
}</span>

func (l *logger) Infof(format string, v ...interface{}) <span class="cov0" title="0">{
        l.INFO.Printf(format, v...)
}</span>

func (l *logger) Infoln(v ...interface{}) <span class="cov0" title="0">{
        l.INFO.Println(v...)
}</span>

func (l *logger) Info() *log.Logger <span class="cov0" title="0">{
        return l.INFO
}</span>

const panicOnWarningMessage = "Warning trapped. Remove the --panicOnWarning flag to continue."

func (l *logger) Warnf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.WARN.Printf(format, v...)
        if PanicOnWarning </span><span class="cov0" title="0">{
                panic(panicOnWarningMessage)</span>
        }
}

func (l *logger) Warnln(v ...interface{}) <span class="cov8" title="1">{
        l.WARN.Println(v...)
        if PanicOnWarning </span><span class="cov0" title="0">{
                panic(panicOnWarningMessage)</span>
        }
}

func (l *logger) Warn() *log.Logger <span class="cov0" title="0">{
        return l.WARN
}</span>

func (l *logger) Errorf(format string, v ...interface{}) <span class="cov0" title="0">{
        l.ERROR.Printf(format, v...)
}</span>

func (l *logger) Errorln(v ...interface{}) <span class="cov8" title="1">{
        l.ERROR.Println(v...)
}</span>

func (l *logger) Error() *log.Logger <span class="cov0" title="0">{
        return l.ERROR
}</span>

func (l *logger) LogCounters() *LogCounters <span class="cov8" title="1">{
        return l.logCounters
}</span>

func (l *logger) Out() io.Writer <span class="cov0" title="0">{
        return l.out
}</span>

// PrintTimerIfDelayed prints a time statement to the FEEDBACK logger
// if considerable time is spent.
func (l *logger) PrintTimerIfDelayed(start time.Time, name string) <span class="cov0" title="0">{
        elapsed := time.Since(start)
        milli := int(1000 * elapsed.Seconds())
        if milli &lt; 500 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">l.Printf("%s in %v ms", name, milli)</span>
}

func (l *logger) PrintTimer(start time.Time, name string) <span class="cov0" title="0">{
        elapsed := time.Since(start)
        milli := int(1000 * elapsed.Seconds())
        l.Printf("%s in %v ms", name, milli)
}</span>

func (l *logger) Errors() string <span class="cov0" title="0">{
        if l.errors == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return ansiColorRe.ReplaceAllString(l.errors.String(), "")</span>
}

// Reset resets the logger's internal state.
func (l *logger) Reset() <span class="cov0" title="0">{
        l.logCounters.ErrorCounter.Reset()
        if l.errors != nil </span><span class="cov0" title="0">{
                l.errors.Reset()
        }</span>
}

//  NewLogger creates a new Logger for the given thresholds
func NewLogger(stdoutThreshold, logThreshold jww.Threshold, outHandle, logHandle io.Writer, saveErrors bool) Logger <span class="cov0" title="0">{
        return newLogger(stdoutThreshold, logThreshold, outHandle, logHandle, saveErrors)
}</span>

// NewDebugLogger is a convenience function to create a debug logger.
func NewDebugLogger() Logger <span class="cov0" title="0">{
        return NewBasicLogger(jww.LevelDebug)
}</span>

// NewWarningLogger is a convenience function to create a warning logger.
func NewWarningLogger() Logger <span class="cov8" title="1">{
        return NewBasicLogger(jww.LevelWarn)
}</span>

// NewInfoLogger is a convenience function to create a info logger.
func NewInfoLogger() Logger <span class="cov0" title="0">{
        return NewBasicLogger(jww.LevelInfo)
}</span>

// NewErrorLogger is a convenience function to create an error logger.
func NewErrorLogger() Logger <span class="cov0" title="0">{
        return NewBasicLogger(jww.LevelError)
}</span>

// NewBasicLogger creates a new basic logger writing to Stdout.
func NewBasicLogger(t jww.Threshold) Logger <span class="cov8" title="1">{
        return newLogger(t, jww.LevelError, os.Stdout, ioutil.Discard, false)
}</span>

// NewBasicLoggerForWriter creates a new basic logger writing to w.
func NewBasicLoggerForWriter(t jww.Threshold, w io.Writer) Logger <span class="cov0" title="0">{
        return newLogger(t, jww.LevelError, w, ioutil.Discard, false)
}</span>

var (
        ansiColorRe = regexp.MustCompile("(?s)\\033\\[\\d*(;\\d*)*m")
        errorRe     = regexp.MustCompile("^(ERROR|FATAL|WARN)")
)

type ansiCleaner struct {
        w io.Writer
}

func (a ansiCleaner) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        return a.w.Write(ansiColorRe.ReplaceAll(p, []byte("")))
}</span>

type labelColorizer struct {
        w io.Writer
}

func (a labelColorizer) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        replaced := errorRe.ReplaceAllStringFunc(string(p), func(m string) string </span><span class="cov0" title="0">{
                switch m </span>{
                case "ERROR", "FATAL":<span class="cov0" title="0">
                        return terminal.Error(m)</span>
                case "WARN":<span class="cov0" title="0">
                        return terminal.Warning(m)</span>
                default:<span class="cov0" title="0">
                        return m</span>
                }
        })
        // io.MultiWriter will abort if we return a bigger write count than input
        // bytes, so we lie a little.
        <span class="cov0" title="0">_, err = a.w.Write([]byte(replaced))
        return len(p), err</span>
}

// InitGlobalLogger initializes the global logger, used in some rare cases.
func InitGlobalLogger(stdoutThreshold, logThreshold jww.Threshold, outHandle, logHandle io.Writer) <span class="cov0" title="0">{
        outHandle, logHandle = getLogWriters(outHandle, logHandle)

        jww.SetStdoutOutput(outHandle)
        jww.SetLogOutput(logHandle)
        jww.SetLogThreshold(logThreshold)
        jww.SetStdoutThreshold(stdoutThreshold)
}</span>

func getLogWriters(outHandle, logHandle io.Writer) (io.Writer, io.Writer) <span class="cov8" title="1">{
        isTerm := terminal.IsTerminal(os.Stdout)
        if logHandle != ioutil.Discard &amp;&amp; isTerm </span><span class="cov0" title="0">{
                // Remove any Ansi coloring from log output
                logHandle = ansiCleaner{w: logHandle}
        }</span>

        <span class="cov8" title="1">if isTerm </span><span class="cov0" title="0">{
                outHandle = labelColorizer{w: outHandle}
        }</span>

        <span class="cov8" title="1">return outHandle, logHandle</span>
}

type fatalLogWriter int

func (s fatalLogWriter) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        trace := make([]byte, 1500)
        runtime.Stack(trace, true)
        fmt.Printf("\n===========\n\n%s\n", trace)
        os.Exit(-1)

        return 0, nil
}</span>

var fatalLogListener = func(t jww.Threshold) io.Writer <span class="cov0" title="0">{
        if t != jww.LevelError </span><span class="cov0" title="0">{
                // Only interested in ERROR
                return nil
        }</span>

        <span class="cov0" title="0">return new(fatalLogWriter)</span>
}

func newLogger(stdoutThreshold, logThreshold jww.Threshold, outHandle, logHandle io.Writer, saveErrors bool) *logger <span class="cov8" title="1">{
        errorCounter := &amp;jww.Counter{}
        warnCounter := &amp;jww.Counter{}
        outHandle, logHandle = getLogWriters(outHandle, logHandle)

        listeners := []jww.LogListener{jww.LogCounter(errorCounter, jww.LevelError), jww.LogCounter(warnCounter, jww.LevelWarn)}
        var errorBuff *bytes.Buffer
        if saveErrors </span><span class="cov0" title="0">{
                errorBuff = new(bytes.Buffer)
                errorCapture := func(t jww.Threshold) io.Writer </span><span class="cov0" title="0">{
                        if t != jww.LevelError </span><span class="cov0" title="0">{
                                // Only interested in ERROR
                                return nil
                        }</span>
                        <span class="cov0" title="0">return errorBuff</span>
                }

                <span class="cov0" title="0">listeners = append(listeners, errorCapture)</span>
        }

        <span class="cov8" title="1">return &amp;logger{
                Notepad: jww.NewNotepad(stdoutThreshold, logThreshold, outHandle, logHandle, "", log.Ldate|log.Ltime, listeners...),
                out:     outHandle,
                logCounters: &amp;LogCounters{
                        ErrorCounter: errorCounter,
                        WarnCounter:  warnCounter,
                },
                errors: errorBuff,
        }</span>
}
</pre>
		
		<pre class="file" id="file44" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package maps

import (
        "fmt"
        "strings"

        "github.com/gohugoio/hugo/common/types"

        "github.com/gobwas/glob"
        "github.com/spf13/cast"
)

// ToStringMapE converts in to map[string]interface{}.
func ToStringMapE(in interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        switch vv := in.(type) </span>{
        case Params:<span class="cov0" title="0">
                return vv, nil</span>
        case map[string]string:<span class="cov0" title="0">
                var m = map[string]interface{}{}
                for k, v := range vv </span><span class="cov0" title="0">{
                        m[k] = v
                }</span>
                <span class="cov0" title="0">return m, nil</span>

        default:<span class="cov8" title="1">
                return cast.ToStringMapE(in)</span>
        }
}

// ToParamsAndPrepare converts in to Params and prepares it for use.
// If in is nil, an empty map is returned.
// See PrepareParams.
func ToParamsAndPrepare(in interface{}) (Params, bool) <span class="cov8" title="1">{
        if types.IsNil(in) </span><span class="cov8" title="1">{
                return Params{}, true
        }</span>
        <span class="cov8" title="1">m, err := ToStringMapE(in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov8" title="1">PrepareParams(m)
        return m, true</span>
}

// MustToParamsAndPrepare calls ToParamsAndPrepare and panics if it fails.
func MustToParamsAndPrepare(in interface{}) Params <span class="cov0" title="0">{
        if p, ok := ToParamsAndPrepare(in); ok </span><span class="cov0" title="0">{
                return p
        }</span> else<span class="cov0" title="0"> {
                panic(fmt.Sprintf("cannot convert %T to maps.Params", in))</span>
        }
}

// ToStringMap converts in to map[string]interface{}.
func ToStringMap(in interface{}) map[string]interface{} <span class="cov0" title="0">{
        m, _ := ToStringMapE(in)
        return m
}</span>

// ToStringMapStringE converts in to map[string]string.
func ToStringMapStringE(in interface{}) (map[string]string, error) <span class="cov0" title="0">{
        m, err := ToStringMapE(in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return cast.ToStringMapStringE(m)</span>
}

// ToStringMapString converts in to map[string]string.
func ToStringMapString(in interface{}) map[string]string <span class="cov0" title="0">{
        m, _ := ToStringMapStringE(in)
        return m
}</span>

// ToStringMapBool converts in to bool.
func ToStringMapBool(in interface{}) map[string]bool <span class="cov0" title="0">{
        m, _ := ToStringMapE(in)
        return cast.ToStringMapBool(m)
}</span>

// ToSliceStringMap converts in to []map[string]interface{}.
func ToSliceStringMap(in interface{}) ([]map[string]interface{}, error) <span class="cov8" title="1">{
        switch v := in.(type) </span>{
        case []map[string]interface{}:<span class="cov8" title="1">
                return v, nil</span>
        case []interface{}:<span class="cov8" title="1">
                var s []map[string]interface{}
                for _, entry := range v </span><span class="cov8" title="1">{
                        if vv, ok := entry.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                s = append(s, vv)
                        }</span>
                }
                <span class="cov8" title="1">return s, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("unable to cast %#v of type %T to []map[string]interface{}", in, in)</span>
        }
}

type keyRename struct {
        pattern glob.Glob
        newKey  string
}

// KeyRenamer supports renaming of keys in a map.
type KeyRenamer struct {
        renames []keyRename
}

// NewKeyRenamer creates a new KeyRenamer given a list of pattern and new key
// value pairs.
func NewKeyRenamer(patternKeys ...string) (KeyRenamer, error) <span class="cov8" title="1">{
        var renames []keyRename
        for i := 0; i &lt; len(patternKeys); i += 2 </span><span class="cov8" title="1">{
                g, err := glob.Compile(strings.ToLower(patternKeys[i]), '/')
                if err != nil </span><span class="cov0" title="0">{
                        return KeyRenamer{}, err
                }</span>
                <span class="cov8" title="1">renames = append(renames, keyRename{pattern: g, newKey: patternKeys[i+1]})</span>
        }

        <span class="cov8" title="1">return KeyRenamer{renames: renames}, nil</span>
}

func (r KeyRenamer) getNewKey(keyPath string) string <span class="cov8" title="1">{
        for _, matcher := range r.renames </span><span class="cov8" title="1">{
                if matcher.pattern.Match(keyPath) </span><span class="cov8" title="1">{
                        return matcher.newKey
                }</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// Rename renames the keys in the given map according
// to the patterns in the current KeyRenamer.
func (r KeyRenamer) Rename(m map[string]interface{}) <span class="cov8" title="1">{
        r.renamePath("", m)
}</span>

func (KeyRenamer) keyPath(k1, k2 string) string <span class="cov8" title="1">{
        k1, k2 = strings.ToLower(k1), strings.ToLower(k2)
        if k1 == "" </span><span class="cov8" title="1">{
                return k2
        }</span>
        <span class="cov8" title="1">return k1 + "/" + k2</span>
}

func (r KeyRenamer) renamePath(parentKeyPath string, m map[string]interface{}) <span class="cov8" title="1">{
        for key, val := range m </span><span class="cov8" title="1">{
                keyPath := r.keyPath(parentKeyPath, key)
                switch val.(type) </span>{
                case map[interface{}]interface{}:<span class="cov0" title="0">
                        val = cast.ToStringMap(val)
                        r.renamePath(keyPath, val.(map[string]interface{}))</span>
                case map[string]interface{}:<span class="cov8" title="1">
                        r.renamePath(keyPath, val.(map[string]interface{}))</span>
                }

                <span class="cov8" title="1">newKey := r.getNewKey(keyPath)

                if newKey != "" </span><span class="cov8" title="1">{
                        delete(m, key)
                        m[newKey] = val
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file45" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package maps

import (
        "fmt"
        "strings"

        "github.com/spf13/cast"
)

// Params is a map where all keys are lower case.
type Params map[string]interface{}

// Get does a lower case and nested search in this map.
// It will return nil if none found.
func (p Params) Get(indices ...string) interface{} <span class="cov8" title="1">{
        v, _, _ := getNested(p, indices)
        return v
}</span>

// Set overwrites values in p with values in pp for common or new keys.
// This is done recursively.
func (p Params) Set(pp Params) <span class="cov8" title="1">{
        for k, v := range pp </span><span class="cov8" title="1">{
                vv, found := p[k]
                if !found </span><span class="cov8" title="1">{
                        p[k] = v
                }</span> else<span class="cov8" title="1"> {
                        switch vvv := vv.(type) </span>{
                        case Params:<span class="cov8" title="1">
                                if pv, ok := v.(Params); ok </span><span class="cov8" title="1">{
                                        vvv.Set(pv)
                                }</span> else<span class="cov0" title="0"> {
                                        p[k] = v
                                }</span>
                        default:<span class="cov8" title="1">
                                p[k] = v</span>
                        }
                }
        }
}

// IsZero returns true if p is considered empty.
func (p Params) IsZero() bool <span class="cov8" title="1">{
        if p == nil || len(p) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if len(p) &gt; 1 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for k, _ := range p </span><span class="cov8" title="1">{
                return k == mergeStrategyKey
        }</span>

        <span class="cov0" title="0">return false</span>

}

// Merge transfers values from pp to p for new keys.
// This is done recursively.
func (p Params) Merge(pp Params) <span class="cov8" title="1">{
        p.merge("", pp)
}</span>

// MergeRoot transfers values from pp to p for new keys where p is the
// root of the tree.
// This is done recursively.
func (p Params) MergeRoot(pp Params) <span class="cov0" title="0">{
        ms, _ := p.GetMergeStrategy()
        p.merge(ms, pp)
}</span>

func (p Params) merge(ps ParamsMergeStrategy, pp Params) <span class="cov8" title="1">{
        ns, found := p.GetMergeStrategy()

        var ms = ns
        if !found &amp;&amp; ps != "" </span><span class="cov8" title="1">{
                ms = ps
        }</span>

        <span class="cov8" title="1">noUpdate := ms == ParamsMergeStrategyNone
        noUpdate = noUpdate || (ps != "" &amp;&amp; ps == ParamsMergeStrategyShallow)

        for k, v := range pp </span><span class="cov8" title="1">{

                if k == mergeStrategyKey </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">vv, found := p[k]

                if found </span><span class="cov8" title="1">{
                        // Key matches, if both sides are Params, we try to merge.
                        if vvv, ok := vv.(Params); ok </span><span class="cov8" title="1">{
                                if pv, ok := v.(Params); ok </span><span class="cov8" title="1">{
                                        vvv.merge(ms, pv)
                                }</span>
                        }
                } else<span class="cov8" title="1"> if !noUpdate </span><span class="cov8" title="1">{
                        p[k] = v
                }</span>

        }
}

func (p Params) GetMergeStrategy() (ParamsMergeStrategy, bool) <span class="cov8" title="1">{
        if v, found := p[mergeStrategyKey]; found </span><span class="cov8" title="1">{
                if s, ok := v.(ParamsMergeStrategy); ok </span><span class="cov8" title="1">{
                        return s, true
                }</span>
        }
        <span class="cov8" title="1">return ParamsMergeStrategyShallow, false</span>
}

func (p Params) DeleteMergeStrategy() bool <span class="cov8" title="1">{
        if _, found := p[mergeStrategyKey]; found </span><span class="cov8" title="1">{
                delete(p, mergeStrategyKey)
                return true
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (p Params) SetDefaultMergeStrategy(s ParamsMergeStrategy) <span class="cov8" title="1">{
        switch s </span>{
        case ParamsMergeStrategyDeep, ParamsMergeStrategyNone, ParamsMergeStrategyShallow:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("invalid merge strategy %q", s))</span>
        }
        <span class="cov8" title="1">p[mergeStrategyKey] = s</span>
}

func getNested(m map[string]interface{}, indices []string) (interface{}, string, map[string]interface{}) <span class="cov8" title="1">{
        if len(indices) == 0 </span><span class="cov0" title="0">{
                return nil, "", nil
        }</span>

        <span class="cov8" title="1">first := indices[0]
        v, found := m[strings.ToLower(cast.ToString(first))]
        if !found </span><span class="cov8" title="1">{
                if len(indices) == 1 </span><span class="cov8" title="1">{
                        return nil, first, m
                }</span>
                <span class="cov0" title="0">return nil, "", nil</span>

        }

        <span class="cov8" title="1">if len(indices) == 1 </span><span class="cov8" title="1">{
                return v, first, m
        }</span>

        <span class="cov8" title="1">switch m2 := v.(type) </span>{
        case Params:<span class="cov0" title="0">
                return getNested(m2, indices[1:])</span>
        case map[string]interface{}:<span class="cov8" title="1">
                return getNested(m2, indices[1:])</span>
        default:<span class="cov8" title="1">
                return nil, "", nil</span>
        }
}

// GetNestedParam gets the first match of the keyStr in the candidates given.
// It will first try the exact match and then try to find it as a nested map value,
// using the given separator, e.g. "mymap.name".
// It assumes that all the maps given have lower cased keys.
func GetNestedParam(keyStr, separator string, candidates ...Params) (interface{}, error) <span class="cov8" title="1">{
        keyStr = strings.ToLower(keyStr)

        // Try exact match first
        for _, m := range candidates </span><span class="cov8" title="1">{
                if v, ok := m[keyStr]; ok </span><span class="cov8" title="1">{
                        return v, nil
                }</span>
        }

        <span class="cov8" title="1">keySegments := strings.Split(keyStr, separator)
        for _, m := range candidates </span><span class="cov8" title="1">{
                if v := m.Get(keySegments...); v != nil </span><span class="cov8" title="1">{
                        return v, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, nil</span>
}

func GetNestedParamFn(keyStr, separator string, lookupFn func(key string) interface{}) (interface{}, string, map[string]interface{}, error) <span class="cov8" title="1">{
        keySegments := strings.Split(keyStr, separator)
        if len(keySegments) == 0 </span><span class="cov0" title="0">{
                return nil, "", nil, nil
        }</span>

        <span class="cov8" title="1">first := lookupFn(keySegments[0])
        if first == nil </span><span class="cov0" title="0">{
                return nil, "", nil, nil
        }</span>

        <span class="cov8" title="1">if len(keySegments) == 1 </span><span class="cov0" title="0">{
                return first, keySegments[0], nil, nil
        }</span>

        <span class="cov8" title="1">switch m := first.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                v, key, owner := getNested(m, keySegments[1:])
                return v, key, owner, nil</span>
        case Params:<span class="cov0" title="0">
                v, key, owner := getNested(m, keySegments[1:])
                return v, key, owner, nil</span>
        }

        <span class="cov0" title="0">return nil, "", nil, nil</span>
}

// ParamsMergeStrategy tells what strategy to use in Params.Merge.
type ParamsMergeStrategy string

const (
        // Do not merge.
        ParamsMergeStrategyNone ParamsMergeStrategy = "none"
        // Only add new keys.
        ParamsMergeStrategyShallow ParamsMergeStrategy = "shallow"
        // Add new keys, merge existing.
        ParamsMergeStrategyDeep ParamsMergeStrategy = "deep"

        mergeStrategyKey = "_merge"
)

func toMergeStrategy(v interface{}) ParamsMergeStrategy <span class="cov0" title="0">{
        s := ParamsMergeStrategy(cast.ToString(v))
        switch s </span>{
        case ParamsMergeStrategyDeep, ParamsMergeStrategyNone, ParamsMergeStrategyShallow:<span class="cov0" title="0">
                return s</span>
        default:<span class="cov0" title="0">
                return ParamsMergeStrategyDeep</span>
        }
}

// PrepareParams
// * makes all the keys in the given map lower cased and will do so
// * This will modify the map given.
// * Any nested map[interface{}]interface{}, map[string]interface{},map[string]string  will be converted to Params.
// * Any _merge value will be converted to proper type and value.
func PrepareParams(m Params) <span class="cov8" title="1">{
        for k, v := range m </span><span class="cov8" title="1">{
                var retyped bool
                lKey := strings.ToLower(k)
                if lKey == mergeStrategyKey </span><span class="cov0" title="0">{
                        v = toMergeStrategy(v)
                        retyped = true
                }</span> else<span class="cov8" title="1"> {
                        switch vv := v.(type) </span>{
                        case map[interface{}]interface{}:<span class="cov8" title="1">
                                var p Params = cast.ToStringMap(v)
                                v = p
                                PrepareParams(p)
                                retyped = true</span>
                        case map[string]interface{}:<span class="cov8" title="1">
                                var p Params = v.(map[string]interface{})
                                v = p
                                PrepareParams(p)
                                retyped = true</span>
                        case map[string]string:<span class="cov8" title="1">
                                p := make(Params)
                                for k, v := range vv </span><span class="cov8" title="1">{
                                        p[k] = v
                                }</span>
                                <span class="cov8" title="1">v = p
                                PrepareParams(p)
                                retyped = true</span>
                        }
                }

                <span class="cov8" title="1">if retyped || k != lKey </span><span class="cov8" title="1">{
                        delete(m, k)
                        m[lKey] = v
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file46" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package maps

import (
        "reflect"
        "sort"
        "sync"

        "github.com/gohugoio/hugo/common/collections"
        "github.com/gohugoio/hugo/common/math"
)

// Scratch is a writable context used for stateful operations in Page/Node rendering.
type Scratch struct {
        values map[string]interface{}
        mu     sync.RWMutex
}

// Scratcher provides a scratching service.
type Scratcher interface {
        Scratch() *Scratch
}

type scratcher struct {
        s *Scratch
}

func (s scratcher) Scratch() *Scratch <span class="cov0" title="0">{
        return s.s
}</span>

// NewScratcher creates a new Scratcher.
func NewScratcher() Scratcher <span class="cov0" title="0">{
        return scratcher{s: NewScratch()}
}</span>

// Add will, for single values, add (using the + operator) the addend to the existing addend (if found).
// Supports numeric values and strings.
//
// If the first add for a key is an array or slice, then the next value(s) will be appended.
func (c *Scratch) Add(key string, newAddend interface{}) (string, error) <span class="cov8" title="1">{
        var newVal interface{}
        c.mu.RLock()
        existingAddend, found := c.values[key]
        c.mu.RUnlock()
        if found </span><span class="cov8" title="1">{
                var err error

                addendV := reflect.TypeOf(existingAddend)

                if addendV.Kind() == reflect.Slice || addendV.Kind() == reflect.Array </span><span class="cov8" title="1">{
                        newVal, err = collections.Append(existingAddend, newAddend)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", err
                        }</span>
                } else<span class="cov8" title="1"> {
                        newVal, err = math.DoArithmetic(existingAddend, newAddend, '+')
                        if err != nil </span><span class="cov8" title="1">{
                                return "", err
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                newVal = newAddend
        }</span>
        <span class="cov8" title="1">c.mu.Lock()
        c.values[key] = newVal
        c.mu.Unlock()
        return "", nil</span> // have to return something to make it work with the Go templates
}

// Set stores a value with the given key in the Node context.
// This value can later be retrieved with Get.
func (c *Scratch) Set(key string, value interface{}) string <span class="cov8" title="1">{
        c.mu.Lock()
        c.values[key] = value
        c.mu.Unlock()
        return ""
}</span>

// Delete deletes the given key.
func (c *Scratch) Delete(key string) string <span class="cov8" title="1">{
        c.mu.Lock()
        delete(c.values, key)
        c.mu.Unlock()
        return ""
}</span>

// Get returns a value previously set by Add or Set.
func (c *Scratch) Get(key string) interface{} <span class="cov8" title="1">{
        c.mu.RLock()
        val := c.values[key]
        c.mu.RUnlock()

        return val
}</span>

// Values returns the raw backing map. Note that you should just use
// this method on the locally scoped Scratch instances you obtain via newScratch, not
// .Page.Scratch etc., as that will lead to concurrency issues.
func (c *Scratch) Values() map[string]interface{} <span class="cov8" title="1">{
        c.mu.RLock()
        defer c.mu.RUnlock()
        return c.values
}</span>

// SetInMap stores a value to a map with the given key in the Node context.
// This map can later be retrieved with GetSortedMapValues.
func (c *Scratch) SetInMap(key string, mapKey string, value interface{}) string <span class="cov8" title="1">{
        c.mu.Lock()
        _, found := c.values[key]
        if !found </span><span class="cov8" title="1">{
                c.values[key] = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">c.values[key].(map[string]interface{})[mapKey] = value
        c.mu.Unlock()
        return ""</span>
}

// DeleteInMap deletes a value to a map with the given key in the Node context.
func (c *Scratch) DeleteInMap(key string, mapKey string) string <span class="cov8" title="1">{
        c.mu.Lock()
        _, found := c.values[key]
        if found </span><span class="cov8" title="1">{
                delete(c.values[key].(map[string]interface{}), mapKey)
        }</span>
        <span class="cov8" title="1">c.mu.Unlock()
        return ""</span>
}

// GetSortedMapValues returns a sorted map previously filled with SetInMap.
func (c *Scratch) GetSortedMapValues(key string) interface{} <span class="cov8" title="1">{
        c.mu.RLock()

        if c.values[key] == nil </span><span class="cov8" title="1">{
                c.mu.RUnlock()
                return nil
        }</span>

        <span class="cov8" title="1">unsortedMap := c.values[key].(map[string]interface{})
        c.mu.RUnlock()
        var keys []string
        for mapKey := range unsortedMap </span><span class="cov8" title="1">{
                keys = append(keys, mapKey)
        }</span>

        <span class="cov8" title="1">sort.Strings(keys)

        sortedArray := make([]interface{}, len(unsortedMap))
        for i, mapKey := range keys </span><span class="cov8" title="1">{
                sortedArray[i] = unsortedMap[mapKey]
        }</span>

        <span class="cov8" title="1">return sortedArray</span>
}

// NewScratch returns a new instance of Scratch.
func NewScratch() *Scratch <span class="cov8" title="1">{
        return &amp;Scratch{values: make(map[string]interface{})}
}</span>
</pre>
		
		<pre class="file" id="file47" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package math

import (
        "errors"
        "reflect"
)

// DoArithmetic performs arithmetic operations (+,-,*,/) using reflection to
// determine the type of the two terms.
func DoArithmetic(a, b interface{}, op rune) (interface{}, error) <span class="cov8" title="1">{
        av := reflect.ValueOf(a)
        bv := reflect.ValueOf(b)
        var ai, bi int64
        var af, bf float64
        var au, bu uint64
        switch av.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                ai = av.Int()
                switch bv.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                        bi = bv.Int()</span>
                case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                        af = float64(ai) // may overflow
                        ai = 0
                        bf = bv.Float()</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                        bu = bv.Uint()
                        if ai &gt;= 0 </span><span class="cov8" title="1">{
                                au = uint64(ai)
                                ai = 0
                        }</span> else<span class="cov8" title="1"> {
                                bi = int64(bu) // may overflow
                                bu = 0
                        }</span>
                default:<span class="cov8" title="1">
                        return nil, errors.New("can't apply the operator to the values")</span>
                }
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                af = av.Float()
                switch bv.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                        bf = float64(bv.Int())</span> // may overflow
                case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                        bf = bv.Float()</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                        bf = float64(bv.Uint())</span> // may overflow
                default:<span class="cov8" title="1">
                        return nil, errors.New("can't apply the operator to the values")</span>
                }
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                au = av.Uint()
                switch bv.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                        bi = bv.Int()
                        if bi &gt;= 0 </span><span class="cov8" title="1">{
                                bu = uint64(bi)
                                bi = 0
                        }</span> else<span class="cov8" title="1"> {
                                ai = int64(au) // may overflow
                                au = 0
                        }</span>
                case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                        af = float64(au) // may overflow
                        au = 0
                        bf = bv.Float()</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                        bu = bv.Uint()</span>
                default:<span class="cov8" title="1">
                        return nil, errors.New("can't apply the operator to the values")</span>
                }
        case reflect.String:<span class="cov8" title="1">
                as := av.String()
                if bv.Kind() == reflect.String &amp;&amp; op == '+' </span><span class="cov8" title="1">{
                        bs := bv.String()
                        return as + bs, nil
                }</span>
                <span class="cov8" title="1">return nil, errors.New("can't apply the operator to the values")</span>
        default:<span class="cov0" title="0">
                return nil, errors.New("can't apply the operator to the values")</span>
        }

        <span class="cov8" title="1">switch op </span>{
        case '+':<span class="cov8" title="1">
                if ai != 0 || bi != 0 </span><span class="cov8" title="1">{
                        return ai + bi, nil
                }</span> else<span class="cov8" title="1"> if af != 0 || bf != 0 </span><span class="cov8" title="1">{
                        return af + bf, nil
                }</span> else<span class="cov8" title="1"> if au != 0 || bu != 0 </span><span class="cov8" title="1">{
                        return au + bu, nil
                }</span>
                <span class="cov8" title="1">return 0, nil</span>
        case '-':<span class="cov8" title="1">
                if ai != 0 || bi != 0 </span><span class="cov8" title="1">{
                        return ai - bi, nil
                }</span> else<span class="cov8" title="1"> if af != 0 || bf != 0 </span><span class="cov8" title="1">{
                        return af - bf, nil
                }</span> else<span class="cov8" title="1"> if au != 0 || bu != 0 </span><span class="cov8" title="1">{
                        return au - bu, nil
                }</span>
                <span class="cov8" title="1">return 0, nil</span>
        case '*':<span class="cov8" title="1">
                if ai != 0 || bi != 0 </span><span class="cov8" title="1">{
                        return ai * bi, nil
                }</span> else<span class="cov8" title="1"> if af != 0 || bf != 0 </span><span class="cov8" title="1">{
                        return af * bf, nil
                }</span> else<span class="cov8" title="1"> if au != 0 || bu != 0 </span><span class="cov8" title="1">{
                        return au * bu, nil
                }</span>
                <span class="cov8" title="1">return 0, nil</span>
        case '/':<span class="cov8" title="1">
                if bi != 0 </span><span class="cov8" title="1">{
                        return ai / bi, nil
                }</span> else<span class="cov8" title="1"> if bf != 0 </span><span class="cov8" title="1">{
                        return af / bf, nil
                }</span> else<span class="cov8" title="1"> if bu != 0 </span><span class="cov8" title="1">{
                        return au / bu, nil
                }</span>
                <span class="cov8" title="1">return nil, errors.New("can't divide the value by 0")</span>
        default:<span class="cov8" title="1">
                return nil, errors.New("there is no such an operation")</span>
        }
}
</pre>
		
		<pre class="file" id="file48" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package para implements parallel execution helpers.
package para

import (
        "context"

        "golang.org/x/sync/errgroup"
)

// Workers configures a task executor with the most number of tasks to be executed in parallel.
type Workers struct {
        sem chan struct{}
}

// Runner wraps the lifecycle methods of a new task set.
//
// Run wil block until a worker is available or the context is cancelled,
// and then run the given func in a new goroutine.
// Wait will wait for all the running goroutines to finish.
type Runner interface {
        Run(func() error)
        Wait() error
}

type errGroupRunner struct {
        *errgroup.Group
        w   *Workers
        ctx context.Context
}

func (g *errGroupRunner) Run(fn func() error) <span class="cov0" title="0">{
        select </span>{
        case g.w.sem &lt;- struct{}{}:<span class="cov0" title="0"></span>
        case &lt;-g.ctx.Done():<span class="cov0" title="0">
                return</span>
        }

        <span class="cov0" title="0">g.Go(func() error </span><span class="cov0" title="0">{
                err := fn()
                &lt;-g.w.sem
                return err
        }</span>)
}

// New creates a new Workers with the given number of workers.
func New(numWorkers int) *Workers <span class="cov0" title="0">{
        return &amp;Workers{
                sem: make(chan struct{}, numWorkers),
        }
}</span>

// Start starts a new Runner.
func (w *Workers) Start(ctx context.Context) (Runner, context.Context) <span class="cov0" title="0">{
        g, ctx := errgroup.WithContext(ctx)
        return &amp;errGroupRunner{
                Group: g,
                ctx:   ctx,
                w:     w,
        }, ctx
}</span>
</pre>
		
		<pre class="file" id="file49" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package paths

import (
        "errors"
        "fmt"
        "path"
        "path/filepath"
        "regexp"
        "strings"
)

// FilePathSeparator as defined by os.Separator.
const FilePathSeparator = string(filepath.Separator)

// filepathPathBridge is a bridge for common functionality in filepath vs path
type filepathPathBridge interface {
        Base(in string) string
        Clean(in string) string
        Dir(in string) string
        Ext(in string) string
        Join(elem ...string) string
        Separator() string
}

type filepathBridge struct{}

func (filepathBridge) Base(in string) string <span class="cov8" title="1">{
        return filepath.Base(in)
}</span>

func (filepathBridge) Clean(in string) string <span class="cov0" title="0">{
        return filepath.Clean(in)
}</span>

func (filepathBridge) Dir(in string) string <span class="cov0" title="0">{
        return filepath.Dir(in)
}</span>

func (filepathBridge) Ext(in string) string <span class="cov8" title="1">{
        return filepath.Ext(in)
}</span>

func (filepathBridge) Join(elem ...string) string <span class="cov0" title="0">{
        return filepath.Join(elem...)
}</span>

func (filepathBridge) Separator() string <span class="cov8" title="1">{
        return FilePathSeparator
}</span>

var fpb filepathBridge

// MakeTitle converts the path given to a suitable title, trimming whitespace
// and replacing hyphens with whitespace.
func MakeTitle(inpath string) string <span class="cov8" title="1">{
        return strings.Replace(strings.TrimSpace(inpath), "-", " ", -1)
}</span>

// ReplaceExtension takes a path and an extension, strips the old extension
// and returns the path with the new extension.
func ReplaceExtension(path string, newExt string) string <span class="cov8" title="1">{
        f, _ := fileAndExt(path, fpb)
        return f + "." + newExt
}</span>

func makePathRelative(inPath string, possibleDirectories ...string) (string, error) <span class="cov8" title="1">{
        for _, currentPath := range possibleDirectories </span><span class="cov8" title="1">{
                if strings.HasPrefix(inPath, currentPath) </span><span class="cov8" title="1">{
                        return strings.TrimPrefix(inPath, currentPath), nil
                }</span>
        }
        <span class="cov8" title="1">return inPath, errors.New("can't extract relative path, unknown prefix")</span>
}

// Should be good enough for Hugo.
var isFileRe = regexp.MustCompile(`.*\..{1,6}$`)

// GetDottedRelativePath expects a relative path starting after the content directory.
// It returns a relative path with dots ("..") navigating up the path structure.
func GetDottedRelativePath(inPath string) string <span class="cov8" title="1">{
        inPath = filepath.Clean(filepath.FromSlash(inPath))

        if inPath == "." </span><span class="cov8" title="1">{
                return "./"
        }</span>

        <span class="cov8" title="1">if !isFileRe.MatchString(inPath) &amp;&amp; !strings.HasSuffix(inPath, FilePathSeparator) </span><span class="cov8" title="1">{
                inPath += FilePathSeparator
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(inPath, FilePathSeparator) </span><span class="cov8" title="1">{
                inPath = FilePathSeparator + inPath
        }</span>

        <span class="cov8" title="1">dir, _ := filepath.Split(inPath)

        sectionCount := strings.Count(dir, FilePathSeparator)

        if sectionCount == 0 || dir == FilePathSeparator </span><span class="cov8" title="1">{
                return "./"
        }</span>

        <span class="cov8" title="1">var dottedPath string

        for i := 1; i &lt; sectionCount; i++ </span><span class="cov8" title="1">{
                dottedPath += "../"
        }</span>

        <span class="cov8" title="1">return dottedPath</span>
}

// ExtNoDelimiter takes a path and returns the extension, excluding the delimiter, i.e. "md".
func ExtNoDelimiter(in string) string <span class="cov8" title="1">{
        return strings.TrimPrefix(Ext(in), ".")
}</span>

// Ext takes a path and returns the extension, including the delimiter, i.e. ".md".
func Ext(in string) string <span class="cov8" title="1">{
        _, ext := fileAndExt(in, fpb)
        return ext
}</span>

// PathAndExt is the same as FileAndExt, but it uses the path package.
func PathAndExt(in string) (string, string) <span class="cov0" title="0">{
        return fileAndExt(in, pb)
}</span>

// FileAndExt takes a path and returns the file and extension separated,
// the extension including the delimiter, i.e. ".md".
func FileAndExt(in string) (string, string) <span class="cov0" title="0">{
        return fileAndExt(in, fpb)
}</span>

// FileAndExtNoDelimiter takes a path and returns the file and extension separated,
// the extension excluding the delimiter, e.g "md".
func FileAndExtNoDelimiter(in string) (string, string) <span class="cov0" title="0">{
        file, ext := fileAndExt(in, fpb)
        return file, strings.TrimPrefix(ext, ".")
}</span>

// Filename takes a file path, strips out the extension,
// and returns the name of the file.
func Filename(in string) (name string) <span class="cov8" title="1">{
        name, _ = fileAndExt(in, fpb)
        return
}</span>

// PathNoExt takes a path, strips out the extension,
// and returns the name of the file.
func PathNoExt(in string) string <span class="cov0" title="0">{
        return strings.TrimSuffix(in, path.Ext(in))
}</span>

// FileAndExt returns the filename and any extension of a file path as
// two separate strings.
//
// If the path, in, contains a directory name ending in a slash,
// then both name and ext will be empty strings.
//
// If the path, in, is either the current directory, the parent
// directory or the root directory, or an empty string,
// then both name and ext will be empty strings.
//
// If the path, in, represents the path of a file without an extension,
// then name will be the name of the file and ext will be an empty string.
//
// If the path, in, represents a filename with an extension,
// then name will be the filename minus any extension - including the dot
// and ext will contain the extension - minus the dot.
func fileAndExt(in string, b filepathPathBridge) (name string, ext string) <span class="cov8" title="1">{
        ext = b.Ext(in)
        base := b.Base(in)

        return extractFilename(in, ext, base, b.Separator()), ext
}</span>

func extractFilename(in, ext, base, pathSeparator string) (name string) <span class="cov8" title="1">{
        // No file name cases. These are defined as:
        // 1. any "in" path that ends in a pathSeparator
        // 2. any "base" consisting of just an pathSeparator
        // 3. any "base" consisting of just an empty string
        // 4. any "base" consisting of just the current directory i.e. "."
        // 5. any "base" consisting of just the parent directory i.e. ".."
        if (strings.LastIndex(in, pathSeparator) == len(in)-1) || base == "" || base == "." || base == ".." || base == pathSeparator </span><span class="cov8" title="1">{
                name = "" // there is NO filename
        }</span> else<span class="cov8" title="1"> if ext != "" </span><span class="cov8" title="1">{ // there was an Extension
                // return the filename minus the extension (and the ".")
                name = base[:strings.LastIndex(base, ".")]
        }</span> else<span class="cov8" title="1"> {
                // no extension case so just return base, which willi
                // be the filename
                name = base
        }</span>
        <span class="cov8" title="1">return</span>
}

// GetRelativePath returns the relative path of a given path.
func GetRelativePath(path, base string) (final string, err error) <span class="cov8" title="1">{
        if filepath.IsAbs(path) &amp;&amp; base == "" </span><span class="cov8" title="1">{
                return "", errors.New("source: missing base directory")
        }</span>
        <span class="cov8" title="1">name := filepath.Clean(path)
        base = filepath.Clean(base)

        name, err = filepath.Rel(base, name)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if strings.HasSuffix(filepath.FromSlash(path), FilePathSeparator) &amp;&amp; !strings.HasSuffix(name, FilePathSeparator) </span><span class="cov8" title="1">{
                name += FilePathSeparator
        }</span>
        <span class="cov8" title="1">return name, nil</span>
}

func prettifyPath(in string, b filepathPathBridge) string <span class="cov8" title="1">{
        if filepath.Ext(in) == "" </span><span class="cov8" title="1">{
                // /section/name/  -&gt; /section/name/index.html
                if len(in) &lt; 2 </span><span class="cov8" title="1">{
                        return b.Separator()
                }</span>
                <span class="cov8" title="1">return b.Join(in, "index.html")</span>
        }
        <span class="cov8" title="1">name, ext := fileAndExt(in, b)
        if name == "index" </span><span class="cov8" title="1">{
                // /section/name/index.html -&gt; /section/name/index.html
                return b.Clean(in)
        }</span>
        // /section/name.html -&gt; /section/name/index.html
        <span class="cov8" title="1">return b.Join(b.Dir(in), name, "index"+ext)</span>
}

type NamedSlice struct {
        Name  string
        Slice []string
}

func (n NamedSlice) String() string <span class="cov0" title="0">{
        if len(n.Slice) == 0 </span><span class="cov0" title="0">{
                return n.Name
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s%s{%s}", n.Name, FilePathSeparator, strings.Join(n.Slice, ","))</span>
}
</pre>
		
		<pre class="file" id="file50" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package paths

import (
        "fmt"
        "net/url"
        "path"
        "strings"
)

type pathBridge struct{}

func (pathBridge) Base(in string) string <span class="cov8" title="1">{
        return path.Base(in)
}</span>

func (pathBridge) Clean(in string) string <span class="cov8" title="1">{
        return path.Clean(in)
}</span>

func (pathBridge) Dir(in string) string <span class="cov8" title="1">{
        return path.Dir(in)
}</span>

func (pathBridge) Ext(in string) string <span class="cov8" title="1">{
        return path.Ext(in)
}</span>

func (pathBridge) Join(elem ...string) string <span class="cov8" title="1">{
        return path.Join(elem...)
}</span>

func (pathBridge) Separator() string <span class="cov8" title="1">{
        return "/"
}</span>

var pb pathBridge

// MakePermalink combines base URL with content path to create full URL paths.
// Example
//    base:   http://spf13.com/
//    path:   post/how-i-blog
//    result: http://spf13.com/post/how-i-blog
func MakePermalink(host, plink string) *url.URL <span class="cov8" title="1">{
        base, err := url.Parse(host)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">p, err := url.Parse(plink)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">if p.Host != "" </span><span class="cov0" title="0">{
                panic(fmt.Errorf("can't make permalink from absolute link %q", plink))</span>
        }

        <span class="cov8" title="1">base.Path = path.Join(base.Path, p.Path)

        // path.Join will strip off the last /, so put it back if it was there.
        hadTrailingSlash := (plink == "" &amp;&amp; strings.HasSuffix(host, "/")) || strings.HasSuffix(p.Path, "/")
        if hadTrailingSlash &amp;&amp; !strings.HasSuffix(base.Path, "/") </span><span class="cov8" title="1">{
                base.Path = base.Path + "/"
        }</span>

        <span class="cov8" title="1">return base</span>
}

// AddContextRoot adds the context root to an URL if it's not already set.
// For relative URL entries on sites with a base url with a context root set (i.e. http://example.com/mysite),
// relative URLs must not include the context root if canonifyURLs is enabled. But if it's disabled, it must be set.
func AddContextRoot(baseURL, relativePath string) string <span class="cov8" title="1">{
        url, err := url.Parse(baseURL)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">newPath := path.Join(url.Path, relativePath)

        // path strips trailing slash, ignore root path.
        if newPath != "/" &amp;&amp; strings.HasSuffix(relativePath, "/") </span><span class="cov8" title="1">{
                newPath += "/"
        }</span>
        <span class="cov8" title="1">return newPath</span>
}

// URLizeAn

// PrettifyURL takes a URL string and returns a semantic, clean URL.
func PrettifyURL(in string) string <span class="cov8" title="1">{
        x := PrettifyURLPath(in)

        if path.Base(x) == "index.html" </span><span class="cov8" title="1">{
                return path.Dir(x)
        }</span>

        <span class="cov8" title="1">if in == "" </span><span class="cov8" title="1">{
                return "/"
        }</span>

        <span class="cov8" title="1">return x</span>
}

// PrettifyURLPath takes a URL path to a content and converts it
// to enable pretty URLs.
//     /section/name.html       becomes /section/name/index.html
//     /section/name/           becomes /section/name/index.html
//     /section/name/index.html becomes /section/name/index.html
func PrettifyURLPath(in string) string <span class="cov8" title="1">{
        return prettifyPath(in, pb)
}</span>

// Uglify does the opposite of PrettifyURLPath().
//     /section/name/index.html becomes /section/name.html
//     /section/name/           becomes /section/name.html
//     /section/name.html       becomes /section/name.html
func Uglify(in string) string <span class="cov8" title="1">{
        if path.Ext(in) == "" </span><span class="cov8" title="1">{
                if len(in) &lt; 2 </span><span class="cov8" title="1">{
                        return "/"
                }</span>
                // /section/name/  -&gt; /section/name.html
                <span class="cov8" title="1">return path.Clean(in) + ".html"</span>
        }

        <span class="cov8" title="1">name, ext := fileAndExt(in, pb)
        if name == "index" </span><span class="cov8" title="1">{
                // /section/name/index.html -&gt; /section/name.html
                d := path.Dir(in)
                if len(d) &gt; 1 </span><span class="cov8" title="1">{
                        return d + ext
                }</span>
                <span class="cov8" title="1">return in</span>
        }
        // /.xml -&gt; /index.xml
        <span class="cov8" title="1">if name == "" </span><span class="cov0" title="0">{
                return path.Dir(in) + "index" + ext
        }</span>
        // /section/name.html -&gt; /section/name.html
        <span class="cov8" title="1">return path.Clean(in)</span>
}
</pre>
		
		<pre class="file" id="file51" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package text

import (
        "fmt"
        "os"
        "strings"

        "github.com/gohugoio/hugo/common/terminal"
)

// Positioner represents a thing that knows its position in a text file or stream,
// typically an error.
type Positioner interface {
        Position() Position
}

// Position holds a source position in a text file or stream.
type Position struct {
        Filename     string // filename, if any
        Offset       int    // byte offset, starting at 0. It's set to -1 if not provided.
        LineNumber   int    // line number, starting at 1
        ColumnNumber int    // column number, starting at 1 (character count per line)
}

func (pos Position) String() string <span class="cov8" title="1">{
        if pos.Filename == "" </span><span class="cov0" title="0">{
                pos.Filename = "&lt;stream&gt;"
        }</span>
        <span class="cov8" title="1">return positionStringFormatfunc(pos)</span>
}

// IsValid returns true if line number is &gt; 0.
func (pos Position) IsValid() bool <span class="cov0" title="0">{
        return pos.LineNumber &gt; 0
}</span>

var positionStringFormatfunc func(p Position) string

func createPositionStringFormatter(formatStr string) func(p Position) string <span class="cov8" title="1">{
        if formatStr == "" </span><span class="cov8" title="1">{
                formatStr = "\":file::line::col\""
        }</span>

        <span class="cov8" title="1">identifiers := []string{":file", ":line", ":col"}
        var identifiersFound []string

        for i := range formatStr </span><span class="cov8" title="1">{
                for _, id := range identifiers </span><span class="cov8" title="1">{
                        if strings.HasPrefix(formatStr[i:], id) </span><span class="cov8" title="1">{
                                identifiersFound = append(identifiersFound, id)
                        }</span>
                }
        }

        <span class="cov8" title="1">replacer := strings.NewReplacer(":file", "%s", ":line", "%d", ":col", "%d")
        format := replacer.Replace(formatStr)

        f := func(pos Position) string </span><span class="cov8" title="1">{
                args := make([]interface{}, len(identifiersFound))
                for i, id := range identifiersFound </span><span class="cov8" title="1">{
                        switch id </span>{
                        case ":file":<span class="cov8" title="1">
                                args[i] = pos.Filename</span>
                        case ":line":<span class="cov8" title="1">
                                args[i] = pos.LineNumber</span>
                        case ":col":<span class="cov8" title="1">
                                args[i] = pos.ColumnNumber</span>
                        }
                }

                <span class="cov8" title="1">msg := fmt.Sprintf(format, args...)

                if terminal.IsTerminal(os.Stdout) </span><span class="cov0" title="0">{
                        return terminal.Notice(msg)
                }</span>

                <span class="cov8" title="1">return msg</span>
        }

        <span class="cov8" title="1">return f</span>
}

func init() <span class="cov8" title="1">{
        positionStringFormatfunc = createPositionStringFormatter(os.Getenv("HUGO_FILE_LOG_FORMAT"))
}</span>
</pre>
		
		<pre class="file" id="file52" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package text

import (
        "sync"
        "unicode"

        "golang.org/x/text/runes"
        "golang.org/x/text/transform"
        "golang.org/x/text/unicode/norm"
)

var accentTransformerPool = &amp;sync.Pool{
        New: func() interface{} <span class="cov8" title="1">{
                return transform.Chain(norm.NFD, runes.Remove(runes.In(unicode.Mn)), norm.NFC)
        }</span>,
}

// RemoveAccents removes all accents from b.
func RemoveAccents(b []byte) []byte <span class="cov8" title="1">{
        t := accentTransformerPool.Get().(transform.Transformer)
        b, _, _ = transform.Bytes(t, b)
        t.Reset()
        accentTransformerPool.Put(t)
        return b
}</span>

// RemoveAccentsString removes all accents from s.
func RemoveAccentsString(s string) string <span class="cov8" title="1">{
        t := accentTransformerPool.Get().(transform.Transformer)
        s, _, _ = transform.String(t, s)
        t.Reset()
        accentTransformerPool.Put(t)
        return s
}</span>
</pre>
		
		<pre class="file" id="file53" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package types

import (
        "encoding/json"
        "fmt"
        "html/template"
        "reflect"
        "time"

        "github.com/spf13/cast"
)

// ToDuration converts v to time.Duration.
// See ToDurationE if you need to handle errors.
func ToDuration(v interface{}) time.Duration <span class="cov8" title="1">{
        d, _ := ToDurationE(v)
        return d
}</span>

// ToDurationE converts v to time.Duration.
func ToDurationE(v interface{}) (time.Duration, error) <span class="cov8" title="1">{
        if n := cast.ToInt(v); n &gt; 0 </span><span class="cov8" title="1">{
                return time.Duration(n) * time.Millisecond, nil
        }</span>
        <span class="cov8" title="1">d, err := time.ParseDuration(cast.ToString(v))
        if err != nil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("cannot convert %v to time.Duration", v)
        }</span>
        <span class="cov8" title="1">return d, nil</span>
}

// ToStringSlicePreserveString is the same as ToStringSlicePreserveStringE,
// but it never fails.
func ToStringSlicePreserveString(v interface{}) []string <span class="cov8" title="1">{
        vv, _ := ToStringSlicePreserveStringE(v)
        return vv
}</span>

// ToStringSlicePreserveStringE converts v to a string slice.
// If v is a string, it will be wrapped in a string slice.
func ToStringSlicePreserveStringE(v interface{}) ([]string, error) <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if sds, ok := v.(string); ok </span><span class="cov8" title="1">{
                return []string{sds}, nil
        }</span>
        <span class="cov8" title="1">result, err := cast.ToStringSliceE(v)
        if err == nil </span><span class="cov8" title="1">{
                return result, nil
        }</span>

        // Probably []int or similar. Fall back to reflect.
        <span class="cov0" title="0">vv := reflect.ValueOf(v)

        switch vv.Kind() </span>{
        case reflect.Slice, reflect.Array:<span class="cov0" title="0">
                result = make([]string, vv.Len())
                for i := 0; i &lt; vv.Len(); i++ </span><span class="cov0" title="0">{
                        s, err := cast.ToStringE(vv.Index(i).Interface())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">result[i] = s</span>
                }
                <span class="cov0" title="0">return result, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("failed to convert %T to a string slice", v)</span>
        }

}

// TypeToString converts v to a string if it's a valid string type.
// Note that this will not try to convert numeric values etc.,
// use ToString for that.
func TypeToString(v interface{}) (string, bool) <span class="cov8" title="1">{
        switch s := v.(type) </span>{
        case string:<span class="cov0" title="0">
                return s, true</span>
        case template.HTML:<span class="cov0" title="0">
                return string(s), true</span>
        case template.CSS:<span class="cov0" title="0">
                return string(s), true</span>
        case template.HTMLAttr:<span class="cov0" title="0">
                return string(s), true</span>
        case template.JS:<span class="cov0" title="0">
                return string(s), true</span>
        case template.JSStr:<span class="cov0" title="0">
                return string(s), true</span>
        case template.URL:<span class="cov0" title="0">
                return string(s), true</span>
        case template.Srcset:<span class="cov0" title="0">
                return string(s), true</span>
        }

        <span class="cov8" title="1">return "", false</span>
}

// ToString converts v to a string.
func ToString(v interface{}) string <span class="cov8" title="1">{
        s, _ := ToStringE(v)
        return s
}</span>

// ToStringE converts v to a string.
func ToStringE(v interface{}) (string, error) <span class="cov8" title="1">{
        if s, ok := TypeToString(v); ok </span><span class="cov0" title="0">{
                return s, nil
        }</span>

        <span class="cov8" title="1">switch s := v.(type) </span>{
        case json.RawMessage:<span class="cov8" title="1">
                return string(s), nil</span>
        default:<span class="cov8" title="1">
                return cast.ToStringE(v)</span>
        }
}
</pre>
		
		<pre class="file" id="file54" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package types contains types shared between packages in Hugo.
package types

import (
        "sync"
)

// EvictingStringQueue is a queue which automatically evicts elements from the head of
// the queue when attempting to add new elements onto the queue and it is full.
// This queue orders elements LIFO (last-in-first-out). It throws away duplicates.
// Note: This queue currently does not contain any remove (poll etc.) methods.
type EvictingStringQueue struct {
        size int
        vals []string
        set  map[string]bool
        mu   sync.Mutex
}

// NewEvictingStringQueue creates a new queue with the given size.
func NewEvictingStringQueue(size int) *EvictingStringQueue <span class="cov8" title="1">{
        return &amp;EvictingStringQueue{size: size, set: make(map[string]bool)}
}</span>

// Add adds a new string to the tail of the queue if it's not already there.
func (q *EvictingStringQueue) Add(v string) <span class="cov8" title="1">{
        q.mu.Lock()
        if q.set[v] </span><span class="cov8" title="1">{
                q.mu.Unlock()
                return
        }</span>

        <span class="cov8" title="1">if len(q.set) == q.size </span><span class="cov8" title="1">{
                // Full
                delete(q.set, q.vals[0])
                q.vals = append(q.vals[:0], q.vals[1:]...)
        }</span>
        <span class="cov8" title="1">q.set[v] = true
        q.vals = append(q.vals, v)
        q.mu.Unlock()</span>
}

// Contains returns whether the queue contains v.
func (q *EvictingStringQueue) Contains(v string) bool <span class="cov8" title="1">{
        q.mu.Lock()
        defer q.mu.Unlock()
        return q.set[v]
}</span>

// Peek looks at the last element added to the queue.
func (q *EvictingStringQueue) Peek() string <span class="cov8" title="1">{
        q.mu.Lock()
        l := len(q.vals)
        if l == 0 </span><span class="cov8" title="1">{
                q.mu.Unlock()
                return ""
        }</span>
        <span class="cov8" title="1">elem := q.vals[l-1]
        q.mu.Unlock()
        return elem</span>
}

// PeekAll looks at all the elements in the queue, with the newest first.
func (q *EvictingStringQueue) PeekAll() []string <span class="cov8" title="1">{
        q.mu.Lock()
        vals := make([]string, len(q.vals))
        copy(vals, q.vals)
        q.mu.Unlock()
        for i, j := 0, len(vals)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                vals[i], vals[j] = vals[j], vals[i]
        }</span>
        <span class="cov8" title="1">return vals</span>
}

// PeekAllSet returns PeekAll as a set.
func (q *EvictingStringQueue) PeekAllSet() map[string]bool <span class="cov8" title="1">{
        all := q.PeekAll()
        set := make(map[string]bool)
        for _, v := range all </span><span class="cov8" title="1">{
                set[v] = true
        }</span>

        <span class="cov8" title="1">return set</span>
}
</pre>
		
		<pre class="file" id="file55" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package types contains types shared between packages in Hugo.
package types

import (
        "fmt"
        "reflect"

        "github.com/spf13/cast"
)

// RLocker represents the read locks in sync.RWMutex.
type RLocker interface {
        RLock()
        RUnlock()
}

// KeyValue is a interface{} tuple.
type KeyValue struct {
        Key   interface{}
        Value interface{}
}

// KeyValueStr is a string tuple.
type KeyValueStr struct {
        Key   string
        Value string
}

// KeyValues holds an key and a slice of values.
type KeyValues struct {
        Key    interface{}
        Values []interface{}
}

// KeyString returns the key as a string, an empty string if conversion fails.
func (k KeyValues) KeyString() string <span class="cov8" title="1">{
        return cast.ToString(k.Key)
}</span>

func (k KeyValues) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%v: %v", k.Key, k.Values)
}</span>

// NewKeyValuesStrings takes a given key and slice of values and returns a new
// KeyValues struct.
func NewKeyValuesStrings(key string, values ...string) KeyValues <span class="cov8" title="1">{
        iv := make([]interface{}, len(values))
        for i := 0; i &lt; len(values); i++ </span><span class="cov8" title="1">{
                iv[i] = values[i]
        }</span>
        <span class="cov8" title="1">return KeyValues{Key: key, Values: iv}</span>
}

// Zeroer, as implemented by time.Time, will be used by the truth template
// funcs in Hugo (if, with, not, and, or).
type Zeroer interface {
        IsZero() bool
}

// IsNil reports whether v is nil.
func IsNil(v interface{}) bool <span class="cov0" title="0">{
        if v == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">value := reflect.ValueOf(v)
        switch value.Kind() </span>{
        case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:<span class="cov0" title="0">
                return value.IsNil()</span>
        }

        <span class="cov0" title="0">return false</span>
}

// DevMarker is a marker interface for types that should only be used during
// development.
type DevMarker interface {
        DevOnly()
}
</pre>
		
		<pre class="file" id="file56" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package compare

import (
        "strings"
        "unicode"
        "unicode/utf8"
)

// Strings returns an integer comparing two strings lexicographically.
func Strings(s, t string) int <span class="cov8" title="1">{
        c := compareFold(s, t)

        if c == 0 </span><span class="cov8" title="1">{
                // "B" and "b" would be the same so we need a tiebreaker.
                return strings.Compare(s, t)
        }</span>

        <span class="cov8" title="1">return c</span>
}

// This function is derived from strings.EqualFold in Go's stdlib.
// https://github.com/golang/go/blob/ad4a58e31501bce5de2aad90a620eaecdc1eecb8/src/strings/strings.go#L893
func compareFold(s, t string) int <span class="cov8" title="1">{
        for s != "" &amp;&amp; t != "" </span><span class="cov8" title="1">{
                var sr, tr rune
                if s[0] &lt; utf8.RuneSelf </span><span class="cov8" title="1">{
                        sr, s = rune(s[0]), s[1:]
                }</span> else<span class="cov8" title="1"> {
                        r, size := utf8.DecodeRuneInString(s)
                        sr, s = r, s[size:]
                }</span>
                <span class="cov8" title="1">if t[0] &lt; utf8.RuneSelf </span><span class="cov8" title="1">{
                        tr, t = rune(t[0]), t[1:]
                }</span> else<span class="cov8" title="1"> {
                        r, size := utf8.DecodeRuneInString(t)
                        tr, t = r, t[size:]
                }</span>

                <span class="cov8" title="1">if tr == sr </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">c := 1
                if tr &lt; sr </span><span class="cov8" title="1">{
                        tr, sr = sr, tr
                        c = -c
                }</span>

                //  ASCII only.
                <span class="cov8" title="1">if tr &lt; utf8.RuneSelf </span><span class="cov8" title="1">{
                        if sr &gt;= 'A' &amp;&amp; sr &lt;= 'Z' </span><span class="cov8" title="1">{
                                if tr &lt;= 'Z' </span><span class="cov8" title="1">{
                                        // Same case.
                                        return -c
                                }</span>

                                <span class="cov8" title="1">diff := tr - (sr + 'a' - 'A')

                                if diff == 0 </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">if diff &lt; 0 </span><span class="cov8" title="1">{
                                        return c
                                }</span>

                                <span class="cov8" title="1">if diff &gt; 0 </span><span class="cov8" title="1">{
                                        return -c
                                }</span>
                        }
                }

                // Unicode.
                <span class="cov8" title="1">r := unicode.SimpleFold(sr)
                for r != sr &amp;&amp; r &lt; tr </span><span class="cov8" title="1">{
                        r = unicode.SimpleFold(r)
                }</span>

                <span class="cov8" title="1">if r == tr </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">return -c</span>
        }

        <span class="cov8" title="1">if s == "" &amp;&amp; t == "" </span><span class="cov8" title="1">{
                return 0
        }</span>

        <span class="cov8" title="1">if s == "" </span><span class="cov8" title="1">{
                return -1
        }</span>

        <span class="cov8" title="1">return 1</span>
}

// LessStrings returns whether s is less than t lexicographically.
func LessStrings(s, t string) bool <span class="cov8" title="1">{
        return Strings(s, t) &lt; 0
}</span>
</pre>
		
		<pre class="file" id="file57" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
        "sort"
        "strings"
        "sync"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/types"

        "github.com/gobwas/glob"
        "github.com/gohugoio/hugo/common/herrors"
        "github.com/mitchellh/mapstructure"
        "github.com/spf13/cast"
        jww "github.com/spf13/jwalterweatherman"
)

var DefaultBuild = Build{
        UseResourceCacheWhen: "fallback",
        WriteStats:           false,
}

// Build holds some build related configuration.
type Build struct {
        UseResourceCacheWhen string // never, fallback, always. Default is fallback

        // When enabled, will collect and write a hugo_stats.json with some build
        // related aggregated data (e.g. CSS class names).
        WriteStats bool

        // Can be used to toggle off writing of the intellinsense /assets/jsconfig.js
        // file.
        NoJSConfigInAssets bool
}

func (b Build) UseResourceCache(err error) bool <span class="cov8" title="1">{
        if b.UseResourceCacheWhen == "never" </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if b.UseResourceCacheWhen == "fallback" </span><span class="cov8" title="1">{
                return err == herrors.ErrFeatureNotAvailable
        }</span>

        <span class="cov8" title="1">return true</span>
}

func DecodeBuild(cfg Provider) Build <span class="cov8" title="1">{
        m := cfg.GetStringMap("build")
        b := DefaultBuild
        if m == nil </span><span class="cov0" title="0">{
                return b
        }</span>

        <span class="cov8" title="1">err := mapstructure.WeakDecode(m, &amp;b)
        if err != nil </span><span class="cov0" title="0">{
                return DefaultBuild
        }</span>

        <span class="cov8" title="1">b.UseResourceCacheWhen = strings.ToLower(b.UseResourceCacheWhen)
        when := b.UseResourceCacheWhen
        if when != "never" &amp;&amp; when != "always" &amp;&amp; when != "fallback" </span><span class="cov8" title="1">{
                b.UseResourceCacheWhen = "fallback"
        }</span>

        <span class="cov8" title="1">return b</span>
}

// Sitemap configures the sitemap to be generated.
type Sitemap struct {
        ChangeFreq string
        Priority   float64
        Filename   string
}

func DecodeSitemap(prototype Sitemap, input map[string]interface{}) Sitemap <span class="cov0" title="0">{
        for key, value := range input </span><span class="cov0" title="0">{
                switch key </span>{
                case "changefreq":<span class="cov0" title="0">
                        prototype.ChangeFreq = cast.ToString(value)</span>
                case "priority":<span class="cov0" title="0">
                        prototype.Priority = cast.ToFloat64(value)</span>
                case "filename":<span class="cov0" title="0">
                        prototype.Filename = cast.ToString(value)</span>
                default:<span class="cov0" title="0">
                        jww.WARN.Printf("Unknown Sitemap field: %s\n", key)</span>
                }
        }

        <span class="cov0" title="0">return prototype</span>
}

// Config for the dev server.
type Server struct {
        Headers   []Headers
        Redirects []Redirect

        compiledInit      sync.Once
        compiledHeaders   []glob.Glob
        compiledRedirects []glob.Glob
}

func (s *Server) init() <span class="cov8" title="1">{
        s.compiledInit.Do(func() </span><span class="cov8" title="1">{
                for _, h := range s.Headers </span><span class="cov8" title="1">{
                        s.compiledHeaders = append(s.compiledHeaders, glob.MustCompile(h.For))
                }</span>
                <span class="cov8" title="1">for _, r := range s.Redirects </span><span class="cov8" title="1">{
                        s.compiledRedirects = append(s.compiledRedirects, glob.MustCompile(r.From))
                }</span>
        })
}

func (s *Server) MatchHeaders(pattern string) []types.KeyValueStr <span class="cov8" title="1">{
        s.init()

        if s.compiledHeaders == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var matches []types.KeyValueStr

        for i, g := range s.compiledHeaders </span><span class="cov8" title="1">{
                if g.Match(pattern) </span><span class="cov8" title="1">{
                        h := s.Headers[i]
                        for k, v := range h.Values </span><span class="cov8" title="1">{
                                matches = append(matches, types.KeyValueStr{Key: k, Value: cast.ToString(v)})
                        }</span>
                }
        }

        <span class="cov8" title="1">sort.Slice(matches, func(i, j int) bool </span><span class="cov8" title="1">{
                return matches[i].Key &lt; matches[j].Key
        }</span>)

        <span class="cov8" title="1">return matches</span>
}

func (s *Server) MatchRedirect(pattern string) Redirect <span class="cov8" title="1">{
        s.init()

        if s.compiledRedirects == nil </span><span class="cov0" title="0">{
                return Redirect{}
        }</span>

        <span class="cov8" title="1">pattern = strings.TrimSuffix(pattern, "index.html")

        for i, g := range s.compiledRedirects </span><span class="cov8" title="1">{
                redir := s.Redirects[i]

                // No redirect to self.
                if redir.To == pattern </span><span class="cov8" title="1">{
                        return Redirect{}
                }</span>

                <span class="cov8" title="1">if g.Match(pattern) </span><span class="cov8" title="1">{
                        return redir
                }</span>
        }

        <span class="cov0" title="0">return Redirect{}</span>
}

type Headers struct {
        For    string
        Values map[string]interface{}
}

type Redirect struct {
        From   string
        To     string
        Status int
        Force  bool
}

func (r Redirect) IsZero() bool <span class="cov0" title="0">{
        return r.From == ""
}</span>

func DecodeServer(cfg Provider) (*Server, error) <span class="cov8" title="1">{
        m := cfg.GetStringMap("server")
        s := &amp;Server{}
        if m == nil </span><span class="cov0" title="0">{
                return s, nil
        }</span>

        <span class="cov8" title="1">_ = mapstructure.WeakDecode(m, s)

        for i, redir := range s.Redirects </span><span class="cov8" title="1">{
                // Get it in line with the Hugo server.
                redir.To = strings.TrimSuffix(redir.To, "index.html")
                if !strings.HasPrefix(redir.To, "https") &amp;&amp; !strings.HasSuffix(redir.To, "/") </span><span class="cov8" title="1">{
                        // There are some tricky infinite loop situations when dealing
                        // when the target does not have a trailing slash.
                        // This can certainly be handled better, but not time for that now.
                        return nil, errors.Errorf("unsupported redirect to value %q in server config; currently this must be either a remote destination or a local folder, e.g. \"/blog/\" or \"/blog/index.html\"", redir.To)
                }</span>
                <span class="cov8" title="1">s.Redirects[i] = redir</span>
        }

        <span class="cov8" title="1">return s, nil</span>
}
</pre>
		
		<pre class="file" id="file58" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
        "github.com/gohugoio/hugo/common/maps"
)

// NewCompositeConfig creates a new composite Provider with a read-only base
// and a writeable layer.
func NewCompositeConfig(base, layer Provider) Provider <span class="cov8" title="1">{
        return &amp;compositeConfig{
                base:  base,
                layer: layer,
        }
}</span>

// compositeConfig contains a read only config base with
// a possibly writeable config layer on top.
type compositeConfig struct {
        base  Provider
        layer Provider
}

func (c *compositeConfig) GetBool(key string) bool <span class="cov0" title="0">{
        if c.layer.IsSet(key) </span><span class="cov0" title="0">{
                return c.layer.GetBool(key)
        }</span>
        <span class="cov0" title="0">return c.base.GetBool(key)</span>
}

func (c *compositeConfig) GetInt(key string) int <span class="cov0" title="0">{
        if c.layer.IsSet(key) </span><span class="cov0" title="0">{
                return c.layer.GetInt(key)
        }</span>
        <span class="cov0" title="0">return c.base.GetInt(key)</span>
}

func (c *compositeConfig) Merge(key string, value interface{}) <span class="cov0" title="0">{
        c.layer.Merge(key, value)
}</span>

func (c *compositeConfig) GetParams(key string) maps.Params <span class="cov0" title="0">{
        if c.layer.IsSet(key) </span><span class="cov0" title="0">{
                return c.layer.GetParams(key)
        }</span>
        <span class="cov0" title="0">return c.base.GetParams(key)</span>
}

func (c *compositeConfig) GetStringMap(key string) map[string]interface{} <span class="cov0" title="0">{
        if c.layer.IsSet(key) </span><span class="cov0" title="0">{
                return c.layer.GetStringMap(key)
        }</span>
        <span class="cov0" title="0">return c.base.GetStringMap(key)</span>
}

func (c *compositeConfig) GetStringMapString(key string) map[string]string <span class="cov0" title="0">{
        if c.layer.IsSet(key) </span><span class="cov0" title="0">{
                return c.layer.GetStringMapString(key)
        }</span>
        <span class="cov0" title="0">return c.base.GetStringMapString(key)</span>
}

func (c *compositeConfig) GetStringSlice(key string) []string <span class="cov0" title="0">{
        if c.layer.IsSet(key) </span><span class="cov0" title="0">{
                return c.layer.GetStringSlice(key)
        }</span>
        <span class="cov0" title="0">return c.base.GetStringSlice(key)</span>
}

func (c *compositeConfig) Get(key string) interface{} <span class="cov8" title="1">{
        if c.layer.IsSet(key) </span><span class="cov8" title="1">{
                return c.layer.Get(key)
        }</span>
        <span class="cov8" title="1">return c.base.Get(key)</span>
}

func (c *compositeConfig) IsSet(key string) bool <span class="cov8" title="1">{
        if c.layer.IsSet(key) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov0" title="0">return c.base.IsSet(key)</span>
}

func (c *compositeConfig) GetString(key string) string <span class="cov0" title="0">{
        if c.layer.IsSet(key) </span><span class="cov0" title="0">{
                return c.layer.GetString(key)
        }</span>
        <span class="cov0" title="0">return c.base.GetString(key)</span>
}

func (c *compositeConfig) Set(key string, value interface{}) <span class="cov8" title="1">{
        c.layer.Set(key, value)
}</span>

func (c *compositeConfig) SetDefaults(params maps.Params) <span class="cov0" title="0">{
        c.layer.SetDefaults(params)
}</span>

func (c *compositeConfig) WalkParams(walkFn func(params ...KeyParams) bool) <span class="cov0" title="0">{
        panic("not supported")</span>
}

func (c *compositeConfig) SetDefaultMergeStrategy() <span class="cov0" title="0">{
        panic("not supported")</span>
}
</pre>
		
		<pre class="file" id="file59" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
        "os"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/herrors"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/paths"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/parser/metadecoders"
        "github.com/spf13/afero"
)

var (
        ValidConfigFileExtensions                    = []string{"toml", "yaml", "yml", "json"}
        validConfigFileExtensionsMap map[string]bool = make(map[string]bool)
)

func init() <span class="cov8" title="1">{
        for _, ext := range ValidConfigFileExtensions </span><span class="cov8" title="1">{
                validConfigFileExtensionsMap[ext] = true
        }</span>
}

// IsValidConfigFilename returns whether filename is one of the supported
// config formats in Hugo.
func IsValidConfigFilename(filename string) bool <span class="cov8" title="1">{
        ext := strings.ToLower(strings.TrimPrefix(filepath.Ext(filename), "."))
        return validConfigFileExtensionsMap[ext]
}</span>

// FromConfigString creates a config from the given YAML, JSON or TOML config. This is useful in tests.
func FromConfigString(config, configType string) (Provider, error) <span class="cov8" title="1">{
        m, err := readConfig(metadecoders.FormatFromString(configType), []byte(config))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return NewFrom(m), nil</span>
}

// FromFile loads the configuration from the given filename.
func FromFile(fs afero.Fs, filename string) (Provider, error) <span class="cov0" title="0">{
        m, err := loadConfigFromFile(fs, filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, herrors.WithFileContextForFileDefault(err, filename, fs)
        }</span>
        <span class="cov0" title="0">return NewFrom(m), nil</span>
}

// FromFileToMap is the same as FromFile, but it returns the config values
// as a simple map.
func FromFileToMap(fs afero.Fs, filename string) (map[string]interface{}, error) <span class="cov0" title="0">{
        return loadConfigFromFile(fs, filename)
}</span>

func readConfig(format metadecoders.Format, data []byte) (map[string]interface{}, error) <span class="cov8" title="1">{
        m, err := metadecoders.Default.UnmarshalToMap(data, format)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">RenameKeys(m)

        return m, nil</span>
}

func loadConfigFromFile(fs afero.Fs, filename string) (map[string]interface{}, error) <span class="cov0" title="0">{
        m, err := metadecoders.Default.UnmarshalFileToMap(fs, filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">RenameKeys(m)
        return m, nil</span>
}

func LoadConfigFromDir(sourceFs afero.Fs, configDir, environment string) (Provider, []string, error) <span class="cov0" title="0">{
        defaultConfigDir := filepath.Join(configDir, "_default")
        environmentConfigDir := filepath.Join(configDir, environment)
        cfg := New()

        var configDirs []string
        // Merge from least to most specific.
        for _, dir := range []string{defaultConfigDir, environmentConfigDir} </span><span class="cov0" title="0">{
                if _, err := sourceFs.Stat(dir); err == nil </span><span class="cov0" title="0">{
                        configDirs = append(configDirs, dir)
                }</span>
        }

        <span class="cov0" title="0">if len(configDirs) == 0 </span><span class="cov0" title="0">{
                return nil, nil, nil
        }</span>

        // Keep track of these so we can watch them for changes.
        <span class="cov0" title="0">var dirnames []string

        for _, configDir := range configDirs </span><span class="cov0" title="0">{
                err := afero.Walk(sourceFs, configDir, func(path string, fi os.FileInfo, err error) error </span><span class="cov0" title="0">{
                        if fi == nil || err != nil </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                                dirnames = append(dirnames, path)
                                return nil
                        }</span>

                        <span class="cov0" title="0">if !IsValidConfigFilename(path) </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">name := paths.Filename(filepath.Base(path))

                        item, err := metadecoders.Default.UnmarshalFileToMap(sourceFs, path)
                        if err != nil </span><span class="cov0" title="0">{
                                // This will be used in error reporting, use the most specific value.
                                dirnames = []string{path}
                                return errors.Wrapf(err, "failed to unmarshl config for path %q", path)
                        }</span>

                        <span class="cov0" title="0">var keyPath []string

                        if name != "config" </span><span class="cov0" title="0">{
                                // Can be params.jp, menus.en etc.
                                name, lang := paths.FileAndExtNoDelimiter(name)

                                keyPath = []string{name}

                                if lang != "" </span><span class="cov0" title="0">{
                                        keyPath = []string{"languages", lang}
                                        switch name </span>{
                                        case "menu", "menus":<span class="cov0" title="0">
                                                keyPath = append(keyPath, "menus")</span>
                                        case "params":<span class="cov0" title="0">
                                                keyPath = append(keyPath, "params")</span>
                                        }
                                }
                        }

                        <span class="cov0" title="0">root := item
                        if len(keyPath) &gt; 0 </span><span class="cov0" title="0">{
                                root = make(map[string]interface{})
                                m := root
                                for i, key := range keyPath </span><span class="cov0" title="0">{
                                        if i &gt;= len(keyPath)-1 </span><span class="cov0" title="0">{
                                                m[key] = item
                                        }</span> else<span class="cov0" title="0"> {
                                                nm := make(map[string]interface{})
                                                m[key] = nm
                                                m = nm
                                        }</span>
                                }
                        }

                        // Migrate menu =&gt; menus etc.
                        <span class="cov0" title="0">RenameKeys(root)

                        // Set will overwrite keys with the same name, recursively.
                        cfg.Set("", root)

                        return nil</span>
                })
                <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                        return nil, dirnames, err
                }</span>

        }

        <span class="cov0" title="0">return cfg, dirnames, nil</span>

}

var keyAliases maps.KeyRenamer

func init() <span class="cov8" title="1">{
        var err error
        keyAliases, err = maps.NewKeyRenamer(
                // Before 0.53 we used singular for "menu".
                "{menu,languages/*/menu}", "menus",
        )

        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

// RenameKeys renames config keys in m recursively according to a global Hugo
// alias definition.
func RenameKeys(m map[string]interface{}) <span class="cov8" title="1">{
        keyAliases.Rename(m)
}</span>
</pre>
		
		<pre class="file" id="file60" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/common/types"
)

// Provider provides the configuration settings for Hugo.
type Provider interface {
        GetString(key string) string
        GetInt(key string) int
        GetBool(key string) bool
        GetParams(key string) maps.Params
        GetStringMap(key string) map[string]interface{}
        GetStringMapString(key string) map[string]string
        GetStringSlice(key string) []string
        Get(key string) interface{}
        Set(key string, value interface{})
        Merge(key string, value interface{})
        SetDefaults(params maps.Params)
        SetDefaultMergeStrategy()
        WalkParams(walkFn func(params ...KeyParams) bool)
        IsSet(key string) bool
}

// GetStringSlicePreserveString returns a string slice from the given config and key.
// It differs from the GetStringSlice method in that if the config value is a string,
// we do not attempt to split it into fields.
func GetStringSlicePreserveString(cfg Provider, key string) []string <span class="cov8" title="1">{
        sd := cfg.Get(key)
        return types.ToStringSlicePreserveString(sd)
}</span>

// SetBaseTestDefaults provides some common config defaults used in tests.
func SetBaseTestDefaults(cfg Provider) <span class="cov0" title="0">{
        cfg.Set("resourceDir", "resources")
        cfg.Set("contentDir", "content")
        cfg.Set("dataDir", "data")
        cfg.Set("i18nDir", "i18n")
        cfg.Set("layoutDir", "layouts")
        cfg.Set("assetDir", "assets")
        cfg.Set("archetypeDir", "archetypes")
        cfg.Set("publishDir", "public")
}</span>
</pre>
		
		<pre class="file" id="file61" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
        "fmt"
        "sort"
        "strings"
        "sync"

        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/common/maps"
)

var (

        // ConfigRootKeysSet contains all of the config map root keys.
        ConfigRootKeysSet = map[string]bool{
                "build":         true,
                "caches":        true,
                "cascade":       true,
                "frontmatter":   true,
                "languages":     true,
                "imaging":       true,
                "markup":        true,
                "mediatypes":    true,
                "menus":         true,
                "minify":        true,
                "module":        true,
                "outputformats": true,
                "params":        true,
                "permalinks":    true,
                "related":       true,
                "sitemap":       true,
                "privacy":       true,
                "security":      true,
                "taxonomies":    true,
        }

        // ConfigRootKeys is a sorted version of ConfigRootKeysSet.
        ConfigRootKeys []string
)

func init() <span class="cov8" title="1">{
        for k := range ConfigRootKeysSet </span><span class="cov8" title="1">{
                ConfigRootKeys = append(ConfigRootKeys, k)
        }</span>
        <span class="cov8" title="1">sort.Strings(ConfigRootKeys)</span>
}

// New creates a Provider backed by an empty maps.Params.
func New() Provider <span class="cov8" title="1">{
        return &amp;defaultConfigProvider{
                root: make(maps.Params),
        }
}</span>

// NewFrom creates a Provider backed by params.
func NewFrom(params maps.Params) Provider <span class="cov8" title="1">{
        maps.PrepareParams(params)
        return &amp;defaultConfigProvider{
                root: params,
        }
}</span>

// defaultConfigProvider is a Provider backed by a map where all keys are lower case.
// All methods are thread safe.
type defaultConfigProvider struct {
        mu   sync.RWMutex
        root maps.Params

        keyCache sync.Map
}

func (c *defaultConfigProvider) Get(k string) interface{} <span class="cov8" title="1">{
        if k == "" </span><span class="cov8" title="1">{
                return c.root
        }</span>
        <span class="cov8" title="1">c.mu.RLock()
        key, m := c.getNestedKeyAndMap(strings.ToLower(k), false)
        if m == nil </span><span class="cov0" title="0">{
                c.mu.RUnlock()
                return nil
        }</span>
        <span class="cov8" title="1">v := m[key]
        c.mu.RUnlock()
        return v</span>
}

func (c *defaultConfigProvider) GetBool(k string) bool <span class="cov0" title="0">{
        v := c.Get(k)
        return cast.ToBool(v)
}</span>

func (c *defaultConfigProvider) GetInt(k string) int <span class="cov8" title="1">{
        v := c.Get(k)
        return cast.ToInt(v)
}</span>

func (c *defaultConfigProvider) IsSet(k string) bool <span class="cov8" title="1">{
        var found bool
        c.mu.RLock()
        key, m := c.getNestedKeyAndMap(strings.ToLower(k), false)
        if m != nil </span><span class="cov8" title="1">{
                _, found = m[key]
        }</span>
        <span class="cov8" title="1">c.mu.RUnlock()
        return found</span>
}

func (c *defaultConfigProvider) GetString(k string) string <span class="cov8" title="1">{
        v := c.Get(k)
        return cast.ToString(v)
}</span>

func (c *defaultConfigProvider) GetParams(k string) maps.Params <span class="cov0" title="0">{
        v := c.Get(k)
        if v == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return v.(maps.Params)</span>
}

func (c *defaultConfigProvider) GetStringMap(k string) map[string]interface{} <span class="cov8" title="1">{
        v := c.Get(k)
        return maps.ToStringMap(v)
}</span>

func (c *defaultConfigProvider) GetStringMapString(k string) map[string]string <span class="cov8" title="1">{
        v := c.Get(k)
        return maps.ToStringMapString(v)
}</span>

func (c *defaultConfigProvider) GetStringSlice(k string) []string <span class="cov0" title="0">{
        v := c.Get(k)
        return cast.ToStringSlice(v)
}</span>

func (c *defaultConfigProvider) Set(k string, v interface{}) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()

        k = strings.ToLower(k)

        if k == "" </span><span class="cov8" title="1">{
                if p, ok := maps.ToParamsAndPrepare(v); ok </span><span class="cov8" title="1">{
                        // Set the values directly in root.
                        c.root.Set(p)
                }</span> else<span class="cov0" title="0"> {
                        c.root[k] = v
                }</span>

                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">switch vv := v.(type) </span>{
        case map[string]interface{}, map[interface{}]interface{}, map[string]string:<span class="cov8" title="1">
                p := maps.MustToParamsAndPrepare(vv)
                v = p</span>
        }

        <span class="cov8" title="1">key, m := c.getNestedKeyAndMap(k, true)
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if existing, found := m[key]; found </span><span class="cov8" title="1">{
                if p1, ok := existing.(maps.Params); ok </span><span class="cov8" title="1">{
                        if p2, ok := v.(maps.Params); ok </span><span class="cov8" title="1">{
                                p1.Set(p2)
                                return
                        }</span>
                }
        }

        <span class="cov8" title="1">m[key] = v</span>
}

// SetDefaults will set values from params if not already set.
func (c *defaultConfigProvider) SetDefaults(params maps.Params) <span class="cov0" title="0">{
        maps.PrepareParams(params)
        for k, v := range params </span><span class="cov0" title="0">{
                if _, found := c.root[k]; !found </span><span class="cov0" title="0">{
                        c.root[k] = v
                }</span>
        }
}

func (c *defaultConfigProvider) Merge(k string, v interface{}) <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        k = strings.ToLower(k)

        const (
                languagesKey = "languages"
                paramsKey    = "params"
                menusKey     = "menus"
        )

        if k == "" </span><span class="cov8" title="1">{
                rs, f := c.root.GetMergeStrategy()
                if f &amp;&amp; rs == maps.ParamsMergeStrategyNone </span><span class="cov0" title="0">{
                        // The user has set a "no merge" strategy on this,
                        // nothing more to do.
                        return
                }</span>

                <span class="cov8" title="1">if p, ok := maps.ToParamsAndPrepare(v); ok </span><span class="cov8" title="1">{
                        // As there may be keys in p not in root, we need to handle
                        // those as a special case.
                        var keysToDelete []string
                        for kk, vv := range p </span><span class="cov8" title="1">{
                                if pp, ok := vv.(maps.Params); ok </span><span class="cov8" title="1">{
                                        if pppi, ok := c.root[kk]; ok </span><span class="cov8" title="1">{
                                                ppp := pppi.(maps.Params)
                                                if kk == languagesKey </span><span class="cov0" title="0">{
                                                        // Languages is currently a special case.
                                                        // We may have languages with menus or params in the
                                                        // right map that is not present in the left map.
                                                        // With the default merge strategy those items will not
                                                        // be passed over.
                                                        var hasParams, hasMenus bool
                                                        for _, rv := range pp </span><span class="cov0" title="0">{
                                                                if lkp, ok := rv.(maps.Params); ok </span><span class="cov0" title="0">{
                                                                        _, hasMenus = lkp[menusKey]
                                                                        _, hasParams = lkp[paramsKey]
                                                                }</span>
                                                        }

                                                        <span class="cov0" title="0">if hasMenus || hasParams </span><span class="cov0" title="0">{
                                                                for _, lv := range ppp </span><span class="cov0" title="0">{
                                                                        if lkp, ok := lv.(maps.Params); ok </span><span class="cov0" title="0">{
                                                                                if hasMenus </span><span class="cov0" title="0">{
                                                                                        if _, ok := lkp[menusKey]; !ok </span><span class="cov0" title="0">{
                                                                                                p := maps.Params{}
                                                                                                p.SetDefaultMergeStrategy(maps.ParamsMergeStrategyShallow)
                                                                                                lkp[menusKey] = p
                                                                                        }</span>
                                                                                }
                                                                                <span class="cov0" title="0">if hasParams </span><span class="cov0" title="0">{
                                                                                        if _, ok := lkp[paramsKey]; !ok </span><span class="cov0" title="0">{
                                                                                                p := maps.Params{}
                                                                                                p.SetDefaultMergeStrategy(maps.ParamsMergeStrategyShallow)
                                                                                                lkp[paramsKey] = p
                                                                                        }</span>
                                                                                }
                                                                        }
                                                                }
                                                        }
                                                }
                                                <span class="cov8" title="1">ppp.Merge(pp)</span>
                                        } else<span class="cov8" title="1"> {
                                                // We need to use the default merge strategy for
                                                // this key.
                                                np := make(maps.Params)
                                                strategy := c.determineMergeStrategy(KeyParams{Key: "", Params: c.root}, KeyParams{Key: kk, Params: np})
                                                np.SetDefaultMergeStrategy(strategy)
                                                np.Merge(pp)
                                                c.root[kk] = np
                                                if np.IsZero() </span><span class="cov8" title="1">{
                                                        // Just keep it until merge is done.
                                                        keysToDelete = append(keysToDelete, kk)
                                                }</span>
                                        }
                                }
                        }
                        // Merge the rest.
                        <span class="cov8" title="1">c.root.MergeRoot(p)
                        for _, k := range keysToDelete </span><span class="cov8" title="1">{
                                delete(c.root, k)
                        }</span>
                } else<span class="cov0" title="0"> {
                        panic(fmt.Sprintf("unsupported type %T received in Merge", v))</span>
                }

                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">switch vv := v.(type) </span>{
        case map[string]interface{}, map[interface{}]interface{}, map[string]string:<span class="cov8" title="1">
                p := maps.MustToParamsAndPrepare(vv)
                v = p</span>
        }

        <span class="cov8" title="1">key, m := c.getNestedKeyAndMap(k, true)
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if existing, found := m[key]; found </span><span class="cov8" title="1">{
                if p1, ok := existing.(maps.Params); ok </span><span class="cov8" title="1">{
                        if p2, ok := v.(maps.Params); ok </span><span class="cov8" title="1">{
                                p1.Merge(p2)
                        }</span>
                }
        } else<span class="cov0" title="0"> {
                m[key] = v
        }</span>
}

func (c *defaultConfigProvider) WalkParams(walkFn func(params ...KeyParams) bool) <span class="cov0" title="0">{
        var walk func(params ...KeyParams)
        walk = func(params ...KeyParams) </span><span class="cov0" title="0">{
                if walkFn(params...) </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">p1 := params[len(params)-1]
                i := len(params)
                for k, v := range p1.Params </span><span class="cov0" title="0">{
                        if p2, ok := v.(maps.Params); ok </span><span class="cov0" title="0">{
                                paramsplus1 := make([]KeyParams, i+1)
                                copy(paramsplus1, params)
                                paramsplus1[i] = KeyParams{Key: k, Params: p2}
                                walk(paramsplus1...)
                        }</span>
                }
        }
        <span class="cov0" title="0">walk(KeyParams{Key: "", Params: c.root})</span>
}

func (c *defaultConfigProvider) determineMergeStrategy(params ...KeyParams) maps.ParamsMergeStrategy <span class="cov8" title="1">{
        if len(params) == 0 </span><span class="cov0" title="0">{
                return maps.ParamsMergeStrategyNone
        }</span>

        <span class="cov8" title="1">var (
                strategy   maps.ParamsMergeStrategy
                prevIsRoot bool
                curr       = params[len(params)-1]
        )

        if len(params) &gt; 1 </span><span class="cov8" title="1">{
                prev := params[len(params)-2]
                prevIsRoot = prev.Key == ""

                // Inherit from parent (but not from the root unless it's set by user).
                s, found := prev.Params.GetMergeStrategy()
                if !prevIsRoot &amp;&amp; !found </span><span class="cov0" title="0">{
                        panic("invalid state, merge strategy not set on parent")</span>
                }
                <span class="cov8" title="1">if found || !prevIsRoot </span><span class="cov0" title="0">{
                        strategy = s
                }</span>
        }

        <span class="cov8" title="1">switch curr.Key </span>{
        case "":<span class="cov0" title="0"></span>
        // Don't set a merge strategy on the root unless set by user.
        // This will be handled as a special case.
        case "params":<span class="cov0" title="0">
                strategy = maps.ParamsMergeStrategyDeep</span>
        case "outputformats", "mediatypes":<span class="cov0" title="0">
                if prevIsRoot </span><span class="cov0" title="0">{
                        strategy = maps.ParamsMergeStrategyShallow
                }</span>
        case "menus":<span class="cov0" title="0">
                isMenuKey := prevIsRoot
                if !isMenuKey </span><span class="cov0" title="0">{
                        // Can also be set below languages.
                        // root &gt; languages &gt; en &gt; menus
                        if len(params) == 4 &amp;&amp; params[1].Key == "languages" </span><span class="cov0" title="0">{
                                isMenuKey = true
                        }</span>
                }
                <span class="cov0" title="0">if isMenuKey </span><span class="cov0" title="0">{
                        strategy = maps.ParamsMergeStrategyShallow
                }</span>
        default:<span class="cov8" title="1">
                if strategy == "" </span><span class="cov8" title="1">{
                        strategy = maps.ParamsMergeStrategyNone
                }</span>
        }

        <span class="cov8" title="1">return strategy</span>
}

type KeyParams struct {
        Key    string
        Params maps.Params
}

func (c *defaultConfigProvider) SetDefaultMergeStrategy() <span class="cov0" title="0">{
        c.WalkParams(func(params ...KeyParams) bool </span><span class="cov0" title="0">{
                if len(params) == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov0" title="0">p := params[len(params)-1].Params
                var found bool
                if _, found = p.GetMergeStrategy(); found </span><span class="cov0" title="0">{
                        // Set by user.
                        return false
                }</span>
                <span class="cov0" title="0">strategy := c.determineMergeStrategy(params...)
                if strategy != "" </span><span class="cov0" title="0">{
                        p.SetDefaultMergeStrategy(strategy)
                }</span>
                <span class="cov0" title="0">return false</span>
        })

}

func (c *defaultConfigProvider) getNestedKeyAndMap(key string, create bool) (string, maps.Params) <span class="cov8" title="1">{
        var parts []string
        v, ok := c.keyCache.Load(key)
        if ok </span><span class="cov8" title="1">{
                parts = v.([]string)
        }</span> else<span class="cov8" title="1"> {
                parts = strings.Split(key, ".")
                c.keyCache.Store(key, parts)
        }</span>
        <span class="cov8" title="1">current := c.root
        for i := 0; i &lt; len(parts)-1; i++ </span><span class="cov8" title="1">{
                next, found := current[parts[i]]
                if !found </span><span class="cov8" title="1">{
                        if create </span><span class="cov8" title="1">{
                                next = make(maps.Params)
                                current[parts[i]] = next
                        }</span> else<span class="cov0" title="0"> {
                                return "", nil
                        }</span>
                }
                <span class="cov8" title="1">var ok bool
                current, ok = next.(maps.Params)
                if !ok </span><span class="cov0" title="0">{
                        // E.g. a string, not a map that we can store values in.
                        return "", nil
                }</span>
        }
        <span class="cov8" title="1">return parts[len(parts)-1], current</span>
}
</pre>
		
		<pre class="file" id="file62" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/docshelper"
)

// This is is just some helpers used to create some JSON used in the Hugo docs.
func init() <span class="cov8" title="1">{
        docsProvider := func() docshelper.DocProvider </span><span class="cov0" title="0">{

                cfg := New()
                for _, configRoot := range ConfigRootKeys </span><span class="cov0" title="0">{
                        cfg.Set(configRoot, make(maps.Params))
                }</span>
                <span class="cov0" title="0">lang := maps.Params{
                        "en": maps.Params{
                                "menus":  maps.Params{},
                                "params": maps.Params{},
                        },
                }
                cfg.Set("languages", lang)
                cfg.SetDefaultMergeStrategy()

                configHelpers := map[string]interface{}{
                        "mergeStrategy": cfg.Get(""),
                }
                return docshelper.DocProvider{"config": configHelpers}</span>
        }

        <span class="cov8" title="1">docshelper.AddDocProviderFunc(docsProvider)</span>
}
</pre>
		
		<pre class="file" id="file63" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package config

import (
        "os"
        "runtime"
        "strconv"
        "strings"
)

// GetNumWorkerMultiplier returns the base value used to calculate the number
// of workers to use for Hugo's parallel execution.
// It returns the value in HUGO_NUMWORKERMULTIPLIER OS env variable if set to a
// positive integer, else the number of logical CPUs.
func GetNumWorkerMultiplier() int <span class="cov0" title="0">{
        if gmp := os.Getenv("HUGO_NUMWORKERMULTIPLIER"); gmp != "" </span><span class="cov0" title="0">{
                if p, err := strconv.Atoi(gmp); err == nil &amp;&amp; p &gt; 0 </span><span class="cov0" title="0">{
                        return p
                }</span>
        }
        <span class="cov0" title="0">return runtime.NumCPU()</span>
}

// SetEnvVars sets vars on the form key=value in the oldVars slice.
func SetEnvVars(oldVars *[]string, keyValues ...string) <span class="cov8" title="1">{
        for i := 0; i &lt; len(keyValues); i += 2 </span><span class="cov8" title="1">{
                setEnvVar(oldVars, keyValues[i], keyValues[i+1])
        }</span>
}

func SplitEnvVar(v string) (string, string) <span class="cov8" title="1">{
        parts := strings.SplitN(v, "=", 2)
        return parts[0], parts[1]
}</span>

func setEnvVar(vars *[]string, key, value string) <span class="cov8" title="1">{
        for i := range *vars </span><span class="cov8" title="1">{
                if strings.HasPrefix((*vars)[i], key+"=") </span><span class="cov8" title="1">{
                        (*vars)[i] = key + "=" + value
                        return
                }</span>
        }
        // New var.
        <span class="cov8" title="1">*vars = append(*vars, key+"="+value)</span>
}
</pre>
		
		<pre class="file" id="file64" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package privacy

import (
        "github.com/gohugoio/hugo/config"
        "github.com/mitchellh/mapstructure"
)

const privacyConfigKey = "privacy"

// Service is the common values for a service in a policy definition.
type Service struct {
        Disable bool
}

// Config is a privacy configuration for all the relevant services in Hugo.
type Config struct {
        Disqus          Disqus
        GoogleAnalytics GoogleAnalytics
        Instagram       Instagram
        Twitter         Twitter
        Vimeo           Vimeo
        YouTube         YouTube
}

// Disqus holds the privacy configuration settings related to the Disqus template.
type Disqus struct {
        Service `mapstructure:",squash"`
}

// GoogleAnalytics holds the privacy configuration settings related to the Google Analytics template.
type GoogleAnalytics struct {
        Service `mapstructure:",squash"`

        // Enabling this will disable the use of Cookies and use Session Storage to Store the GA Client ID.
        UseSessionStorage bool

        // Enabling this will make the GA templates respect the
        // "Do Not Track" HTTP header. See  https://www.paulfurley.com/google-analytics-dnt/.
        RespectDoNotTrack bool

        // Enabling this will make it so the users' IP addresses are anonymized within Google Analytics.
        AnonymizeIP bool
}

// Instagram holds the privacy configuration settings related to the Instagram shortcode.
type Instagram struct {
        Service `mapstructure:",squash"`

        // If simple mode is enabled, a static and no-JS version of the Instagram
        // image card will be built.
        Simple bool
}

// Twitter holds the privacy configuration settingsrelated to the Twitter shortcode.
type Twitter struct {
        Service `mapstructure:",squash"`

        // When set to true, the Tweet and its embedded page on your site are not used
        // for purposes that include personalized suggestions and personalized ads.
        EnableDNT bool

        // If simple mode is enabled, a static and no-JS version of the Tweet will be built.
        Simple bool
}

// Vimeo holds the privacy configuration settingsrelated to the Vimeo shortcode.
type Vimeo struct {
        Service `mapstructure:",squash"`

        // When set to true, the Vimeo player will be blocked from tracking any session data,
        // including all cookies and stats.
        EnableDNT bool

        // If simple mode is enabled, only a thumbnail is fetched from i.vimeocdn.com and
        // shown with a play button overlaid. If a user clicks the button, he/she will
        // be taken to the video page on vimeo.com in a new browser tab.
        Simple bool
}

// YouTube holds the privacy configuration settingsrelated to the YouTube shortcode.
type YouTube struct {
        Service `mapstructure:",squash"`

        // When you turn on privacy-enhanced mode,
        // YouTube won’t store information about visitors on your website
        // unless the user plays the embedded video.
        PrivacyEnhanced bool
}

// DecodeConfig creates a privacy Config from a given Hugo configuration.
func DecodeConfig(cfg config.Provider) (pc Config, err error) <span class="cov8" title="1">{
        if !cfg.IsSet(privacyConfigKey) </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">m := cfg.GetStringMap(privacyConfigKey)

        err = mapstructure.WeakDecode(m, &amp;pc)

        return</span>
}
</pre>
		
		<pre class="file" id="file65" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package security

import (
        "github.com/gohugoio/hugo/docshelper"
)

func init() <span class="cov8" title="1">{
        docsProvider := func() docshelper.DocProvider </span><span class="cov0" title="0">{

                return docshelper.DocProvider{"config": DefaultConfig.ToSecurityMap()}
        }</span>
        <span class="cov8" title="1">docshelper.AddDocProviderFunc(docsProvider)</span>
}
</pre>
		
		<pre class="file" id="file66" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package security

import (
        "bytes"
        "encoding/json"
        "errors"
        "fmt"
        "reflect"
        "strings"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/parser"
        "github.com/gohugoio/hugo/parser/metadecoders"
        "github.com/mitchellh/mapstructure"
)

const securityConfigKey = "security"

// DefaultConfig holds the default security policy.
var DefaultConfig = Config{
        Exec: Exec{
                Allow: NewWhitelist(
                        "^dart-sass-embedded$",
                        "^go$",  // for Go Modules
                        "^npx$", // used by all Node tools (Babel, PostCSS).
                        "^postcss$",
                ),
                // These have been tested to work with Hugo's external programs
                // on Windows, Linux and MacOS.
                OsEnv: NewWhitelist("(?i)^(PATH|PATHEXT|APPDATA|TMP|TEMP|TERM)$"),
        },
        Funcs: Funcs{
                Getenv: NewWhitelist("^HUGO_"),
        },
        HTTP: HTTP{
                URLs:    NewWhitelist(".*"),
                Methods: NewWhitelist("(?i)GET|POST"),
        },
}

// Config is the top level security config.
type Config struct {
        // Restricts access to os.Exec.
        Exec Exec `json:"exec"`

        // Restricts access to certain template funcs.
        Funcs Funcs `json:"funcs"`

        // Restricts access to resources.Get, getJSON, getCSV.
        HTTP HTTP `json:"http"`

        // Allow inline shortcodes
        EnableInlineShortcodes bool `json:"enableInlineShortcodes"`
}

// Exec holds os/exec policies.
type Exec struct {
        Allow Whitelist `json:"allow"`
        OsEnv Whitelist `json:"osEnv"`
}

// Funcs holds template funcs policies.
type Funcs struct {
        // OS env keys allowed to query in os.Getenv.
        Getenv Whitelist `json:"getenv"`
}

type HTTP struct {
        // URLs to allow in remote HTTP (resources.Get, getJSON, getCSV).
        URLs Whitelist `json:"urls"`

        // HTTP methods to allow.
        Methods Whitelist `json:"methods"`
}

// ToTOML converts c to TOML with [security] as the root.
func (c Config) ToTOML() string <span class="cov8" title="1">{
        sec := c.ToSecurityMap()

        var b bytes.Buffer

        if err := parser.InterfaceToConfig(sec, metadecoders.TOML, &amp;b); err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return strings.TrimSpace(b.String())</span>
}

func (c Config) CheckAllowedExec(name string) error <span class="cov0" title="0">{
        if !c.Exec.Allow.Accept(name) </span><span class="cov0" title="0">{
                return &amp;AccessDeniedError{
                        name:     name,
                        path:     "security.exec.allow",
                        policies: c.ToTOML(),
                }
        }</span>
        <span class="cov0" title="0">return nil</span>

}

func (c Config) CheckAllowedGetEnv(name string) error <span class="cov0" title="0">{
        if !c.Funcs.Getenv.Accept(name) </span><span class="cov0" title="0">{
                return &amp;AccessDeniedError{
                        name:     name,
                        path:     "security.funcs.getenv",
                        policies: c.ToTOML(),
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c Config) CheckAllowedHTTPURL(url string) error <span class="cov0" title="0">{
        if !c.HTTP.URLs.Accept(url) </span><span class="cov0" title="0">{
                return &amp;AccessDeniedError{
                        name:     url,
                        path:     "security.http.urls",
                        policies: c.ToTOML(),
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (c Config) CheckAllowedHTTPMethod(method string) error <span class="cov0" title="0">{
        if !c.HTTP.Methods.Accept(method) </span><span class="cov0" title="0">{
                return &amp;AccessDeniedError{
                        name:     method,
                        path:     "security.http.method",
                        policies: c.ToTOML(),
                }
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// ToSecurityMap converts c to a map with 'security' as the root key.
func (c Config) ToSecurityMap() map[string]interface{} <span class="cov8" title="1">{
        // Take it to JSON and back to get proper casing etc.
        asJson, err := json.Marshal(c)
        herrors.Must(err)
        m := make(map[string]interface{})
        herrors.Must(json.Unmarshal(asJson, &amp;m))

        // Add the root
        sec := map[string]interface{}{
                "security": m,
        }
        return sec

}</span>

// DecodeConfig creates a privacy Config from a given Hugo configuration.
func DecodeConfig(cfg config.Provider) (Config, error) <span class="cov8" title="1">{
        sc := DefaultConfig
        if cfg.IsSet(securityConfigKey) </span><span class="cov8" title="1">{
                m := cfg.GetStringMap(securityConfigKey)
                dec, err := mapstructure.NewDecoder(
                        &amp;mapstructure.DecoderConfig{
                                WeaklyTypedInput: true,
                                Result:           &amp;sc,
                                DecodeHook:       stringSliceToWhitelistHook(),
                        },
                )
                if err != nil </span><span class="cov0" title="0">{
                        return sc, err
                }</span>

                <span class="cov8" title="1">if err = dec.Decode(m); err != nil </span><span class="cov0" title="0">{
                        return sc, err
                }</span>
        }

        <span class="cov8" title="1">if !sc.EnableInlineShortcodes </span><span class="cov8" title="1">{
                // Legacy
                sc.EnableInlineShortcodes = cfg.GetBool("enableInlineShortcodes")
        }</span>

        <span class="cov8" title="1">return sc, nil</span>

}

func stringSliceToWhitelistHook() mapstructure.DecodeHookFuncType <span class="cov8" title="1">{
        return func(
                f reflect.Type,
                t reflect.Type,
                data interface{}) (interface{}, error) </span><span class="cov8" title="1">{

                if t != reflect.TypeOf(Whitelist{}) </span><span class="cov8" title="1">{
                        return data, nil
                }</span>

                <span class="cov8" title="1">wl := types.ToStringSlicePreserveString(data)

                return NewWhitelist(wl...), nil</span>

        }
}

// AccessDeniedError represents a security policy conflict.
type AccessDeniedError struct {
        path     string
        name     string
        policies string
}

func (e *AccessDeniedError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("access denied: %q is not whitelisted in policy %q; the current security configuration is:\n\n%s\n\n", e.name, e.path, e.policies)
}</span>

// IsAccessDenied reports whether err is an AccessDeniedError
func IsAccessDenied(err error) bool <span class="cov0" title="0">{
        var notFoundErr *AccessDeniedError
        return errors.As(err, &amp;notFoundErr)
}</span>
</pre>
		
		<pre class="file" id="file67" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package security

import (
        "encoding/json"
        "fmt"
        "regexp"
        "strings"
)

const (
        acceptNoneKeyword = "none"
)

// Whitelist holds a whitelist.
type Whitelist struct {
        acceptNone bool
        patterns   []*regexp.Regexp

        // Store this for debugging/error reporting
        patternsStrings []string
}

func (w Whitelist) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        if w.acceptNone </span><span class="cov0" title="0">{
                return json.Marshal(acceptNoneKeyword)
        }</span>

        <span class="cov8" title="1">return json.Marshal(w.patternsStrings)</span>
}

// NewWhitelist creates a new Whitelist from zero or more patterns.
// An empty patterns list or a pattern with the value 'none' will create
// a whitelist that will Accept noone.
func NewWhitelist(patterns ...string) Whitelist <span class="cov8" title="1">{
        if len(patterns) == 0 </span><span class="cov8" title="1">{
                return Whitelist{acceptNone: true}
        }</span>

        <span class="cov8" title="1">var acceptSome bool
        var patternsStrings []string

        for _, p := range patterns </span><span class="cov8" title="1">{
                if p == acceptNoneKeyword </span><span class="cov8" title="1">{
                        acceptSome = false
                        break</span>
                }

                <span class="cov8" title="1">if ps := strings.TrimSpace(p); ps != "" </span><span class="cov8" title="1">{
                        acceptSome = true
                        patternsStrings = append(patternsStrings, ps)
                }</span>
        }

        <span class="cov8" title="1">if !acceptSome </span><span class="cov8" title="1">{
                return Whitelist{
                        acceptNone: true,
                }
        }</span>

        <span class="cov8" title="1">var patternsr []*regexp.Regexp

        for i := 0; i &lt; len(patterns); i++ </span><span class="cov8" title="1">{
                p := strings.TrimSpace(patterns[i])
                if p == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">patternsr = append(patternsr, regexp.MustCompile(p))</span>
        }

        <span class="cov8" title="1">return Whitelist{patterns: patternsr, patternsStrings: patternsStrings}</span>
}

// Accepted reports whether name is whitelisted.
func (w Whitelist) Accept(name string) bool <span class="cov8" title="1">{
        if w.acceptNone </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, p := range w.patterns </span><span class="cov8" title="1">{
                if p.MatchString(name) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (w Whitelist) String() string <span class="cov0" title="0">{
        return fmt.Sprint(w.patternsStrings)
}</span>
</pre>
		
		<pre class="file" id="file68" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package services

import (
        "github.com/gohugoio/hugo/config"
        "github.com/mitchellh/mapstructure"
)

const (
        servicesConfigKey = "services"

        disqusShortnameKey = "disqusshortname"
        googleAnalyticsKey = "googleanalytics"
        rssLimitKey        = "rssLimit"
)

// Config is a privacy configuration for all the relevant services in Hugo.
type Config struct {
        Disqus          Disqus
        GoogleAnalytics GoogleAnalytics
        Instagram       Instagram
        Twitter         Twitter
        RSS             RSS
}

// Disqus holds the functional configuration settings related to the Disqus template.
type Disqus struct {
        // A Shortname is the unique identifier assigned to a Disqus site.
        Shortname string
}

// GoogleAnalytics holds the functional configuration settings related to the Google Analytics template.
type GoogleAnalytics struct {
        // The GA tracking ID.
        ID string
}

// Instagram holds the functional configuration settings related to the Instagram shortcodes.
type Instagram struct {
        // The Simple variant of the Instagram is decorated with Bootstrap 4 card classes.
        // This means that if you use Bootstrap 4 or want to provide your own CSS, you want
        // to disable the inline CSS provided by Hugo.
        DisableInlineCSS bool

        // App or Client Access Token.
        // If you are using a Client Access Token, remember that you must combine it with your App ID
        // using a pipe symbol (&lt;APPID&gt;|&lt;CLIENTTOKEN&gt;) otherwise the request will fail.
        AccessToken string
}

// Twitter holds the functional configuration settings related to the Twitter shortcodes.
type Twitter struct {
        // The Simple variant of Twitter is decorated with a basic set of inline styles.
        // This means that if you want to provide your own CSS, you want
        // to disable the inline CSS provided by Hugo.
        DisableInlineCSS bool
}

// RSS holds the functional configuration settings related to the RSS feeds.
type RSS struct {
        // Limit the number of pages.
        Limit int
}

// DecodeConfig creates a services Config from a given Hugo configuration.
func DecodeConfig(cfg config.Provider) (c Config, err error) <span class="cov8" title="1">{
        m := cfg.GetStringMap(servicesConfigKey)

        err = mapstructure.WeakDecode(m, &amp;c)

        // Keep backwards compatibility.
        if c.GoogleAnalytics.ID == "" </span><span class="cov8" title="1">{
                // Try the global config
                c.GoogleAnalytics.ID = cfg.GetString(googleAnalyticsKey)
        }</span>
        <span class="cov8" title="1">if c.Disqus.Shortname == "" </span><span class="cov8" title="1">{
                c.Disqus.Shortname = cfg.GetString(disqusShortnameKey)
        }</span>

        <span class="cov8" title="1">if c.RSS.Limit == 0 </span><span class="cov8" title="1">{
                c.RSS.Limit = cfg.GetInt(rssLimitKey)
        }</span>

        <span class="cov8" title="1">return</span>
}
</pre>
		
		<pre class="file" id="file69" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package create provides functions to create new content.
package create

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/gohugoio/hugo/common/hexec"
        "github.com/gohugoio/hugo/common/paths"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugolib"
        "github.com/spf13/afero"
)

const (
        // DefaultArchetypeTemplateTemplate is the template used in 'hugo new site'
        // and the template we use as a fall back.
        DefaultArchetypeTemplateTemplate = `---
title: "{{ replace .Name "-" " " | title }}"
date: {{ .Date }}
draft: true
---

`
)

// NewContent creates a new content file in h (or a full bundle if the archetype is a directory)
// in targetPath.
func NewContent(h *hugolib.HugoSites, kind, targetPath string) error <span class="cov8" title="1">{
        if h.BaseFs.Content.Dirs == nil </span><span class="cov0" title="0">{
                return errors.New("no existing content directory configured for this project")
        }</span>

        <span class="cov8" title="1">cf := hugolib.NewContentFactory(h)

        if kind == "" </span><span class="cov8" title="1">{
                var err error
                kind, err = cf.SectionFromFilename(targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">b := &amp;contentBuilder{
                archeTypeFs: h.PathSpec.BaseFs.Archetypes.Fs,
                sourceFs:    h.PathSpec.Fs.Source,
                ps:          h.PathSpec,
                h:           h,
                cf:          cf,

                kind:       kind,
                targetPath: targetPath,
        }

        ext := paths.Ext(targetPath)

        b.setArcheTypeFilenameToUse(ext)

        withBuildLock := func() (string, error) </span><span class="cov8" title="1">{
                unlock, err := h.BaseFs.LockBuild()
                if err != nil </span><span class="cov0" title="0">{
                        return "", fmt.Errorf("failed to acquire a build lock: %s", err)
                }</span>
                <span class="cov8" title="1">defer unlock()

                if b.isDir </span><span class="cov8" title="1">{
                        return "", b.buildDir()
                }</span>

                <span class="cov8" title="1">if ext == "" </span><span class="cov0" title="0">{
                        return "", errors.Errorf("failed to resolve %q to a archetype template", targetPath)
                }</span>

                <span class="cov8" title="1">if !files.IsContentFile(b.targetPath) </span><span class="cov8" title="1">{
                        return "", errors.Errorf("target path %q is not a known content format", b.targetPath)
                }</span>

                <span class="cov8" title="1">return b.buildFile()</span>

        }

        <span class="cov8" title="1">filename, err := withBuildLock()
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if filename != "" </span><span class="cov8" title="1">{
                return b.openInEditorIfConfigured(filename)
        }</span>

        <span class="cov8" title="1">return nil</span>

}

type contentBuilder struct {
        archeTypeFs afero.Fs
        sourceFs    afero.Fs

        ps *helpers.PathSpec
        h  *hugolib.HugoSites
        cf hugolib.ContentFactory

        // Builder state
        archetypeFilename string
        targetPath        string
        kind              string
        isDir             bool
        dirMap            archetypeMap
}

func (b *contentBuilder) buildDir() error <span class="cov8" title="1">{
        // Split the dir into content files and the rest.
        if err := b.mapArcheTypeDir(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var contentTargetFilenames []string
        var baseDir string

        for _, fi := range b.dirMap.contentFiles </span><span class="cov8" title="1">{
                targetFilename := filepath.Join(b.targetPath, strings.TrimPrefix(fi.Meta().Path, b.archetypeFilename))
                abs, err := b.cf.CreateContentPlaceHolder(targetFilename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if baseDir == "" </span><span class="cov8" title="1">{
                        baseDir = strings.TrimSuffix(abs, targetFilename)
                }</span>

                <span class="cov8" title="1">contentTargetFilenames = append(contentTargetFilenames, abs)</span>
        }

        <span class="cov8" title="1">var contentInclusionFilter *glob.FilenameFilter
        if !b.dirMap.siteUsed </span><span class="cov8" title="1">{
                // We don't need to build everything.
                contentInclusionFilter = glob.NewFilenameFilterForInclusionFunc(func(filename string) bool </span><span class="cov8" title="1">{
                        filename = strings.TrimPrefix(filename, string(os.PathSeparator))
                        for _, cn := range contentTargetFilenames </span><span class="cov8" title="1">{
                                if strings.Contains(cn, filename) </span><span class="cov8" title="1">{
                                        return true
                                }</span>
                        }
                        <span class="cov8" title="1">return false</span>
                })

        }

        <span class="cov8" title="1">if err := b.h.Build(hugolib.BuildCfg{NoBuildLock: true, SkipRender: true, ContentInclusionFilter: contentInclusionFilter}); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for i, filename := range contentTargetFilenames </span><span class="cov8" title="1">{
                if err := b.applyArcheType(filename, b.dirMap.contentFiles[i].Meta().Path); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Copy the rest as is.
        <span class="cov8" title="1">for _, f := range b.dirMap.otherFiles </span><span class="cov8" title="1">{
                meta := f.Meta()
                filename := meta.Path

                in, err := meta.Open()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to open non-content file")
                }</span>

                <span class="cov8" title="1">targetFilename := filepath.Join(baseDir, b.targetPath, strings.TrimPrefix(filename, b.archetypeFilename))
                targetDir := filepath.Dir(targetFilename)

                if err := b.sourceFs.MkdirAll(targetDir, 0o777); err != nil &amp;&amp; !os.IsExist(err) </span><span class="cov0" title="0">{
                        return errors.Wrapf(err, "failed to create target directory for %q", targetDir)
                }</span>

                <span class="cov8" title="1">out, err := b.sourceFs.Create(targetFilename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">_, err = io.Copy(out, in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">in.Close()
                out.Close()</span>
        }

        <span class="cov8" title="1">b.h.Log.Printf("Content dir %q created", filepath.Join(baseDir, b.targetPath))

        return nil</span>
}

func (b *contentBuilder) buildFile() (string, error) <span class="cov8" title="1">{
        contentPlaceholderAbsFilename, err := b.cf.CreateContentPlaceHolder(b.targetPath)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">usesSite, err := b.usesSiteVar(b.archetypeFilename)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">var contentInclusionFilter *glob.FilenameFilter
        if !usesSite </span><span class="cov8" title="1">{
                // We don't need to build everything.
                contentInclusionFilter = glob.NewFilenameFilterForInclusionFunc(func(filename string) bool </span><span class="cov8" title="1">{
                        filename = strings.TrimPrefix(filename, string(os.PathSeparator))
                        return strings.Contains(contentPlaceholderAbsFilename, filename)
                }</span>)
        }

        <span class="cov8" title="1">if err := b.h.Build(hugolib.BuildCfg{NoBuildLock: true, SkipRender: true, ContentInclusionFilter: contentInclusionFilter}); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if err := b.applyArcheType(contentPlaceholderAbsFilename, b.archetypeFilename); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">b.h.Log.Printf("Content %q created", contentPlaceholderAbsFilename)

        return contentPlaceholderAbsFilename, nil</span>
}

func (b *contentBuilder) setArcheTypeFilenameToUse(ext string) <span class="cov8" title="1">{
        var pathsToCheck []string

        if b.kind != "" </span><span class="cov8" title="1">{
                pathsToCheck = append(pathsToCheck, b.kind+ext)
        }</span>

        <span class="cov8" title="1">pathsToCheck = append(pathsToCheck, "default"+ext)

        for _, p := range pathsToCheck </span><span class="cov8" title="1">{
                fi, err := b.archeTypeFs.Stat(p)
                if err == nil </span><span class="cov8" title="1">{
                        b.archetypeFilename = p
                        b.isDir = fi.IsDir()
                        return
                }</span>
        }

}

func (b *contentBuilder) applyArcheType(contentFilename, archetypeFilename string) error <span class="cov8" title="1">{
        p := b.h.GetContentPage(contentFilename)
        if p == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("[BUG] no Page found for %q", contentFilename))</span>
        }

        <span class="cov8" title="1">f, err := b.sourceFs.Create(contentFilename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        if archetypeFilename == "" </span><span class="cov8" title="1">{
                return b.cf.AppplyArchetypeTemplate(f, p, b.kind, DefaultArchetypeTemplateTemplate)
        }</span>

        <span class="cov8" title="1">return b.cf.AppplyArchetypeFilename(f, p, b.kind, archetypeFilename)</span>

}

func (b *contentBuilder) mapArcheTypeDir() error <span class="cov8" title="1">{
        var m archetypeMap

        walkFn := func(path string, fi hugofs.FileMetaInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if fi.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">fil := fi.(hugofs.FileMetaInfo)

                if files.IsContentFile(path) </span><span class="cov8" title="1">{
                        m.contentFiles = append(m.contentFiles, fil)
                        if !m.siteUsed </span><span class="cov8" title="1">{
                                m.siteUsed, err = b.usesSiteVar(path)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                }

                <span class="cov8" title="1">m.otherFiles = append(m.otherFiles, fil)

                return nil</span>
        }

        <span class="cov8" title="1">walkCfg := hugofs.WalkwayConfig{
                WalkFn: walkFn,
                Fs:     b.archeTypeFs,
                Root:   b.archetypeFilename,
        }

        w := hugofs.NewWalkway(walkCfg)

        if err := w.Walk(); err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to walk archetype dir %q", b.archetypeFilename)
        }</span>

        <span class="cov8" title="1">b.dirMap = m

        return nil</span>
}

func (b *contentBuilder) openInEditorIfConfigured(filename string) error <span class="cov8" title="1">{
        editor := b.h.Cfg.GetString("newContentEditor")
        if editor == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">editorExec := strings.Fields(editor)[0]
        editorFlags := strings.Fields(editor)[1:]

        var args []interface{}
        for _, editorFlag := range editorFlags </span><span class="cov0" title="0">{
                args = append(args, editorFlag)
        }</span>
        <span class="cov0" title="0">args = append(
                args,
                filename,
                hexec.WithStdin(os.Stdin),
                hexec.WithStderr(os.Stderr),
                hexec.WithStdout(os.Stdout),
        )

        b.h.Log.Printf("Editing %q with %q ...\n", filename, editorExec)

        cmd, err := b.h.Deps.ExecHelper.New(editorExec, args...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return cmd.Run()</span>
}

func (b *contentBuilder) usesSiteVar(filename string) (bool, error) <span class="cov8" title="1">{
        if filename == "" </span><span class="cov8" title="1">{
                return false, nil
        }</span>
        <span class="cov8" title="1">bb, err := afero.ReadFile(b.archeTypeFs, filename)
        if err != nil </span><span class="cov0" title="0">{
                return false, errors.Wrap(err, "failed to open archetype file")
        }</span>

        <span class="cov8" title="1">return bytes.Contains(bb, []byte(".Site")) || bytes.Contains(bb, []byte("site.")), nil</span>

}

type archetypeMap struct {
        // These needs to be parsed and executed as Go templates.
        contentFiles []hugofs.FileMetaInfo
        // These are just copied to destination.
        otherFiles []hugofs.FileMetaInfo
        // If the templates needs a fully built site. This can potentially be
        // expensive, so only do when needed.
        siteUsed bool
}
</pre>
		
		<pre class="file" id="file70" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +build !nodeploy

package deploy

import (
        "context"
        "time"

        "github.com/aws/aws-sdk-go/aws"
        "github.com/aws/aws-sdk-go/aws/session"
        "github.com/aws/aws-sdk-go/service/cloudfront"
)

// InvalidateCloudFront invalidates the CloudFront cache for distributionID.
// It uses the default AWS credentials from the environment.
func InvalidateCloudFront(ctx context.Context, distributionID string) error <span class="cov0" title="0">{
        // SharedConfigEnable enables loading "shared config (~/.aws/config) and
        // shared credentials (~/.aws/credentials) files".
        // See https://docs.aws.amazon.com/sdk-for-go/api/aws/session/ for more
        // details.
        // This is the same codepath used by Go CDK when creating an s3 URL.
        // TODO: Update this to a Go CDK helper once available
        // (https://github.com/google/go-cloud/issues/2003).
        sess, err := session.NewSessionWithOptions(session.Options{SharedConfigState: session.SharedConfigEnable})
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">req := &amp;cloudfront.CreateInvalidationInput{
                DistributionId: aws.String(distributionID),
                InvalidationBatch: &amp;cloudfront.InvalidationBatch{
                        CallerReference: aws.String(time.Now().Format("20060102150405")),
                        Paths: &amp;cloudfront.Paths{
                                Items:    []*string{aws.String("/*")},
                                Quantity: aws.Int64(1),
                        },
                },
        }
        _, err = cloudfront.New(sess).CreateInvalidationWithContext(ctx, req)
        return err</span>
}
</pre>
		
		<pre class="file" id="file71" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +build !nodeploy

package deploy

import (
        "bytes"
        "compress/gzip"
        "context"
        "crypto/md5"
        "fmt"
        "io"
        "io/ioutil"
        "mime"
        "os"
        "path/filepath"
        "regexp"
        "runtime"
        "sort"
        "strings"
        "sync"

        "github.com/dustin/go-humanize"
        "github.com/gobwas/glob"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/media"
        "github.com/pkg/errors"
        "github.com/spf13/afero"
        jww "github.com/spf13/jwalterweatherman"
        "golang.org/x/text/unicode/norm"

        "gocloud.dev/blob"
        _ "gocloud.dev/blob/fileblob" // import
        _ "gocloud.dev/blob/gcsblob"  // import
        _ "gocloud.dev/blob/s3blob"   // import
        "gocloud.dev/gcerrors"
)

// Deployer supports deploying the site to target cloud providers.
type Deployer struct {
        localFs afero.Fs
        bucket  *blob.Bucket

        target        *target          // the target to deploy to
        matchers      []*matcher       // matchers to apply to uploaded files
        mediaTypes    media.Types      // Hugo's MediaType to guess ContentType
        ordering      []*regexp.Regexp // orders uploads
        quiet         bool             // true reduces STDOUT
        confirm       bool             // true enables confirmation before making changes
        dryRun        bool             // true skips conformations and prints changes instead of applying them
        force         bool             // true forces upload of all files
        invalidateCDN bool             // true enables invalidate CDN cache (if possible)
        maxDeletes    int              // caps the # of files to delete; -1 to disable

        // For tests...
        summary deploySummary // summary of latest Deploy results
}

type deploySummary struct {
        NumLocal, NumRemote, NumUploads, NumDeletes int
}

// New constructs a new *Deployer.
func New(cfg config.Provider, localFs afero.Fs) (*Deployer, error) <span class="cov0" title="0">{
        targetName := cfg.GetString("target")

        // Load the [deployment] section of the config.
        dcfg, err := decodeConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if len(dcfg.Targets) == 0 </span><span class="cov0" title="0">{
                return nil, errors.New("no deployment targets found")
        }</span>

        // Find the target to deploy to.
        <span class="cov0" title="0">var tgt *target
        if targetName == "" </span><span class="cov0" title="0">{
                // Default to the first target.
                tgt = dcfg.Targets[0]
        }</span> else<span class="cov0" title="0"> {
                for _, t := range dcfg.Targets </span><span class="cov0" title="0">{
                        if t.Name == targetName </span><span class="cov0" title="0">{
                                tgt = t
                        }</span>
                }
                <span class="cov0" title="0">if tgt == nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("deployment target %q not found", targetName)
                }</span>
        }

        <span class="cov0" title="0">return &amp;Deployer{
                localFs:       localFs,
                target:        tgt,
                matchers:      dcfg.Matchers,
                ordering:      dcfg.ordering,
                mediaTypes:    dcfg.mediaTypes,
                quiet:         cfg.GetBool("quiet"),
                confirm:       cfg.GetBool("confirm"),
                dryRun:        cfg.GetBool("dryRun"),
                force:         cfg.GetBool("force"),
                invalidateCDN: cfg.GetBool("invalidateCDN"),
                maxDeletes:    cfg.GetInt("maxDeletes"),
        }, nil</span>
}

func (d *Deployer) openBucket(ctx context.Context) (*blob.Bucket, error) <span class="cov8" title="1">{
        if d.bucket != nil </span><span class="cov8" title="1">{
                return d.bucket, nil
        }</span>
        <span class="cov0" title="0">jww.FEEDBACK.Printf("Deploying to target %q (%s)\n", d.target.Name, d.target.URL)
        return blob.OpenBucket(ctx, d.target.URL)</span>
}

// Deploy deploys the site to a target.
func (d *Deployer) Deploy(ctx context.Context) error <span class="cov8" title="1">{
        bucket, err := d.openBucket(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Load local files from the source directory.
        <span class="cov8" title="1">var include, exclude glob.Glob
        if d.target != nil </span><span class="cov8" title="1">{
                include, exclude = d.target.includeGlob, d.target.excludeGlob
        }</span>
        <span class="cov8" title="1">local, err := walkLocal(d.localFs, d.matchers, include, exclude, d.mediaTypes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">jww.INFO.Printf("Found %d local files.\n", len(local))
        d.summary.NumLocal = len(local)

        // Load remote files from the target.
        remote, err := walkRemote(ctx, bucket, include, exclude)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">jww.INFO.Printf("Found %d remote files.\n", len(remote))
        d.summary.NumRemote = len(remote)

        // Diff local vs remote to see what changes need to be applied.
        uploads, deletes := findDiffs(local, remote, d.force)
        d.summary.NumUploads = len(uploads)
        d.summary.NumDeletes = len(deletes)
        if len(uploads)+len(deletes) == 0 </span><span class="cov8" title="1">{
                if !d.quiet </span><span class="cov8" title="1">{
                        jww.FEEDBACK.Println("No changes required.")
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
        <span class="cov8" title="1">if !d.quiet </span><span class="cov8" title="1">{
                jww.FEEDBACK.Println(summarizeChanges(uploads, deletes))
        }</span>

        // Ask for confirmation before proceeding.
        <span class="cov8" title="1">if d.confirm &amp;&amp; !d.dryRun </span><span class="cov0" title="0">{
                fmt.Printf("Continue? (Y/n) ")
                var confirm string
                if _, err := fmt.Scanln(&amp;confirm); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if confirm != "" &amp;&amp; confirm[0] != 'y' &amp;&amp; confirm[0] != 'Y' </span><span class="cov0" title="0">{
                        return errors.New("aborted")
                }</span>
        }

        // Order the uploads. They are organized in groups; all uploads in a group
        // must be complete before moving on to the next group.
        <span class="cov8" title="1">uploadGroups := applyOrdering(d.ordering, uploads)

        // Apply the changes in parallel, using an inverted worker
        // pool (https://www.youtube.com/watch?v=5zXAHh5tJqQ&amp;t=26m58s).
        // sem prevents more than nParallel concurrent goroutines.
        const nParallel = 10
        var errs []error
        var errMu sync.Mutex // protects errs

        for _, uploads := range uploadGroups </span><span class="cov8" title="1">{
                // Short-circuit for an empty group.
                if len(uploads) == 0 </span><span class="cov8" title="1">{
                        continue</span>
                }

                // Within the group, apply uploads in parallel.
                <span class="cov8" title="1">sem := make(chan struct{}, nParallel)
                for _, upload := range uploads </span><span class="cov8" title="1">{
                        if d.dryRun </span><span class="cov0" title="0">{
                                if !d.quiet </span><span class="cov0" title="0">{
                                        jww.FEEDBACK.Printf("[DRY RUN] Would upload: %v\n", upload)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }

                        <span class="cov8" title="1">sem &lt;- struct{}{}
                        go func(upload *fileToUpload) </span><span class="cov8" title="1">{
                                if err := doSingleUpload(ctx, bucket, upload); err != nil </span><span class="cov0" title="0">{
                                        errMu.Lock()
                                        defer errMu.Unlock()
                                        errs = append(errs, err)
                                }</span>
                                <span class="cov8" title="1">&lt;-sem</span>
                        }(upload)
                }
                // Wait for all uploads in the group to finish.
                <span class="cov8" title="1">for n := nParallel; n &gt; 0; n-- </span><span class="cov8" title="1">{
                        sem &lt;- struct{}{}
                }</span>
        }

        <span class="cov8" title="1">if d.maxDeletes != -1 &amp;&amp; len(deletes) &gt; d.maxDeletes </span><span class="cov8" title="1">{
                jww.WARN.Printf("Skipping %d deletes because it is more than --maxDeletes (%d). If this is expected, set --maxDeletes to a larger number, or -1 to disable this check.\n", len(deletes), d.maxDeletes)
                d.summary.NumDeletes = 0
        }</span> else<span class="cov8" title="1"> {
                // Apply deletes in parallel.
                sort.Slice(deletes, func(i, j int) bool </span><span class="cov8" title="1">{ return deletes[i] &lt; deletes[j] }</span>)
                <span class="cov8" title="1">sem := make(chan struct{}, nParallel)
                for _, del := range deletes </span><span class="cov8" title="1">{
                        if d.dryRun </span><span class="cov0" title="0">{
                                if !d.quiet </span><span class="cov0" title="0">{
                                        jww.FEEDBACK.Printf("[DRY RUN] Would delete %s\n", del)
                                }</span>
                                <span class="cov0" title="0">continue</span>
                        }
                        <span class="cov8" title="1">sem &lt;- struct{}{}
                        go func(del string) </span><span class="cov8" title="1">{
                                jww.INFO.Printf("Deleting %s...\n", del)
                                if err := bucket.Delete(ctx, del); err != nil </span><span class="cov0" title="0">{
                                        if gcerrors.Code(err) == gcerrors.NotFound </span><span class="cov0" title="0">{
                                                jww.WARN.Printf("Failed to delete %q because it wasn't found: %v", del, err)
                                        }</span> else<span class="cov0" title="0"> {
                                                errMu.Lock()
                                                defer errMu.Unlock()
                                                errs = append(errs, err)
                                        }</span>
                                }
                                <span class="cov8" title="1">&lt;-sem</span>
                        }(del)
                }
                // Wait for all deletes to finish.
                <span class="cov8" title="1">for n := nParallel; n &gt; 0; n-- </span><span class="cov8" title="1">{
                        sem &lt;- struct{}{}
                }</span>
        }
        <span class="cov8" title="1">if len(errs) &gt; 0 </span><span class="cov0" title="0">{
                if !d.quiet </span><span class="cov0" title="0">{
                        jww.FEEDBACK.Printf("Encountered %d errors.\n", len(errs))
                }</span>
                <span class="cov0" title="0">return errs[0]</span>
        }
        <span class="cov8" title="1">if !d.quiet </span><span class="cov8" title="1">{
                jww.FEEDBACK.Println("Success!")
        }</span>

        <span class="cov8" title="1">if d.invalidateCDN </span><span class="cov0" title="0">{
                if d.target.CloudFrontDistributionID != "" </span><span class="cov0" title="0">{
                        if d.dryRun </span><span class="cov0" title="0">{
                                if !d.quiet </span><span class="cov0" title="0">{
                                        jww.FEEDBACK.Printf("[DRY RUN] Would invalidate CloudFront CDN with ID %s\n", d.target.CloudFrontDistributionID)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                jww.FEEDBACK.Println("Invalidating CloudFront CDN...")
                                if err := InvalidateCloudFront(ctx, d.target.CloudFrontDistributionID); err != nil </span><span class="cov0" title="0">{
                                        jww.FEEDBACK.Printf("Failed to invalidate CloudFront CDN: %v\n", err)
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">if d.target.GoogleCloudCDNOrigin != "" </span><span class="cov0" title="0">{
                        if d.dryRun </span><span class="cov0" title="0">{
                                if !d.quiet </span><span class="cov0" title="0">{
                                        jww.FEEDBACK.Printf("[DRY RUN] Would invalidate Google Cloud CDN with origin %s\n", d.target.GoogleCloudCDNOrigin)
                                }</span>
                        } else<span class="cov0" title="0"> {
                                jww.FEEDBACK.Println("Invalidating Google Cloud CDN...")
                                if err := InvalidateGoogleCloudCDN(ctx, d.target.GoogleCloudCDNOrigin); err != nil </span><span class="cov0" title="0">{
                                        jww.FEEDBACK.Printf("Failed to invalidate Google Cloud CDN: %v\n", err)
                                        return err
                                }</span>
                        }
                }
                <span class="cov0" title="0">jww.FEEDBACK.Println("Success!")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// summarizeChanges creates a text description of the proposed changes.
func summarizeChanges(uploads []*fileToUpload, deletes []string) string <span class="cov8" title="1">{
        uploadSize := int64(0)
        for _, u := range uploads </span><span class="cov8" title="1">{
                uploadSize += u.Local.UploadSize
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("Identified %d file(s) to upload, totaling %s, and %d file(s) to delete.", len(uploads), humanize.Bytes(uint64(uploadSize)), len(deletes))</span>
}

// doSingleUpload executes a single file upload.
func doSingleUpload(ctx context.Context, bucket *blob.Bucket, upload *fileToUpload) error <span class="cov8" title="1">{
        jww.INFO.Printf("Uploading %v...\n", upload)
        opts := &amp;blob.WriterOptions{
                CacheControl:    upload.Local.CacheControl(),
                ContentEncoding: upload.Local.ContentEncoding(),
                ContentType:     upload.Local.ContentType(),
        }
        w, err := bucket.NewWriter(ctx, upload.Local.SlashPath, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r, err := upload.Local.Reader()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">defer r.Close()
        _, err = io.Copy(w, r)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := w.Close(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// localFile represents a local file from the source. Use newLocalFile to
// construct one.
type localFile struct {
        // NativePath is the native path to the file (using file.Separator).
        NativePath string
        // SlashPath is NativePath converted to use /.
        SlashPath string
        // UploadSize is the size of the content to be uploaded. It may not
        // be the same as the local file size if the content will be
        // gzipped before upload.
        UploadSize int64

        fs         afero.Fs
        matcher    *matcher
        md5        []byte       // cache
        gzipped    bytes.Buffer // cached of gzipped contents if gzipping
        mediaTypes media.Types
}

// newLocalFile initializes a *localFile.
func newLocalFile(fs afero.Fs, nativePath, slashpath string, m *matcher, mt media.Types) (*localFile, error) <span class="cov8" title="1">{
        f, err := fs.Open(nativePath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer f.Close()
        lf := &amp;localFile{
                NativePath: nativePath,
                SlashPath:  slashpath,
                fs:         fs,
                matcher:    m,
                mediaTypes: mt,
        }
        if m != nil &amp;&amp; m.Gzip </span><span class="cov8" title="1">{
                // We're going to gzip the content. Do it once now, and cache the result
                // in gzipped. The UploadSize is the size of the gzipped content.
                gz := gzip.NewWriter(&amp;lf.gzipped)
                if _, err := io.Copy(gz, f); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if err := gz.Close(); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">lf.UploadSize = int64(lf.gzipped.Len())</span>
        } else<span class="cov8" title="1"> {
                // Raw content. Just get the UploadSize.
                info, err := f.Stat()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">lf.UploadSize = info.Size()</span>
        }
        <span class="cov8" title="1">return lf, nil</span>
}

// Reader returns an io.ReadCloser for reading the content to be uploaded.
// The caller must call Close on the returned ReaderCloser.
// The reader content may not be the same as the local file content due to
// gzipping.
func (lf *localFile) Reader() (io.ReadCloser, error) <span class="cov8" title="1">{
        if lf.matcher != nil &amp;&amp; lf.matcher.Gzip </span><span class="cov8" title="1">{
                // We've got the gzipped contents cached in gzipped.
                // Note: we can't use lf.gzipped directly as a Reader, since we it discards
                // data after it is read, and we may read it more than once.
                return ioutil.NopCloser(bytes.NewReader(lf.gzipped.Bytes())), nil
        }</span>
        // Not expected to fail since we did it successfully earlier in newLocalFile,
        // but could happen due to changes in the underlying filesystem.
        <span class="cov8" title="1">return lf.fs.Open(lf.NativePath)</span>
}

// CacheControl returns the Cache-Control header to use for lf, based on the
// first matching matcher (if any).
func (lf *localFile) CacheControl() string <span class="cov8" title="1">{
        if lf.matcher == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">return lf.matcher.CacheControl</span>
}

// ContentEncoding returns the Content-Encoding header to use for lf, based
// on the matcher's Content-Encoding and Gzip fields.
func (lf *localFile) ContentEncoding() string <span class="cov8" title="1">{
        if lf.matcher == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if lf.matcher.Gzip </span><span class="cov8" title="1">{
                return "gzip"
        }</span>
        <span class="cov8" title="1">return lf.matcher.ContentEncoding</span>
}

// ContentType returns the Content-Type header to use for lf.
// It first checks if there's a Content-Type header configured via a matching
// matcher; if not, it tries to generate one based on the filename extension.
// If this fails, the Content-Type will be the empty string. In this case, Go
// Cloud will automatically try to infer a Content-Type based on the file
// content.
func (lf *localFile) ContentType() string <span class="cov8" title="1">{
        if lf.matcher != nil &amp;&amp; lf.matcher.ContentType != "" </span><span class="cov8" title="1">{
                return lf.matcher.ContentType
        }</span>

        <span class="cov8" title="1">ext := filepath.Ext(lf.NativePath)
        if mimeType, _, found := lf.mediaTypes.GetFirstBySuffix(strings.TrimPrefix(ext, ".")); found </span><span class="cov8" title="1">{
                return mimeType.Type()
        }</span>

        <span class="cov0" title="0">return mime.TypeByExtension(ext)</span>
}

// Force returns true if the file should be forced to re-upload based on the
// matching matcher.
func (lf *localFile) Force() bool <span class="cov8" title="1">{
        return lf.matcher != nil &amp;&amp; lf.matcher.Force
}</span>

// MD5 returns an MD5 hash of the content to be uploaded.
func (lf *localFile) MD5() []byte <span class="cov8" title="1">{
        if len(lf.md5) &gt; 0 </span><span class="cov8" title="1">{
                return lf.md5
        }</span>
        <span class="cov8" title="1">h := md5.New()
        r, err := lf.Reader()
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">defer r.Close()
        if _, err := io.Copy(h, r); err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">lf.md5 = h.Sum(nil)
        return lf.md5</span>
}

// knownHiddenDirectory checks if the specified name is a well known
// hidden directory.
func knownHiddenDirectory(name string) bool <span class="cov8" title="1">{
        knownDirectories := []string{
                ".well-known",
        }

        for _, dir := range knownDirectories </span><span class="cov8" title="1">{
                if name == dir </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// walkLocal walks the source directory and returns a flat list of files,
// using localFile.SlashPath as the map keys.
func walkLocal(fs afero.Fs, matchers []*matcher, include, exclude glob.Glob, mediaTypes media.Types) (map[string]*localFile, error) <span class="cov8" title="1">{
        retval := map[string]*localFile{}
        err := afero.Walk(fs, "", func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        // Skip hidden directories.
                        if path != "" &amp;&amp; strings.HasPrefix(info.Name(), ".") </span><span class="cov8" title="1">{
                                // Except for specific hidden directories
                                if !knownHiddenDirectory(info.Name()) </span><span class="cov8" title="1">{
                                        return filepath.SkipDir
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                }

                // .DS_Store is an internal MacOS attribute file; skip it.
                <span class="cov8" title="1">if info.Name() == ".DS_Store" </span><span class="cov0" title="0">{
                        return nil
                }</span>

                // When a file system is HFS+, its filepath is in NFD form.
                <span class="cov8" title="1">if runtime.GOOS == "darwin" </span><span class="cov0" title="0">{
                        path = norm.NFC.String(path)
                }</span>

                // Check include/exclude matchers.
                <span class="cov8" title="1">slashpath := filepath.ToSlash(path)
                if include != nil &amp;&amp; !include.Match(slashpath) </span><span class="cov8" title="1">{
                        jww.INFO.Printf("  dropping %q due to include\n", slashpath)
                        return nil
                }</span>
                <span class="cov8" title="1">if exclude != nil &amp;&amp; exclude.Match(slashpath) </span><span class="cov8" title="1">{
                        jww.INFO.Printf("  dropping %q due to exclude\n", slashpath)
                        return nil
                }</span>

                // Find the first matching matcher (if any).
                <span class="cov8" title="1">var m *matcher
                for _, cur := range matchers </span><span class="cov8" title="1">{
                        if cur.Matches(slashpath) </span><span class="cov8" title="1">{
                                m = cur
                                break</span>
                        }
                }
                <span class="cov8" title="1">lf, err := newLocalFile(fs, path, slashpath, m, mediaTypes)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">retval[lf.SlashPath] = lf
                return nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return retval, nil</span>
}

// walkRemote walks the target bucket and returns a flat list.
func walkRemote(ctx context.Context, bucket *blob.Bucket, include, exclude glob.Glob) (map[string]*blob.ListObject, error) <span class="cov8" title="1">{
        retval := map[string]*blob.ListObject{}
        iter := bucket.List(nil)
        for </span><span class="cov8" title="1">{
                obj, err := iter.Next(ctx)
                if err == io.EOF </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                // Check include/exclude matchers.
                <span class="cov8" title="1">if include != nil &amp;&amp; !include.Match(obj.Key) </span><span class="cov8" title="1">{
                        jww.INFO.Printf("  remote dropping %q due to include\n", obj.Key)
                        continue</span>
                }
                <span class="cov8" title="1">if exclude != nil &amp;&amp; exclude.Match(obj.Key) </span><span class="cov8" title="1">{
                        jww.INFO.Printf("  remote dropping %q due to exclude\n", obj.Key)
                        continue</span>
                }
                // If the remote didn't give us an MD5, compute one.
                // This can happen for some providers (e.g., fileblob, which uses the
                // local filesystem), but not for the most common Cloud providers
                // (S3, GCS, Azure). Although, it can happen for S3 if the blob was uploaded
                // via a multi-part upload.
                // Although it's unfortunate to have to read the file, it's likely better
                // than assuming a delta and re-uploading it.
                <span class="cov8" title="1">if len(obj.MD5) == 0 </span><span class="cov8" title="1">{
                        r, err := bucket.NewReader(ctx, obj.Key, nil)
                        if err == nil </span><span class="cov8" title="1">{
                                h := md5.New()
                                if _, err := io.Copy(h, r); err == nil </span><span class="cov8" title="1">{
                                        obj.MD5 = h.Sum(nil)
                                }</span>
                                <span class="cov8" title="1">r.Close()</span>
                        }
                }
                <span class="cov8" title="1">retval[obj.Key] = obj</span>
        }
        <span class="cov8" title="1">return retval, nil</span>
}

// uploadReason is an enum of reasons why a file must be uploaded.
type uploadReason string

const (
        reasonUnknown    uploadReason = "unknown"
        reasonNotFound   uploadReason = "not found at target"
        reasonForce      uploadReason = "--force"
        reasonSize       uploadReason = "size differs"
        reasonMD5Differs uploadReason = "md5 differs"
        reasonMD5Missing uploadReason = "remote md5 missing"
)

// fileToUpload represents a single local file that should be uploaded to
// the target.
type fileToUpload struct {
        Local  *localFile
        Reason uploadReason
}

func (u *fileToUpload) String() string <span class="cov0" title="0">{
        details := []string{humanize.Bytes(uint64(u.Local.UploadSize))}
        if s := u.Local.CacheControl(); s != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("Cache-Control: %q", s))
        }</span>
        <span class="cov0" title="0">if s := u.Local.ContentEncoding(); s != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("Content-Encoding: %q", s))
        }</span>
        <span class="cov0" title="0">if s := u.Local.ContentType(); s != "" </span><span class="cov0" title="0">{
                details = append(details, fmt.Sprintf("Content-Type: %q", s))
        }</span>
        <span class="cov0" title="0">return fmt.Sprintf("%s (%s): %v", u.Local.SlashPath, strings.Join(details, ", "), u.Reason)</span>
}

// findDiffs diffs localFiles vs remoteFiles to see what changes should be
// applied to the remote target. It returns a slice of *fileToUpload and a
// slice of paths for files to delete.
func findDiffs(localFiles map[string]*localFile, remoteFiles map[string]*blob.ListObject, force bool) ([]*fileToUpload, []string) <span class="cov8" title="1">{
        var uploads []*fileToUpload
        var deletes []string

        found := map[string]bool{}
        for path, lf := range localFiles </span><span class="cov8" title="1">{
                upload := false
                reason := reasonUnknown

                if remoteFile, ok := remoteFiles[path]; ok </span><span class="cov8" title="1">{
                        // The file exists in remote. Let's see if we need to upload it anyway.

                        // TODO: We don't register a diff if the metadata (e.g., Content-Type
                        // header) has changed. This would be difficult/expensive to detect; some
                        // providers return metadata along with their "List" result, but others
                        // (notably AWS S3) do not, so gocloud.dev's blob.Bucket doesn't expose
                        // it in the list result. It would require a separate request per blob
                        // to fetch. At least for now, we work around this by documenting it and
                        // providing a "force" flag (to re-upload everything) and a "force" bool
                        // per matcher (to re-upload all files in a matcher whose headers may have
                        // changed).
                        // Idea: extract a sample set of 1 file per extension + 1 file per matcher
                        // and check those files?
                        if force </span><span class="cov8" title="1">{
                                upload = true
                                reason = reasonForce
                        }</span> else<span class="cov8" title="1"> if lf.Force() </span><span class="cov8" title="1">{
                                upload = true
                                reason = reasonForce
                        }</span> else<span class="cov8" title="1"> if lf.UploadSize != remoteFile.Size </span><span class="cov8" title="1">{
                                upload = true
                                reason = reasonSize
                        }</span> else<span class="cov8" title="1"> if len(remoteFile.MD5) == 0 </span><span class="cov8" title="1">{
                                // This shouldn't happen unless the remote didn't give us an MD5 hash
                                // from List, AND we failed to compute one by reading the remote file.
                                // Default to considering the files different.
                                upload = true
                                reason = reasonMD5Missing
                        }</span> else<span class="cov8" title="1"> if !bytes.Equal(lf.MD5(), remoteFile.MD5) </span><span class="cov8" title="1">{
                                upload = true
                                reason = reasonMD5Differs
                        }</span> else <span class="cov8" title="1">{
                                // Nope! Leave uploaded = false.
                        }</span>
                        <span class="cov8" title="1">found[path] = true</span>
                } else<span class="cov8" title="1"> {
                        // The file doesn't exist in remote.
                        upload = true
                        reason = reasonNotFound
                }</span>
                <span class="cov8" title="1">if upload </span><span class="cov8" title="1">{
                        jww.DEBUG.Printf("%s needs to be uploaded: %v\n", path, reason)
                        uploads = append(uploads, &amp;fileToUpload{lf, reason})
                }</span> else<span class="cov8" title="1"> {
                        jww.DEBUG.Printf("%s exists at target and does not need to be uploaded", path)
                }</span>
        }

        // Remote files that weren't found locally should be deleted.
        <span class="cov8" title="1">for path := range remoteFiles </span><span class="cov8" title="1">{
                if !found[path] </span><span class="cov8" title="1">{
                        deletes = append(deletes, path)
                }</span>
        }
        <span class="cov8" title="1">return uploads, deletes</span>
}

// applyOrdering returns an ordered slice of slices of uploads.
//
// The returned slice will have length len(ordering)+1.
//
// The subslice at index i, for i = 0 ... len(ordering)-1, will have all of the
// uploads whose Local.SlashPath matched the regex at ordering[i] (but not any
// previous ordering regex).
// The subslice at index len(ordering) will have the remaining uploads that
// didn't match any ordering regex.
//
// The subslices are sorted by Local.SlashPath.
func applyOrdering(ordering []*regexp.Regexp, uploads []*fileToUpload) [][]*fileToUpload <span class="cov8" title="1">{
        // Sort the whole slice by Local.SlashPath first.
        sort.Slice(uploads, func(i, j int) bool </span><span class="cov8" title="1">{ return uploads[i].Local.SlashPath &lt; uploads[j].Local.SlashPath }</span>)

        <span class="cov8" title="1">retval := make([][]*fileToUpload, len(ordering)+1)
        for _, u := range uploads </span><span class="cov8" title="1">{
                matched := false
                for i, re := range ordering </span><span class="cov8" title="1">{
                        if re.MatchString(u.Local.SlashPath) </span><span class="cov8" title="1">{
                                retval[i] = append(retval[i], u)
                                matched = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !matched </span><span class="cov8" title="1">{
                        retval[len(ordering)] = append(retval[len(ordering)], u)
                }</span>
        }
        <span class="cov8" title="1">return retval</span>
}
</pre>
		
		<pre class="file" id="file72" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//go:build !nodeploy
// +build !nodeploy

package deploy

import (
        "fmt"
        "regexp"

        "github.com/gobwas/glob"
        "github.com/gohugoio/hugo/config"
        hglob "github.com/gohugoio/hugo/hugofs/glob"
        "github.com/gohugoio/hugo/media"
        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"
)

const deploymentConfigKey = "deployment"

// deployConfig is the complete configuration for deployment.
type deployConfig struct {
        Targets  []*target
        Matchers []*matcher
        Order    []string

        ordering   []*regexp.Regexp // compiled Order
        mediaTypes media.Types
}

type target struct {
        Name string
        URL  string

        CloudFrontDistributionID string

        // GoogleCloudCDNOrigin specifies the Google Cloud project and CDN origin to
        // invalidate when deploying this target.  It is specified as &lt;project&gt;/&lt;origin&gt;.
        GoogleCloudCDNOrigin string

        // Optional patterns of files to include/exclude for this target.
        // Parsed using github.com/gobwas/glob.
        Include string
        Exclude string

        // Parsed versions of Include/Exclude.
        includeGlob glob.Glob
        excludeGlob glob.Glob
}

func (tgt *target) parseIncludeExclude() error <span class="cov8" title="1">{
        var err error
        if tgt.Include != "" </span><span class="cov8" title="1">{
                tgt.includeGlob, err = hglob.GetGlob(tgt.Include)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid deployment.target.include %q: %v", tgt.Include, err)
                }</span>
        }
        <span class="cov8" title="1">if tgt.Exclude != "" </span><span class="cov8" title="1">{
                tgt.excludeGlob, err = hglob.GetGlob(tgt.Exclude)
                if err != nil </span><span class="cov0" title="0">{
                        return fmt.Errorf("invalid deployment.target.exclude %q: %v", tgt.Exclude, err)
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// matcher represents configuration to be applied to files whose paths match
// a specified pattern.
type matcher struct {
        // Pattern is the string pattern to match against paths.
        // Matching is done against paths converted to use / as the path separator.
        Pattern string

        // CacheControl specifies caching attributes to use when serving the blob.
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Cache-Control
        CacheControl string

        // ContentEncoding specifies the encoding used for the blob's content, if any.
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Encoding
        ContentEncoding string

        // ContentType specifies the MIME type of the blob being written.
        // https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type
        ContentType string

        // Gzip determines whether the file should be gzipped before upload.
        // If so, the ContentEncoding field will automatically be set to "gzip".
        Gzip bool

        // Force indicates that matching files should be re-uploaded. Useful when
        // other route-determined metadata (e.g., ContentType) has changed.
        Force bool

        // re is Pattern compiled.
        re *regexp.Regexp
}

func (m *matcher) Matches(path string) bool <span class="cov8" title="1">{
        return m.re.MatchString(path)
}</span>

// decode creates a config from a given Hugo configuration.
func decodeConfig(cfg config.Provider) (deployConfig, error) <span class="cov8" title="1">{
        var (
                mediaTypesConfig []map[string]interface{}
                dcfg             deployConfig
        )

        if !cfg.IsSet(deploymentConfigKey) </span><span class="cov8" title="1">{
                return dcfg, nil
        }</span>
        <span class="cov8" title="1">if err := mapstructure.WeakDecode(cfg.GetStringMap(deploymentConfigKey), &amp;dcfg); err != nil </span><span class="cov0" title="0">{
                return dcfg, err
        }</span>
        <span class="cov8" title="1">for _, tgt := range dcfg.Targets </span><span class="cov8" title="1">{
                if tgt == nil </span><span class="cov8" title="1">{
                        return dcfg, errors.New("empty deployment target")
                }</span>
                <span class="cov8" title="1">if err := tgt.parseIncludeExclude(); err != nil </span><span class="cov0" title="0">{
                        return dcfg, err
                }</span>
        }
        <span class="cov8" title="1">var err error
        for _, m := range dcfg.Matchers </span><span class="cov8" title="1">{
                if m == nil </span><span class="cov8" title="1">{
                        return dcfg, errors.New("empty deployment matcher")
                }</span>
                <span class="cov8" title="1">m.re, err = regexp.Compile(m.Pattern)
                if err != nil </span><span class="cov8" title="1">{
                        return dcfg, fmt.Errorf("invalid deployment.matchers.pattern: %v", err)
                }</span>
        }
        <span class="cov8" title="1">for _, o := range dcfg.Order </span><span class="cov8" title="1">{
                re, err := regexp.Compile(o)
                if err != nil </span><span class="cov8" title="1">{
                        return dcfg, fmt.Errorf("invalid deployment.orderings.pattern: %v", err)
                }</span>
                <span class="cov8" title="1">dcfg.ordering = append(dcfg.ordering, re)</span>
        }

        <span class="cov8" title="1">if cfg.IsSet("mediaTypes") </span><span class="cov0" title="0">{
                mediaTypesConfig = append(mediaTypesConfig, cfg.GetStringMap("mediaTypes"))
        }</span>

        <span class="cov8" title="1">dcfg.mediaTypes, err = media.DecodeTypes(mediaTypesConfig...)
        if err != nil </span><span class="cov0" title="0">{
                return dcfg, err
        }</span>
        <span class="cov8" title="1">return dcfg, nil</span>
}
</pre>
		
		<pre class="file" id="file73" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +build !nodeploy

package deploy

import (
        "context"
        "fmt"
        "strings"

        "google.golang.org/api/compute/v1"
)

// Invalidate all of the content in a Google Cloud CDN distribution.
func InvalidateGoogleCloudCDN(ctx context.Context, origin string) error <span class="cov0" title="0">{
        parts := strings.Split(origin, "/")
        if len(parts) != 2 </span><span class="cov0" title="0">{
                return fmt.Errorf("origin must be &lt;project&gt;/&lt;origin&gt;")
        }</span>
        <span class="cov0" title="0">service, err := compute.NewService(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">rule := &amp;compute.CacheInvalidationRule{Path: "/*"}
        _, err = service.UrlMaps.InvalidateCache(parts[0], parts[1], rule).Context(ctx).Do()
        return err</span>
}
</pre>
		
		<pre class="file" id="file74" style="display: none">package deps

import (
        "sync"
        "sync/atomic"
        "time"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/cache/filecache"
        "github.com/gohugoio/hugo/common/hexec"
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/config/security"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/resources/page"

        "github.com/gohugoio/hugo/metrics"
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/source"
        "github.com/gohugoio/hugo/tpl"
        "github.com/spf13/cast"
        jww "github.com/spf13/jwalterweatherman"
)

// Deps holds dependencies used by many.
// There will be normally only one instance of deps in play
// at a given time, i.e. one per Site built.
type Deps struct {

        // The logger to use.
        Log loggers.Logger `json:"-"`

        // Used to log errors that may repeat itself many times.
        LogDistinct loggers.Logger

        ExecHelper *hexec.Exec

        // The templates to use. This will usually implement the full tpl.TemplateManager.
        tmpl tpl.TemplateHandler

        // We use this to parse and execute ad-hoc text templates.
        textTmpl tpl.TemplateParseFinder

        // The file systems to use.
        Fs *hugofs.Fs `json:"-"`

        // The PathSpec to use
        *helpers.PathSpec `json:"-"`

        // The ContentSpec to use
        *helpers.ContentSpec `json:"-"`

        // The SourceSpec to use
        SourceSpec *source.SourceSpec `json:"-"`

        // The Resource Spec to use
        ResourceSpec *resources.Spec

        // The configuration to use
        Cfg config.Provider `json:"-"`

        // The file cache to use.
        FileCaches filecache.Caches

        // The translation func to use
        Translate func(translationID string, templateData interface{}) string `json:"-"`

        // The language in use. TODO(bep) consolidate with site
        Language *langs.Language

        // The site building.
        Site page.Site

        // All the output formats available for the current site.
        OutputFormatsConfig output.Formats

        templateProvider ResourceProvider
        WithTemplate     func(templ tpl.TemplateManager) error `json:"-"`

        // Used in tests
        OverloadedTemplateFuncs map[string]interface{}

        translationProvider ResourceProvider

        Metrics metrics.Provider

        // Timeout is configurable in site config.
        Timeout time.Duration

        // BuildStartListeners will be notified before a build starts.
        BuildStartListeners *Listeners

        // Resources that gets closed when the build is done or the server shuts down.
        BuildClosers *Closers

        // Atomic values set during a build.
        // This is common/global for all sites.
        BuildState *BuildState

        // Whether we are in running (server) mode
        Running bool

        *globalErrHandler
}

type globalErrHandler struct {
        // Channel for some "hard to get to" build errors
        buildErrors chan error
}

// SendErr sends the error on a channel to be handled later.
// This can be used in situations where returning and aborting the current
// operation isn't practical.
func (e *globalErrHandler) SendError(err error) <span class="cov0" title="0">{
        if e.buildErrors != nil </span><span class="cov0" title="0">{
                select </span>{
                case e.buildErrors &lt;- err:<span class="cov0" title="0"></span>
                default:<span class="cov0" title="0"></span>
                }
                <span class="cov0" title="0">return</span>
        }

        <span class="cov0" title="0">jww.ERROR.Println(err)</span>
}

func (e *globalErrHandler) StartErrorCollector() chan error <span class="cov0" title="0">{
        e.buildErrors = make(chan error, 10)
        return e.buildErrors
}</span>

// Listeners represents an event listener.
type Listeners struct {
        sync.Mutex

        // A list of funcs to be notified about an event.
        listeners []func()
}

// Add adds a function to a Listeners instance.
func (b *Listeners) Add(f func()) <span class="cov0" title="0">{
        if b == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">b.Lock()
        defer b.Unlock()
        b.listeners = append(b.listeners, f)</span>
}

// Notify executes all listener functions.
func (b *Listeners) Notify() <span class="cov0" title="0">{
        b.Lock()
        defer b.Unlock()
        for _, notify := range b.listeners </span><span class="cov0" title="0">{
                notify()
        }</span>
}

// ResourceProvider is used to create and refresh, and clone resources needed.
type ResourceProvider interface {
        Update(deps *Deps) error
        Clone(deps *Deps) error
}

func (d *Deps) Tmpl() tpl.TemplateHandler <span class="cov0" title="0">{
        return d.tmpl
}</span>

func (d *Deps) TextTmpl() tpl.TemplateParseFinder <span class="cov0" title="0">{
        return d.textTmpl
}</span>

func (d *Deps) SetTmpl(tmpl tpl.TemplateHandler) <span class="cov0" title="0">{
        d.tmpl = tmpl
}</span>

func (d *Deps) SetTextTmpl(tmpl tpl.TemplateParseFinder) <span class="cov0" title="0">{
        d.textTmpl = tmpl
}</span>

// LoadResources loads translations and templates.
func (d *Deps) LoadResources() error <span class="cov0" title="0">{
        // Note that the translations need to be loaded before the templates.
        if err := d.translationProvider.Update(d); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "loading translations")
        }</span>

        <span class="cov0" title="0">if err := d.templateProvider.Update(d); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "loading templates")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// New initializes a Dep struct.
// Defaults are set for nil values,
// but TemplateProvider, TranslationProvider and Language are always required.
func New(cfg DepsCfg) (*Deps, error) <span class="cov0" title="0">{
        var (
                logger = cfg.Logger
                fs     = cfg.Fs
        )

        if cfg.TemplateProvider == nil </span><span class="cov0" title="0">{
                panic("Must have a TemplateProvider")</span>
        }

        <span class="cov0" title="0">if cfg.TranslationProvider == nil </span><span class="cov0" title="0">{
                panic("Must have a TranslationProvider")</span>
        }

        <span class="cov0" title="0">if cfg.Language == nil </span><span class="cov0" title="0">{
                panic("Must have a Language")</span>
        }

        <span class="cov0" title="0">if logger == nil </span><span class="cov0" title="0">{
                logger = loggers.NewErrorLogger()
        }</span>

        <span class="cov0" title="0">if fs == nil </span><span class="cov0" title="0">{
                // Default to the production file system.
                fs = hugofs.NewDefault(cfg.Language)
        }</span>

        <span class="cov0" title="0">if cfg.MediaTypes == nil </span><span class="cov0" title="0">{
                cfg.MediaTypes = media.DefaultTypes
        }</span>

        <span class="cov0" title="0">if cfg.OutputFormats == nil </span><span class="cov0" title="0">{
                cfg.OutputFormats = output.DefaultFormats
        }</span>

        <span class="cov0" title="0">securityConfig, err := security.DecodeConfig(cfg.Cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.WithMessage(err, "failed to create security config from configuration")
        }</span>
        <span class="cov0" title="0">execHelper := hexec.New(securityConfig)

        ps, err := helpers.NewPathSpec(fs, cfg.Language, logger)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "create PathSpec")
        }</span>

        <span class="cov0" title="0">fileCaches, err := filecache.NewCaches(ps)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.WithMessage(err, "failed to create file caches from configuration")
        }</span>

        <span class="cov0" title="0">errorHandler := &amp;globalErrHandler{}
        buildState := &amp;BuildState{}

        resourceSpec, err := resources.NewSpec(ps, fileCaches, buildState, logger, errorHandler, execHelper, cfg.OutputFormats, cfg.MediaTypes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">contentSpec, err := helpers.NewContentSpec(cfg.Language, logger, ps.BaseFs.Content.Fs, execHelper)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">sp := source.NewSourceSpec(ps, nil, fs.Source)

        timeoutms := cfg.Language.GetInt("timeout")
        if timeoutms &lt;= 0 </span><span class="cov0" title="0">{
                timeoutms = 3000
        }</span>

        <span class="cov0" title="0">ignoreErrors := cast.ToStringSlice(cfg.Cfg.Get("ignoreErrors"))
        ignorableLogger := loggers.NewIgnorableLogger(logger, ignoreErrors...)

        logDistinct := helpers.NewDistinctLogger(logger)

        d := &amp;Deps{
                Fs:                      fs,
                Log:                     ignorableLogger,
                LogDistinct:             logDistinct,
                ExecHelper:              execHelper,
                templateProvider:        cfg.TemplateProvider,
                translationProvider:     cfg.TranslationProvider,
                WithTemplate:            cfg.WithTemplate,
                OverloadedTemplateFuncs: cfg.OverloadedTemplateFuncs,
                PathSpec:                ps,
                ContentSpec:             contentSpec,
                SourceSpec:              sp,
                ResourceSpec:            resourceSpec,
                Cfg:                     cfg.Language,
                Language:                cfg.Language,
                Site:                    cfg.Site,
                FileCaches:              fileCaches,
                BuildStartListeners:     &amp;Listeners{},
                BuildClosers:            &amp;Closers{},
                BuildState:              buildState,
                Running:                 cfg.Running,
                Timeout:                 time.Duration(timeoutms) * time.Millisecond,
                globalErrHandler:        errorHandler,
        }

        if cfg.Cfg.GetBool("templateMetrics") </span><span class="cov0" title="0">{
                d.Metrics = metrics.NewProvider(cfg.Cfg.GetBool("templateMetricsHints"))
        }</span>

        <span class="cov0" title="0">return d, nil</span>
}

func (d *Deps) Close() error <span class="cov0" title="0">{
        return d.BuildClosers.Close()
}</span>

// ForLanguage creates a copy of the Deps with the language dependent
// parts switched out.
func (d Deps) ForLanguage(cfg DepsCfg, onCreated func(d *Deps) error) (*Deps, error) <span class="cov0" title="0">{
        l := cfg.Language
        var err error

        d.PathSpec, err = helpers.NewPathSpecWithBaseBaseFsProvided(d.Fs, l, d.Log, d.BaseFs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">d.ContentSpec, err = helpers.NewContentSpec(l, d.Log, d.BaseFs.Content.Fs, d.ExecHelper)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">d.Site = cfg.Site

        // These are common for all sites, so reuse.
        // TODO(bep) clean up these inits.
        resourceCache := d.ResourceSpec.ResourceCache
        postBuildAssets := d.ResourceSpec.PostBuildAssets
        d.ResourceSpec, err = resources.NewSpec(d.PathSpec, d.ResourceSpec.FileCaches, d.BuildState, d.Log, d.globalErrHandler, d.ExecHelper, cfg.OutputFormats, cfg.MediaTypes)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">d.ResourceSpec.ResourceCache = resourceCache
        d.ResourceSpec.PostBuildAssets = postBuildAssets

        d.Cfg = l
        d.Language = l

        if onCreated != nil </span><span class="cov0" title="0">{
                if err = onCreated(&amp;d); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov0" title="0">if err := d.translationProvider.Clone(&amp;d); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if err := d.templateProvider.Clone(&amp;d); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">d.BuildStartListeners = &amp;Listeners{}

        return &amp;d, nil</span>
}

// DepsCfg contains configuration options that can be used to configure Hugo
// on a global level, i.e. logging etc.
// Nil values will be given default values.
type DepsCfg struct {

        // The Logger to use.
        Logger loggers.Logger

        // The file systems to use
        Fs *hugofs.Fs

        // The language to use.
        Language *langs.Language

        // The Site in use
        Site page.Site

        // The configuration to use.
        Cfg config.Provider

        // The media types configured.
        MediaTypes media.Types

        // The output formats configured.
        OutputFormats output.Formats

        // Template handling.
        TemplateProvider ResourceProvider
        WithTemplate     func(templ tpl.TemplateManager) error
        // Used in tests
        OverloadedTemplateFuncs map[string]interface{}

        // i18n handling.
        TranslationProvider ResourceProvider

        // Whether we are in running (server) mode
        Running bool
}

// BuildState are flags that may be turned on during a build.
type BuildState struct {
        counter uint64
}

func (b *BuildState) Incr() int <span class="cov8" title="1">{
        return int(atomic.AddUint64(&amp;b.counter, uint64(1)))
}</span>

func NewBuildState() BuildState <span class="cov0" title="0">{
        return BuildState{}
}</span>

type Closer interface {
        Close() error
}

type Closers struct {
        mu sync.Mutex
        cs []Closer
}

func (cs *Closers) Add(c Closer) <span class="cov0" title="0">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        cs.cs = append(cs.cs, c)
}</span>

func (cs *Closers) Close() error <span class="cov0" title="0">{
        cs.mu.Lock()
        defer cs.mu.Unlock()
        for _, c := range cs.cs </span><span class="cov0" title="0">{
                c.Close()
        }</span>

        <span class="cov0" title="0">cs.cs = cs.cs[:0]

        return nil</span>
}
</pre>
		
		<pre class="file" id="file75" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package helpers implements general utility functions that work with
// and on content.  The helper functions defined here lay down the
// foundation of how Hugo works with files and filepaths, and perform
// string operations on content.
package helpers

import (
        "bytes"
        "html/template"
        "strings"
        "unicode"
        "unicode/utf8"

        "github.com/gohugoio/hugo/common/hexec"
        "github.com/gohugoio/hugo/common/loggers"

        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/markup/converter"

        "github.com/gohugoio/hugo/markup"

        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/config"
)

var (
        openingPTag        = []byte("&lt;p&gt;")
        closingPTag        = []byte("&lt;/p&gt;")
        paragraphIndicator = []byte("&lt;p")
        closingIndicator   = []byte("&lt;/")
)

// ContentSpec provides functionality to render markdown content.
type ContentSpec struct {
        Converters          markup.ConverterProvider
        MardownConverter    converter.Converter // Markdown converter with no document context
        anchorNameSanitizer converter.AnchorNameSanitizer

        // SummaryLength is the length of the summary that Hugo extracts from a content.
        summaryLength int

        BuildFuture  bool
        BuildExpired bool
        BuildDrafts  bool

        Cfg config.Provider
}

// NewContentSpec returns a ContentSpec initialized
// with the appropriate fields from the given config.Provider.
func NewContentSpec(cfg config.Provider, logger loggers.Logger, contentFs afero.Fs, ex *hexec.Exec) (*ContentSpec, error) <span class="cov8" title="1">{
        spec := &amp;ContentSpec{
                summaryLength: cfg.GetInt("summaryLength"),
                BuildFuture:   cfg.GetBool("buildFuture"),
                BuildExpired:  cfg.GetBool("buildExpired"),
                BuildDrafts:   cfg.GetBool("buildDrafts"),

                Cfg: cfg,
        }

        converterProvider, err := markup.NewConverterProvider(converter.ProviderConfig{
                Cfg:       cfg,
                ContentFs: contentFs,
                Logger:    logger,
                Exec:      ex,
        })
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">spec.Converters = converterProvider
        p := converterProvider.Get("markdown")
        conv, err := p.New(converter.DocumentContext{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">spec.MardownConverter = conv
        if as, ok := conv.(converter.AnchorNameSanitizer); ok </span><span class="cov8" title="1">{
                spec.anchorNameSanitizer = as
        }</span> else<span class="cov0" title="0"> {
                // Use Goldmark's sanitizer
                p := converterProvider.Get("goldmark")
                conv, err := p.New(converter.DocumentContext{})
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">spec.anchorNameSanitizer = conv.(converter.AnchorNameSanitizer)</span>
        }

        <span class="cov8" title="1">return spec, nil</span>
}

var stripHTMLReplacer = strings.NewReplacer("\n", " ", "&lt;/p&gt;", "\n", "&lt;br&gt;", "\n", "&lt;br /&gt;", "\n")

// StripHTML accepts a string, strips out all HTML tags and returns it.
func StripHTML(s string) string <span class="cov8" title="1">{
        // Shortcut strings with no tags in them
        if !strings.ContainsAny(s, "&lt;&gt;") </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">s = stripHTMLReplacer.Replace(s)

        // Walk through the string removing all tags
        b := bp.GetBuffer()
        defer bp.PutBuffer(b)
        var inTag, isSpace, wasSpace bool
        for _, r := range s </span><span class="cov8" title="1">{
                if !inTag </span><span class="cov8" title="1">{
                        isSpace = false
                }</span>

                <span class="cov8" title="1">switch </span>{
                case r == '&lt;':<span class="cov8" title="1">
                        inTag = true</span>
                case r == '&gt;':<span class="cov8" title="1">
                        inTag = false</span>
                case unicode.IsSpace(r):<span class="cov8" title="1">
                        isSpace = true
                        fallthrough</span>
                default:<span class="cov8" title="1">
                        if !inTag &amp;&amp; (!isSpace || (isSpace &amp;&amp; !wasSpace)) </span><span class="cov8" title="1">{
                                b.WriteRune(r)
                        }</span>
                }

                <span class="cov8" title="1">wasSpace = isSpace</span>

        }
        <span class="cov8" title="1">return b.String()</span>
}

// stripEmptyNav strips out empty &lt;nav&gt; tags from content.
func stripEmptyNav(in []byte) []byte <span class="cov8" title="1">{
        return bytes.Replace(in, []byte("&lt;nav&gt;\n&lt;/nav&gt;\n\n"), []byte(``), -1)
}</span>

// BytesToHTML converts bytes to type template.HTML.
func BytesToHTML(b []byte) template.HTML <span class="cov8" title="1">{
        return template.HTML(string(b))
}</span>

// ExtractTOC extracts Table of Contents from content.
func ExtractTOC(content []byte) (newcontent []byte, toc []byte) <span class="cov8" title="1">{
        if !bytes.Contains(content, []byte("&lt;nav&gt;")) </span><span class="cov8" title="1">{
                return content, nil
        }</span>
        <span class="cov8" title="1">origContent := make([]byte, len(content))
        copy(origContent, content)
        first := []byte(`&lt;nav&gt;
&lt;ul&gt;`)

        last := []byte(`&lt;/ul&gt;
&lt;/nav&gt;`)

        replacement := []byte(`&lt;nav id="TableOfContents"&gt;
&lt;ul&gt;`)

        startOfTOC := bytes.Index(content, first)

        peekEnd := len(content)
        if peekEnd &gt; 70+startOfTOC </span><span class="cov8" title="1">{
                peekEnd = 70 + startOfTOC
        }</span>

        <span class="cov8" title="1">if startOfTOC &lt; 0 </span><span class="cov0" title="0">{
                return stripEmptyNav(content), toc
        }</span>
        // Need to peek ahead to see if this nav element is actually the right one.
        <span class="cov8" title="1">correctNav := bytes.Index(content[startOfTOC:peekEnd], []byte(`&lt;li&gt;&lt;a href="#`))
        if correctNav &lt; 0 </span><span class="cov8" title="1">{ // no match found
                return content, toc
        }</span>
        <span class="cov8" title="1">lengthOfTOC := bytes.Index(content[startOfTOC:], last) + len(last)
        endOfTOC := startOfTOC + lengthOfTOC

        newcontent = append(content[:startOfTOC], content[endOfTOC:]...)
        toc = append(replacement, origContent[startOfTOC+len(first):endOfTOC]...)
        return</span>
}

func (c *ContentSpec) RenderMarkdown(src []byte) ([]byte, error) <span class="cov0" title="0">{
        b, err := c.MardownConverter.Convert(converter.RenderContext{Src: src})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return b.Bytes(), nil</span>
}

func (c *ContentSpec) SanitizeAnchorName(s string) string <span class="cov0" title="0">{
        return c.anchorNameSanitizer.SanitizeAnchorName(s)
}</span>

func (c *ContentSpec) ResolveMarkup(in string) string <span class="cov8" title="1">{
        in = strings.ToLower(in)
        switch in </span>{
        case "md", "markdown", "mdown":<span class="cov8" title="1">
                return "markdown"</span>
        case "html", "htm":<span class="cov8" title="1">
                return "html"</span>
        default:<span class="cov8" title="1">
                if conv := c.Converters.Get(in); conv != nil </span><span class="cov8" title="1">{
                        return conv.Name()
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}

// TotalWords counts instance of one or more consecutive white space
// characters, as defined by unicode.IsSpace, in s.
// This is a cheaper way of word counting than the obvious len(strings.Fields(s)).
func TotalWords(s string) int <span class="cov8" title="1">{
        n := 0
        inWord := false
        for _, r := range s </span><span class="cov8" title="1">{
                wasInWord := inWord
                inWord = !unicode.IsSpace(r)
                if inWord &amp;&amp; !wasInWord </span><span class="cov8" title="1">{
                        n++
                }</span>
        }
        <span class="cov8" title="1">return n</span>
}

// TruncateWordsByRune truncates words by runes.
func (c *ContentSpec) TruncateWordsByRune(in []string) (string, bool) <span class="cov8" title="1">{
        words := make([]string, len(in))
        copy(words, in)

        count := 0
        for index, word := range words </span><span class="cov8" title="1">{
                if count &gt;= c.summaryLength </span><span class="cov8" title="1">{
                        return strings.Join(words[:index], " "), true
                }</span>
                <span class="cov8" title="1">runeCount := utf8.RuneCountInString(word)
                if len(word) == runeCount </span><span class="cov8" title="1">{
                        count++
                }</span> else<span class="cov8" title="1"> if count+runeCount &lt; c.summaryLength </span><span class="cov8" title="1">{
                        count += runeCount
                }</span> else<span class="cov8" title="1"> {
                        for ri := range word </span><span class="cov8" title="1">{
                                if count &gt;= c.summaryLength </span><span class="cov8" title="1">{
                                        truncatedWords := append(words[:index], word[:ri])
                                        return strings.Join(truncatedWords, " "), true
                                }</span>
                                <span class="cov8" title="1">count++</span>
                        }
                }
        }

        <span class="cov8" title="1">return strings.Join(words, " "), false</span>
}

// TruncateWordsToWholeSentence takes content and truncates to whole sentence
// limited by max number of words. It also returns whether it is truncated.
func (c *ContentSpec) TruncateWordsToWholeSentence(s string) (string, bool) <span class="cov8" title="1">{
        var (
                wordCount     = 0
                lastWordIndex = -1
        )

        for i, r := range s </span><span class="cov8" title="1">{
                if unicode.IsSpace(r) </span><span class="cov8" title="1">{
                        wordCount++
                        lastWordIndex = i

                        if wordCount &gt;= c.summaryLength </span><span class="cov8" title="1">{
                                break</span>
                        }

                }
        }

        <span class="cov8" title="1">if lastWordIndex == -1 </span><span class="cov8" title="1">{
                return s, false
        }</span>

        <span class="cov8" title="1">endIndex := -1

        for j, r := range s[lastWordIndex:] </span><span class="cov8" title="1">{
                if isEndOfSentence(r) </span><span class="cov8" title="1">{
                        endIndex = j + lastWordIndex + utf8.RuneLen(r)
                        break</span>
                }
        }

        <span class="cov8" title="1">if endIndex == -1 </span><span class="cov8" title="1">{
                return s, false
        }</span>

        <span class="cov8" title="1">return strings.TrimSpace(s[:endIndex]), endIndex &lt; len(s)</span>
}

// TrimShortHTML removes the &lt;p&gt;/&lt;/p&gt; tags from HTML input in the situation
// where said tags are the only &lt;p&gt; tags in the input and enclose the content
// of the input (whitespace excluded).
func (c *ContentSpec) TrimShortHTML(input []byte) []byte <span class="cov8" title="1">{
        firstOpeningP := bytes.Index(input, paragraphIndicator)
        lastOpeningP := bytes.LastIndex(input, paragraphIndicator)

        lastClosingP := bytes.LastIndex(input, closingPTag)
        lastClosing := bytes.LastIndex(input, closingIndicator)

        if firstOpeningP == lastOpeningP &amp;&amp; lastClosingP == lastClosing </span><span class="cov8" title="1">{
                input = bytes.TrimSpace(input)
                input = bytes.TrimPrefix(input, openingPTag)
                input = bytes.TrimSuffix(input, closingPTag)
                input = bytes.TrimSpace(input)
        }</span>
        <span class="cov8" title="1">return input</span>
}

func isEndOfSentence(r rune) bool <span class="cov8" title="1">{
        return r == '.' || r == '?' || r == '!' || r == '"' || r == '\n'
}</span>

// Kept only for benchmark.
func (c *ContentSpec) truncateWordsToWholeSentenceOld(content string) (string, bool) <span class="cov0" title="0">{
        words := strings.Fields(content)

        if c.summaryLength &gt;= len(words) </span><span class="cov0" title="0">{
                return strings.Join(words, " "), false
        }</span>

        <span class="cov0" title="0">for counter, word := range words[c.summaryLength:] </span><span class="cov0" title="0">{
                if strings.HasSuffix(word, ".") ||
                        strings.HasSuffix(word, "?") ||
                        strings.HasSuffix(word, ".\"") ||
                        strings.HasSuffix(word, "!") </span><span class="cov0" title="0">{
                        upper := c.summaryLength + counter + 1
                        return strings.Join(words[:upper], " "), (upper &lt; len(words))
                }</span>
        }

        <span class="cov0" title="0">return strings.Join(words[:c.summaryLength], " "), true</span>
}
</pre>
		
		<pre class="file" id="file76" style="display: none">package helpers

import (
        "path/filepath"
        "sort"
        "strings"

        "github.com/alecthomas/chroma/lexers"
        "github.com/gohugoio/hugo/docshelper"
)

// This is is just some helpers used to create some JSON used in the Hugo docs.
func init() <span class="cov8" title="1">{
        docsProvider := func() docshelper.DocProvider </span><span class="cov0" title="0">{
                var chromaLexers []interface{}

                sort.Sort(lexers.Registry.Lexers)

                for _, l := range lexers.Registry.Lexers </span><span class="cov0" title="0">{

                        config := l.Config()

                        var filenames []string
                        filenames = append(filenames, config.Filenames...)
                        filenames = append(filenames, config.AliasFilenames...)

                        aliases := config.Aliases

                        for _, filename := range filenames </span><span class="cov0" title="0">{
                                alias := strings.TrimSpace(strings.TrimPrefix(filepath.Ext(filename), "."))
                                if alias != "" </span><span class="cov0" title="0">{
                                        aliases = append(aliases, alias)
                                }</span>
                        }

                        <span class="cov0" title="0">aliases = UniqueStringsSorted(aliases)

                        lexerEntry := struct {
                                Name    string
                                Aliases []string
                        }{
                                config.Name,
                                aliases,
                        }

                        chromaLexers = append(chromaLexers, lexerEntry)</span>

                }

                <span class="cov0" title="0">return docshelper.DocProvider{"chroma": map[string]interface{}{"lexers": chromaLexers}}</span>
        }

        <span class="cov8" title="1">docshelper.AddDocProviderFunc(docsProvider)</span>
}
</pre>
		
		<pre class="file" id="file77" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "bytes"
        "sync"

        "github.com/kyokomi/emoji/v2"
)

var (
        emojiInit sync.Once

        emojis = make(map[string][]byte)

        emojiDelim     = []byte(":")
        emojiWordDelim = []byte(" ")
        emojiMaxSize   int
)

// Emoji returns the emojy given a key, e.g. ":smile:", nil if not found.
func Emoji(key string) []byte <span class="cov0" title="0">{
        emojiInit.Do(initEmoji)
        return emojis[key]
}</span>

// Emojify "emojifies" the input source.
// Note that the input byte slice will be modified if needed.
// See http://www.emoji-cheat-sheet.com/
func Emojify(source []byte) []byte <span class="cov8" title="1">{
        emojiInit.Do(initEmoji)

        start := 0
        k := bytes.Index(source[start:], emojiDelim)

        for k != -1 </span><span class="cov8" title="1">{

                j := start + k

                upper := j + emojiMaxSize

                if upper &gt; len(source) </span><span class="cov8" title="1">{
                        upper = len(source)
                }</span>

                <span class="cov8" title="1">endEmoji := bytes.Index(source[j+1:upper], emojiDelim)
                nextWordDelim := bytes.Index(source[j:upper], emojiWordDelim)

                if endEmoji &lt; 0 </span><span class="cov8" title="1">{
                        start++
                }</span> else<span class="cov8" title="1"> if endEmoji == 0 || (nextWordDelim != -1 &amp;&amp; nextWordDelim &lt; endEmoji) </span><span class="cov8" title="1">{
                        start += endEmoji + 1
                }</span> else<span class="cov8" title="1"> {
                        endKey := endEmoji + j + 2
                        emojiKey := source[j:endKey]

                        if emoji, ok := emojis[string(emojiKey)]; ok </span><span class="cov8" title="1">{
                                source = append(source[:j], append(emoji, source[endKey:]...)...)
                        }</span>

                        <span class="cov8" title="1">start += endEmoji</span>
                }

                <span class="cov8" title="1">if start &gt;= len(source) </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">k = bytes.Index(source[start:], emojiDelim)</span>
        }

        <span class="cov8" title="1">return source</span>
}

func initEmoji() <span class="cov8" title="1">{
        emojiMap := emoji.CodeMap()

        for k, v := range emojiMap </span><span class="cov8" title="1">{
                emojis[k] = []byte(v)

                if len(k) &gt; emojiMaxSize </span><span class="cov8" title="1">{
                        emojiMaxSize = len(k)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file78" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "bytes"
        "crypto/md5"
        "encoding/hex"
        "fmt"
        "io"
        "net"
        "os"
        "path/filepath"
        "sort"
        "strconv"
        "strings"
        "sync"
        "unicode"
        "unicode/utf8"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/mitchellh/hashstructure"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/common/hugo"

        "github.com/spf13/afero"

        "github.com/jdkato/prose/transform"

        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/spf13/pflag"
)

// FilePathSeparator as defined by os.Separator.
const FilePathSeparator = string(filepath.Separator)

// FindAvailablePort returns an available and valid TCP port.
func FindAvailablePort() (*net.TCPAddr, error) <span class="cov8" title="1">{
        l, err := net.Listen("tcp", ":0")
        if err == nil </span><span class="cov8" title="1">{
                defer l.Close()
                addr := l.Addr()
                if a, ok := addr.(*net.TCPAddr); ok </span><span class="cov8" title="1">{
                        return a, nil
                }</span>
                <span class="cov0" title="0">return nil, fmt.Errorf("unable to obtain a valid tcp port: %v", addr)</span>
        }
        <span class="cov0" title="0">return nil, err</span>
}

// InStringArray checks if a string is an element of a slice of strings
// and returns a boolean value.
func InStringArray(arr []string, el string) bool <span class="cov0" title="0">{
        for _, v := range arr </span><span class="cov0" title="0">{
                if v == el </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// FirstUpper returns a string with the first character as upper case.
func FirstUpper(s string) string <span class="cov8" title="1">{
        if s == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">r, n := utf8.DecodeRuneInString(s)
        return string(unicode.ToUpper(r)) + s[n:]</span>
}

// UniqueStrings returns a new slice with any duplicates removed.
func UniqueStrings(s []string) []string <span class="cov8" title="1">{
        unique := make([]string, 0, len(s))
        for i, val := range s </span><span class="cov8" title="1">{
                var seen bool
                for j := 0; j &lt; i; j++ </span><span class="cov8" title="1">{
                        if s[j] == val </span><span class="cov8" title="1">{
                                seen = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !seen </span><span class="cov8" title="1">{
                        unique = append(unique, val)
                }</span>
        }
        <span class="cov8" title="1">return unique</span>
}

// UniqueStringsReuse returns a slice with any duplicates removed.
// It will modify the input slice.
func UniqueStringsReuse(s []string) []string <span class="cov8" title="1">{
        result := s[:0]
        for i, val := range s </span><span class="cov8" title="1">{
                var seen bool

                for j := 0; j &lt; i; j++ </span><span class="cov8" title="1">{
                        if s[j] == val </span><span class="cov8" title="1">{
                                seen = true
                                break</span>
                        }
                }

                <span class="cov8" title="1">if !seen </span><span class="cov8" title="1">{
                        result = append(result, val)
                }</span>
        }
        <span class="cov8" title="1">return result</span>
}

// UniqueStringsReuse returns a sorted slice with any duplicates removed.
// It will modify the input slice.
func UniqueStringsSorted(s []string) []string <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">ss := sort.StringSlice(s)
        ss.Sort()
        i := 0
        for j := 1; j &lt; len(s); j++ </span><span class="cov8" title="1">{
                if !ss.Less(i, j) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">i++
                s[i] = s[j]</span>
        }

        <span class="cov8" title="1">return s[:i+1]</span>
}

// ReaderToBytes takes an io.Reader argument, reads from it
// and returns bytes.
func ReaderToBytes(lines io.Reader) []byte <span class="cov0" title="0">{
        if lines == nil </span><span class="cov0" title="0">{
                return []byte{}
        }</span>
        <span class="cov0" title="0">b := bp.GetBuffer()
        defer bp.PutBuffer(b)

        b.ReadFrom(lines)

        bc := make([]byte, b.Len())
        copy(bc, b.Bytes())
        return bc</span>
}

// ReaderToString is the same as ReaderToBytes, but returns a string.
func ReaderToString(lines io.Reader) string <span class="cov0" title="0">{
        if lines == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">b := bp.GetBuffer()
        defer bp.PutBuffer(b)
        b.ReadFrom(lines)
        return b.String()</span>
}

// ReaderContains reports whether subslice is within r.
func ReaderContains(r io.Reader, subslice []byte) bool <span class="cov8" title="1">{
        if r == nil || len(subslice) == 0 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">bufflen := len(subslice) * 4
        halflen := bufflen / 2
        buff := make([]byte, bufflen)
        var err error
        var n, i int

        for </span><span class="cov8" title="1">{
                i++
                if i == 1 </span><span class="cov8" title="1">{
                        n, err = io.ReadAtLeast(r, buff[:halflen], halflen)
                }</span> else<span class="cov8" title="1"> {
                        if i != 2 </span><span class="cov8" title="1">{
                                // shift left to catch overlapping matches
                                copy(buff[:], buff[halflen:])
                        }</span>
                        <span class="cov8" title="1">n, err = io.ReadAtLeast(r, buff[halflen:], halflen)</span>
                }

                <span class="cov8" title="1">if n &gt; 0 &amp;&amp; bytes.Contains(buff, subslice) </span><span class="cov8" title="1">{
                        return true
                }</span>

                <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

// GetTitleFunc returns a func that can be used to transform a string to
// title case.
//
// The supported styles are
//
// - "Go" (strings.Title)
// - "AP" (see https://www.apstylebook.com/)
// - "Chicago" (see http://www.chicagomanualofstyle.org/home.html)
//
// If an unknown or empty style is provided, AP style is what you get.
func GetTitleFunc(style string) func(s string) string <span class="cov8" title="1">{
        switch strings.ToLower(style) </span>{
        case "go":<span class="cov8" title="1">
                return strings.Title</span>
        case "chicago":<span class="cov8" title="1">
                tc := transform.NewTitleConverter(transform.ChicagoStyle)
                return tc.Title</span>
        default:<span class="cov8" title="1">
                tc := transform.NewTitleConverter(transform.APStyle)
                return tc.Title</span>
        }
}

// HasStringsPrefix tests whether the string slice s begins with prefix slice s.
func HasStringsPrefix(s, prefix []string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(prefix) &amp;&amp; compareStringSlices(s[0:len(prefix)], prefix)
}</span>

// HasStringsSuffix tests whether the string slice s ends with suffix slice s.
func HasStringsSuffix(s, suffix []string) bool <span class="cov8" title="1">{
        return len(s) &gt;= len(suffix) &amp;&amp; compareStringSlices(s[len(s)-len(suffix):], suffix)
}</span>

func compareStringSlices(a, b []string) bool <span class="cov8" title="1">{
        if a == nil &amp;&amp; b == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if a == nil || b == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if len(a) != len(b) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range a </span><span class="cov8" title="1">{
                if a[i] != b[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// DistinctLogger ignores duplicate log statements.
type DistinctLogger struct {
        loggers.Logger
        sync.RWMutex
        m map[string]bool
}

func (l *DistinctLogger) Reset() <span class="cov0" title="0">{
        l.Lock()
        defer l.Unlock()

        l.m = make(map[string]bool)
}</span>

// Println will log the string returned from fmt.Sprintln given the arguments,
// but not if it has been logged before.
func (l *DistinctLogger) Println(v ...interface{}) <span class="cov0" title="0">{
        // fmt.Sprint doesn't add space between string arguments
        logStatement := strings.TrimSpace(fmt.Sprintln(v...))
        l.printIfNotPrinted("println", logStatement, func() </span><span class="cov0" title="0">{
                l.Logger.Println(logStatement)
        }</span>)
}

// Printf will log the string returned from fmt.Sprintf given the arguments,
// but not if it has been logged before.
func (l *DistinctLogger) Printf(format string, v ...interface{}) <span class="cov0" title="0">{
        logStatement := fmt.Sprintf(format, v...)
        l.printIfNotPrinted("printf", logStatement, func() </span><span class="cov0" title="0">{
                l.Logger.Printf(format, v...)
        }</span>)
}

func (l *DistinctLogger) Debugf(format string, v ...interface{}) <span class="cov0" title="0">{
        logStatement := fmt.Sprintf(format, v...)
        l.printIfNotPrinted("debugf", logStatement, func() </span><span class="cov0" title="0">{
                l.Logger.Debugf(format, v...)
        }</span>)
}

func (l *DistinctLogger) Debugln(v ...interface{}) <span class="cov0" title="0">{
        logStatement := fmt.Sprint(v...)
        l.printIfNotPrinted("debugln", logStatement, func() </span><span class="cov0" title="0">{
                l.Logger.Debugln(v...)
        }</span>)
}

func (l *DistinctLogger) Infof(format string, v ...interface{}) <span class="cov0" title="0">{
        logStatement := fmt.Sprintf(format, v...)
        l.printIfNotPrinted("info", logStatement, func() </span><span class="cov0" title="0">{
                l.Logger.Infof(format, v...)
        }</span>)
}

func (l *DistinctLogger) Infoln(v ...interface{}) <span class="cov0" title="0">{
        logStatement := fmt.Sprint(v...)
        l.printIfNotPrinted("infoln", logStatement, func() </span><span class="cov0" title="0">{
                l.Logger.Infoln(v...)
        }</span>)
}

func (l *DistinctLogger) Warnf(format string, v ...interface{}) <span class="cov8" title="1">{
        logStatement := fmt.Sprintf(format, v...)
        l.printIfNotPrinted("warnf", logStatement, func() </span><span class="cov8" title="1">{
                l.Logger.Warnf(format, v...)
        }</span>)
}

func (l *DistinctLogger) Warnln(v ...interface{}) <span class="cov0" title="0">{
        logStatement := fmt.Sprint(v...)
        l.printIfNotPrinted("warnln", logStatement, func() </span><span class="cov0" title="0">{
                l.Logger.Warnln(v...)
        }</span>)
}

func (l *DistinctLogger) Errorf(format string, v ...interface{}) <span class="cov0" title="0">{
        logStatement := fmt.Sprint(v...)
        l.printIfNotPrinted("errorf", logStatement, func() </span><span class="cov0" title="0">{
                l.Logger.Errorf(format, v...)
        }</span>)
}

func (l *DistinctLogger) Errorln(v ...interface{}) <span class="cov0" title="0">{
        logStatement := fmt.Sprint(v...)
        l.printIfNotPrinted("errorln", logStatement, func() </span><span class="cov0" title="0">{
                l.Logger.Errorln(v...)
        }</span>)
}

func (l *DistinctLogger) hasPrinted(key string) bool <span class="cov8" title="1">{
        l.RLock()
        defer l.RUnlock()
        _, found := l.m[key]
        return found
}</span>

func (l *DistinctLogger) printIfNotPrinted(level, logStatement string, print func()) <span class="cov8" title="1">{
        key := level + logStatement
        if l.hasPrinted(key) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">l.Lock()
        defer l.Unlock()
        l.m[key] = true // Placing this after print() can cause duplicate warning entries to be logged when --panicOnWarning is true.
        print()</span>

}

// NewDistinctErrorLogger creates a new DistinctLogger that logs ERRORs
func NewDistinctErrorLogger() loggers.Logger <span class="cov8" title="1">{
        return &amp;DistinctLogger{m: make(map[string]bool), Logger: loggers.NewErrorLogger()}
}</span>

// NewDistinctLogger creates a new DistinctLogger that logs to the provided logger.
func NewDistinctLogger(logger loggers.Logger) loggers.Logger <span class="cov8" title="1">{
        return &amp;DistinctLogger{m: make(map[string]bool), Logger: logger}
}</span>

// NewDistinctWarnLogger creates a new DistinctLogger that logs WARNs
func NewDistinctWarnLogger() loggers.Logger <span class="cov8" title="1">{
        return &amp;DistinctLogger{m: make(map[string]bool), Logger: loggers.NewWarningLogger()}
}</span>

var (
        // DistinctErrorLog can be used to avoid spamming the logs with errors.
        DistinctErrorLog = NewDistinctErrorLogger()

        // DistinctWarnLog can be used to avoid spamming the logs with warnings.
        DistinctWarnLog = NewDistinctWarnLogger()
)

// InitLoggers resets the global distinct loggers.
func InitLoggers() <span class="cov0" title="0">{
        DistinctErrorLog.Reset()
        DistinctWarnLog.Reset()
}</span>

// Deprecated informs about a deprecation, but only once for a given set of arguments' values.
// If the err flag is enabled, it logs as an ERROR (will exit with -1) and the text will
// point at the next Hugo release.
// The idea is two remove an item in two Hugo releases to give users and theme authors
// plenty of time to fix their templates.
func Deprecated(item, alternative string, err bool) <span class="cov0" title="0">{
        if err </span><span class="cov0" title="0">{
                DistinctErrorLog.Errorf("%s is deprecated and will be removed in Hugo %s. %s", item, hugo.CurrentVersion.Next().ReleaseVersion(), alternative)
        }</span> else<span class="cov0" title="0"> {
                var warnPanicMessage string
                if !loggers.PanicOnWarning </span><span class="cov0" title="0">{
                        warnPanicMessage = "\n\nRe-run Hugo with the flag --panicOnWarning to get a better error message."
                }</span>
                <span class="cov0" title="0">DistinctWarnLog.Warnf("%s is deprecated and will be removed in a future release. %s%s", item, alternative, warnPanicMessage)</span>
        }
}

// SliceToLower goes through the source slice and lowers all values.
func SliceToLower(s []string) []string <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">l := make([]string, len(s))
        for i, v := range s </span><span class="cov8" title="1">{
                l[i] = strings.ToLower(v)
        }</span>

        <span class="cov8" title="1">return l</span>
}

// MD5String takes a string and returns its MD5 hash.
func MD5String(f string) string <span class="cov0" title="0">{
        h := md5.New()
        h.Write([]byte(f))
        return hex.EncodeToString(h.Sum([]byte{}))
}</span>

// MD5FromFileFast creates a MD5 hash from the given file. It only reads parts of
// the file for speed, so don't use it if the files are very subtly different.
// It will not close the file.
func MD5FromFileFast(r io.ReadSeeker) (string, error) <span class="cov8" title="1">{
        const (
                // Do not change once set in stone!
                maxChunks = 8
                peekSize  = 64
                seek      = 2048
        )

        h := md5.New()
        buff := make([]byte, peekSize)

        for i := 0; i &lt; maxChunks; i++ </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        _, err := r.Seek(seek, 0)
                        if err != nil </span><span class="cov0" title="0">{
                                if err == io.EOF </span><span class="cov0" title="0">{
                                        break</span>
                                }
                                <span class="cov0" title="0">return "", err</span>
                        }
                }

                <span class="cov8" title="1">_, err := io.ReadAtLeast(r, buff, peekSize)
                if err != nil </span><span class="cov8" title="1">{
                        if err == io.EOF || err == io.ErrUnexpectedEOF </span><span class="cov8" title="1">{
                                h.Write(buff)
                                break</span>
                        }
                        <span class="cov0" title="0">return "", err</span>
                }
                <span class="cov8" title="1">h.Write(buff)</span>
        }

        <span class="cov8" title="1">return hex.EncodeToString(h.Sum(nil)), nil</span>
}

// MD5FromReader creates a MD5 hash from the given reader.
func MD5FromReader(r io.Reader) (string, error) <span class="cov8" title="1">{
        h := md5.New()
        if _, err := io.Copy(h, r); err != nil </span><span class="cov8" title="1">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return hex.EncodeToString(h.Sum(nil)), nil</span>
}

// IsWhitespace determines if the given rune is whitespace.
func IsWhitespace(r rune) bool <span class="cov0" title="0">{
        return r == ' ' || r == '\t' || r == '\n' || r == '\r'
}</span>

// NormalizeHugoFlags facilitates transitions of Hugo command-line flags,
// e.g. --baseUrl to --baseURL, --uglyUrls to --uglyURLs
func NormalizeHugoFlags(f *pflag.FlagSet, name string) pflag.NormalizedName <span class="cov0" title="0">{
        switch name </span>{
        case "baseUrl":<span class="cov0" title="0">
                name = "baseURL"</span>
        case "uglyUrls":<span class="cov0" title="0">
                name = "uglyURLs"</span>
        }
        <span class="cov0" title="0">return pflag.NormalizedName(name)</span>
}

// PrintFs prints the given filesystem to the given writer starting from the given path.
// This is useful for debugging.
func PrintFs(fs afero.Fs, path string, w io.Writer) <span class="cov0" title="0">{
        if fs == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">afero.Walk(fs, path, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                var filename string
                var meta interface{}
                if fim, ok := info.(hugofs.FileMetaInfo); ok </span><span class="cov0" title="0">{
                        filename = fim.Meta().Filename
                        meta = fim.Meta()
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, "    %q %q\t\t%v\n", path, filename, meta)
                return nil</span>
        })
}

// HashString returns a hash from the given elements.
// It will panic if the hash cannot be calculated.
func HashString(elements ...interface{}) string <span class="cov8" title="1">{
        var o interface{}
        if len(elements) == 1 </span><span class="cov8" title="1">{
                o = elements[0]
        }</span> else<span class="cov8" title="1"> {
                o = elements
        }</span>

        <span class="cov8" title="1">hash, err := hashstructure.Hash(o, nil)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return strconv.FormatUint(hash, 10)</span>
}
</pre>
		
		<pre class="file" id="file79" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "errors"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "regexp"
        "sort"
        "strings"
        "unicode"

        "github.com/gohugoio/hugo/common/text"

        "github.com/gohugoio/hugo/config"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/common/hugio"
        _errors "github.com/pkg/errors"
        "github.com/spf13/afero"
)

// MakePath takes a string with any characters and replace it
// so the string could be used in a path.
// It does so by creating a Unicode-sanitized string, with the spaces replaced,
// whilst preserving the original casing of the string.
// E.g. Social Media -&gt; Social-Media
func (p *PathSpec) MakePath(s string) string <span class="cov8" title="1">{
        return p.UnicodeSanitize(s)
}</span>

// MakePathsSanitized applies MakePathSanitized on every item in the slice
func (p *PathSpec) MakePathsSanitized(paths []string) <span class="cov0" title="0">{
        for i, path := range paths </span><span class="cov0" title="0">{
                paths[i] = p.MakePathSanitized(path)
        }</span>
}

// MakePathSanitized creates a Unicode-sanitized string, with the spaces replaced
func (p *PathSpec) MakePathSanitized(s string) string <span class="cov8" title="1">{
        if p.DisablePathToLower </span><span class="cov8" title="1">{
                return p.MakePath(s)
        }</span>
        <span class="cov8" title="1">return strings.ToLower(p.MakePath(s))</span>
}

// ToSlashTrimLeading is just a filepath.ToSlaas with an added / prefix trimmer.
func ToSlashTrimLeading(s string) string <span class="cov0" title="0">{
        return strings.TrimPrefix(filepath.ToSlash(s), "/")
}</span>

// MakeTitle converts the path given to a suitable title, trimming whitespace
// and replacing hyphens with whitespace.
func MakeTitle(inpath string) string <span class="cov8" title="1">{
        return strings.Replace(strings.TrimSpace(inpath), "-", " ", -1)
}</span>

// From https://golang.org/src/net/url/url.go
func ishex(c rune) bool <span class="cov8" title="1">{
        switch </span>{
        case '0' &lt;= c &amp;&amp; c &lt;= '9':<span class="cov8" title="1">
                return true</span>
        case 'a' &lt;= c &amp;&amp; c &lt;= 'f':<span class="cov0" title="0">
                return true</span>
        case 'A' &lt;= c &amp;&amp; c &lt;= 'F':<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// UnicodeSanitize sanitizes string to be used in Hugo URL's, allowing only
// a predefined set of special Unicode characters.
// If RemovePathAccents configuration flag is enabled, Unicode accents
// are also removed.
// Spaces will be replaced with a single hyphen, and sequential hyphens will be reduced to one.
func (p *PathSpec) UnicodeSanitize(s string) string <span class="cov8" title="1">{
        if p.RemovePathAccents </span><span class="cov8" title="1">{
                s = text.RemoveAccentsString(s)
        }</span>

        <span class="cov8" title="1">source := []rune(s)
        target := make([]rune, 0, len(source))
        var prependHyphen bool

        for i, r := range source </span><span class="cov8" title="1">{
                isAllowed := r == '.' || r == '/' || r == '\\' || r == '_' || r == '#' || r == '+' || r == '~'
                isAllowed = isAllowed || unicode.IsLetter(r) || unicode.IsDigit(r) || unicode.IsMark(r)
                isAllowed = isAllowed || (r == '%' &amp;&amp; i+2 &lt; len(source) &amp;&amp; ishex(source[i+1]) &amp;&amp; ishex(source[i+2]))

                if isAllowed </span><span class="cov8" title="1">{
                        if prependHyphen </span><span class="cov8" title="1">{
                                target = append(target, '-')
                                prependHyphen = false
                        }</span>
                        <span class="cov8" title="1">target = append(target, r)</span>
                } else<span class="cov8" title="1"> if len(target) &gt; 0 &amp;&amp; (r == '-' || unicode.IsSpace(r)) </span><span class="cov8" title="1">{
                        prependHyphen = true
                }</span>
        }

        <span class="cov8" title="1">return string(target)</span>
}

func makePathRelative(inPath string, possibleDirectories ...string) (string, error) <span class="cov8" title="1">{
        for _, currentPath := range possibleDirectories </span><span class="cov8" title="1">{
                if strings.HasPrefix(inPath, currentPath) </span><span class="cov8" title="1">{
                        return strings.TrimPrefix(inPath, currentPath), nil
                }</span>
        }
        <span class="cov8" title="1">return inPath, errors.New("can't extract relative path, unknown prefix")</span>
}

// Should be good enough for Hugo.
var isFileRe = regexp.MustCompile(`.*\..{1,6}$`)

// GetDottedRelativePath expects a relative path starting after the content directory.
// It returns a relative path with dots ("..") navigating up the path structure.
func GetDottedRelativePath(inPath string) string <span class="cov8" title="1">{
        inPath = filepath.Clean(filepath.FromSlash(inPath))

        if inPath == "." </span><span class="cov8" title="1">{
                return "./"
        }</span>

        <span class="cov8" title="1">if !isFileRe.MatchString(inPath) &amp;&amp; !strings.HasSuffix(inPath, FilePathSeparator) </span><span class="cov8" title="1">{
                inPath += FilePathSeparator
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(inPath, FilePathSeparator) </span><span class="cov8" title="1">{
                inPath = FilePathSeparator + inPath
        }</span>

        <span class="cov8" title="1">dir, _ := filepath.Split(inPath)

        sectionCount := strings.Count(dir, FilePathSeparator)

        if sectionCount == 0 || dir == FilePathSeparator </span><span class="cov8" title="1">{
                return "./"
        }</span>

        <span class="cov8" title="1">var dottedPath string

        for i := 1; i &lt; sectionCount; i++ </span><span class="cov8" title="1">{
                dottedPath += "../"
        }</span>

        <span class="cov8" title="1">return dottedPath</span>
}

type NamedSlice struct {
        Name  string
        Slice []string
}

func (n NamedSlice) String() string <span class="cov8" title="1">{
        if len(n.Slice) == 0 </span><span class="cov8" title="1">{
                return n.Name
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s%s{%s}", n.Name, FilePathSeparator, strings.Join(n.Slice, ","))</span>
}

func ExtractAndGroupRootPaths(paths []string) []NamedSlice <span class="cov8" title="1">{
        if len(paths) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">pathsCopy := make([]string, len(paths))
        hadSlashPrefix := strings.HasPrefix(paths[0], FilePathSeparator)

        for i, p := range paths </span><span class="cov8" title="1">{
                pathsCopy[i] = strings.Trim(filepath.ToSlash(p), "/")
        }</span>

        <span class="cov8" title="1">sort.Strings(pathsCopy)

        pathsParts := make([][]string, len(pathsCopy))

        for i, p := range pathsCopy </span><span class="cov8" title="1">{
                pathsParts[i] = strings.Split(p, "/")
        }</span>

        <span class="cov8" title="1">var groups [][]string

        for i, p1 := range pathsParts </span><span class="cov8" title="1">{
                c1 := -1

                for j, p2 := range pathsParts </span><span class="cov8" title="1">{
                        if i == j </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">c2 := -1

                        for i, v := range p1 </span><span class="cov8" title="1">{
                                if i &gt;= len(p2) </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">if v != p2[i] </span><span class="cov8" title="1">{
                                        break</span>
                                }

                                <span class="cov8" title="1">c2 = i</span>
                        }

                        <span class="cov8" title="1">if c1 == -1 || (c2 != -1 &amp;&amp; c2 &lt; c1) </span><span class="cov8" title="1">{
                                c1 = c2
                        }</span>
                }

                <span class="cov8" title="1">if c1 != -1 </span><span class="cov8" title="1">{
                        groups = append(groups, p1[:c1+1])
                }</span> else<span class="cov8" title="1"> {
                        groups = append(groups, p1)
                }</span>
        }

        <span class="cov8" title="1">groupsStr := make([]string, len(groups))
        for i, g := range groups </span><span class="cov8" title="1">{
                groupsStr[i] = strings.Join(g, "/")
        }</span>

        <span class="cov8" title="1">groupsStr = UniqueStringsSorted(groupsStr)

        var result []NamedSlice

        for _, g := range groupsStr </span><span class="cov8" title="1">{
                name := filepath.FromSlash(g)
                if hadSlashPrefix </span><span class="cov8" title="1">{
                        name = FilePathSeparator + name
                }</span>
                <span class="cov8" title="1">ns := NamedSlice{Name: name}
                for _, p := range pathsCopy </span><span class="cov8" title="1">{
                        if !strings.HasPrefix(p, g) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">p = strings.TrimPrefix(p, g)
                        if p != "" </span><span class="cov8" title="1">{
                                ns.Slice = append(ns.Slice, p)
                        }</span>
                }

                <span class="cov8" title="1">ns.Slice = UniqueStrings(ExtractRootPaths(ns.Slice))

                result = append(result, ns)</span>
        }

        <span class="cov8" title="1">return result</span>
}

// ExtractRootPaths extracts the root paths from the supplied list of paths.
// The resulting root path will not contain any file separators, but there
// may be duplicates.
// So "/content/section/" becomes "content"
func ExtractRootPaths(paths []string) []string <span class="cov8" title="1">{
        r := make([]string, len(paths))
        for i, p := range paths </span><span class="cov8" title="1">{
                root := filepath.ToSlash(p)
                sections := strings.Split(root, "/")
                for _, section := range sections </span><span class="cov8" title="1">{
                        if section != "" </span><span class="cov8" title="1">{
                                root = section
                                break</span>
                        }
                }
                <span class="cov8" title="1">r[i] = root</span>
        }
        <span class="cov8" title="1">return r</span>
}

// FindCWD returns the current working directory from where the Hugo
// executable is run.
func FindCWD() (string, error) <span class="cov0" title="0">{
        serverFile, err := filepath.Abs(os.Args[0])
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("can't get absolute path for executable: %v", err)
        }</span>

        <span class="cov0" title="0">path := filepath.Dir(serverFile)
        realFile, err := filepath.EvalSymlinks(serverFile)
        if err != nil </span><span class="cov0" title="0">{
                if _, err = os.Stat(serverFile + ".exe"); err == nil </span><span class="cov0" title="0">{
                        realFile = filepath.Clean(serverFile + ".exe")
                }</span>
        }

        <span class="cov0" title="0">if err == nil &amp;&amp; realFile != serverFile </span><span class="cov0" title="0">{
                path = filepath.Dir(realFile)
        }</span>

        <span class="cov0" title="0">return path, nil</span>
}

// SymbolicWalk is like filepath.Walk, but it follows symbolic links.
func SymbolicWalk(fs afero.Fs, root string, walker hugofs.WalkFunc) error <span class="cov0" title="0">{
        if _, isOs := fs.(*afero.OsFs); isOs </span><span class="cov0" title="0">{
                // Mainly to track symlinks.
                fs = hugofs.NewBaseFileDecorator(fs)
        }</span>

        <span class="cov0" title="0">w := hugofs.NewWalkway(hugofs.WalkwayConfig{
                Fs:     fs,
                Root:   root,
                WalkFn: walker,
        })

        return w.Walk()</span>
}

// LstatIfPossible can be used to call Lstat if possible, else Stat.
func LstatIfPossible(fs afero.Fs, path string) (os.FileInfo, error) <span class="cov0" title="0">{
        if lstater, ok := fs.(afero.Lstater); ok </span><span class="cov0" title="0">{
                fi, _, err := lstater.LstatIfPossible(path)
                return fi, err
        }</span>

        <span class="cov0" title="0">return fs.Stat(path)</span>
}

// SafeWriteToDisk is the same as WriteToDisk
// but it also checks to see if file/directory already exists.
func SafeWriteToDisk(inpath string, r io.Reader, fs afero.Fs) (err error) <span class="cov8" title="1">{
        return afero.SafeWriteReader(fs, inpath, r)
}</span>

// WriteToDisk writes content to disk.
func WriteToDisk(inpath string, r io.Reader, fs afero.Fs) (err error) <span class="cov8" title="1">{
        return afero.WriteReader(fs, inpath, r)
}</span>

// OpenFilesForWriting opens all the given filenames for writing.
func OpenFilesForWriting(fs afero.Fs, filenames ...string) (io.WriteCloser, error) <span class="cov0" title="0">{
        var writeClosers []io.WriteCloser
        for _, filename := range filenames </span><span class="cov0" title="0">{
                f, err := OpenFileForWriting(fs, filename)
                if err != nil </span><span class="cov0" title="0">{
                        for _, wc := range writeClosers </span><span class="cov0" title="0">{
                                wc.Close()
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov0" title="0">writeClosers = append(writeClosers, f)</span>
        }

        <span class="cov0" title="0">return hugio.NewMultiWriteCloser(writeClosers...), nil</span>
}

// OpenFileForWriting opens or creates the given file. If the target directory
// does not exist, it gets created.
func OpenFileForWriting(fs afero.Fs, filename string) (afero.File, error) <span class="cov0" title="0">{
        filename = filepath.Clean(filename)
        // Create will truncate if file already exists.
        // os.Create will create any new files with mode 0666 (before umask).
        f, err := fs.Create(filename)
        if err != nil </span><span class="cov0" title="0">{
                if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">if err = fs.MkdirAll(filepath.Dir(filename), 0777); err != nil </span><span class="cov0" title="0">{ //  before umask
                        return nil, err
                }</span>
                <span class="cov0" title="0">f, err = fs.Create(filename)</span>
        }

        <span class="cov0" title="0">return f, err</span>
}

// GetCacheDir returns a cache dir from the given filesystem and config.
// The dir will be created if it does not exist.
func GetCacheDir(fs afero.Fs, cfg config.Provider) (string, error) <span class="cov0" title="0">{
        cacheDir := getCacheDir(cfg)
        if cacheDir != "" </span><span class="cov0" title="0">{
                exists, err := DirExists(cacheDir, fs)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov0" title="0">if !exists </span><span class="cov0" title="0">{
                        err := fs.MkdirAll(cacheDir, 0777) // Before umask
                        if err != nil </span><span class="cov0" title="0">{
                                return "", _errors.Wrap(err, "failed to create cache dir")
                        }</span>
                }
                <span class="cov0" title="0">return cacheDir, nil</span>
        }

        // Fall back to a cache in /tmp.
        <span class="cov0" title="0">return GetTempDir("hugo_cache", fs), nil</span>
}

func getCacheDir(cfg config.Provider) string <span class="cov0" title="0">{
        // Always use the cacheDir config if set.
        cacheDir := cfg.GetString("cacheDir")
        if len(cacheDir) &gt; 1 </span><span class="cov0" title="0">{
                return addTrailingFileSeparator(cacheDir)
        }</span>

        // See Issue #8714.
        // Turns out that Cloudflare also sets NETLIFY=true in its build environment,
        // but all of these 3 should not give any false positives.
        <span class="cov0" title="0">if os.Getenv("NETLIFY") == "true" &amp;&amp; os.Getenv("PULL_REQUEST") != "" &amp;&amp; os.Getenv("DEPLOY_PRIME_URL") != "" </span><span class="cov0" title="0">{
                // Netlify's cache behaviour is not documented, the currently best example
                // is this project:
                // https://github.com/philhawksworth/content-shards/blob/master/gulpfile.js
                return "/opt/build/cache/hugo_cache/"
        }</span>

        // This will fall back to an hugo_cache folder in the tmp dir, which should work fine for most CI
        // providers. See this for a working CircleCI setup:
        // https://github.com/bep/hugo-sass-test/blob/6c3960a8f4b90e8938228688bc49bdcdd6b2d99e/.circleci/config.yml
        // If not, they can set the HUGO_CACHEDIR environment variable or cacheDir config key.
        <span class="cov0" title="0">return ""</span>
}

func addTrailingFileSeparator(s string) string <span class="cov0" title="0">{
        if !strings.HasSuffix(s, FilePathSeparator) </span><span class="cov0" title="0">{
                s = s + FilePathSeparator
        }</span>
        <span class="cov0" title="0">return s</span>
}

// GetTempDir returns a temporary directory with the given sub path.
func GetTempDir(subPath string, fs afero.Fs) string <span class="cov8" title="1">{
        return afero.GetTempDir(fs, subPath)
}</span>

// DirExists checks if a path exists and is a directory.
func DirExists(path string, fs afero.Fs) (bool, error) <span class="cov8" title="1">{
        return afero.DirExists(fs, path)
}</span>

// IsDir checks if a given path is a directory.
func IsDir(path string, fs afero.Fs) (bool, error) <span class="cov8" title="1">{
        return afero.IsDir(fs, path)
}</span>

// IsEmpty checks if a given path is empty.
func IsEmpty(path string, fs afero.Fs) (bool, error) <span class="cov8" title="1">{
        return afero.IsEmpty(fs, path)
}</span>

// Exists checks if a file or directory exists.
func Exists(path string, fs afero.Fs) (bool, error) <span class="cov8" title="1">{
        return afero.Exists(fs, path)
}</span>

// AddTrailingSlash adds a trailing Unix styled slash (/) if not already
// there.
func AddTrailingSlash(path string) string <span class="cov0" title="0">{
        if !strings.HasSuffix(path, "/") </span><span class="cov0" title="0">{
                path += "/"
        }</span>
        <span class="cov0" title="0">return path</span>
}
</pre>
		
		<pre class="file" id="file80" style="display: none">// Copyright 2016-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "strings"

        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/hugolib/filesystems"
        "github.com/gohugoio/hugo/hugolib/paths"
)

// PathSpec holds methods that decides how paths in URLs and files in Hugo should look like.
type PathSpec struct {
        *paths.Paths
        *filesystems.BaseFs

        ProcessingStats *ProcessingStats

        // The file systems to use
        Fs *hugofs.Fs

        // The config provider to use
        Cfg config.Provider
}

// NewPathSpec creates a new PathSpec from the given filesystems and language.
func NewPathSpec(fs *hugofs.Fs, cfg config.Provider, logger loggers.Logger) (*PathSpec, error) <span class="cov8" title="1">{
        return NewPathSpecWithBaseBaseFsProvided(fs, cfg, logger, nil)
}</span>

// NewPathSpecWithBaseBaseFsProvided creats a new PathSpec from the given filesystems and language.
// If an existing BaseFs is provided, parts of that is reused.
func NewPathSpecWithBaseBaseFsProvided(fs *hugofs.Fs, cfg config.Provider, logger loggers.Logger, baseBaseFs *filesystems.BaseFs) (*PathSpec, error) <span class="cov8" title="1">{
        p, err := paths.New(fs, cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var options []func(*filesystems.BaseFs) error
        if baseBaseFs != nil </span><span class="cov0" title="0">{
                options = []func(*filesystems.BaseFs) error{
                        filesystems.WithBaseFs(baseBaseFs),
                }
        }</span>
        <span class="cov8" title="1">bfs, err := filesystems.NewBase(p, logger, options...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ps := &amp;PathSpec{
                Paths:           p,
                BaseFs:          bfs,
                Fs:              fs,
                Cfg:             cfg,
                ProcessingStats: NewProcessingStats(p.Lang()),
        }

        basePath := ps.BaseURL.Path()
        if basePath != "" &amp;&amp; basePath != "/" </span><span class="cov8" title="1">{
                ps.BasePath = basePath
        }</span>

        <span class="cov8" title="1">return ps, nil</span>
}

// PermalinkForBaseURL creates a permalink from the given link and baseURL.
func (p *PathSpec) PermalinkForBaseURL(link, baseURL string) string <span class="cov0" title="0">{
        link = strings.TrimPrefix(link, "/")
        if !strings.HasSuffix(baseURL, "/") </span><span class="cov0" title="0">{
                baseURL += "/"
        }</span>
        <span class="cov0" title="0">return baseURL + link</span>
}
</pre>
		
		<pre class="file" id="file81" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "io"
        "strconv"
        "sync/atomic"

        "github.com/olekukonko/tablewriter"
)

// ProcessingStats represents statistics about a site build.
type ProcessingStats struct {
        Name string

        Pages           uint64
        PaginatorPages  uint64
        Static          uint64
        ProcessedImages uint64
        Files           uint64
        Aliases         uint64
        Sitemaps        uint64
        Cleaned         uint64
}

type processingStatsTitleVal struct {
        name string
        val  uint64
}

func (s *ProcessingStats) toVals() []processingStatsTitleVal <span class="cov0" title="0">{
        return []processingStatsTitleVal{
                {"Pages", s.Pages},
                {"Paginator pages", s.PaginatorPages},
                {"Non-page files", s.Files},
                {"Static files", s.Static},
                {"Processed images", s.ProcessedImages},
                {"Aliases", s.Aliases},
                {"Sitemaps", s.Sitemaps},
                {"Cleaned", s.Cleaned},
        }
}</span>

// NewProcessingStats returns a new ProcessingStats instance.
func NewProcessingStats(name string) *ProcessingStats <span class="cov8" title="1">{
        return &amp;ProcessingStats{Name: name}
}</span>

// Incr increments a given counter.
func (s *ProcessingStats) Incr(counter *uint64) <span class="cov0" title="0">{
        atomic.AddUint64(counter, 1)
}</span>

// Add adds an amount to a given counter.
func (s *ProcessingStats) Add(counter *uint64, amount int) <span class="cov0" title="0">{
        atomic.AddUint64(counter, uint64(amount))
}</span>

// Table writes a table-formatted representation of the stats in a
// ProcessingStats instance to w.
func (s *ProcessingStats) Table(w io.Writer) <span class="cov0" title="0">{
        titleVals := s.toVals()
        data := make([][]string, len(titleVals))
        for i, tv := range titleVals </span><span class="cov0" title="0">{
                data[i] = []string{tv.name, strconv.Itoa(int(tv.val))}
        }</span>

        <span class="cov0" title="0">table := tablewriter.NewWriter(w)

        table.AppendBulk(data)
        table.SetHeader([]string{"", s.Name})
        table.SetBorder(false)
        table.Render()</span>
}

// ProcessingStatsTable writes a table-formatted representation of stats to w.
func ProcessingStatsTable(w io.Writer, stats ...*ProcessingStats) <span class="cov0" title="0">{
        names := make([]string, len(stats)+1)

        var data [][]string

        for i := 0; i &lt; len(stats); i++ </span><span class="cov0" title="0">{
                stat := stats[i]
                names[i+1] = stat.Name

                titleVals := stat.toVals()

                if i == 0 </span><span class="cov0" title="0">{
                        data = make([][]string, len(titleVals))
                }</span>

                <span class="cov0" title="0">for j, tv := range titleVals </span><span class="cov0" title="0">{
                        if i == 0 </span><span class="cov0" title="0">{
                                data[j] = []string{tv.name, strconv.Itoa(int(tv.val))}
                        }</span> else<span class="cov0" title="0"> {
                                data[j] = append(data[j], strconv.Itoa(int(tv.val)))
                        }</span>
                }

        }

        <span class="cov0" title="0">table := tablewriter.NewWriter(w)

        table.AppendBulk(data)
        table.SetHeader(names)
        table.SetBorder(false)
        table.Render()</span>
}
</pre>
		
		<pre class="file" id="file82" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package helpers

import (
        "net/url"
        "path"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/paths"

        "github.com/PuerkitoBio/purell"
)

func sanitizeURLWithFlags(in string, f purell.NormalizationFlags) string <span class="cov8" title="1">{
        s, err := purell.NormalizeURLString(in, f)
        if err != nil </span><span class="cov0" title="0">{
                return in
        }</span>

        // Temporary workaround for the bug fix and resulting
        // behavioral change in purell.NormalizeURLString():
        // a leading '/' was inadvertently added to relative links,
        // but no longer, see #878.
        //
        // I think the real solution is to allow Hugo to
        // make relative URL with relative path,
        // e.g. "../../post/hello-again/", as wished by users
        // in issues #157, #622, etc., without forcing
        // relative URLs to begin with '/'.
        // Once the fixes are in, let's remove this kludge
        // and restore SanitizeURL() to the way it was.
        //                         -- @anthonyfok, 2015-02-16
        //
        // Begin temporary kludge
        <span class="cov8" title="1">u, err := url.Parse(s)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">if len(u.Path) &gt; 0 &amp;&amp; !strings.HasPrefix(u.Path, "/") </span><span class="cov0" title="0">{
                u.Path = "/" + u.Path
        }</span>
        <span class="cov8" title="1">return u.String()</span>
        // End temporary kludge

        // return s

}

// SanitizeURL sanitizes the input URL string.
func SanitizeURL(in string) string <span class="cov8" title="1">{
        return sanitizeURLWithFlags(in, purell.FlagsSafe|purell.FlagRemoveTrailingSlash|purell.FlagRemoveDotSegments|purell.FlagRemoveDuplicateSlashes|purell.FlagRemoveUnnecessaryHostDots|purell.FlagRemoveEmptyPortSeparator)
}</span>

// SanitizeURLKeepTrailingSlash is the same as SanitizeURL, but will keep any trailing slash.
func SanitizeURLKeepTrailingSlash(in string) string <span class="cov8" title="1">{
        return sanitizeURLWithFlags(in, purell.FlagsSafe|purell.FlagRemoveDotSegments|purell.FlagRemoveDuplicateSlashes|purell.FlagRemoveUnnecessaryHostDots|purell.FlagRemoveEmptyPortSeparator)
}</span>

// URLize is similar to MakePath, but with Unicode handling
// Example:
//     uri: Vim (text editor)
//     urlize: vim-text-editor
func (p *PathSpec) URLize(uri string) string <span class="cov8" title="1">{
        return p.URLEscape(p.MakePathSanitized(uri))
}</span>

// URLizeFilename creates an URL from a filename by escaping unicode letters
// and turn any filepath separator into forward slashes.
func (p *PathSpec) URLizeFilename(filename string) string <span class="cov0" title="0">{
        return p.URLEscape(filepath.ToSlash(filename))
}</span>

// URLEscape escapes unicode letters.
func (p *PathSpec) URLEscape(uri string) string <span class="cov8" title="1">{
        // escape unicode letters
        parsedURI, err := url.Parse(uri)
        if err != nil </span><span class="cov0" title="0">{
                // if net/url can not parse URL it means Sanitize works incorrectly
                panic(err)</span>
        }
        <span class="cov8" title="1">x := parsedURI.String()
        return x</span>
}

// AbsURL creates an absolute URL from the relative path given and the BaseURL set in config.
func (p *PathSpec) AbsURL(in string, addLanguage bool) string <span class="cov8" title="1">{
        url, err := url.Parse(in)
        if err != nil </span><span class="cov0" title="0">{
                return in
        }</span>

        <span class="cov8" title="1">if url.IsAbs() || strings.HasPrefix(in, "//") </span><span class="cov8" title="1">{
                return in
        }</span>

        <span class="cov8" title="1">var baseURL string
        if strings.HasPrefix(in, "/") </span><span class="cov8" title="1">{
                u := p.BaseURL.URL()
                u.Path = ""
                baseURL = u.String()
        }</span> else<span class="cov8" title="1"> {
                baseURL = p.BaseURL.String()
        }</span>

        <span class="cov8" title="1">if addLanguage </span><span class="cov8" title="1">{
                prefix := p.GetLanguagePrefix()
                if prefix != "" </span><span class="cov8" title="1">{
                        hasPrefix := false
                        // avoid adding language prefix if already present
                        in2 := in
                        if strings.HasPrefix(in, "/") </span><span class="cov8" title="1">{
                                in2 = in[1:]
                        }</span>
                        <span class="cov8" title="1">if in2 == prefix </span><span class="cov0" title="0">{
                                hasPrefix = true
                        }</span> else<span class="cov8" title="1"> {
                                hasPrefix = strings.HasPrefix(in2, prefix+"/")
                        }</span>

                        <span class="cov8" title="1">if !hasPrefix </span><span class="cov8" title="1">{
                                addSlash := in == "" || strings.HasSuffix(in, "/")
                                in = path.Join(prefix, in)

                                if addSlash </span><span class="cov8" title="1">{
                                        in += "/"
                                }</span>
                        }
                }
        }
        <span class="cov8" title="1">return paths.MakePermalink(baseURL, in).String()</span>
}

// RelURL creates a URL relative to the BaseURL root.
// Note: The result URL will not include the context root if canonifyURLs is enabled.
func (p *PathSpec) RelURL(in string, addLanguage bool) string <span class="cov8" title="1">{
        baseURL := p.BaseURL.String()
        canonifyURLs := p.CanonifyURLs
        if (!strings.HasPrefix(in, baseURL) &amp;&amp; strings.HasPrefix(in, "http")) || strings.HasPrefix(in, "//") </span><span class="cov8" title="1">{
                return in
        }</span>

        <span class="cov8" title="1">u := in

        if strings.HasPrefix(in, baseURL) </span><span class="cov0" title="0">{
                u = strings.TrimPrefix(u, baseURL)
        }</span>

        <span class="cov8" title="1">if addLanguage </span><span class="cov8" title="1">{
                prefix := p.GetLanguagePrefix()
                if prefix != "" </span><span class="cov8" title="1">{
                        hasPrefix := false
                        // avoid adding language prefix if already present
                        in2 := in
                        if strings.HasPrefix(in, "/") </span><span class="cov8" title="1">{
                                in2 = in[1:]
                        }</span>
                        <span class="cov8" title="1">if in2 == prefix </span><span class="cov0" title="0">{
                                hasPrefix = true
                        }</span> else<span class="cov8" title="1"> {
                                hasPrefix = strings.HasPrefix(in2, prefix+"/")
                        }</span>

                        <span class="cov8" title="1">if !hasPrefix </span><span class="cov8" title="1">{
                                hadSlash := strings.HasSuffix(u, "/")

                                u = path.Join(prefix, u)

                                if hadSlash </span><span class="cov8" title="1">{
                                        u += "/"
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if !canonifyURLs </span><span class="cov8" title="1">{
                u = paths.AddContextRoot(baseURL, u)
        }</span>

        <span class="cov8" title="1">if in == "" &amp;&amp; !strings.HasSuffix(u, "/") &amp;&amp; strings.HasSuffix(baseURL, "/") </span><span class="cov8" title="1">{
                u += "/"
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(u, "/") </span><span class="cov8" title="1">{
                u = "/" + u
        }</span>

        <span class="cov8" title="1">return u</span>
}

// PrependBasePath prepends any baseURL sub-folder to the given resource
func (p *PathSpec) PrependBasePath(rel string, isAbs bool) string <span class="cov0" title="0">{
        basePath := p.GetBasePath(!isAbs)
        if basePath != "" </span><span class="cov0" title="0">{
                rel = filepath.ToSlash(rel)
                // Need to prepend any path from the baseURL
                hadSlash := strings.HasSuffix(rel, "/")
                rel = path.Join(basePath, rel)
                if hadSlash </span><span class="cov0" title="0">{
                        rel += "/"
                }</span>
        }
        <span class="cov0" title="0">return rel</span>
}

// URLizeAndPrep applies misc sanitation to the given URL to get it in line
// with the Hugo standard.
func (p *PathSpec) URLizeAndPrep(in string) string <span class="cov0" title="0">{
        return p.URLPrep(p.URLize(in))
}</span>

// URLPrep applies misc sanitation to the given URL.
func (p *PathSpec) URLPrep(in string) string <span class="cov8" title="1">{
        if p.UglyURLs </span><span class="cov8" title="1">{
                return paths.Uglify(SanitizeURL(in))
        }</span>
        <span class="cov8" title="1">pretty := paths.PrettifyURL(SanitizeURL(in))
        if path.Ext(pretty) == ".xml" </span><span class="cov0" title="0">{
                return pretty
        }</span>
        <span class="cov8" title="1">url, err := purell.NormalizeURLString(pretty, purell.FlagAddTrailingSlash)
        if err != nil </span><span class="cov0" title="0">{
                return pretty
        }</span>
        <span class="cov8" title="1">return url</span>
}
</pre>
		
		<pre class="file" id="file83" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package htesting

import (
        "math/rand"
        "os"
        "regexp"
        "runtime"
        "strconv"
        "strings"
        "time"

        "github.com/spf13/afero"
)

// IsTest reports whether we're running as a test.
var IsTest bool

func init() <span class="cov8" title="1">{
        for _, arg := range os.Args </span><span class="cov8" title="1">{
                if strings.HasPrefix(arg, "-test.") </span><span class="cov8" title="1">{
                        IsTest = true
                        break</span>
                }
        }
}

// CreateTempDir creates a temp dir in the given filesystem and
// returns the dirnam and a func that removes it when done.
func CreateTempDir(fs afero.Fs, prefix string) (string, func(), error) <span class="cov0" title="0">{
        tempDir, err := afero.TempDir(fs, "", prefix)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>

        <span class="cov0" title="0">_, isOsFs := fs.(*afero.OsFs)

        if isOsFs &amp;&amp; runtime.GOOS == "darwin" &amp;&amp; !strings.HasPrefix(tempDir, "/private") </span><span class="cov0" title="0">{
                // To get the entry folder in line with the rest. This its a little bit
                // mysterious, but so be it.
                tempDir = "/private" + tempDir
        }</span>
        <span class="cov0" title="0">return tempDir, func() </span><span class="cov0" title="0">{ fs.RemoveAll(tempDir) }</span>, nil
}

// BailOut panics with a stack trace after the given duration. Useful for
// hanging tests.
func BailOut(after time.Duration) <span class="cov0" title="0">{
        time.AfterFunc(after, func() </span><span class="cov0" title="0">{
                buf := make([]byte, 1&lt;&lt;16)
                runtime.Stack(buf, true)
                panic(string(buf))</span>
        })
}

// Rnd is used only for testing.
var Rnd = rand.New(rand.NewSource(time.Now().UnixNano()))

func RandBool() bool <span class="cov0" title="0">{
        return Rnd.Intn(2) != 0
}</span>

// DiffStringSlices returns the difference between two string slices.
// Useful in tests.
// See:
// http://stackoverflow.com/questions/19374219/how-to-find-the-difference-between-two-slices-of-strings-in-golang
func DiffStringSlices(slice1 []string, slice2 []string) []string <span class="cov0" title="0">{
        diffStr := []string{}
        m := map[string]int{}

        for _, s1Val := range slice1 </span><span class="cov0" title="0">{
                m[s1Val] = 1
        }</span>
        <span class="cov0" title="0">for _, s2Val := range slice2 </span><span class="cov0" title="0">{
                m[s2Val] = m[s2Val] + 1
        }</span>

        <span class="cov0" title="0">for mKey, mVal := range m </span><span class="cov0" title="0">{
                if mVal == 1 </span><span class="cov0" title="0">{
                        diffStr = append(diffStr, mKey)
                }</span>
        }

        <span class="cov0" title="0">return diffStr</span>
}

// DiffStrings splits the strings into fields and runs it into DiffStringSlices.
// Useful for tests.
func DiffStrings(s1, s2 string) []string <span class="cov0" title="0">{
        return DiffStringSlices(strings.Fields(s1), strings.Fields(s2))
}</span>

// IsCI reports whether we're running in a CI server.
func IsCI() bool <span class="cov0" title="0">{
        return (os.Getenv("CI") != "" || os.Getenv("CI_LOCAL") != "") &amp;&amp; os.Getenv("CIRCLE_BRANCH") == ""
}</span>

// IsGitHubAction reports whether we're running in a GitHub Action.
func IsGitHubAction() bool <span class="cov0" title="0">{
        return os.Getenv("GITHUB_ACTION") != ""
}</span>

// SupportsAll reports whether the running system supports all Hugo features,
// e.g. Asciidoc, Pandoc etc.
func SupportsAll() bool <span class="cov0" title="0">{
        return IsGitHubAction() || os.Getenv("CI_LOCAL") != ""
}</span>

// GoMinorVersion returns the minor version of the current Go version,
// e.g. 16 for Go 1.16.
func GoMinorVersion() int <span class="cov0" title="0">{
        return extractMinorVersionFromGoTag(runtime.Version())
}</span>

var goMinorVersionRe = regexp.MustCompile(`go1.(\d*)`)

func extractMinorVersionFromGoTag(tag string) int <span class="cov8" title="1">{
        // The tag may be on the form go1.17, go1.17.5 go1.17rc2 -- or just a commit hash.
        match := goMinorVersionRe.FindStringSubmatch(tag)

        if len(match) == 2 </span><span class="cov8" title="1">{
                i, err := strconv.Atoi(match[1])
                if err != nil </span><span class="cov0" title="0">{
                        return -1
                }</span>
                <span class="cov8" title="1">return i</span>
        }

        // a commit hash, not useful.
        <span class="cov8" title="1">return -1</span>

}
</pre>
		
		<pre class="file" id="file84" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package htesting

import (
        "path/filepath"
        "testing"

        "github.com/spf13/afero"
)

type testFile struct {
        name    string
        content string
}

type testdataBuilder struct {
        t          testing.TB
        fs         afero.Fs
        workingDir string

        files []testFile
}

func NewTestdataBuilder(fs afero.Fs, workingDir string, t testing.TB) *testdataBuilder <span class="cov0" title="0">{
        workingDir = filepath.Clean(workingDir)
        return &amp;testdataBuilder{fs: fs, workingDir: workingDir, t: t}
}</span>

func (b *testdataBuilder) Add(filename, content string) *testdataBuilder <span class="cov0" title="0">{
        b.files = append(b.files, testFile{name: filename, content: content})
        return b
}</span>

func (b *testdataBuilder) Build() *testdataBuilder <span class="cov0" title="0">{
        for _, f := range b.files </span><span class="cov0" title="0">{
                if err := afero.WriteFile(b.fs, filepath.Join(b.workingDir, f.name), []byte(f.content), 0666); err != nil </span><span class="cov0" title="0">{
                        b.t.Fatalf("failed to add %q: %s", f.name, err)
                }</span>
        }
        <span class="cov0" title="0">return b</span>
}

func (b testdataBuilder) WithWorkingDir(dir string) *testdataBuilder <span class="cov0" title="0">{
        b.workingDir = filepath.Clean(dir)
        b.files = make([]testFile, 0)
        return &amp;b
}</span>
</pre>
		
		<pre class="file" id="file85" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "fmt"
        "os"
        "sort"
        "strings"
        "sync"

        "github.com/spf13/afero"
)

// Reseter is implemented by some of the stateful filesystems.
type Reseter interface {
        Reset()
}

// DuplicatesReporter reports about duplicate filenames.
type DuplicatesReporter interface {
        ReportDuplicates() string
}

func NewCreateCountingFs(fs afero.Fs) afero.Fs <span class="cov0" title="0">{
        return &amp;createCountingFs{Fs: fs, fileCount: make(map[string]int)}
}</span>

// ReportDuplicates reports filenames written more than once.
func (c *createCountingFs) ReportDuplicates() string <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        var dupes []string

        for k, v := range c.fileCount </span><span class="cov0" title="0">{
                if v &gt; 1 </span><span class="cov0" title="0">{
                        dupes = append(dupes, fmt.Sprintf("%s (%d)", k, v))
                }</span>
        }

        <span class="cov0" title="0">if len(dupes) == 0 </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">sort.Strings(dupes)

        return strings.Join(dupes, ", ")</span>
}

// createCountingFs counts filenames of created files or files opened
// for writing.
type createCountingFs struct {
        afero.Fs

        mu        sync.Mutex
        fileCount map[string]int
}

func (c *createCountingFs) Reset() <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()

        c.fileCount = make(map[string]int)
}</span>

func (fs *createCountingFs) onCreate(filename string) <span class="cov0" title="0">{
        fs.mu.Lock()
        defer fs.mu.Unlock()

        fs.fileCount[filename] = fs.fileCount[filename] + 1
}</span>

func (fs *createCountingFs) Create(name string) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.Fs.Create(name)
        if err == nil </span><span class="cov0" title="0">{
                fs.onCreate(name)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}

func (fs *createCountingFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.Fs.OpenFile(name, flag, perm)
        if err == nil &amp;&amp; isWrite(flag) </span><span class="cov0" title="0">{
                fs.onCreate(name)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}
</pre>
		
		<pre class="file" id="file86" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "os"
        "path/filepath"
        "strings"

        "github.com/pkg/errors"

        "github.com/spf13/afero"
)

func decorateDirs(fs afero.Fs, meta *FileMeta) afero.Fs <span class="cov8" title="1">{
        ffs := &amp;baseFileDecoratorFs{Fs: fs}

        decorator := func(fi os.FileInfo, name string) (os.FileInfo, error) </span><span class="cov8" title="1">{
                if !fi.IsDir() </span><span class="cov0" title="0">{
                        // Leave regular files as they are.
                        return fi, nil
                }</span>

                <span class="cov8" title="1">return decorateFileInfo(fi, fs, nil, "", "", meta), nil</span>
        }

        <span class="cov8" title="1">ffs.decorate = decorator

        return ffs</span>
}

func decoratePath(fs afero.Fs, createPath func(name string) string) afero.Fs <span class="cov8" title="1">{
        ffs := &amp;baseFileDecoratorFs{Fs: fs}

        decorator := func(fi os.FileInfo, name string) (os.FileInfo, error) </span><span class="cov8" title="1">{
                path := createPath(name)

                return decorateFileInfo(fi, fs, nil, "", path, nil), nil
        }</span>

        <span class="cov8" title="1">ffs.decorate = decorator

        return ffs</span>
}

// DecorateBasePathFs adds Path info to files and directories in the
// provided BasePathFs, using the base as base.
func DecorateBasePathFs(base *afero.BasePathFs) afero.Fs <span class="cov0" title="0">{
        basePath, _ := base.RealPath("")
        if !strings.HasSuffix(basePath, filepathSeparator) </span><span class="cov0" title="0">{
                basePath += filepathSeparator
        }</span>

        <span class="cov0" title="0">ffs := &amp;baseFileDecoratorFs{Fs: base}

        decorator := func(fi os.FileInfo, name string) (os.FileInfo, error) </span><span class="cov0" title="0">{
                path := strings.TrimPrefix(name, basePath)

                return decorateFileInfo(fi, base, nil, "", path, nil), nil
        }</span>

        <span class="cov0" title="0">ffs.decorate = decorator

        return ffs</span>
}

// NewBaseFileDecorator decorates the given Fs to provide the real filename
// and an Opener func.
func NewBaseFileDecorator(fs afero.Fs, callbacks ...func(fi FileMetaInfo)) afero.Fs <span class="cov8" title="1">{
        ffs := &amp;baseFileDecoratorFs{Fs: fs}

        decorator := func(fi os.FileInfo, filename string) (os.FileInfo, error) </span><span class="cov8" title="1">{
                // Store away the original in case it's a symlink.
                meta := NewFileMeta()
                meta.Name = fi.Name()

                if fi.IsDir() </span><span class="cov8" title="1">{
                        meta.JoinStatFunc = func(name string) (FileMetaInfo, error) </span><span class="cov8" title="1">{
                                joinedFilename := filepath.Join(filename, name)
                                fi, _, err := lstatIfPossible(fs, joinedFilename)
                                if err != nil </span><span class="cov8" title="1">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">fi, err = ffs.decorate(fi, joinedFilename)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">return fi.(FileMetaInfo), nil</span>
                        }
                }

                <span class="cov8" title="1">isSymlink := isSymlink(fi)
                if isSymlink </span><span class="cov8" title="1">{
                        meta.OriginalFilename = filename
                        var link string
                        var err error
                        link, fi, err = evalSymlinks(fs, filename)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">filename = link
                        meta.IsSymlink = true</span>
                }

                <span class="cov8" title="1">opener := func() (afero.File, error) </span><span class="cov8" title="1">{
                        return ffs.open(filename)
                }</span>

                <span class="cov8" title="1">fim := decorateFileInfo(fi, ffs, opener, filename, "", meta)

                for _, cb := range callbacks </span><span class="cov0" title="0">{
                        cb(fim)
                }</span>

                <span class="cov8" title="1">return fim, nil</span>
        }

        <span class="cov8" title="1">ffs.decorate = decorator
        return ffs</span>
}

func evalSymlinks(fs afero.Fs, filename string) (string, os.FileInfo, error) <span class="cov8" title="1">{
        link, err := filepath.EvalSymlinks(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>

        <span class="cov8" title="1">fi, err := fs.Stat(link)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil, err
        }</span>

        <span class="cov8" title="1">return link, fi, nil</span>
}

type baseFileDecoratorFs struct {
        afero.Fs
        decorate func(fi os.FileInfo, filename string) (os.FileInfo, error)
}

func (fs *baseFileDecoratorFs) Stat(name string) (os.FileInfo, error) <span class="cov8" title="1">{
        fi, err := fs.Fs.Stat(name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return fs.decorate(fi, name)</span>
}

func (fs *baseFileDecoratorFs) LstatIfPossible(name string) (os.FileInfo, bool, error) <span class="cov8" title="1">{
        var (
                fi  os.FileInfo
                err error
                ok  bool
        )

        if lstater, isLstater := fs.Fs.(afero.Lstater); isLstater </span><span class="cov8" title="1">{
                fi, ok, err = lstater.LstatIfPossible(name)
        }</span> else<span class="cov0" title="0"> {
                fi, err = fs.Fs.Stat(name)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>

        <span class="cov8" title="1">fi, err = fs.decorate(fi, name)

        return fi, ok, err</span>
}

func (fs *baseFileDecoratorFs) Open(name string) (afero.File, error) <span class="cov8" title="1">{
        return fs.open(name)
}</span>

func (fs *baseFileDecoratorFs) open(name string) (afero.File, error) <span class="cov8" title="1">{
        f, err := fs.Fs.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;baseFileDecoratorFile{File: f, fs: fs}, nil</span>
}

type baseFileDecoratorFile struct {
        afero.File
        fs *baseFileDecoratorFs
}

func (l *baseFileDecoratorFile) Readdir(c int) (ofi []os.FileInfo, err error) <span class="cov8" title="1">{
        dirnames, err := l.File.Readdirnames(c)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">fisp := make([]os.FileInfo, 0, len(dirnames))

        for _, dirname := range dirnames </span><span class="cov8" title="1">{
                filename := dirname

                if l.Name() != "" &amp;&amp; l.Name() != filepathSeparator </span><span class="cov8" title="1">{
                        filename = filepath.Join(l.Name(), dirname)
                }</span>

                // We need to resolve any symlink info.
                <span class="cov8" title="1">fi, _, err := lstatIfPossible(l.fs.Fs, filename)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">fi, err = l.fs.decorate(fi, filename)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "decorate")
                }</span>
                <span class="cov8" title="1">fisp = append(fisp, fi)</span>
        }

        <span class="cov8" title="1">return fisp, err</span>
}
</pre>
		
		<pre class="file" id="file87" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package hugofs provides the file systems used by Hugo.
package hugofs

import (
        "os"
        "path/filepath"
        "reflect"
        "runtime"
        "sort"
        "strings"
        "time"

        "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/gohugoio/hugo/hugofs/files"
        "golang.org/x/text/unicode/norm"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/hreflect"

        "github.com/spf13/afero"
)

func NewFileMeta() *FileMeta <span class="cov8" title="1">{
        return &amp;FileMeta{}
}</span>

// PathFile returns the relative file path for the file source.
func (f *FileMeta) PathFile() string <span class="cov8" title="1">{
        if f.BaseDir == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.TrimPrefix(strings.TrimPrefix(f.Filename, f.BaseDir), filepathSeparator)</span>
}

type FileMeta struct {
        Name             string
        Filename         string
        Path             string
        PathWalk         string
        OriginalFilename string
        BaseDir          string

        SourceRoot string
        MountRoot  string
        Module     string

        Weight     int
        Ordinal    int
        IsOrdered  bool
        IsSymlink  bool
        IsRootFile bool
        IsProject  bool
        Watch      bool

        Classifier files.ContentClass

        SkipDir bool

        Lang                       string
        TranslationBaseName        string
        TranslationBaseNameWithExt string
        Translations               []string

        Fs           afero.Fs
        OpenFunc     func() (afero.File, error)
        JoinStatFunc func(name string) (FileMetaInfo, error)

        // Include only files or directories that match.
        InclusionFilter *glob.FilenameFilter
}

func (m *FileMeta) Copy() *FileMeta <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                return NewFileMeta()
        }</span>
        <span class="cov8" title="1">c := *m
        return &amp;c</span>
}

func (m *FileMeta) Merge(from *FileMeta) <span class="cov8" title="1">{
        if m == nil || from == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">dstv := reflect.Indirect(reflect.ValueOf(m))
        srcv := reflect.Indirect(reflect.ValueOf(from))

        for i := 0; i &lt; dstv.NumField(); i++ </span><span class="cov8" title="1">{
                v := dstv.Field(i)
                if !v.CanSet() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if !hreflect.IsTruthfulValue(v) </span><span class="cov8" title="1">{
                        v.Set(srcv.Field(i))
                }</span>
        }

        <span class="cov8" title="1">if m.InclusionFilter == nil </span><span class="cov8" title="1">{
                m.InclusionFilter = from.InclusionFilter
        }</span>
}

func (f *FileMeta) Open() (afero.File, error) <span class="cov8" title="1">{
        if f.OpenFunc == nil </span><span class="cov0" title="0">{
                return nil, errors.New("OpenFunc not set")
        }</span>
        <span class="cov8" title="1">return f.OpenFunc()</span>
}

func (f *FileMeta) JoinStat(name string) (FileMetaInfo, error) <span class="cov8" title="1">{
        if f.JoinStatFunc == nil </span><span class="cov0" title="0">{
                return nil, os.ErrNotExist
        }</span>
        <span class="cov8" title="1">return f.JoinStatFunc(name)</span>
}

type FileMetaInfo interface {
        os.FileInfo
        Meta() *FileMeta
}

type fileInfoMeta struct {
        os.FileInfo

        m *FileMeta
}

// Name returns the file's name. Note that we follow symlinks,
// if supported by the file system, and the Name given here will be the
// name of the symlink, which is what Hugo needs in all situations.
func (fi *fileInfoMeta) Name() string <span class="cov8" title="1">{
        if name := fi.m.Name; name != "" </span><span class="cov8" title="1">{
                return name
        }</span>
        <span class="cov8" title="1">return fi.FileInfo.Name()</span>
}

func (fi *fileInfoMeta) Meta() *FileMeta <span class="cov8" title="1">{
        return fi.m
}</span>

func NewFileMetaInfo(fi os.FileInfo, m *FileMeta) FileMetaInfo <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                panic("FileMeta must be set")</span>
        }
        <span class="cov8" title="1">if fim, ok := fi.(FileMetaInfo); ok </span><span class="cov8" title="1">{
                m.Merge(fim.Meta())
        }</span>
        <span class="cov8" title="1">return &amp;fileInfoMeta{FileInfo: fi, m: m}</span>
}

type dirNameOnlyFileInfo struct {
        name    string
        modTime time.Time
}

func (fi *dirNameOnlyFileInfo) Name() string <span class="cov8" title="1">{
        return fi.name
}</span>

func (fi *dirNameOnlyFileInfo) Size() int64 <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (fi *dirNameOnlyFileInfo) Mode() os.FileMode <span class="cov0" title="0">{
        return os.ModeDir
}</span>

func (fi *dirNameOnlyFileInfo) ModTime() time.Time <span class="cov0" title="0">{
        return fi.modTime
}</span>

func (fi *dirNameOnlyFileInfo) IsDir() bool <span class="cov8" title="1">{
        return true
}</span>

func (fi *dirNameOnlyFileInfo) Sys() interface{} <span class="cov0" title="0">{
        return nil
}</span>

func newDirNameOnlyFileInfo(name string, meta *FileMeta, fileOpener func() (afero.File, error)) FileMetaInfo <span class="cov8" title="1">{
        name = normalizeFilename(name)
        _, base := filepath.Split(name)

        m := meta.Copy()
        if m.Filename == "" </span><span class="cov8" title="1">{
                m.Filename = name
        }</span>
        <span class="cov8" title="1">m.OpenFunc = fileOpener
        m.IsOrdered = false

        return NewFileMetaInfo(
                &amp;dirNameOnlyFileInfo{name: base, modTime: time.Now()},
                m,
        )</span>
}

func decorateFileInfo(
        fi os.FileInfo,
        fs afero.Fs, opener func() (afero.File, error),
        filename, filepath string, inMeta *FileMeta) FileMetaInfo <span class="cov8" title="1">{
        var meta *FileMeta
        var fim FileMetaInfo

        filepath = strings.TrimPrefix(filepath, filepathSeparator)

        var ok bool
        if fim, ok = fi.(FileMetaInfo); ok </span><span class="cov8" title="1">{
                meta = fim.Meta()
        }</span> else<span class="cov8" title="1"> {
                meta = NewFileMeta()
                fim = NewFileMetaInfo(fi, meta)
        }</span>

        <span class="cov8" title="1">if opener != nil </span><span class="cov8" title="1">{
                meta.OpenFunc = opener
        }</span>
        <span class="cov8" title="1">if fs != nil </span><span class="cov8" title="1">{
                meta.Fs = fs
        }</span>
        <span class="cov8" title="1">nfilepath := normalizeFilename(filepath)
        nfilename := normalizeFilename(filename)
        if nfilepath != "" </span><span class="cov8" title="1">{
                meta.Path = nfilepath
        }</span>
        <span class="cov8" title="1">if nfilename != "" </span><span class="cov8" title="1">{
                meta.Filename = nfilename
        }</span>

        <span class="cov8" title="1">meta.Merge(inMeta)

        return fim</span>
}

func isSymlink(fi os.FileInfo) bool <span class="cov8" title="1">{
        return fi != nil &amp;&amp; fi.Mode()&amp;os.ModeSymlink == os.ModeSymlink
}</span>

func fileInfosToFileMetaInfos(fis []os.FileInfo) []FileMetaInfo <span class="cov8" title="1">{
        fims := make([]FileMetaInfo, len(fis))
        for i, v := range fis </span><span class="cov8" title="1">{
                fims[i] = v.(FileMetaInfo)
        }</span>
        <span class="cov8" title="1">return fims</span>
}

func normalizeFilename(filename string) string <span class="cov8" title="1">{
        if filename == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov8" title="1">if runtime.GOOS == "darwin" </span><span class="cov0" title="0">{
                // When a file system is HFS+, its filepath is in NFD form.
                return norm.NFC.String(filename)
        }</span>
        <span class="cov8" title="1">return filename</span>
}

func fileInfosToNames(fis []os.FileInfo) []string <span class="cov8" title="1">{
        names := make([]string, len(fis))
        for i, d := range fis </span><span class="cov8" title="1">{
                names[i] = d.Name()
        }</span>
        <span class="cov8" title="1">return names</span>
}

func fromSlash(filenames []string) []string <span class="cov0" title="0">{
        for i, name := range filenames </span><span class="cov0" title="0">{
                filenames[i] = filepath.FromSlash(name)
        }</span>
        <span class="cov0" title="0">return filenames</span>
}

func sortFileInfos(fis []os.FileInfo) <span class="cov8" title="1">{
        sort.Slice(fis, func(i, j int) bool </span><span class="cov8" title="1">{
                fimi, fimj := fis[i].(FileMetaInfo), fis[j].(FileMetaInfo)
                return fimi.Meta().Filename &lt; fimj.Meta().Filename
        }</span>)
}
</pre>
		
		<pre class="file" id="file88" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "os"
        "strings"
        "syscall"
        "time"

        "github.com/gohugoio/hugo/hugofs/glob"
        "github.com/spf13/afero"
)

func newFilenameFilterFs(fs afero.Fs, base string, filter *glob.FilenameFilter) afero.Fs <span class="cov8" title="1">{
        return &amp;filenameFilterFs{
                fs:     fs,
                base:   base,
                filter: filter,
        }
}</span>

// filenameFilterFs is a filesystem that filters by filename.
type filenameFilterFs struct {
        base string
        fs   afero.Fs

        filter *glob.FilenameFilter
}

func (fs *filenameFilterFs) LstatIfPossible(name string) (os.FileInfo, bool, error) <span class="cov8" title="1">{
        fi, b, err := fs.fs.(afero.Lstater).LstatIfPossible(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">if !fs.filter.Match(name, fi.IsDir()) </span><span class="cov8" title="1">{
                return nil, false, os.ErrNotExist
        }</span>
        <span class="cov8" title="1">return fi, b, nil</span>
}

func (fs *filenameFilterFs) Open(name string) (afero.File, error) <span class="cov8" title="1">{
        fi, err := fs.fs.Stat(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !fs.filter.Match(name, fi.IsDir()) </span><span class="cov8" title="1">{
                return nil, os.ErrNotExist
        }</span>

        <span class="cov8" title="1">f, err := fs.fs.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if !fi.IsDir() </span><span class="cov8" title="1">{
                return f, nil
        }</span>

        <span class="cov8" title="1">return &amp;filenameFilterDir{
                File:   f,
                base:   fs.base,
                filter: fs.filter,
        }, nil</span>
}

func (fs *filenameFilterFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        return fs.Open(name)
}</span>

func (fs *filenameFilterFs) Stat(name string) (os.FileInfo, error) <span class="cov8" title="1">{
        fi, _, err := fs.LstatIfPossible(name)
        return fi, err
}</span>

func (fs *filenameFilterFs) getOpener(name string) func() (afero.File, error) <span class="cov0" title="0">{
        return func() (afero.File, error) </span><span class="cov0" title="0">{
                return fs.Open(name)
        }</span>
}

type filenameFilterDir struct {
        afero.File
        base   string
        filter *glob.FilenameFilter
}

func (f *filenameFilterDir) Readdir(count int) ([]os.FileInfo, error) <span class="cov8" title="1">{
        fis, err := f.File.Readdir(-1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var result []os.FileInfo
        for _, fi := range fis </span><span class="cov8" title="1">{
                fim := fi.(FileMetaInfo)
                if f.filter.Match(strings.TrimPrefix(fim.Meta().Filename, f.base), fim.IsDir()) </span><span class="cov8" title="1">{
                        result = append(result, fi)
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

func (f *filenameFilterDir) Readdirnames(count int) ([]string, error) <span class="cov8" title="1">{
        dirsi, err := f.Readdir(count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">dirs := make([]string, len(dirsi))
        for i, d := range dirsi </span><span class="cov8" title="1">{
                dirs[i] = d.Name()
        }</span>
        <span class="cov8" title="1">return dirs, nil</span>
}

func (fs *filenameFilterFs) Chmod(n string, m os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *filenameFilterFs) Chtimes(n string, a, m time.Time) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *filenameFilterFs) Chown(n string, uid, gid int) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *filenameFilterFs) ReadDir(name string) ([]os.FileInfo, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (fs *filenameFilterFs) Remove(n string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *filenameFilterFs) RemoveAll(p string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *filenameFilterFs) Rename(o, n string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>
func (fs *filenameFilterFs) Create(n string) (afero.File, error) <span class="cov0" title="0">{
        return nil, syscall.EPERM
}</span>
func (fs *filenameFilterFs) Name() string <span class="cov0" title="0">{
        return "FinameFilterFS"
}</span>

func (fs *filenameFilterFs) Mkdir(n string, p os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *filenameFilterFs) MkdirAll(n string, p os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>
</pre>
		
		<pre class="file" id="file89" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package files

import (
        "bufio"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "unicode"

        "github.com/spf13/afero"
)

const (
        // The NPM package.json "template" file.
        FilenamePackageHugoJSON = "package.hugo.json"
        // The NPM package file.
        FilenamePackageJSON = "package.json"
)

var (
        // This should be the only list of valid extensions for content files.
        contentFileExtensions = []string{
                "html", "htm",
                "mdown", "markdown", "md",
                "asciidoc", "adoc", "ad",
                "rest", "rst",
                "org",
                "pandoc", "pdc",
        }

        contentFileExtensionsSet map[string]bool

        htmlFileExtensions = []string{
                "html", "htm",
        }

        htmlFileExtensionsSet map[string]bool
)

func init() <span class="cov8" title="1">{
        contentFileExtensionsSet = make(map[string]bool)
        for _, ext := range contentFileExtensions </span><span class="cov8" title="1">{
                contentFileExtensionsSet[ext] = true
        }</span>
        <span class="cov8" title="1">htmlFileExtensionsSet = make(map[string]bool)
        for _, ext := range htmlFileExtensions </span><span class="cov8" title="1">{
                htmlFileExtensionsSet[ext] = true
        }</span>
}

func IsContentFile(filename string) bool <span class="cov8" title="1">{
        return contentFileExtensionsSet[strings.TrimPrefix(filepath.Ext(filename), ".")]
}</span>

func IsIndexContentFile(filename string) bool <span class="cov0" title="0">{
        if !IsContentFile(filename) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">base := filepath.Base(filename)

        return strings.HasPrefix(base, "index.") || strings.HasPrefix(base, "_index.")</span>
}

func IsHTMLFile(filename string) bool <span class="cov0" title="0">{
        return htmlFileExtensionsSet[strings.TrimPrefix(filepath.Ext(filename), ".")]
}</span>

func IsContentExt(ext string) bool <span class="cov8" title="1">{
        return contentFileExtensionsSet[ext]
}</span>

type ContentClass string

const (
        ContentClassLeaf    ContentClass = "leaf"
        ContentClassBranch  ContentClass = "branch"
        ContentClassFile    ContentClass = "zfile" // Sort below
        ContentClassContent ContentClass = "zcontent"
)

func (c ContentClass) IsBundle() bool <span class="cov0" title="0">{
        return c == ContentClassLeaf || c == ContentClassBranch
}</span>

func ClassifyContentFile(filename string, open func() (afero.File, error)) ContentClass <span class="cov0" title="0">{
        if !IsContentFile(filename) </span><span class="cov0" title="0">{
                return ContentClassFile
        }</span>

        <span class="cov0" title="0">if IsHTMLFile(filename) </span><span class="cov0" title="0">{
                // We need to look inside the file. If the first non-whitespace
                // character is a "&lt;", then we treat it as a regular file.
                // Eearlier we created pages for these files, but that had all sorts
                // of troubles, and isn't what it says in the documentation.
                // See https://github.com/gohugoio/hugo/issues/7030
                if open == nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("no file opener provided for %q", filename))</span>
                }

                <span class="cov0" title="0">f, err := open()
                if err != nil </span><span class="cov0" title="0">{
                        return ContentClassFile
                }</span>
                <span class="cov0" title="0">ishtml := isHTMLContent(f)
                f.Close()
                if ishtml </span><span class="cov0" title="0">{
                        return ContentClassFile
                }</span>

        }

        <span class="cov0" title="0">if strings.HasPrefix(filename, "_index.") </span><span class="cov0" title="0">{
                return ContentClassBranch
        }</span>

        <span class="cov0" title="0">if strings.HasPrefix(filename, "index.") </span><span class="cov0" title="0">{
                return ContentClassLeaf
        }</span>

        <span class="cov0" title="0">return ContentClassContent</span>
}

var htmlComment = []rune{'&lt;', '!', '-', '-'}

func isHTMLContent(r io.Reader) bool <span class="cov8" title="1">{
        br := bufio.NewReader(r)
        i := 0
        for </span><span class="cov8" title="1">{
                c, _, err := br.ReadRune()
                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">if i &gt; 0 </span><span class="cov8" title="1">{
                        if i &gt;= len(htmlComment) </span><span class="cov8" title="1">{
                                return false
                        }</span>

                        <span class="cov8" title="1">if c != htmlComment[i] </span><span class="cov8" title="1">{
                                return true
                        }</span>

                        <span class="cov8" title="1">i++
                        continue</span>
                }

                <span class="cov8" title="1">if !unicode.IsSpace(c) </span><span class="cov8" title="1">{
                        if i == 0 &amp;&amp; c != '&lt;' </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">i++</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

const (
        ComponentFolderArchetypes = "archetypes"
        ComponentFolderStatic     = "static"
        ComponentFolderLayouts    = "layouts"
        ComponentFolderContent    = "content"
        ComponentFolderData       = "data"
        ComponentFolderAssets     = "assets"
        ComponentFolderI18n       = "i18n"

        FolderResources = "resources"
        FolderJSConfig  = "_jsconfig" // Mounted below /assets with postcss.config.js etc.
)

var (
        JsConfigFolderMountPrefix = filepath.Join(ComponentFolderAssets, FolderJSConfig)

        ComponentFolders = []string{
                ComponentFolderArchetypes,
                ComponentFolderStatic,
                ComponentFolderLayouts,
                ComponentFolderContent,
                ComponentFolderData,
                ComponentFolderAssets,
                ComponentFolderI18n,
        }

        componentFoldersSet = make(map[string]bool)
)

func init() <span class="cov8" title="1">{
        sort.Strings(ComponentFolders)
        for _, f := range ComponentFolders </span><span class="cov8" title="1">{
                componentFoldersSet[f] = true
        }</span>
}

// ResolveComponentFolder returns "content" from "content/blog/foo.md" etc.
func ResolveComponentFolder(filename string) string <span class="cov0" title="0">{
        filename = strings.TrimPrefix(filename, string(os.PathSeparator))
        for _, cf := range ComponentFolders </span><span class="cov0" title="0">{
                if strings.HasPrefix(filename, cf) </span><span class="cov0" title="0">{
                        return cf
                }</span>
        }

        <span class="cov0" title="0">return ""</span>
}

func IsComponentFolder(name string) bool <span class="cov8" title="1">{
        return componentFoldersSet[name]
}</span>
</pre>
		
		<pre class="file" id="file90" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "fmt"
        "io"
        "os"
        "path/filepath"
        "sort"
        "strings"
        "syscall"
        "time"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/spf13/afero"
)

var (
        _ afero.Fs      = (*FilterFs)(nil)
        _ afero.Lstater = (*FilterFs)(nil)
        _ afero.File    = (*filterDir)(nil)
)

func NewLanguageFs(langs map[string]int, fs afero.Fs) (afero.Fs, error) <span class="cov0" title="0">{
        applyMeta := func(fs *FilterFs, name string, fis []os.FileInfo) </span><span class="cov0" title="0">{
                for i, fi := range fis </span><span class="cov0" title="0">{
                        if fi.IsDir() </span><span class="cov0" title="0">{
                                filename := filepath.Join(name, fi.Name())
                                fis[i] = decorateFileInfo(fi, fs, fs.getOpener(filename), "", "", nil)
                                continue</span>
                        }

                        <span class="cov0" title="0">meta := fi.(FileMetaInfo).Meta()
                        lang := meta.Lang

                        fileLang, translationBaseName, translationBaseNameWithExt := langInfoFrom(langs, fi.Name())
                        weight := 0

                        if fileLang != "" </span><span class="cov0" title="0">{
                                weight = 1
                                if fileLang == lang </span><span class="cov0" title="0">{
                                        // Give priority to myfile.sv.txt inside the sv filesystem.
                                        weight++
                                }</span>
                                <span class="cov0" title="0">lang = fileLang</span>
                        }

                        <span class="cov0" title="0">fim := NewFileMetaInfo(
                                fi,
                                &amp;FileMeta{
                                        Lang:                       lang,
                                        Weight:                     weight,
                                        Ordinal:                    langs[lang],
                                        TranslationBaseName:        translationBaseName,
                                        TranslationBaseNameWithExt: translationBaseNameWithExt,
                                        Classifier:                 files.ClassifyContentFile(fi.Name(), meta.OpenFunc),
                                })

                        fis[i] = fim</span>
                }
        }

        <span class="cov0" title="0">all := func(fis []os.FileInfo) </span><span class="cov0" title="0">{
                // Maps translation base name to a list of language codes.
                translations := make(map[string][]string)
                trackTranslation := func(meta *FileMeta) </span><span class="cov0" title="0">{
                        name := meta.TranslationBaseNameWithExt
                        translations[name] = append(translations[name], meta.Lang)
                }</span>
                <span class="cov0" title="0">for _, fi := range fis </span><span class="cov0" title="0">{
                        if fi.IsDir() </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">meta := fi.(FileMetaInfo).Meta()

                        trackTranslation(meta)</span>

                }

                <span class="cov0" title="0">for _, fi := range fis </span><span class="cov0" title="0">{
                        fim := fi.(FileMetaInfo)
                        langs := translations[fim.Meta().TranslationBaseNameWithExt]
                        if len(langs) &gt; 0 </span><span class="cov0" title="0">{
                                fim.Meta().Translations = sortAndremoveStringDuplicates(langs)
                        }</span>
                }
        }

        <span class="cov0" title="0">return &amp;FilterFs{
                fs:             fs,
                applyPerSource: applyMeta,
                applyAll:       all,
        }, nil</span>
}

func NewFilterFs(fs afero.Fs) (afero.Fs, error) <span class="cov0" title="0">{
        applyMeta := func(fs *FilterFs, name string, fis []os.FileInfo) </span><span class="cov0" title="0">{
                for i, fi := range fis </span><span class="cov0" title="0">{
                        if fi.IsDir() </span><span class="cov0" title="0">{
                                fis[i] = decorateFileInfo(fi, fs, fs.getOpener(fi.(FileMetaInfo).Meta().Filename), "", "", nil)
                        }</span>
                }
        }

        <span class="cov0" title="0">ffs := &amp;FilterFs{
                fs:             fs,
                applyPerSource: applyMeta,
        }

        return ffs, nil</span>
}

// FilterFs is an ordered composite filesystem.
type FilterFs struct {
        fs afero.Fs

        applyPerSource func(fs *FilterFs, name string, fis []os.FileInfo)
        applyAll       func(fis []os.FileInfo)
}

func (fs *FilterFs) Chmod(n string, m os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) Chtimes(n string, a, m time.Time) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) Chown(n string, uid, gid int) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) LstatIfPossible(name string) (os.FileInfo, bool, error) <span class="cov0" title="0">{
        fi, b, err := lstatIfPossible(fs.fs, name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                return decorateFileInfo(fi, fs, fs.getOpener(name), "", "", nil), false, nil
        }</span>

        <span class="cov0" title="0">parent := filepath.Dir(name)
        fs.applyFilters(parent, -1, fi)

        return fi, b, nil</span>
}

func (fs *FilterFs) Mkdir(n string, p os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) MkdirAll(n string, p os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) Name() string <span class="cov0" title="0">{
        return "WeightedFileSystem"
}</span>

func (fs *FilterFs) Open(name string) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.fs.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;filterDir{
                File: f,
                ffs:  fs,
        }, nil</span>
}

func (fs *FilterFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        return fs.fs.Open(name)
}</span>

func (fs *FilterFs) ReadDir(name string) ([]os.FileInfo, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (fs *FilterFs) Remove(n string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) RemoveAll(p string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) Rename(o, n string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *FilterFs) Stat(name string) (os.FileInfo, error) <span class="cov0" title="0">{
        fi, _, err := fs.LstatIfPossible(name)
        return fi, err
}</span>

func (fs *FilterFs) Create(n string) (afero.File, error) <span class="cov0" title="0">{
        return nil, syscall.EPERM
}</span>

func (fs *FilterFs) getOpener(name string) func() (afero.File, error) <span class="cov0" title="0">{
        return func() (afero.File, error) </span><span class="cov0" title="0">{
                return fs.Open(name)
        }</span>
}

func (fs *FilterFs) applyFilters(name string, count int, fis ...os.FileInfo) ([]os.FileInfo, error) <span class="cov0" title="0">{
        if fs.applyPerSource != nil </span><span class="cov0" title="0">{
                fs.applyPerSource(fs, name, fis)
        }</span>

        <span class="cov0" title="0">seen := make(map[string]bool)
        var duplicates []int
        for i, dir := range fis </span><span class="cov0" title="0">{
                if !dir.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if seen[dir.Name()] </span><span class="cov0" title="0">{
                        duplicates = append(duplicates, i)
                }</span> else<span class="cov0" title="0"> {
                        seen[dir.Name()] = true
                }</span>
        }

        // Remove duplicate directories, keep first.
        <span class="cov0" title="0">if len(duplicates) &gt; 0 </span><span class="cov0" title="0">{
                for i := len(duplicates) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        idx := duplicates[i]
                        fis = append(fis[:idx], fis[idx+1:]...)
                }</span>
        }

        <span class="cov0" title="0">if fs.applyAll != nil </span><span class="cov0" title="0">{
                fs.applyAll(fis)
        }</span>

        <span class="cov0" title="0">if count &gt; 0 &amp;&amp; len(fis) &gt;= count </span><span class="cov0" title="0">{
                return fis[:count], nil
        }</span>

        <span class="cov0" title="0">return fis, nil</span>
}

type filterDir struct {
        afero.File
        ffs *FilterFs
}

func (f *filterDir) Readdir(count int) ([]os.FileInfo, error) <span class="cov0" title="0">{
        fis, err := f.File.Readdir(-1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return f.ffs.applyFilters(f.Name(), count, fis...)</span>
}

func (f *filterDir) Readdirnames(count int) ([]string, error) <span class="cov0" title="0">{
        dirsi, err := f.Readdir(count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dirs := make([]string, len(dirsi))
        for i, d := range dirsi </span><span class="cov0" title="0">{
                dirs[i] = d.Name()
        }</span>
        <span class="cov0" title="0">return dirs, nil</span>
}

// Try to extract the language from the given filename.
// Any valid language identifier in the name will win over the
// language set on the file system, e.g. "mypost.en.md".
func langInfoFrom(languages map[string]int, name string) (string, string, string) <span class="cov8" title="1">{
        var lang string

        baseName := filepath.Base(name)
        ext := filepath.Ext(baseName)
        translationBaseName := baseName

        if ext != "" </span><span class="cov8" title="1">{
                translationBaseName = strings.TrimSuffix(translationBaseName, ext)
        }</span>

        <span class="cov8" title="1">fileLangExt := filepath.Ext(translationBaseName)
        fileLang := strings.TrimPrefix(fileLangExt, ".")

        if _, found := languages[fileLang]; found </span><span class="cov8" title="1">{
                lang = fileLang
                translationBaseName = strings.TrimSuffix(translationBaseName, fileLangExt)
        }</span>

        <span class="cov8" title="1">translationBaseNameWithExt := translationBaseName

        if ext != "" </span><span class="cov8" title="1">{
                translationBaseNameWithExt += ext
        }</span>

        <span class="cov8" title="1">return lang, translationBaseName, translationBaseNameWithExt</span>
}

func printFs(fs afero.Fs, path string, w io.Writer) <span class="cov0" title="0">{
        if fs == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">afero.Walk(fs, path, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                fmt.Println("p:::", path)
                return nil
        }</span>)
}

func sortAndremoveStringDuplicates(s []string) []string <span class="cov0" title="0">{
        ss := sort.StringSlice(s)
        ss.Sort()
        i := 0
        for j := 1; j &lt; len(s); j++ </span><span class="cov0" title="0">{
                if !ss.Less(i, j) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">i++
                s[i] = s[j]</span>
        }

        <span class="cov0" title="0">return s[:i+1]</span>
}
</pre>
		
		<pre class="file" id="file91" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package hugofs provides the file systems used by Hugo.
package hugofs

import (
        "fmt"
        "os"
        "strings"

        "github.com/gohugoio/hugo/config"
        "github.com/spf13/afero"
)

// Os points to the (real) Os filesystem.
var Os = &amp;afero.OsFs{}

// Fs abstracts the file system to separate source and destination file systems
// and allows both to be mocked for testing.
type Fs struct {
        // Source is Hugo's source file system.
        Source afero.Fs

        // Destination is Hugo's destination file system.
        Destination afero.Fs

        // Os is an OS file system.
        // NOTE: Field is currently unused.
        Os afero.Fs

        // WorkingDir is a read-only file system
        // restricted to the project working dir.
        WorkingDir *afero.BasePathFs
}

// NewDefault creates a new Fs with the OS file system
// as source and destination file systems.
func NewDefault(cfg config.Provider) *Fs <span class="cov8" title="1">{
        fs := &amp;afero.OsFs{}
        return newFs(fs, cfg)
}</span>

// NewMem creates a new Fs with the MemMapFs
// as source and destination file systems.
// Useful for testing.
func NewMem(cfg config.Provider) *Fs <span class="cov8" title="1">{
        fs := &amp;afero.MemMapFs{}
        return newFs(fs, cfg)
}</span>

// NewFrom creates a new Fs based on the provided Afero Fs
// as source and destination file systems.
// Useful for testing.
func NewFrom(fs afero.Fs, cfg config.Provider) *Fs <span class="cov0" title="0">{
        return newFs(fs, cfg)
}</span>

func newFs(base afero.Fs, cfg config.Provider) *Fs <span class="cov8" title="1">{
        return &amp;Fs{
                Source:      base,
                Destination: base,
                Os:          &amp;afero.OsFs{},
                WorkingDir:  getWorkingDirFs(base, cfg),
        }
}</span>

func getWorkingDirFs(base afero.Fs, cfg config.Provider) *afero.BasePathFs <span class="cov8" title="1">{
        workingDir := cfg.GetString("workingDir")

        if workingDir != "" </span><span class="cov8" title="1">{
                return afero.NewBasePathFs(afero.NewReadOnlyFs(base), workingDir).(*afero.BasePathFs)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func isWrite(flag int) bool <span class="cov0" title="0">{
        return flag&amp;os.O_RDWR != 0 || flag&amp;os.O_WRONLY != 0
}</span>

// MakeReadableAndRemoveAllModulePkgDir makes any subdir in dir readable and then
// removes the root.
// TODO(bep) move this to a more suitable place.
//
func MakeReadableAndRemoveAllModulePkgDir(fs afero.Fs, dir string) (int, error) <span class="cov0" title="0">{
        // Safe guard
        if !strings.Contains(dir, "pkg") </span><span class="cov0" title="0">{
                panic(fmt.Sprint("invalid dir:", dir))</span>
        }

        <span class="cov0" title="0">counter := 0
        afero.Walk(fs, dir, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        counter++
                        fs.Chmod(path, 0777)
                }</span>
                <span class="cov0" title="0">return nil</span>
        })
        <span class="cov0" title="0">return counter, fs.RemoveAll(dir)</span>
}
</pre>
		
		<pre class="file" id="file92" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "errors"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/spf13/afero"
)

// Glob walks the fs and passes all matches to the handle func.
// The handle func can return true to signal a stop.
func Glob(fs afero.Fs, pattern string, handle func(fi FileMetaInfo) (bool, error)) error <span class="cov8" title="1">{
        pattern = glob.NormalizePath(pattern)
        if pattern == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">g, err := glob.GetGlob(pattern)
        if err != nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">hasSuperAsterisk := strings.Contains(pattern, "**")
        levels := strings.Count(pattern, "/")
        root := glob.ResolveRootDir(pattern)

        // Signals that we're done.
        done := errors.New("done")

        wfn := func(p string, info FileMetaInfo, err error) error </span><span class="cov8" title="1">{
                p = glob.NormalizePath(p)
                if info.IsDir() </span><span class="cov8" title="1">{
                        if !hasSuperAsterisk </span><span class="cov8" title="1">{
                                // Avoid walking to the bottom if we can avoid it.
                                if p != "" &amp;&amp; strings.Count(p, "/") &gt;= levels </span><span class="cov8" title="1">{
                                        return filepath.SkipDir
                                }</span>
                        }
                        <span class="cov8" title="1">return nil</span>
                }

                <span class="cov8" title="1">if g.Match(p) </span><span class="cov8" title="1">{
                        d, err := handle(info)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if d </span><span class="cov0" title="0">{
                                return done
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">w := NewWalkway(WalkwayConfig{
                Root:   root,
                Fs:     fs,
                WalkFn: wfn,
        })

        err = w.Walk()

        if err != done </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file93" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package glob

import (
        "path"
        "path/filepath"
        "strings"

        "github.com/gobwas/glob"
)

type FilenameFilter struct {
        shouldInclude func(filename string) bool
        inclusions    []glob.Glob
        dirInclusions []glob.Glob
        exclusions    []glob.Glob
        isWindows     bool
}

func normalizeFilenameGlobPattern(s string) string <span class="cov8" title="1">{
        // Use Unix separators even on Windows.
        s = filepath.ToSlash(s)
        if !strings.HasPrefix(s, "/") </span><span class="cov8" title="1">{
                s = "/" + s
        }</span>
        <span class="cov8" title="1">return s</span>
}

// NewFilenameFilter creates a new Glob where the Match method will
// return true if the file should be included.
// Note that the inclusions will be checked first.
func NewFilenameFilter(inclusions, exclusions []string) (*FilenameFilter, error) <span class="cov8" title="1">{
        if inclusions == nil &amp;&amp; exclusions == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">filter := &amp;FilenameFilter{isWindows: isWindows}

        for _, include := range inclusions </span><span class="cov8" title="1">{
                include = normalizeFilenameGlobPattern(include)
                g, err := filenamesGlobCache.GetGlob(include)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">filter.inclusions = append(filter.inclusions, g)

                // For mounts that do directory walking (e.g. content) we
                // must make sure that all directories up to this inclusion also
                // gets included.
                dir := path.Dir(include)
                parts := strings.Split(dir, "/")
                for i, _ := range parts </span><span class="cov8" title="1">{
                        pattern := "/" + filepath.Join(parts[:i+1]...)
                        g, err := filenamesGlobCache.GetGlob(pattern)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">filter.dirInclusions = append(filter.dirInclusions, g)</span>
                }
        }

        <span class="cov8" title="1">for _, exclude := range exclusions </span><span class="cov8" title="1">{
                exclude = normalizeFilenameGlobPattern(exclude)
                g, err := filenamesGlobCache.GetGlob(exclude)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">filter.exclusions = append(filter.exclusions, g)</span>
        }

        <span class="cov8" title="1">return filter, nil</span>
}

// MustNewFilenameFilter invokes NewFilenameFilter and panics on error.
func MustNewFilenameFilter(inclusions, exclusions []string) *FilenameFilter <span class="cov0" title="0">{
        filter, err := NewFilenameFilter(inclusions, exclusions)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return filter</span>
}

// NewFilenameFilterForInclusionFunc create a new filter using the provided inclusion func.
func NewFilenameFilterForInclusionFunc(shouldInclude func(filename string) bool) *FilenameFilter <span class="cov8" title="1">{
        return &amp;FilenameFilter{shouldInclude: shouldInclude, isWindows: isWindows}
}</span>

// Match returns whether filename should be included.
func (f *FilenameFilter) Match(filename string, isDir bool) bool <span class="cov8" title="1">{
        if f == nil </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return f.doMatch(filename, isDir)</span>
        /*if f.shouldInclude == nil {
                fmt.Printf("Match: %q (%t) =&gt; %t\n", filename, isDir, isMatch)
        }
        return isMatch*/
}

func (f *FilenameFilter) doMatch(filename string, isDir bool) bool <span class="cov8" title="1">{
        if f == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(filename, filepathSeparator) </span><span class="cov8" title="1">{
                filename = filepathSeparator + filename
        }</span>

        <span class="cov8" title="1">if f.shouldInclude != nil </span><span class="cov8" title="1">{
                if f.shouldInclude(filename) </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if f.isWindows </span><span class="cov0" title="0">{
                        // The Glob matchers below handles this by themselves,
                        // for the shouldInclude we need to take some extra steps
                        // to make this robust.
                        winFilename := filepath.FromSlash(filename)
                        if filename != winFilename </span><span class="cov0" title="0">{
                                if f.shouldInclude(winFilename) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }

        }

        <span class="cov8" title="1">for _, inclusion := range f.inclusions </span><span class="cov8" title="1">{
                if inclusion.Match(filename) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">if isDir &amp;&amp; f.inclusions != nil </span><span class="cov8" title="1">{
                for _, inclusion := range f.dirInclusions </span><span class="cov8" title="1">{
                        if inclusion.Match(filename) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, exclusion := range f.exclusions </span><span class="cov8" title="1">{
                if exclusion.Match(filename) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return f.inclusions == nil &amp;&amp; f.shouldInclude == nil</span>
}
</pre>
		
		<pre class="file" id="file94" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package glob

import (
        "os"
        "path"
        "path/filepath"
        "runtime"
        "strings"
        "sync"

        "github.com/gobwas/glob"
        "github.com/gobwas/glob/syntax"
)

const filepathSeparator = string(os.PathSeparator)

var (
        isWindows        = runtime.GOOS == "windows"
        defaultGlobCache = &amp;globCache{
                isCaseSensitive: false,
                isWindows:       isWindows,
                cache:           make(map[string]globErr),
        }

        filenamesGlobCache = &amp;globCache{
                isCaseSensitive: false, // As long as the search strings are all lower case, this does not allocate.
                isWindows:       isWindows,
                cache:           make(map[string]globErr),
        }
)

type globErr struct {
        glob glob.Glob
        err  error
}

type globCache struct {
        // Config
        isCaseSensitive bool
        isWindows       bool

        // Cache
        sync.RWMutex
        cache map[string]globErr
}

func (gc *globCache) GetGlob(pattern string) (glob.Glob, error) <span class="cov8" title="1">{
        var eg globErr

        gc.RLock()
        var found bool
        eg, found = gc.cache[pattern]
        gc.RUnlock()
        if found </span><span class="cov8" title="1">{
                return eg.glob, eg.err
        }</span>

        <span class="cov8" title="1">var g glob.Glob
        var err error

        pattern = filepath.ToSlash(pattern)

        if gc.isCaseSensitive </span><span class="cov0" title="0">{
                g, err = glob.Compile(pattern, '/')
        }</span> else<span class="cov8" title="1"> {
                g, err = glob.Compile(strings.ToLower(pattern), '/')

        }</span>

        <span class="cov8" title="1">eg = globErr{
                globDecorator{
                        g:               g,
                        isCaseSensitive: gc.isCaseSensitive,
                        isWindows:       gc.isWindows},
                err,
        }

        gc.Lock()
        gc.cache[pattern] = eg
        gc.Unlock()

        return eg.glob, eg.err</span>
}

type globDecorator struct {
        // Whether both pattern and the strings to match will be matched
        // by their original case.
        isCaseSensitive bool

        // On Windows we may get filenames with Windows slashes to match,
        // which wee need to normalize.
        isWindows bool

        g glob.Glob
}

func (g globDecorator) Match(s string) bool <span class="cov8" title="1">{
        if g.isWindows </span><span class="cov0" title="0">{
                s = filepath.ToSlash(s)
        }</span>
        <span class="cov8" title="1">if !g.isCaseSensitive </span><span class="cov8" title="1">{
                s = strings.ToLower(s)
        }</span>
        <span class="cov8" title="1">return g.g.Match(s)</span>
}

func GetGlob(pattern string) (glob.Glob, error) <span class="cov0" title="0">{
        return defaultGlobCache.GetGlob(pattern)
}</span>

func NormalizePath(p string) string <span class="cov8" title="1">{
        return strings.Trim(path.Clean(filepath.ToSlash(strings.ToLower(p))), "/.")
}</span>

// ResolveRootDir takes a normalized path on the form "assets/**.json" and
// determines any root dir, i.e. any start path without any wildcards.
func ResolveRootDir(p string) string <span class="cov8" title="1">{
        parts := strings.Split(path.Dir(p), "/")
        var roots []string
        for _, part := range parts </span><span class="cov8" title="1">{
                if HasGlobChar(part) </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">roots = append(roots, part)</span>
        }

        <span class="cov8" title="1">if len(roots) == 0 </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">return strings.Join(roots, "/")</span>
}

// FilterGlobParts removes any string with glob wildcard.
func FilterGlobParts(a []string) []string <span class="cov8" title="1">{
        b := a[:0]
        for _, x := range a </span><span class="cov8" title="1">{
                if !HasGlobChar(x) </span><span class="cov8" title="1">{
                        b = append(b, x)
                }</span>
        }
        <span class="cov8" title="1">return b</span>
}

// HasGlobChar returns whether s contains any glob wildcards.
func HasGlobChar(s string) bool <span class="cov8" title="1">{
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                if syntax.Special(s[i]) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file95" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "crypto/md5"
        "encoding/hex"
        "hash"
        "os"

        "github.com/spf13/afero"
)

var _ afero.Fs = (*md5HashingFs)(nil)

// FileHashReceiver will receive the filename an the content's MD5 sum on file close.
type FileHashReceiver interface {
        OnFileClose(name, md5sum string)
}

type md5HashingFs struct {
        afero.Fs
        hashReceiver FileHashReceiver
}

// NewHashingFs creates a new filesystem that will receive MD5 checksums of
// any written file content on Close. Note that this is probably not a good
// idea for "full build" situations, but when doing fast render mode, the amount
// of files published is low, and it would be really nice to know exactly which
// of these files where actually changed.
// Note that this will only work for file operations that use the io.Writer
// to write content to file, but that is fine for the "publish content" use case.
func NewHashingFs(delegate afero.Fs, hashReceiver FileHashReceiver) afero.Fs <span class="cov8" title="1">{
        return &amp;md5HashingFs{Fs: delegate, hashReceiver: hashReceiver}
}</span>

func (fs *md5HashingFs) Create(name string) (afero.File, error) <span class="cov8" title="1">{
        f, err := fs.Fs.Create(name)
        if err == nil </span><span class="cov8" title="1">{
                f = fs.wrapFile(f)
        }</span>
        <span class="cov8" title="1">return f, err</span>
}

func (fs *md5HashingFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.Fs.OpenFile(name, flag, perm)
        if err == nil &amp;&amp; isWrite(flag) </span><span class="cov0" title="0">{
                f = fs.wrapFile(f)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}

func (fs *md5HashingFs) wrapFile(f afero.File) afero.File <span class="cov8" title="1">{
        return &amp;hashingFile{File: f, h: md5.New(), hashReceiver: fs.hashReceiver}
}</span>

func (fs *md5HashingFs) Name() string <span class="cov0" title="0">{
        return "md5HashingFs"
}</span>

type hashingFile struct {
        hashReceiver FileHashReceiver
        h            hash.Hash
        afero.File
}

func (h *hashingFile) Write(p []byte) (n int, err error) <span class="cov8" title="1">{
        n, err = h.File.Write(p)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">return h.h.Write(p)</span>
}

func (h *hashingFile) Close() error <span class="cov8" title="1">{
        sum := hex.EncodeToString(h.h.Sum(nil))
        h.hashReceiver.OnFileClose(h.Name(), sum)
        return h.File.Close()
}</span>
</pre>
		
		<pre class="file" id="file96" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "os"
        "path"

        "github.com/spf13/afero"
)

var (
        _ afero.Fs      = (*languageCompositeFs)(nil)
        _ afero.Lstater = (*languageCompositeFs)(nil)
)

type languageCompositeFs struct {
        *afero.CopyOnWriteFs
}

// NewLanguageCompositeFs creates a composite and language aware filesystem.
// This is a hybrid filesystem. To get a specific file in Open, Stat etc., use the full filename
// to the target filesystem. This information is available in Readdir, Stat etc. via the
// special LanguageFileInfo FileInfo implementation.
func NewLanguageCompositeFs(base, overlay afero.Fs) afero.Fs <span class="cov0" title="0">{
        return &amp;languageCompositeFs{afero.NewCopyOnWriteFs(base, overlay).(*afero.CopyOnWriteFs)}
}</span>

// Open takes the full path to the file in the target filesystem. If it is a directory, it gets merged
// using the language as a weight.
func (fs *languageCompositeFs) Open(name string) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.CopyOnWriteFs.Open(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">fu, ok := f.(*afero.UnionFile)
        if ok </span><span class="cov0" title="0">{
                // This is a directory: Merge it.
                fu.Merger = LanguageDirsMerger
        }</span>
        <span class="cov0" title="0">return f, nil</span>
}

// LanguageDirsMerger implements the afero.DirsMerger interface, which is used
// to merge two directories.
var LanguageDirsMerger = func(lofi, bofi []os.FileInfo) ([]os.FileInfo, error) <span class="cov0" title="0">{
        m := make(map[string]FileMetaInfo)

        getKey := func(fim FileMetaInfo) string </span><span class="cov0" title="0">{
                return path.Join(fim.Meta().Lang, fim.Name())
        }</span>

        <span class="cov0" title="0">for _, fi := range lofi </span><span class="cov0" title="0">{
                fim := fi.(FileMetaInfo)
                m[getKey(fim)] = fim
        }</span>

        <span class="cov0" title="0">for _, fi := range bofi </span><span class="cov0" title="0">{
                fim := fi.(FileMetaInfo)
                key := getKey(fim)
                _, found := m[key]
                if !found </span><span class="cov0" title="0">{
                        m[key] = fim
                }</span>
        }

        <span class="cov0" title="0">merged := make([]os.FileInfo, len(m))
        i := 0
        for _, v := range m </span><span class="cov0" title="0">{
                merged[i] = v
                i++
        }</span>

        <span class="cov0" title="0">return merged, nil</span>
}
</pre>
		
		<pre class="file" id="file97" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "errors"
        "os"
        "time"

        "github.com/spf13/afero"
)

var (
        errNoOp          = errors.New("this is a filesystem that does nothing and this operation is not supported")
        _       afero.Fs = (*noOpFs)(nil)

        // NoOpFs provides a no-op filesystem that implements the afero.Fs
        // interface.
        NoOpFs = &amp;noOpFs{}
)

type noOpFs struct {
}

func (fs noOpFs) Create(name string) (afero.File, error) <span class="cov0" title="0">{
        return nil, errNoOp
}</span>

func (fs noOpFs) Mkdir(name string, perm os.FileMode) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs noOpFs) MkdirAll(path string, perm os.FileMode) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs noOpFs) Open(name string) (afero.File, error) <span class="cov0" title="0">{
        return nil, os.ErrNotExist
}</span>

func (fs noOpFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        return nil, os.ErrNotExist
}</span>

func (fs noOpFs) Remove(name string) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs noOpFs) RemoveAll(path string) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs noOpFs) Rename(oldname string, newname string) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs noOpFs) Stat(name string) (os.FileInfo, error) <span class="cov0" title="0">{
        return nil, os.ErrNotExist
}</span>

func (fs noOpFs) Name() string <span class="cov0" title="0">{
        return "noOpFs"
}</span>

func (fs noOpFs) Chmod(name string, mode os.FileMode) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs noOpFs) Chtimes(name string, atime time.Time, mtime time.Time) error <span class="cov0" title="0">{
        return errNoOp
}</span>

func (fs *noOpFs) Chown(name string, uid int, gid int) error <span class="cov0" title="0">{
        return errNoOp
}</span>
</pre>
		
		<pre class="file" id="file98" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "errors"
        "os"
        "path/filepath"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/spf13/afero"
)

var ErrPermissionSymlink = errors.New("symlinks not allowed in this filesystem")

// NewNoSymlinkFs creates a new filesystem that prevents symlinks.
func NewNoSymlinkFs(fs afero.Fs, logger loggers.Logger, allowFiles bool) afero.Fs <span class="cov8" title="1">{
        return &amp;noSymlinkFs{Fs: fs, logger: logger, allowFiles: allowFiles}
}</span>

// noSymlinkFs is a filesystem that prevents symlinking.
type noSymlinkFs struct {
        allowFiles bool // block dirs only
        logger     loggers.Logger
        afero.Fs
}

type noSymlinkFile struct {
        fs *noSymlinkFs
        afero.File
}

func (f *noSymlinkFile) Readdir(count int) ([]os.FileInfo, error) <span class="cov8" title="1">{
        fis, err := f.File.Readdir(count)

        filtered := fis[:0]
        for _, x := range fis </span><span class="cov8" title="1">{
                filename := filepath.Join(f.Name(), x.Name())
                if _, err := f.fs.checkSymlinkStatus(filename, x); err != nil </span><span class="cov8" title="1">{
                        // Log a warning and drop the file from the list
                        logUnsupportedSymlink(filename, f.fs.logger)
                }</span> else<span class="cov8" title="1"> {
                        filtered = append(filtered, x)
                }</span>
        }

        <span class="cov8" title="1">return filtered, err</span>
}

func (f *noSymlinkFile) Readdirnames(count int) ([]string, error) <span class="cov0" title="0">{
        dirs, err := f.Readdir(count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return fileInfosToNames(dirs), nil</span>
}

func (fs *noSymlinkFs) LstatIfPossible(name string) (os.FileInfo, bool, error) <span class="cov8" title="1">{
        return fs.stat(name)
}</span>

func (fs *noSymlinkFs) Stat(name string) (os.FileInfo, error) <span class="cov8" title="1">{
        fi, _, err := fs.stat(name)
        return fi, err
}</span>

func (fs *noSymlinkFs) stat(name string) (os.FileInfo, bool, error) <span class="cov8" title="1">{
        var (
                fi       os.FileInfo
                wasLstat bool
                err      error
        )

        if lstater, ok := fs.Fs.(afero.Lstater); ok </span><span class="cov8" title="1">{
                fi, wasLstat, err = lstater.LstatIfPossible(name)
        }</span> else<span class="cov0" title="0"> {
                fi, err = fs.Fs.Stat(name)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov8" title="1">fi, err = fs.checkSymlinkStatus(name, fi)

        return fi, wasLstat, err</span>
}

func (fs *noSymlinkFs) checkSymlinkStatus(name string, fi os.FileInfo) (os.FileInfo, error) <span class="cov8" title="1">{
        var metaIsSymlink bool

        if fim, ok := fi.(FileMetaInfo); ok </span><span class="cov8" title="1">{
                meta := fim.Meta()
                metaIsSymlink = meta.IsSymlink
        }</span>

        <span class="cov8" title="1">if metaIsSymlink </span><span class="cov8" title="1">{
                if fs.allowFiles &amp;&amp; !fi.IsDir() </span><span class="cov8" title="1">{
                        return fi, nil
                }</span>
                <span class="cov8" title="1">return nil, ErrPermissionSymlink</span>
        }

        // Also support non-decorated filesystems, e.g. the Os fs.
        <span class="cov8" title="1">if isSymlink(fi) </span><span class="cov8" title="1">{
                // Need to determine if this is a directory or not.
                _, sfi, err := evalSymlinks(fs.Fs, name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if fs.allowFiles &amp;&amp; !sfi.IsDir() </span><span class="cov8" title="1">{
                        // Return the original FileInfo to get the expected Name.
                        return fi, nil
                }</span>
                <span class="cov8" title="1">return nil, ErrPermissionSymlink</span>
        }

        <span class="cov8" title="1">return fi, nil</span>
}

func (fs *noSymlinkFs) Open(name string) (afero.File, error) <span class="cov8" title="1">{
        if _, _, err := fs.stat(name); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return fs.wrapFile(fs.Fs.Open(name))</span>
}

func (fs *noSymlinkFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov8" title="1">{
        if _, _, err := fs.stat(name); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return fs.wrapFile(fs.Fs.OpenFile(name, flag, perm))</span>
}

func (fs *noSymlinkFs) wrapFile(f afero.File, err error) (afero.File, error) <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;noSymlinkFile{File: f, fs: fs}, nil</span>
}
</pre>
		
		<pre class="file" id="file99" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "fmt"
        "os"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/pkg/errors"

        radix "github.com/armon/go-radix"
        "github.com/spf13/afero"
)

var filepathSeparator = string(filepath.Separator)

// NewRootMappingFs creates a new RootMappingFs on top of the provided with
// root mappings with some optional metadata about the root.
// Note that From represents a virtual root that maps to the actual filename in To.
func NewRootMappingFs(fs afero.Fs, rms ...RootMapping) (*RootMappingFs, error) <span class="cov8" title="1">{
        rootMapToReal := radix.New()
        var virtualRoots []RootMapping

        for _, rm := range rms </span><span class="cov8" title="1">{
                (&amp;rm).clean()

                fromBase := files.ResolveComponentFolder(rm.From)

                if len(rm.To) &lt; 2 </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("invalid root mapping; from/to: %s/%s", rm.From, rm.To))</span>
                }

                <span class="cov8" title="1">fi, err := fs.Stat(rm.To)
                if err != nil </span><span class="cov8" title="1">{
                        if os.IsNotExist(err) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov0" title="0">return nil, err</span>
                }
                // Extract "blog" from "content/blog"
                <span class="cov8" title="1">rm.path = strings.TrimPrefix(strings.TrimPrefix(rm.From, fromBase), filepathSeparator)
                if rm.Meta == nil </span><span class="cov8" title="1">{
                        rm.Meta = NewFileMeta()
                }</span>

                <span class="cov8" title="1">rm.Meta.SourceRoot = rm.To
                rm.Meta.BaseDir = rm.ToBasedir
                rm.Meta.MountRoot = rm.path
                rm.Meta.Module = rm.Module
                rm.Meta.IsProject = rm.IsProject

                meta := rm.Meta.Copy()

                if !fi.IsDir() </span><span class="cov8" title="1">{
                        _, name := filepath.Split(rm.From)
                        meta.Name = name
                }</span>

                <span class="cov8" title="1">rm.fi = NewFileMetaInfo(fi, meta)

                key := filepathSeparator + rm.From
                var mappings []RootMapping
                v, found := rootMapToReal.Get(key)
                if found </span><span class="cov8" title="1">{
                        // There may be more than one language pointing to the same root.
                        mappings = v.([]RootMapping)
                }</span>
                <span class="cov8" title="1">mappings = append(mappings, rm)
                rootMapToReal.Insert(key, mappings)

                virtualRoots = append(virtualRoots, rm)</span>
        }

        <span class="cov8" title="1">rootMapToReal.Insert(filepathSeparator, virtualRoots)

        rfs := &amp;RootMappingFs{
                Fs:            fs,
                rootMapToReal: rootMapToReal,
        }

        return rfs, nil</span>
}

func newRootMappingFsFromFromTo(
        baseDir string,
        fs afero.Fs,
        fromTo ...string,
) (*RootMappingFs, error) <span class="cov8" title="1">{
        rms := make([]RootMapping, len(fromTo)/2)
        for i, j := 0, 0; j &lt; len(fromTo); i, j = i+1, j+2 </span><span class="cov8" title="1">{
                rms[i] = RootMapping{
                        From:      fromTo[j],
                        To:        fromTo[j+1],
                        ToBasedir: baseDir,
                }
        }</span>

        <span class="cov8" title="1">return NewRootMappingFs(fs, rms...)</span>
}

// RootMapping describes a virtual file or directory mount.
type RootMapping struct {
        From      string    // The virtual mount.
        To        string    // The source directory or file.
        ToBasedir string    // The base of To. May be empty if an absolute path was provided.
        Module    string    // The module path/ID.
        IsProject bool      // Whether this is a mount in the main project.
        Meta      *FileMeta // File metadata (lang etc.)

        fi   FileMetaInfo
        path string // The virtual mount point, e.g. "blog".

}

type keyRootMappings struct {
        key   string
        roots []RootMapping
}

func (rm *RootMapping) clean() <span class="cov8" title="1">{
        rm.From = strings.Trim(filepath.Clean(rm.From), filepathSeparator)
        rm.To = filepath.Clean(rm.To)
}</span>

func (r RootMapping) filename(name string) string <span class="cov8" title="1">{
        if name == "" </span><span class="cov0" title="0">{
                return r.To
        }</span>
        <span class="cov8" title="1">return filepath.Join(r.To, strings.TrimPrefix(name, r.From))</span>
}

func (r RootMapping) trimFrom(name string) string <span class="cov8" title="1">{
        if name == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">return strings.TrimPrefix(name, r.From)</span>
}

// A RootMappingFs maps several roots into one. Note that the root of this filesystem
// is directories only, and they will be returned in Readdir and Readdirnames
// in the order given.
type RootMappingFs struct {
        afero.Fs
        rootMapToReal *radix.Tree
}

func (fs *RootMappingFs) Dirs(base string) ([]FileMetaInfo, error) <span class="cov8" title="1">{
        base = filepathSeparator + fs.cleanName(base)
        roots := fs.getRootsWithPrefix(base)

        if roots == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">fss := make([]FileMetaInfo, len(roots))
        for i, r := range roots </span><span class="cov8" title="1">{
                bfs := afero.NewBasePathFs(fs.Fs, r.To)
                bfs = decoratePath(bfs, func(name string) string </span><span class="cov8" title="1">{
                        p := strings.TrimPrefix(name, r.To)
                        if r.path != "" </span><span class="cov8" title="1">{
                                // Make sure it's mounted to a any sub path, e.g. blog
                                p = filepath.Join(r.path, p)
                        }</span>
                        <span class="cov8" title="1">p = strings.TrimLeft(p, filepathSeparator)
                        return p</span>
                })

                <span class="cov8" title="1">fs := bfs
                if r.Meta.InclusionFilter != nil </span><span class="cov0" title="0">{
                        fs = newFilenameFilterFs(fs, r.To, r.Meta.InclusionFilter)
                }</span>
                <span class="cov8" title="1">fs = decorateDirs(fs, r.Meta)
                fi, err := fs.Stat("")
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "RootMappingFs.Dirs")
                }</span>

                <span class="cov8" title="1">if !fi.IsDir() </span><span class="cov0" title="0">{
                        fi.(FileMetaInfo).Meta().Merge(r.Meta)
                }</span>

                <span class="cov8" title="1">fss[i] = fi.(FileMetaInfo)</span>
        }

        <span class="cov8" title="1">return fss, nil</span>
}

// Filter creates a copy of this filesystem with only mappings matching a filter.
func (fs RootMappingFs) Filter(f func(m RootMapping) bool) *RootMappingFs <span class="cov8" title="1">{
        rootMapToReal := radix.New()
        fs.rootMapToReal.Walk(func(b string, v interface{}) bool </span><span class="cov8" title="1">{
                rms := v.([]RootMapping)
                var nrms []RootMapping
                for _, rm := range rms </span><span class="cov8" title="1">{
                        if f(rm) </span><span class="cov8" title="1">{
                                nrms = append(nrms, rm)
                        }</span>
                }
                <span class="cov8" title="1">if len(nrms) != 0 </span><span class="cov8" title="1">{
                        rootMapToReal.Insert(b, nrms)
                }</span>
                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">fs.rootMapToReal = rootMapToReal

        return &amp;fs</span>
}

// LstatIfPossible returns the os.FileInfo structure describing a given file.
func (fs *RootMappingFs) LstatIfPossible(name string) (os.FileInfo, bool, error) <span class="cov8" title="1">{
        fis, err := fs.doLstat(name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, false, err
        }</span>
        <span class="cov8" title="1">return fis[0], false, nil</span>
}

// Open opens the named file for reading.
func (fs *RootMappingFs) Open(name string) (afero.File, error) <span class="cov8" title="1">{
        fis, err := fs.doLstat(name)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return fs.newUnionFile(fis...)</span>
}

// Stat returns the os.FileInfo structure describing a given file.  If there is
// an error, it will be of type *os.PathError.
func (fs *RootMappingFs) Stat(name string) (os.FileInfo, error) <span class="cov8" title="1">{
        fi, _, err := fs.LstatIfPossible(name)
        return fi, err
}</span>

func (fs *RootMappingFs) hasPrefix(prefix string) bool <span class="cov8" title="1">{
        hasPrefix := false
        fs.rootMapToReal.WalkPrefix(prefix, func(b string, v interface{}) bool </span><span class="cov8" title="1">{
                hasPrefix = true
                return true
        }</span>)

        <span class="cov8" title="1">return hasPrefix</span>
}

func (fs *RootMappingFs) getRoot(key string) []RootMapping <span class="cov8" title="1">{
        v, found := fs.rootMapToReal.Get(key)
        if !found </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return v.([]RootMapping)</span>
}

func (fs *RootMappingFs) getRoots(key string) (string, []RootMapping) <span class="cov8" title="1">{
        s, v, found := fs.rootMapToReal.LongestPrefix(key)
        if !found || (s == filepathSeparator &amp;&amp; key != filepathSeparator) </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov8" title="1">return s, v.([]RootMapping)</span>
}

func (fs *RootMappingFs) debug() <span class="cov0" title="0">{
        fmt.Println("debug():")
        fs.rootMapToReal.Walk(func(s string, v interface{}) bool </span><span class="cov0" title="0">{
                fmt.Println("Key", s)
                return false
        }</span>)
}

func (fs *RootMappingFs) getRootsWithPrefix(prefix string) []RootMapping <span class="cov8" title="1">{
        var roots []RootMapping
        fs.rootMapToReal.WalkPrefix(prefix, func(b string, v interface{}) bool </span><span class="cov8" title="1">{
                roots = append(roots, v.([]RootMapping)...)
                return false
        }</span>)

        <span class="cov8" title="1">return roots</span>
}

func (fs *RootMappingFs) getAncestors(prefix string) []keyRootMappings <span class="cov8" title="1">{
        var roots []keyRootMappings
        fs.rootMapToReal.WalkPath(prefix, func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                if strings.HasPrefix(prefix, s+filepathSeparator) </span><span class="cov8" title="1">{
                        roots = append(roots, keyRootMappings{
                                key:   s,
                                roots: v.([]RootMapping),
                        })
                }</span>
                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">return roots</span>
}

func (fs *RootMappingFs) newUnionFile(fis ...FileMetaInfo) (afero.File, error) <span class="cov8" title="1">{
        meta := fis[0].Meta()
        f, err := meta.Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(fis) == 1 </span><span class="cov8" title="1">{
                return f, nil
        }</span>

        <span class="cov8" title="1">rf := &amp;rootMappingFile{File: f, fs: fs, name: meta.Name, meta: meta}
        if len(fis) == 1 </span><span class="cov0" title="0">{
                return rf, err
        }</span>

        <span class="cov8" title="1">next, err := fs.newUnionFile(fis[1:]...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">uf := &amp;afero.UnionFile{Base: rf, Layer: next}

        uf.Merger = func(lofi, bofi []os.FileInfo) ([]os.FileInfo, error) </span><span class="cov8" title="1">{
                // Ignore duplicate directory entries
                seen := make(map[string]bool)
                var result []os.FileInfo

                for _, fis := range [][]os.FileInfo{bofi, lofi} </span><span class="cov8" title="1">{
                        for _, fi := range fis </span><span class="cov8" title="1">{

                                if fi.IsDir() &amp;&amp; seen[fi.Name()] </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">if fi.IsDir() </span><span class="cov0" title="0">{
                                        seen[fi.Name()] = true
                                }</span>

                                <span class="cov8" title="1">result = append(result, fi)</span>
                        }
                }

                <span class="cov8" title="1">return result, nil</span>
        }

        <span class="cov8" title="1">return uf, nil</span>
}

func (fs *RootMappingFs) cleanName(name string) string <span class="cov8" title="1">{
        return strings.Trim(filepath.Clean(name), filepathSeparator)
}</span>

func (fs *RootMappingFs) collectDirEntries(prefix string) ([]os.FileInfo, error) <span class="cov8" title="1">{
        prefix = filepathSeparator + fs.cleanName(prefix)

        var fis []os.FileInfo

        seen := make(map[string]bool) // Prevent duplicate directories
        level := strings.Count(prefix, filepathSeparator)

        collectDir := func(rm RootMapping, fi FileMetaInfo) error </span><span class="cov8" title="1">{
                f, err := fi.Meta().Open()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">direntries, err := f.Readdir(-1)
                if err != nil </span><span class="cov0" title="0">{
                        f.Close()
                        return err
                }</span>

                <span class="cov8" title="1">for _, fi := range direntries </span><span class="cov8" title="1">{
                        meta := fi.(FileMetaInfo).Meta()
                        meta.Merge(rm.Meta)
                        if !rm.Meta.InclusionFilter.Match(strings.TrimPrefix(meta.Filename, meta.SourceRoot), fi.IsDir()) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if fi.IsDir() </span><span class="cov8" title="1">{
                                name := fi.Name()
                                if seen[name] </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">seen[name] = true
                                opener := func() (afero.File, error) </span><span class="cov8" title="1">{
                                        return fs.Open(filepath.Join(rm.From, name))
                                }</span>
                                <span class="cov8" title="1">fi = newDirNameOnlyFileInfo(name, meta, opener)</span>
                        }

                        <span class="cov8" title="1">fis = append(fis, fi)</span>
                }

                <span class="cov8" title="1">f.Close()

                return nil</span>
        }

        // First add any real files/directories.
        <span class="cov8" title="1">rms := fs.getRoot(prefix)
        for _, rm := range rms </span><span class="cov8" title="1">{
                if err := collectDir(rm, rm.fi); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        // Next add any file mounts inside the given directory.
        <span class="cov8" title="1">prefixInside := prefix + filepathSeparator
        fs.rootMapToReal.WalkPrefix(prefixInside, func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                if (strings.Count(s, filepathSeparator) - level) != 1 </span><span class="cov8" title="1">{
                        // This directory is not part of the current, but we
                        // need to include the first name part to make it
                        // navigable.
                        path := strings.TrimPrefix(s, prefixInside)
                        parts := strings.Split(path, filepathSeparator)
                        name := parts[0]

                        if seen[name] </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">seen[name] = true
                        opener := func() (afero.File, error) </span><span class="cov0" title="0">{
                                return fs.Open(path)
                        }</span>

                        <span class="cov8" title="1">fi := newDirNameOnlyFileInfo(name, nil, opener)
                        fis = append(fis, fi)

                        return false</span>
                }

                <span class="cov8" title="1">rms := v.([]RootMapping)
                for _, rm := range rms </span><span class="cov8" title="1">{
                        if !rm.fi.IsDir() </span><span class="cov8" title="1">{
                                // A single file mount
                                fis = append(fis, rm.fi)
                                continue</span>
                        }
                        <span class="cov8" title="1">name := filepath.Base(rm.From)
                        if seen[name] </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">seen[name] = true

                        opener := func() (afero.File, error) </span><span class="cov8" title="1">{
                                return fs.Open(rm.From)
                        }</span>

                        <span class="cov8" title="1">fi := newDirNameOnlyFileInfo(name, rm.Meta, opener)

                        fis = append(fis, fi)</span>

                }

                <span class="cov8" title="1">return false</span>
        })

        // Finally add any ancestor dirs with files in this directory.
        <span class="cov8" title="1">ancestors := fs.getAncestors(prefix)
        for _, root := range ancestors </span><span class="cov8" title="1">{
                subdir := strings.TrimPrefix(prefix, root.key)
                for _, rm := range root.roots </span><span class="cov8" title="1">{
                        if rm.fi.IsDir() </span><span class="cov8" title="1">{
                                fi, err := rm.fi.Meta().JoinStat(subdir)
                                if err == nil </span><span class="cov8" title="1">{
                                        if err := collectDir(rm, fi); err != nil </span><span class="cov0" title="0">{
                                                return nil, err
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">return fis, nil</span>
}

func (fs *RootMappingFs) doLstat(name string) ([]FileMetaInfo, error) <span class="cov8" title="1">{
        name = fs.cleanName(name)
        key := filepathSeparator + name

        roots := fs.getRoot(key)

        if roots == nil </span><span class="cov8" title="1">{
                if fs.hasPrefix(key) </span><span class="cov8" title="1">{
                        // We have directories mounted below this.
                        // Make it look like a directory.
                        return []FileMetaInfo{newDirNameOnlyFileInfo(name, nil, fs.virtualDirOpener(name))}, nil
                }</span>

                // Find any real files or directories with this key.
                <span class="cov8" title="1">_, roots := fs.getRoots(key)
                if roots == nil </span><span class="cov0" title="0">{
                        return nil, &amp;os.PathError{Op: "LStat", Path: name, Err: os.ErrNotExist}
                }</span>

                <span class="cov8" title="1">var err error
                var fis []FileMetaInfo

                for _, rm := range roots </span><span class="cov8" title="1">{
                        var fi FileMetaInfo
                        fi, _, err = fs.statRoot(rm, name)
                        if err == nil </span><span class="cov8" title="1">{
                                fis = append(fis, fi)
                        }</span>
                }

                <span class="cov8" title="1">if fis != nil </span><span class="cov8" title="1">{
                        return fis, nil
                }</span>

                <span class="cov8" title="1">if err == nil </span><span class="cov0" title="0">{
                        err = &amp;os.PathError{Op: "LStat", Path: name, Err: err}
                }</span>

                <span class="cov8" title="1">return nil, err</span>
        }

        <span class="cov8" title="1">fileCount := 0
        var wasFiltered bool
        for _, root := range roots </span><span class="cov8" title="1">{
                meta := root.fi.Meta()
                if !meta.InclusionFilter.Match(strings.TrimPrefix(meta.Filename, meta.SourceRoot), root.fi.IsDir()) </span><span class="cov0" title="0">{
                        wasFiltered = true
                        continue</span>
                }

                <span class="cov8" title="1">if !root.fi.IsDir() </span><span class="cov8" title="1">{
                        fileCount++
                }</span>
                <span class="cov8" title="1">if fileCount &gt; 1 </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if fileCount == 0 </span><span class="cov8" title="1">{
                if wasFiltered </span><span class="cov0" title="0">{
                        return nil, os.ErrNotExist
                }</span>
                // Dir only.
                <span class="cov8" title="1">return []FileMetaInfo{newDirNameOnlyFileInfo(name, roots[0].Meta, fs.virtualDirOpener(name))}, nil</span>
        }

        <span class="cov8" title="1">if fileCount &gt; 1 </span><span class="cov8" title="1">{
                // Not supported by this filesystem.
                return nil, errors.Errorf("found multiple files with name %q, use .Readdir or the source filesystem directly", name)
        }</span>

        <span class="cov0" title="0">return []FileMetaInfo{roots[0].fi}, nil</span>
}

func (fs *RootMappingFs) statRoot(root RootMapping, name string) (FileMetaInfo, bool, error) <span class="cov8" title="1">{
        if !root.Meta.InclusionFilter.Match(root.trimFrom(name), root.fi.IsDir()) </span><span class="cov8" title="1">{
                return nil, false, os.ErrNotExist
        }</span>
        <span class="cov8" title="1">filename := root.filename(name)

        fi, b, err := lstatIfPossible(fs.Fs, filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, b, err
        }</span>

        <span class="cov8" title="1">var opener func() (afero.File, error)
        if fi.IsDir() </span><span class="cov8" title="1">{
                // Make sure metadata gets applied in Readdir.
                opener = fs.realDirOpener(filename, root.Meta)
        }</span> else<span class="cov8" title="1"> {
                // Opens the real file directly.
                opener = func() (afero.File, error) </span><span class="cov8" title="1">{
                        return fs.Fs.Open(filename)
                }</span>
        }

        <span class="cov8" title="1">return decorateFileInfo(fi, fs.Fs, opener, "", "", root.Meta), b, nil</span>
}

func (fs *RootMappingFs) virtualDirOpener(name string) func() (afero.File, error) <span class="cov8" title="1">{
        return func() (afero.File, error) </span><span class="cov8" title="1">{ return &amp;rootMappingFile{name: name, fs: fs}, nil }</span>
}

func (fs *RootMappingFs) realDirOpener(name string, meta *FileMeta) func() (afero.File, error) <span class="cov8" title="1">{
        return func() (afero.File, error) </span><span class="cov8" title="1">{
                f, err := fs.Fs.Open(name)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return &amp;rootMappingFile{name: name, meta: meta, fs: fs, File: f}, nil</span>
        }
}

type rootMappingFile struct {
        afero.File
        fs   *RootMappingFs
        name string
        meta *FileMeta
}

func (f *rootMappingFile) Close() error <span class="cov8" title="1">{
        if f.File == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return f.File.Close()</span>
}

func (f *rootMappingFile) Name() string <span class="cov0" title="0">{
        return f.name
}</span>

func (f *rootMappingFile) Readdir(count int) ([]os.FileInfo, error) <span class="cov8" title="1">{
        if f.File != nil </span><span class="cov8" title="1">{

                fis, err := f.File.Readdir(count)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">var result []os.FileInfo
                for _, fi := range fis </span><span class="cov8" title="1">{
                        fim := decorateFileInfo(fi, f.fs, nil, "", "", f.meta)
                        meta := fim.Meta()
                        if f.meta.InclusionFilter.Match(strings.TrimPrefix(meta.Filename, meta.SourceRoot), fim.IsDir()) </span><span class="cov8" title="1">{
                                result = append(result, fim)
                        }</span>
                }
                <span class="cov8" title="1">return result, nil</span>
        }

        <span class="cov8" title="1">return f.fs.collectDirEntries(f.name)</span>
}

func (f *rootMappingFile) Readdirnames(count int) ([]string, error) <span class="cov8" title="1">{
        dirs, err := f.Readdir(count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return fileInfosToNames(dirs), nil</span>
}
</pre>
		
		<pre class="file" id="file100" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "os"
        "syscall"
        "time"

        "github.com/pkg/errors"

        "github.com/spf13/afero"
)

var (
        _ afero.Fs      = (*SliceFs)(nil)
        _ afero.Lstater = (*SliceFs)(nil)
        _ afero.File    = (*sliceDir)(nil)
)

func NewSliceFs(dirs ...FileMetaInfo) (afero.Fs, error) <span class="cov0" title="0">{
        if len(dirs) == 0 </span><span class="cov0" title="0">{
                return NoOpFs, nil
        }</span>

        <span class="cov0" title="0">for _, dir := range dirs </span><span class="cov0" title="0">{
                if !dir.IsDir() </span><span class="cov0" title="0">{
                        return nil, errors.New("this fs supports directories only")
                }</span>
        }

        <span class="cov0" title="0">fs := &amp;SliceFs{
                dirs: dirs,
        }

        return fs, nil</span>
}

// SliceFs is an ordered composite filesystem.
type SliceFs struct {
        dirs []FileMetaInfo
}

func (fs *SliceFs) Chmod(n string, m os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) Chtimes(n string, a, m time.Time) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) Chown(n string, uid, gid int) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) LstatIfPossible(name string) (os.FileInfo, bool, error) <span class="cov0" title="0">{
        fi, _, err := fs.pickFirst(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, false, err
        }</span>

        <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                return decorateFileInfo(fi, fs, fs.getOpener(name), "", "", nil), false, nil
        }</span>

        <span class="cov0" title="0">return nil, false, errors.Errorf("lstat: files not supported: %q", name)</span>
}

func (fs *SliceFs) Mkdir(n string, p os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) MkdirAll(n string, p os.FileMode) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) Name() string <span class="cov0" title="0">{
        return "SliceFs"
}</span>

func (fs *SliceFs) Open(name string) (afero.File, error) <span class="cov0" title="0">{
        fi, idx, err := fs.pickFirst(name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if !fi.IsDir() </span><span class="cov0" title="0">{
                panic("currently only dirs in here")</span>
        }

        <span class="cov0" title="0">return &amp;sliceDir{
                lfs:     fs,
                idx:     idx,
                dirname: name,
        }, nil</span>
}

func (fs *SliceFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (fs *SliceFs) ReadDir(name string) ([]os.FileInfo, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (fs *SliceFs) Remove(n string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) RemoveAll(p string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) Rename(o, n string) error <span class="cov0" title="0">{
        return syscall.EPERM
}</span>

func (fs *SliceFs) Stat(name string) (os.FileInfo, error) <span class="cov0" title="0">{
        fi, _, err := fs.LstatIfPossible(name)
        return fi, err
}</span>

func (fs *SliceFs) Create(n string) (afero.File, error) <span class="cov0" title="0">{
        return nil, syscall.EPERM
}</span>

func (fs *SliceFs) getOpener(name string) func() (afero.File, error) <span class="cov0" title="0">{
        return func() (afero.File, error) </span><span class="cov0" title="0">{
                return fs.Open(name)
        }</span>
}

func (fs *SliceFs) pickFirst(name string) (os.FileInfo, int, error) <span class="cov0" title="0">{
        for i, mfs := range fs.dirs </span><span class="cov0" title="0">{
                meta := mfs.Meta()
                fs := meta.Fs
                fi, _, err := lstatIfPossible(fs, name)
                if err == nil </span><span class="cov0" title="0">{
                        // Gotta match!
                        return fi, i, nil
                }</span>

                <span class="cov0" title="0">if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // Real error
                        return nil, -1, err
                }</span>
        }

        // Not found
        <span class="cov0" title="0">return nil, -1, os.ErrNotExist</span>
}

func (fs *SliceFs) readDirs(name string, startIdx, count int) ([]os.FileInfo, error) <span class="cov0" title="0">{
        collect := func(lfs *FileMeta) ([]os.FileInfo, error) </span><span class="cov0" title="0">{
                d, err := lfs.Fs.Open(name)
                if err != nil </span><span class="cov0" title="0">{
                        if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return nil, nil</span>
                } else<span class="cov0" title="0"> {
                        defer d.Close()
                        dirs, err := d.Readdir(-1)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">return dirs, nil</span>
                }
        }

        <span class="cov0" title="0">var dirs []os.FileInfo

        for i := startIdx; i &lt; len(fs.dirs); i++ </span><span class="cov0" title="0">{
                mfs := fs.dirs[i]

                fis, err := collect(mfs.Meta())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">dirs = append(dirs, fis...)</span>

        }

        <span class="cov0" title="0">seen := make(map[string]bool)
        var duplicates []int
        for i, fi := range dirs </span><span class="cov0" title="0">{
                if !fi.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if seen[fi.Name()] </span><span class="cov0" title="0">{
                        duplicates = append(duplicates, i)
                }</span> else<span class="cov0" title="0"> {
                        // Make sure it's opened by this filesystem.
                        dirs[i] = decorateFileInfo(fi, fs, fs.getOpener(fi.(FileMetaInfo).Meta().Filename), "", "", nil)
                        seen[fi.Name()] = true
                }</span>
        }

        // Remove duplicate directories, keep first.
        <span class="cov0" title="0">if len(duplicates) &gt; 0 </span><span class="cov0" title="0">{
                for i := len(duplicates) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        idx := duplicates[i]
                        dirs = append(dirs[:idx], dirs[idx+1:]...)
                }</span>
        }

        <span class="cov0" title="0">if count &gt; 0 &amp;&amp; len(dirs) &gt;= count </span><span class="cov0" title="0">{
                return dirs[:count], nil
        }</span>

        <span class="cov0" title="0">return dirs, nil</span>
}

type sliceDir struct {
        lfs     *SliceFs
        idx     int
        dirname string
}

func (f *sliceDir) Close() error <span class="cov0" title="0">{
        return nil
}</span>

func (f *sliceDir) Name() string <span class="cov0" title="0">{
        return f.dirname
}</span>

func (f *sliceDir) Read(p []byte) (n int, err error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) ReadAt(p []byte, off int64) (n int, err error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) Readdir(count int) ([]os.FileInfo, error) <span class="cov0" title="0">{
        return f.lfs.readDirs(f.dirname, f.idx, count)
}</span>

func (f *sliceDir) Readdirnames(count int) ([]string, error) <span class="cov0" title="0">{
        dirsi, err := f.Readdir(count)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">dirs := make([]string, len(dirsi))
        for i, d := range dirsi </span><span class="cov0" title="0">{
                dirs[i] = d.Name()
        }</span>
        <span class="cov0" title="0">return dirs, nil</span>
}

func (f *sliceDir) Seek(offset int64, whence int) (int64, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) Stat() (os.FileInfo, error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) Sync() error <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) Truncate(size int64) error <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) WriteAt(p []byte, off int64) (n int, err error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}

func (f *sliceDir) WriteString(s string) (ret int, err error) <span class="cov0" title="0">{
        panic("not implemented")</span>
}
</pre>
		
		<pre class="file" id="file101" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "fmt"
        "os"
        "regexp"
        "runtime"

        "github.com/gohugoio/hugo/common/types"

        "github.com/spf13/afero"
)

// Make sure we don't accidentally use this in the real Hugo.
var _ types.DevMarker = (*stacktracerFs)(nil)

// NewStacktracerFs wraps the given fs printing stack traces for file creates
// matching the given regexp pattern.
func NewStacktracerFs(fs afero.Fs, pattern string) afero.Fs <span class="cov0" title="0">{
        return &amp;stacktracerFs{Fs: fs, re: regexp.MustCompile(pattern)}
}</span>

// stacktracerFs can be used in hard-to-debug development situations where
// you get some input you don't understand where comes from.
type stacktracerFs struct {
        afero.Fs

        // Will print stacktrace for every file creates matching this pattern.
        re *regexp.Regexp
}

func (fs *stacktracerFs) DevOnly() {<span class="cov0" title="0">
}</span>

func (fs *stacktracerFs) onCreate(filename string) <span class="cov0" title="0">{
        if fs.re.MatchString(filename) </span><span class="cov0" title="0">{
                trace := make([]byte, 1500)
                runtime.Stack(trace, true)
                fmt.Printf("\n===========\n%q:\n%s\n", filename, trace)
        }</span>
}

func (fs *stacktracerFs) Create(name string) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.Fs.Create(name)
        if err == nil </span><span class="cov0" title="0">{
                fs.onCreate(name)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}

func (fs *stacktracerFs) OpenFile(name string, flag int, perm os.FileMode) (afero.File, error) <span class="cov0" title="0">{
        f, err := fs.Fs.OpenFile(name, flag, perm)
        if err == nil &amp;&amp; isWrite(flag) </span><span class="cov0" title="0">{
                fs.onCreate(name)
        }</span>
        <span class="cov0" title="0">return f, err</span>
}
</pre>
		
		<pre class="file" id="file102" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugofs

import (
        "fmt"
        "os"
        "path/filepath"
        "sort"
        "strings"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/pkg/errors"

        "github.com/spf13/afero"
)

type (
        WalkFunc func(path string, info FileMetaInfo, err error) error
        WalkHook func(dir FileMetaInfo, path string, readdir []FileMetaInfo) ([]FileMetaInfo, error)
)

type Walkway struct {
        fs       afero.Fs
        root     string
        basePath string

        logger loggers.Logger

        // May be pre-set
        fi         FileMetaInfo
        dirEntries []FileMetaInfo

        walkFn WalkFunc
        walked bool

        // We may traverse symbolic links and bite ourself.
        seen map[string]bool

        // Optional hooks
        hookPre  WalkHook
        hookPost WalkHook
}

type WalkwayConfig struct {
        Fs       afero.Fs
        Root     string
        BasePath string

        Logger loggers.Logger

        // One or both of these may be pre-set.
        Info       FileMetaInfo
        DirEntries []FileMetaInfo

        WalkFn   WalkFunc
        HookPre  WalkHook
        HookPost WalkHook
}

func NewWalkway(cfg WalkwayConfig) *Walkway <span class="cov8" title="1">{
        var fs afero.Fs
        if cfg.Info != nil </span><span class="cov0" title="0">{
                fs = cfg.Info.Meta().Fs
        }</span> else<span class="cov8" title="1"> {
                fs = cfg.Fs
        }</span>

        <span class="cov8" title="1">basePath := cfg.BasePath
        if basePath != "" &amp;&amp; !strings.HasSuffix(basePath, filepathSeparator) </span><span class="cov8" title="1">{
                basePath += filepathSeparator
        }</span>

        <span class="cov8" title="1">logger := cfg.Logger
        if logger == nil </span><span class="cov8" title="1">{
                logger = loggers.NewWarningLogger()
        }</span>

        <span class="cov8" title="1">return &amp;Walkway{
                fs:         fs,
                root:       cfg.Root,
                basePath:   basePath,
                fi:         cfg.Info,
                dirEntries: cfg.DirEntries,
                walkFn:     cfg.WalkFn,
                hookPre:    cfg.HookPre,
                hookPost:   cfg.HookPost,
                logger:     logger,
                seen:       make(map[string]bool),
        }</span>
}

func (w *Walkway) Walk() error <span class="cov8" title="1">{
        if w.walked </span><span class="cov0" title="0">{
                panic("this walkway is already walked")</span>
        }
        <span class="cov8" title="1">w.walked = true

        if w.fs == NoOpFs </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">var fi FileMetaInfo
        if w.fi != nil </span><span class="cov0" title="0">{
                fi = w.fi
        }</span> else<span class="cov8" title="1"> {
                info, _, err := lstatIfPossible(w.fs, w.root)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>

                        <span class="cov0" title="0">if w.checkErr(w.root, err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return w.walkFn(w.root, nil, errors.Wrapf(err, "walk: %q", w.root))</span>
                }
                <span class="cov8" title="1">fi = info.(FileMetaInfo)</span>
        }

        <span class="cov8" title="1">if !fi.IsDir() </span><span class="cov0" title="0">{
                return w.walkFn(w.root, nil, errors.New("file to walk must be a directory"))
        }</span>

        <span class="cov8" title="1">return w.walk(w.root, fi, w.dirEntries, w.walkFn)</span>
}

// if the filesystem supports it, use Lstat, else use fs.Stat
func lstatIfPossible(fs afero.Fs, path string) (os.FileInfo, bool, error) <span class="cov8" title="1">{
        if lfs, ok := fs.(afero.Lstater); ok </span><span class="cov8" title="1">{
                fi, b, err := lfs.LstatIfPossible(path)
                return fi, b, err
        }</span>
        <span class="cov0" title="0">fi, err := fs.Stat(path)
        return fi, false, err</span>
}

// checkErr returns true if the error is handled.
func (w *Walkway) checkErr(filename string, err error) bool <span class="cov0" title="0">{
        if err == ErrPermissionSymlink </span><span class="cov0" title="0">{
                logUnsupportedSymlink(filename, w.logger)
                return true
        }</span>

        <span class="cov0" title="0">if os.IsNotExist(err) </span><span class="cov0" title="0">{
                // The file may be removed in process.
                // This may be a ERROR situation, but it is not possible
                // to determine as a general case.
                w.logger.Warnf("File %q not found, skipping.", filename)
                return true
        }</span>

        <span class="cov0" title="0">return false</span>
}

func logUnsupportedSymlink(filename string, logger loggers.Logger) <span class="cov8" title="1">{
        logger.Warnf("Unsupported symlink found in %q, skipping.", filename)
}</span>

// walk recursively descends path, calling walkFn.
// It follow symlinks if supported by the filesystem, but only the same path once.
func (w *Walkway) walk(path string, info FileMetaInfo, dirEntries []FileMetaInfo, walkFn WalkFunc) error <span class="cov8" title="1">{
        err := walkFn(path, info, nil)
        if err != nil </span><span class="cov8" title="1">{
                if info.IsDir() &amp;&amp; err == filepath.SkipDir </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }
        <span class="cov8" title="1">if !info.IsDir() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">meta := info.Meta()
        filename := meta.Filename

        if dirEntries == nil </span><span class="cov8" title="1">{
                f, err := w.fs.Open(path)
                if err != nil </span><span class="cov0" title="0">{
                        if w.checkErr(path, err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return walkFn(path, info, errors.Wrapf(err, "walk: open %q (%q)", path, w.root))</span>
                }

                <span class="cov8" title="1">fis, err := f.Readdir(-1)
                f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        if w.checkErr(filename, err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return walkFn(path, info, errors.Wrap(err, "walk: Readdir"))</span>
                }

                <span class="cov8" title="1">dirEntries = fileInfosToFileMetaInfos(fis)

                if !meta.IsOrdered </span><span class="cov8" title="1">{
                        sort.Slice(dirEntries, func(i, j int) bool </span><span class="cov8" title="1">{
                                fii := dirEntries[i]
                                fij := dirEntries[j]

                                fim, fjm := fii.Meta(), fij.Meta()

                                // Pull bundle headers to the top.
                                ficlass, fjclass := fim.Classifier, fjm.Classifier
                                if ficlass != fjclass </span><span class="cov0" title="0">{
                                        return ficlass &lt; fjclass
                                }</span>

                                // With multiple content dirs with different languages,
                                // there can be duplicate files, and a weight will be added
                                // to the closest one.
                                <span class="cov8" title="1">fiw, fjw := fim.Weight, fjm.Weight
                                if fiw != fjw </span><span class="cov0" title="0">{
                                        return fiw &gt; fjw
                                }</span>

                                // Explicit order set.
                                <span class="cov8" title="1">fio, fjo := fim.Ordinal, fjm.Ordinal
                                if fio != fjo </span><span class="cov0" title="0">{
                                        return fio &lt; fjo
                                }</span>

                                // When we walk into a symlink, we keep the reference to
                                // the original name.
                                <span class="cov8" title="1">fin, fjn := fim.Name, fjm.Name
                                if fin != "" &amp;&amp; fjn != "" </span><span class="cov8" title="1">{
                                        return fin &lt; fjn
                                }</span>

                                <span class="cov8" title="1">return fii.Name() &lt; fij.Name()</span>
                        })
                }
        }

        // First add some metadata to the dir entries
        <span class="cov8" title="1">for _, fi := range dirEntries </span><span class="cov8" title="1">{
                fim := fi.(FileMetaInfo)

                meta := fim.Meta()

                // Note that we use the original Name even if it's a symlink.
                name := meta.Name
                if name == "" </span><span class="cov8" title="1">{
                        name = fim.Name()
                }</span>

                <span class="cov8" title="1">if name == "" </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("[%s] no name set in %v", path, meta))</span>
                }
                <span class="cov8" title="1">pathn := filepath.Join(path, name)

                pathMeta := pathn
                if w.basePath != "" </span><span class="cov8" title="1">{
                        pathMeta = strings.TrimPrefix(pathn, w.basePath)
                }</span>

                <span class="cov8" title="1">meta.Path = normalizeFilename(pathMeta)
                meta.PathWalk = pathn

                if fim.IsDir() &amp;&amp; meta.IsSymlink &amp;&amp; w.isSeen(meta.Filename) </span><span class="cov8" title="1">{
                        // Prevent infinite recursion
                        // Possible cyclic reference
                        meta.SkipDir = true
                }</span>
        }

        <span class="cov8" title="1">if w.hookPre != nil </span><span class="cov0" title="0">{
                dirEntries, err = w.hookPre(info, path, dirEntries)
                if err != nil </span><span class="cov0" title="0">{
                        if err == filepath.SkipDir </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }

        <span class="cov8" title="1">for _, fi := range dirEntries </span><span class="cov8" title="1">{
                fim := fi.(FileMetaInfo)
                meta := fim.Meta()

                if meta.SkipDir </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">err := w.walk(meta.PathWalk, fim, nil, walkFn)
                if err != nil </span><span class="cov0" title="0">{
                        if !fi.IsDir() || err != filepath.SkipDir </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">if w.hookPost != nil </span><span class="cov0" title="0">{
                dirEntries, err = w.hookPost(info, path, dirEntries)
                if err != nil </span><span class="cov0" title="0">{
                        if err == filepath.SkipDir </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (w *Walkway) isSeen(filename string) bool <span class="cov8" title="1">{
        if filename == "" </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if w.seen[filename] </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">w.seen[filename] = true
        return false</span>
}
</pre>
		
		<pre class="file" id="file103" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "path"
        "path/filepath"
        "runtime"
        "strings"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/publisher"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/tpl"
)

type aliasHandler struct {
        t         tpl.TemplateHandler
        log       loggers.Logger
        allowRoot bool
}

func newAliasHandler(t tpl.TemplateHandler, l loggers.Logger, allowRoot bool) aliasHandler <span class="cov8" title="1">{
        return aliasHandler{t, l, allowRoot}
}</span>

type aliasPage struct {
        Permalink string
        page.Page
}

func (a aliasHandler) renderAlias(permalink string, p page.Page) (io.Reader, error) <span class="cov8" title="1">{
        var templ tpl.Template
        var found bool

        templ, found = a.t.Lookup("alias.html")
        if !found </span><span class="cov8" title="1">{
                // TODO(bep) consolidate
                templ, found = a.t.Lookup("_internal/alias.html")
                if !found </span><span class="cov0" title="0">{
                        return nil, errors.New("no alias template found")
                }</span>
        }

        <span class="cov8" title="1">data := aliasPage{
                permalink,
                p,
        }

        buffer := new(bytes.Buffer)
        err := a.t.Execute(templ, buffer, data)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return buffer, nil</span>
}

func (s *Site) writeDestAlias(path, permalink string, outputFormat output.Format, p page.Page) (err error) <span class="cov8" title="1">{
        return s.publishDestAlias(false, path, permalink, outputFormat, p)
}</span>

func (s *Site) publishDestAlias(allowRoot bool, path, permalink string, outputFormat output.Format, p page.Page) (err error) <span class="cov8" title="1">{
        handler := newAliasHandler(s.Tmpl(), s.Log, allowRoot)

        s.Log.Debugln("creating alias:", path, "redirecting to", permalink)

        targetPath, err := handler.targetPathAlias(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">aliasContent, err := handler.renderAlias(permalink, p)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pd := publisher.Descriptor{
                Src:          aliasContent,
                TargetPath:   targetPath,
                StatCounter:  &amp;s.PathSpec.ProcessingStats.Aliases,
                OutputFormat: outputFormat,
        }

        if s.Info.relativeURLs || s.Info.canonifyURLs </span><span class="cov8" title="1">{
                pd.AbsURLPath = s.absURLPath(targetPath)
        }</span>

        <span class="cov8" title="1">return s.publisher.Publish(pd)</span>
}

func (a aliasHandler) targetPathAlias(src string) (string, error) <span class="cov8" title="1">{
        originalAlias := src
        if len(src) &lt;= 0 </span><span class="cov8" title="1">{
                return "", fmt.Errorf("alias \"\" is an empty string")
        }</span>

        <span class="cov8" title="1">alias := path.Clean(filepath.ToSlash(src))

        if !a.allowRoot &amp;&amp; alias == "/" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("alias \"%s\" resolves to website root directory", originalAlias)
        }</span>

        <span class="cov8" title="1">components := strings.Split(alias, "/")

        // Validate against directory traversal
        if components[0] == ".." </span><span class="cov8" title="1">{
                return "", fmt.Errorf("alias \"%s\" traverses outside the website root directory", originalAlias)
        }</span>

        // Handle Windows file and directory naming restrictions
        // See "Naming Files, Paths, and Namespaces" on MSDN
        // https://msdn.microsoft.com/en-us/library/aa365247%28v=VS.85%29.aspx?f=255&amp;MSPPError=-2147217396
        <span class="cov8" title="1">msgs := []string{}
        reservedNames := []string{"CON", "PRN", "AUX", "NUL", "COM0", "COM1", "COM2", "COM3", "COM4", "COM5", "COM6", "COM7", "COM8", "COM9", "LPT0", "LPT1", "LPT2", "LPT3", "LPT4", "LPT5", "LPT6", "LPT7", "LPT8", "LPT9"}

        if strings.ContainsAny(alias, ":*?\"&lt;&gt;|") </span><span class="cov8" title="1">{
                msgs = append(msgs, fmt.Sprintf("Alias \"%s\" contains invalid characters on Windows: : * ? \" &lt; &gt; |", originalAlias))
        }</span>
        <span class="cov8" title="1">for _, ch := range alias </span><span class="cov8" title="1">{
                if ch &lt; ' ' </span><span class="cov8" title="1">{
                        msgs = append(msgs, fmt.Sprintf("Alias \"%s\" contains ASCII control code (0x00 to 0x1F), invalid on Windows: : * ? \" &lt; &gt; |", originalAlias))
                        continue</span>
                }
        }
        <span class="cov8" title="1">for _, comp := range components </span><span class="cov8" title="1">{
                if strings.HasSuffix(comp, " ") || strings.HasSuffix(comp, ".") </span><span class="cov8" title="1">{
                        msgs = append(msgs, fmt.Sprintf("Alias \"%s\" contains component with a trailing space or period, problematic on Windows", originalAlias))
                }</span>
                <span class="cov8" title="1">for _, r := range reservedNames </span><span class="cov8" title="1">{
                        if comp == r </span><span class="cov8" title="1">{
                                msgs = append(msgs, fmt.Sprintf("Alias \"%s\" contains component with reserved name \"%s\" on Windows", originalAlias, r))
                        }</span>
                }
        }
        <span class="cov8" title="1">if len(msgs) &gt; 0 </span><span class="cov8" title="1">{
                if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                        for _, m := range msgs </span><span class="cov0" title="0">{
                                a.log.Errorln(m)
                        }</span>
                        <span class="cov0" title="0">return "", fmt.Errorf("cannot create \"%s\": Windows filename restriction", originalAlias)</span>
                }
                <span class="cov8" title="1">for _, m := range msgs </span><span class="cov8" title="1">{
                        a.log.Infoln(m)
                }</span>
        }

        // Add the final touch
        <span class="cov8" title="1">alias = strings.TrimPrefix(alias, "/")
        if strings.HasSuffix(alias, "/") </span><span class="cov0" title="0">{
                alias = alias + "index.html"
        }</span> else<span class="cov8" title="1"> if !strings.HasSuffix(alias, ".html") </span><span class="cov8" title="1">{
                alias = alias + "/" + "index.html"
        }</span>

        <span class="cov8" title="1">return filepath.FromSlash(alias), nil</span>
}
</pre>
		
		<pre class="file" id="file104" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/gohugoio/hugo/common/collections"
        "github.com/gohugoio/hugo/resources/page"
)

var (
        _ collections.Grouper = (*pageState)(nil)
        _ collections.Slicer  = (*pageState)(nil)
)

// collections.Slicer implementations below. We keep these bridge implementations
// here as it makes it easier to get an idea of "type coverage". These
// implementations have no value on their own.

// Slice is not meant to be used externally. It's a bridge function
func (p *pageState) Slice(items interface{}) (interface{}, error) <span class="cov8" title="1">{
        return page.ToPages(items)
}</span>

// collections.Grouper  implementations below

// Group creates a PageGroup from a key and a Pages object
// This method is not meant for external use. It got its non-typed arguments to satisfy
// a very generic interface in the tpl package.
func (p *pageState) Group(key interface{}, in interface{}) (interface{}, error) <span class="cov0" title="0">{
        pages, err := page.ToPages(in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return page.PageGroup{Key: key, Pages: pages}, nil</span>
}
</pre>
		
		<pre class="file" id="file105" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "os"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/hexec"
        "github.com/gohugoio/hugo/common/types"

        "github.com/gohugoio/hugo/common/maps"
        cpaths "github.com/gohugoio/hugo/common/paths"

        "github.com/gobwas/glob"
        hglob "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/gohugoio/hugo/cache/filecache"

        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/hugolib/paths"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/modules"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/config/privacy"
        "github.com/gohugoio/hugo/config/security"
        "github.com/gohugoio/hugo/config/services"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/afero"
)

var ErrNoConfigFile = errors.New("Unable to locate config file or config directory. Perhaps you need to create a new site.\n       Run `hugo help new` for details.\n")

// LoadConfig loads Hugo configuration into a new Viper and then adds
// a set of defaults.
func LoadConfig(d ConfigSourceDescriptor, doWithConfig ...func(cfg config.Provider) error) (config.Provider, []string, error) <span class="cov8" title="1">{
        if d.Environment == "" </span><span class="cov8" title="1">{
                d.Environment = hugo.EnvironmentProduction
        }</span>

        <span class="cov8" title="1">if len(d.Environ) == 0 &amp;&amp; !hugo.IsRunningAsTest() </span><span class="cov0" title="0">{
                d.Environ = os.Environ()
        }</span>

        <span class="cov8" title="1">var configFiles []string

        l := configLoader{ConfigSourceDescriptor: d, cfg: config.New()}
        // Make sure we always do this, even in error situations,
        // as we have commands (e.g. "hugo mod init") that will
        // use a partial configuration to do its job.
        defer l.deleteMergeStrategies()

        for _, name := range d.configFilenames() </span><span class="cov8" title="1">{
                var filename string
                filename, err := l.loadConfig(name)
                if err == nil </span><span class="cov8" title="1">{
                        configFiles = append(configFiles, filename)
                }</span> else<span class="cov8" title="1"> if err != ErrNoConfigFile </span><span class="cov0" title="0">{
                        return nil, nil, err
                }</span>
        }

        <span class="cov8" title="1">if d.AbsConfigDir != "" </span><span class="cov8" title="1">{
                dcfg, dirnames, err := config.LoadConfigFromDir(l.Fs, d.AbsConfigDir, l.Environment)
                if err == nil </span><span class="cov8" title="1">{
                        if len(dirnames) &gt; 0 </span><span class="cov8" title="1">{
                                l.cfg.Set("", dcfg.Get(""))
                                configFiles = append(configFiles, dirnames...)
                        }</span>
                } else<span class="cov8" title="1"> if err != ErrNoConfigFile </span><span class="cov8" title="1">{
                        if len(dirnames) &gt; 0 </span><span class="cov8" title="1">{
                                return nil, nil, l.wrapFileError(err, dirnames[0])
                        }</span>
                        <span class="cov0" title="0">return nil, nil, err</span>
                }
        }

        <span class="cov8" title="1">if err := l.applyConfigDefaults(); err != nil </span><span class="cov0" title="0">{
                return l.cfg, configFiles, err
        }</span>

        <span class="cov8" title="1">l.cfg.SetDefaultMergeStrategy()

        // We create languages based on the settings, so we need to make sure that
        // all configuration is loaded/set before doing that.
        for _, d := range doWithConfig </span><span class="cov8" title="1">{
                if err := d(l.cfg); err != nil </span><span class="cov0" title="0">{
                        return l.cfg, configFiles, err
                }</span>
        }

        // Config deprecations.
        <span class="cov8" title="1">if l.cfg.GetString("markup.defaultMarkdownHandler") == "blackfriday" </span><span class="cov8" title="1">{
                helpers.Deprecated("markup.defaultMarkdownHandler=blackfriday", "See https://gohugo.io//content-management/formats/#list-of-content-formats", false)
        }</span>

        // Some settings are used before we're done collecting all settings,
        // so apply OS environment both before and after.
        <span class="cov8" title="1">if err := l.applyOsEnvOverrides(d.Environ); err != nil </span><span class="cov0" title="0">{
                return l.cfg, configFiles, err
        }</span>

        <span class="cov8" title="1">modulesConfig, err := l.loadModulesConfig()
        if err != nil </span><span class="cov0" title="0">{
                return l.cfg, configFiles, err
        }</span>

        // Need to run these after the modules are loaded, but before
        // they are finalized.
        <span class="cov8" title="1">collectHook := func(m *modules.ModulesConfig) error </span><span class="cov8" title="1">{
                // We don't need the merge strategy configuration anymore,
                // remove it so it doesn't accidentaly show up in other settings.
                l.deleteMergeStrategies()

                if err := l.loadLanguageSettings(nil); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">mods := m.ActiveModules

                // Apply default project mounts.
                if err := modules.ApplyProjectConfigDefaults(l.cfg, mods[0]); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">_, modulesConfigFiles, modulesCollectErr := l.collectModules(modulesConfig, l.cfg, collectHook)
        if err != nil </span><span class="cov0" title="0">{
                return l.cfg, configFiles, err
        }</span>

        <span class="cov8" title="1">configFiles = append(configFiles, modulesConfigFiles...)

        if err := l.applyOsEnvOverrides(d.Environ); err != nil </span><span class="cov0" title="0">{
                return l.cfg, configFiles, err
        }</span>

        <span class="cov8" title="1">if err = l.applyConfigAliases(); err != nil </span><span class="cov0" title="0">{
                return l.cfg, configFiles, err
        }</span>

        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                err = modulesCollectErr
        }</span>

        <span class="cov8" title="1">return l.cfg, configFiles, err</span>
}

// LoadConfigDefault is a convenience method to load the default "config.toml" config.
func LoadConfigDefault(fs afero.Fs) (config.Provider, error) <span class="cov8" title="1">{
        v, _, err := LoadConfig(ConfigSourceDescriptor{Fs: fs, Filename: "config.toml"})
        return v, err
}</span>

// ConfigSourceDescriptor describes where to find the config (e.g. config.toml etc.).
type ConfigSourceDescriptor struct {
        Fs     afero.Fs
        Logger loggers.Logger

        // Path to the config file to use, e.g. /my/project/config.toml
        Filename string

        // The path to the directory to look for configuration. Is used if Filename is not
        // set or if it is set to a relative filename.
        Path string

        // The project's working dir. Is used to look for additional theme config.
        WorkingDir string

        // The (optional) directory for additional configuration files.
        AbsConfigDir string

        // production, development
        Environment string

        // Defaults to os.Environ if not set.
        Environ []string
}

func (d ConfigSourceDescriptor) configFileDir() string <span class="cov8" title="1">{
        if d.Path != "" </span><span class="cov0" title="0">{
                return d.Path
        }</span>
        <span class="cov8" title="1">return d.WorkingDir</span>
}

func (d ConfigSourceDescriptor) configFilenames() []string <span class="cov8" title="1">{
        if d.Filename == "" </span><span class="cov8" title="1">{
                return []string{"config"}
        }</span>
        <span class="cov8" title="1">return strings.Split(d.Filename, ",")</span>
}

// SiteConfig represents the config in .Site.Config.
type SiteConfig struct {
        // This contains all privacy related settings that can be used to
        // make the YouTube template etc. GDPR compliant.
        Privacy privacy.Config

        // Services contains config for services such as Google Analytics etc.
        Services services.Config
}

type configLoader struct {
        cfg config.Provider
        ConfigSourceDescriptor
}

// Handle some legacy values.
func (l configLoader) applyConfigAliases() error <span class="cov8" title="1">{
        aliases := []types.KeyValueStr{{Key: "taxonomies", Value: "indexes"}}

        for _, alias := range aliases </span><span class="cov8" title="1">{
                if l.cfg.IsSet(alias.Key) </span><span class="cov8" title="1">{
                        vv := l.cfg.Get(alias.Key)
                        l.cfg.Set(alias.Value, vv)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (l configLoader) applyConfigDefaults() error <span class="cov8" title="1">{
        defaultSettings := maps.Params{
                "cleanDestinationDir":                  false,
                "watch":                                false,
                "resourceDir":                          "resources",
                "publishDir":                           "public",
                "themesDir":                            "themes",
                "buildDrafts":                          false,
                "buildFuture":                          false,
                "buildExpired":                         false,
                "environment":                          hugo.EnvironmentProduction,
                "uglyURLs":                             false,
                "verbose":                              false,
                "ignoreCache":                          false,
                "canonifyURLs":                         false,
                "relativeURLs":                         false,
                "removePathAccents":                    false,
                "titleCaseStyle":                       "AP",
                "taxonomies":                           maps.Params{"tag": "tags", "category": "categories"},
                "permalinks":                           maps.Params{},
                "sitemap":                              maps.Params{"priority": -1, "filename": "sitemap.xml"},
                "disableLiveReload":                    false,
                "pluralizeListTitles":                  true,
                "forceSyncStatic":                      false,
                "footnoteAnchorPrefix":                 "",
                "footnoteReturnLinkContents":           "",
                "newContentEditor":                     "",
                "paginate":                             10,
                "paginatePath":                         "page",
                "summaryLength":                        70,
                "rssLimit":                             -1,
                "sectionPagesMenu":                     "",
                "disablePathToLower":                   false,
                "hasCJKLanguage":                       false,
                "enableEmoji":                          false,
                "defaultContentLanguage":               "en",
                "defaultContentLanguageInSubdir":       false,
                "enableMissingTranslationPlaceholders": false,
                "enableGitInfo":                        false,
                "ignoreFiles":                          make([]string, 0),
                "disableAliases":                       false,
                "debug":                                false,
                "disableFastRender":                    false,
                "timeout":                              "30s",
                "enableInlineShortcodes":               false,
        }

        l.cfg.SetDefaults(defaultSettings)

        return nil
}</span>

func (l configLoader) applyOsEnvOverrides(environ []string) error <span class="cov8" title="1">{
        if len(environ) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">const delim = "__env__delim"

        // Extract all that start with the HUGO prefix.
        // The delimiter is the following rune, usually "_".
        const hugoEnvPrefix = "HUGO"
        var hugoEnv []types.KeyValueStr
        for _, v := range environ </span><span class="cov8" title="1">{
                key, val := config.SplitEnvVar(v)
                if strings.HasPrefix(key, hugoEnvPrefix) </span><span class="cov8" title="1">{
                        delimiterAndKey := strings.TrimPrefix(key, hugoEnvPrefix)
                        if len(delimiterAndKey) &lt; 2 </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        // Allow delimiters to be case sensitive.
                        // It turns out there isn't that many allowed special
                        // chars in environment variables when used in Bash and similar,
                        // so variables on the form HUGOxPARAMSxFOO=bar is one option.
                        <span class="cov8" title="1">key := strings.ReplaceAll(delimiterAndKey[1:], delimiterAndKey[:1], delim)
                        key = strings.ToLower(key)
                        hugoEnv = append(hugoEnv, types.KeyValueStr{
                                Key:   key,
                                Value: val,
                        })</span>

                }
        }

        <span class="cov8" title="1">for _, env := range hugoEnv </span><span class="cov8" title="1">{
                existing, nestedKey, owner, err := maps.GetNestedParamFn(env.Key, delim, l.cfg.Get)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if existing != nil </span><span class="cov8" title="1">{
                        val, err := metadecoders.Default.UnmarshalStringTo(env.Value, existing)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if owner != nil </span><span class="cov8" title="1">{
                                owner[nestedKey] = val
                        }</span> else<span class="cov8" title="1"> {
                                l.cfg.Set(env.Key, val)
                        }</span>
                } else<span class="cov8" title="1"> if nestedKey != "" </span><span class="cov8" title="1">{
                        owner[nestedKey] = env.Value
                }</span> else<span class="cov8" title="1"> {
                        // The container does not exist yet.
                        l.cfg.Set(strings.ReplaceAll(env.Key, delim, "."), env.Value)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (l configLoader) collectModules(modConfig modules.Config, v1 config.Provider, hookBeforeFinalize func(m *modules.ModulesConfig) error) (modules.Modules, []string, error) <span class="cov8" title="1">{
        workingDir := l.WorkingDir
        if workingDir == "" </span><span class="cov8" title="1">{
                workingDir = v1.GetString("workingDir")
        }</span>

        <span class="cov8" title="1">themesDir := paths.AbsPathify(l.WorkingDir, v1.GetString("themesDir"))

        var ignoreVendor glob.Glob
        if s := v1.GetString("ignoreVendorPaths"); s != "" </span><span class="cov0" title="0">{
                ignoreVendor, _ = hglob.GetGlob(hglob.NormalizePath(s))
        }</span>

        <span class="cov8" title="1">filecacheConfigs, err := filecache.DecodeConfig(l.Fs, v1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>

        <span class="cov8" title="1">secConfig, err := security.DecodeConfig(v1)
        if err != nil </span><span class="cov0" title="0">{
                return nil, nil, err
        }</span>
        <span class="cov8" title="1">ex := hexec.New(secConfig)

        v1.Set("filecacheConfigs", filecacheConfigs)

        var configFilenames []string

        hook := func(m *modules.ModulesConfig) error </span><span class="cov8" title="1">{
                for _, tc := range m.ActiveModules </span><span class="cov8" title="1">{
                        if len(tc.ConfigFilenames()) &gt; 0 </span><span class="cov8" title="1">{
                                if tc.Watch() </span><span class="cov8" title="1">{
                                        configFilenames = append(configFilenames, tc.ConfigFilenames()...)
                                }</span>

                                // Merge from theme config into v1 based on configured
                                // merge strategy.
                                <span class="cov8" title="1">v1.Merge("", tc.Cfg().Get(""))</span>

                        }
                }

                <span class="cov8" title="1">if hookBeforeFinalize != nil </span><span class="cov8" title="1">{
                        return hookBeforeFinalize(m)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">modulesClient := modules.NewClient(modules.ClientConfig{
                Fs:                 l.Fs,
                Logger:             l.Logger,
                Exec:               ex,
                HookBeforeFinalize: hook,
                WorkingDir:         workingDir,
                ThemesDir:          themesDir,
                Environment:        l.Environment,
                CacheDir:           filecacheConfigs.CacheDirModules(),
                ModuleConfig:       modConfig,
                IgnoreVendor:       ignoreVendor,
        })

        v1.Set("modulesClient", modulesClient)

        moduleConfig, err := modulesClient.Collect()

        // Avoid recreating these later.
        v1.Set("allModules", moduleConfig.ActiveModules)

        if moduleConfig.GoModulesFilename != "" </span><span class="cov8" title="1">{
                // We want to watch this for changes and trigger rebuild on version
                // changes etc.
                configFilenames = append(configFilenames, moduleConfig.GoModulesFilename)
        }</span>

        <span class="cov8" title="1">return moduleConfig.ActiveModules, configFilenames, err</span>
}

func (l configLoader) loadConfig(configName string) (string, error) <span class="cov8" title="1">{
        baseDir := l.configFileDir()
        var baseFilename string
        if filepath.IsAbs(configName) </span><span class="cov0" title="0">{
                baseFilename = configName
        }</span> else<span class="cov8" title="1"> {
                baseFilename = filepath.Join(baseDir, configName)
        }</span>

        <span class="cov8" title="1">var filename string
        if cpaths.ExtNoDelimiter(configName) != "" </span><span class="cov8" title="1">{
                exists, _ := helpers.Exists(baseFilename, l.Fs)
                if exists </span><span class="cov8" title="1">{
                        filename = baseFilename
                }</span>
        } else<span class="cov8" title="1"> {
                for _, ext := range config.ValidConfigFileExtensions </span><span class="cov8" title="1">{
                        filenameToCheck := baseFilename + "." + ext
                        exists, _ := helpers.Exists(filenameToCheck, l.Fs)
                        if exists </span><span class="cov8" title="1">{
                                filename = filenameToCheck
                                break</span>
                        }
                }
        }

        <span class="cov8" title="1">if filename == "" </span><span class="cov8" title="1">{
                return "", ErrNoConfigFile
        }</span>

        <span class="cov8" title="1">m, err := config.FromFileToMap(l.Fs, filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", l.wrapFileError(err, filename)
        }</span>

        // Set overwrites keys of the same name, recursively.
        <span class="cov8" title="1">l.cfg.Set("", m)

        return filename, nil</span>
}

func (l configLoader) deleteMergeStrategies() <span class="cov8" title="1">{
        l.cfg.WalkParams(func(params ...config.KeyParams) bool </span><span class="cov8" title="1">{
                params[len(params)-1].Params.DeleteMergeStrategy()
                return false
        }</span>)
}

func (l configLoader) loadLanguageSettings(oldLangs langs.Languages) error <span class="cov8" title="1">{
        _, err := langs.LoadLanguageSettings(l.cfg, oldLangs)
        return err
}</span>

func (l configLoader) loadModulesConfig() (modules.Config, error) <span class="cov8" title="1">{
        modConfig, err := modules.DecodeConfig(l.cfg)
        if err != nil </span><span class="cov0" title="0">{
                return modules.Config{}, err
        }</span>

        <span class="cov8" title="1">return modConfig, nil</span>
}

func (configLoader) loadSiteConfig(cfg config.Provider) (scfg SiteConfig, err error) <span class="cov8" title="1">{
        privacyConfig, err := privacy.DecodeConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">servicesConfig, err := services.DecodeConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">scfg.Privacy = privacyConfig
        scfg.Services = servicesConfig

        return</span>
}

func (l configLoader) wrapFileError(err error, filename string) error <span class="cov8" title="1">{
        return herrors.WithFileContextForFileDefault(err, filename, l.Fs)
}</span>
</pre>
		
		<pre class="file" id="file106" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "io"
        "path/filepath"
        "strings"
        "time"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/source"

        "github.com/gohugoio/hugo/resources/page"

        "github.com/pkg/errors"
        "github.com/spf13/afero"
)

// ContentFactory creates content files from archetype templates.
type ContentFactory struct {
        h *HugoSites

        // We parse the archetype templates as Go templates, so we need
        // to replace any shortcode with a temporary placeholder.
        shortocdeReplacerPre  *strings.Replacer
        shortocdeReplacerPost *strings.Replacer
}

// AppplyArchetypeFilename archetypeFilename to w as a template using the given Page p as the foundation for the data context.
func (f ContentFactory) AppplyArchetypeFilename(w io.Writer, p page.Page, archetypeKind, archetypeFilename string) error <span class="cov8" title="1">{

        fi, err := f.h.SourceFilesystems.Archetypes.Fs.Stat(archetypeFilename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if fi.IsDir() </span><span class="cov0" title="0">{
                return errors.Errorf("archetype directory (%q) not supported", archetypeFilename)
        }</span>

        <span class="cov8" title="1">templateSource, err := afero.ReadFile(f.h.SourceFilesystems.Archetypes.Fs, archetypeFilename)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to read archetype file %q: %s", archetypeFilename, err)

        }</span>

        <span class="cov8" title="1">return f.AppplyArchetypeTemplate(w, p, archetypeKind, string(templateSource))</span>

}

// AppplyArchetypeFilename templateSource to w as a template using the given Page p as the foundation for the data context.
func (f ContentFactory) AppplyArchetypeTemplate(w io.Writer, p page.Page, archetypeKind, templateSource string) error <span class="cov8" title="1">{
        ps := p.(*pageState)
        if archetypeKind == "" </span><span class="cov8" title="1">{
                archetypeKind = p.Type()
        }</span>

        <span class="cov8" title="1">d := &amp;archetypeFileData{
                Type: archetypeKind,
                Date: time.Now().Format(time.RFC3339),
                Page: p,
                File: p.File(),
        }

        templateSource = f.shortocdeReplacerPre.Replace(templateSource)

        templ, err := ps.s.TextTmpl().Parse("archetype.md", string(templateSource))
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to parse archetype template: %s", err)
        }</span>

        <span class="cov8" title="1">result, err := executeToString(ps.s.Tmpl(), templ, d)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to execute archetype template: %s", err)
        }</span>

        <span class="cov8" title="1">_, err = io.WriteString(w, f.shortocdeReplacerPost.Replace(result))

        return err</span>

}

func (f ContentFactory) SectionFromFilename(filename string) (string, error) <span class="cov0" title="0">{
        filename = filepath.Clean(filename)
        rel, _, err := f.h.AbsProjectContentDir(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">parts := strings.Split(helpers.ToSlashTrimLeading(rel), "/")
        if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return parts[0], nil</span>
}

// CreateContentPlaceHolder creates a content placeholder file inside the
// best matching content directory.
func (f ContentFactory) CreateContentPlaceHolder(filename string) (string, error) <span class="cov8" title="1">{
        filename = filepath.Clean(filename)
        _, abs, err := f.h.AbsProjectContentDir(filename)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // This will be overwritten later, just write a placholder to get
        // the paths correct.
        <span class="cov8" title="1">placeholder := `---
title: "Content Placeholder"
_build:
  render: never
  list: never
  publishResources: false
---

`

        return abs, afero.SafeWriteReader(f.h.Fs.Source, abs, strings.NewReader(placeholder))</span>
}

// NewContentFactory creates a new ContentFactory for h.
func NewContentFactory(h *HugoSites) ContentFactory <span class="cov8" title="1">{
        return ContentFactory{
                h: h,
                shortocdeReplacerPre: strings.NewReplacer(
                        "{{&lt;", "{x{&lt;",
                        "{{%", "{x{%",
                        "&gt;}}", "&gt;}x}",
                        "%}}", "%}x}"),
                shortocdeReplacerPost: strings.NewReplacer(
                        "{x{&lt;", "{{&lt;",
                        "{x{%", "{{%",
                        "&gt;}x}", "&gt;}}",
                        "%}x}", "%}}"),
        }
}</span>

// archetypeFileData represents the data available to an archetype template.
type archetypeFileData struct {
        // The archetype content type, either given as --kind option or extracted
        // from the target path's section, i.e. "blog/mypost.md" will resolve to
        // "blog".
        Type string

        // The current date and time as a RFC3339 formatted string, suitable for use in front matter.
        Date string

        // The temporary page. Note that only the file path information is relevant at this stage.
        Page page.Page

        // File is the same as Page.File, embedded here for historic reasons.
        // TODO(bep) make this a method.
        source.File
}

func (f *archetypeFileData) Site() page.Site <span class="cov0" title="0">{
        return f.Page.Site()
}</span>

func (f *archetypeFileData) Name() string <span class="cov8" title="1">{
        return f.Page.File().ContentBaseName()
}</span>
</pre>
		
		<pre class="file" id="file107" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "path"
        "path/filepath"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/resources/page"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/hugofs"

        radix "github.com/armon/go-radix"
)

// We store the branch nodes in either the `sections` or `taxonomies` tree
// with their path as a key; Unix style slashes, a leading and trailing slash.
//
// E.g. "/blog/" or "/categories/funny/"
//
// Pages that belongs to a section are stored in the `pages` tree below
// the section name and a branch separator, e.g. "/blog/__hb_". A page is
// given a key using the path below the section and the base filename with no extension
// with a leaf separator added.
//
// For bundled pages (/mybundle/index.md), we use the folder name.
//
// An exmple of a full page key would be "/blog/__hb_page1__hl_"
//
// Bundled resources are stored in the `resources` having their path prefixed
// with the bundle they belong to, e.g.
// "/blog/__hb_bundle__hl_data.json".
//
// The weighted taxonomy entries extracted from page front matter are stored in
// the `taxonomyEntries` tree below /plural/term/page-key, e.g.
// "/categories/funny/blog/__hb_bundle__hl_".
const (
        cmBranchSeparator = "__hb_"
        cmLeafSeparator   = "__hl_"
)

// Used to mark ambiguous keys in reverse index lookups.
var ambiguousContentNode = &amp;contentNode{}

func newContentMap(cfg contentMapConfig) *contentMap <span class="cov8" title="1">{
        m := &amp;contentMap{
                cfg:             &amp;cfg,
                pages:           &amp;contentTree{Name: "pages", Tree: radix.New()},
                sections:        &amp;contentTree{Name: "sections", Tree: radix.New()},
                taxonomies:      &amp;contentTree{Name: "taxonomies", Tree: radix.New()},
                taxonomyEntries: &amp;contentTree{Name: "taxonomyEntries", Tree: radix.New()},
                resources:       &amp;contentTree{Name: "resources", Tree: radix.New()},
        }

        m.pageTrees = []*contentTree{
                m.pages, m.sections, m.taxonomies,
        }

        m.bundleTrees = []*contentTree{
                m.pages, m.sections, m.taxonomies, m.resources,
        }

        m.branchTrees = []*contentTree{
                m.sections, m.taxonomies,
        }

        addToReverseMap := func(k string, n *contentNode, m map[interface{}]*contentNode) </span><span class="cov8" title="1">{
                k = strings.ToLower(k)
                existing, found := m[k]
                if found &amp;&amp; existing != ambiguousContentNode </span><span class="cov8" title="1">{
                        m[k] = ambiguousContentNode
                }</span> else<span class="cov8" title="1"> if !found </span><span class="cov8" title="1">{
                        m[k] = n
                }</span>
        }

        <span class="cov8" title="1">m.pageReverseIndex = &amp;contentTreeReverseIndex{
                t: []*contentTree{m.pages, m.sections, m.taxonomies},
                contentTreeReverseIndexMap: &amp;contentTreeReverseIndexMap{
                        initFn: func(t *contentTree, m map[interface{}]*contentNode) </span><span class="cov8" title="1">{
                                t.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                                        n := v.(*contentNode)
                                        if n.p != nil &amp;&amp; !n.p.File().IsZero() </span><span class="cov8" title="1">{
                                                meta := n.p.File().FileInfo().Meta()
                                                if meta.Path != meta.PathFile() </span><span class="cov8" title="1">{
                                                        // Keep track of the original mount source.
                                                        mountKey := filepath.ToSlash(filepath.Join(meta.Module, meta.PathFile()))
                                                        addToReverseMap(mountKey, n, m)
                                                }</span>
                                        }
                                        <span class="cov8" title="1">k := strings.TrimPrefix(strings.TrimSuffix(path.Base(s), cmLeafSeparator), cmBranchSeparator)
                                        addToReverseMap(k, n, m)
                                        return false</span>
                                })
                        },
                },
        }

        <span class="cov8" title="1">return m</span>
}

type cmInsertKeyBuilder struct {
        m *contentMap

        err error

        // Builder state
        tree    *contentTree
        baseKey string // Section or page key
        key     string
}

func (b cmInsertKeyBuilder) ForPage(s string) *cmInsertKeyBuilder <span class="cov8" title="1">{
        // fmt.Println("ForPage:", s, "baseKey:", b.baseKey, "key:", b.key)
        baseKey := b.baseKey
        b.baseKey = s

        if baseKey != "/" </span><span class="cov8" title="1">{
                // Don't repeat the section path in the key.
                s = strings.TrimPrefix(s, baseKey)
        }</span>
        <span class="cov8" title="1">s = strings.TrimPrefix(s, "/")

        switch b.tree </span>{
        case b.m.sections:<span class="cov8" title="1">
                b.tree = b.m.pages
                b.key = baseKey + cmBranchSeparator + s + cmLeafSeparator</span>
        case b.m.taxonomies:<span class="cov0" title="0">
                b.key = path.Join(baseKey, s)</span>
        default:<span class="cov0" title="0">
                panic("invalid state")</span>
        }

        <span class="cov8" title="1">return &amp;b</span>
}

func (b cmInsertKeyBuilder) ForResource(s string) *cmInsertKeyBuilder <span class="cov8" title="1">{
        // fmt.Println("ForResource:", s, "baseKey:", b.baseKey, "key:", b.key)

        baseKey := helpers.AddTrailingSlash(b.baseKey)
        s = strings.TrimPrefix(s, baseKey)

        switch b.tree </span>{
        case b.m.pages:<span class="cov8" title="1">
                b.key = b.key + s</span>
        case b.m.sections, b.m.taxonomies:<span class="cov8" title="1">
                b.key = b.key + cmLeafSeparator + s</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("invalid state: %#v", b.tree))</span>
        }
        <span class="cov8" title="1">b.tree = b.m.resources
        return &amp;b</span>
}

func (b *cmInsertKeyBuilder) Insert(n *contentNode) *cmInsertKeyBuilder <span class="cov8" title="1">{
        if b.err == nil </span><span class="cov8" title="1">{
                b.tree.Insert(b.Key(), n)
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (b *cmInsertKeyBuilder) Key() string <span class="cov8" title="1">{
        switch b.tree </span>{
        case b.m.sections, b.m.taxonomies:<span class="cov8" title="1">
                return cleanSectionTreeKey(b.key)</span>
        default:<span class="cov8" title="1">
                return cleanTreeKey(b.key)</span>
        }
}

func (b *cmInsertKeyBuilder) DeleteAll() *cmInsertKeyBuilder <span class="cov8" title="1">{
        if b.err == nil </span><span class="cov8" title="1">{
                b.tree.DeletePrefix(b.Key())
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (b *cmInsertKeyBuilder) WithFile(fi hugofs.FileMetaInfo) *cmInsertKeyBuilder <span class="cov8" title="1">{
        b.newTopLevel()
        m := b.m
        meta := fi.Meta()
        p := cleanTreeKey(meta.Path)
        bundlePath := m.getBundleDir(meta)
        isBundle := meta.Classifier.IsBundle()
        if isBundle </span><span class="cov0" title="0">{
                panic("not implemented")</span>
        }

        <span class="cov8" title="1">p, k := b.getBundle(p)
        if k == "" </span><span class="cov0" title="0">{
                b.err = errors.Errorf("no bundle header found for %q", bundlePath)
                return b
        }</span>

        <span class="cov8" title="1">id := k + m.reduceKeyPart(p, fi.Meta().Path)
        b.tree = b.m.resources
        b.key = id
        b.baseKey = p

        return b</span>
}

func (b *cmInsertKeyBuilder) WithSection(s string) *cmInsertKeyBuilder <span class="cov8" title="1">{
        s = cleanSectionTreeKey(s)
        b.newTopLevel()
        b.tree = b.m.sections
        b.baseKey = s
        b.key = s
        return b
}</span>

func (b *cmInsertKeyBuilder) WithTaxonomy(s string) *cmInsertKeyBuilder <span class="cov8" title="1">{
        s = cleanSectionTreeKey(s)
        b.newTopLevel()
        b.tree = b.m.taxonomies
        b.baseKey = s
        b.key = s
        return b
}</span>

// getBundle gets both the key to the section and the prefix to where to store
// this page bundle and its resources.
func (b *cmInsertKeyBuilder) getBundle(s string) (string, string) <span class="cov8" title="1">{
        m := b.m
        section, _ := m.getSection(s)

        p := strings.TrimPrefix(s, section)

        bundlePathParts := strings.Split(p, "/")
        basePath := section + cmBranchSeparator

        // Put it into an existing bundle if found.
        for i := len(bundlePathParts) - 2; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                bundlePath := path.Join(bundlePathParts[:i]...)
                searchKey := basePath + bundlePath + cmLeafSeparator
                if _, found := m.pages.Get(searchKey); found </span><span class="cov8" title="1">{
                        return section + bundlePath, searchKey
                }</span>
        }

        // Put it into the section bundle.
        <span class="cov8" title="1">return section, section + cmLeafSeparator</span>
}

func (b *cmInsertKeyBuilder) newTopLevel() <span class="cov8" title="1">{
        b.key = ""
}</span>

type contentBundleViewInfo struct {
        ordinal    int
        name       viewName
        termKey    string
        termOrigin string
        weight     int
        ref        *contentNode
}

func (c *contentBundleViewInfo) kind() string <span class="cov8" title="1">{
        if c.termKey != "" </span><span class="cov8" title="1">{
                return page.KindTerm
        }</span>
        <span class="cov8" title="1">return page.KindTaxonomy</span>
}

func (c *contentBundleViewInfo) sections() []string <span class="cov8" title="1">{
        if c.kind() == page.KindTaxonomy </span><span class="cov8" title="1">{
                return []string{c.name.plural}
        }</span>

        <span class="cov8" title="1">return []string{c.name.plural, c.termKey}</span>
}

func (c *contentBundleViewInfo) term() string <span class="cov8" title="1">{
        if c.termOrigin != "" </span><span class="cov8" title="1">{
                return c.termOrigin
        }</span>

        <span class="cov0" title="0">return c.termKey</span>
}

type contentMap struct {
        cfg *contentMapConfig

        // View of regular pages, sections, and taxonomies.
        pageTrees contentTrees

        // View of pages, sections, taxonomies, and resources.
        bundleTrees contentTrees

        // View of sections and taxonomies.
        branchTrees contentTrees

        // Stores page bundles keyed by its path's directory or the base filename,
        // e.g. "blog/post.md" =&gt; "/blog/post", "blog/post/index.md" =&gt; "/blog/post"
        // These are the "regular pages" and all of them are bundles.
        pages *contentTree

        // A reverse index used as a fallback in GetPage.
        // There are currently two cases where this is used:
        // 1. Short name lookups in ref/relRef, e.g. using only "mypage.md" without a path.
        // 2. Links resolved from a remounted content directory. These are restricted to the same module.
        // Both of the above cases can  result in ambigous lookup errors.
        pageReverseIndex *contentTreeReverseIndex

        // Section nodes.
        sections *contentTree

        // Taxonomy nodes.
        taxonomies *contentTree

        // Pages in a taxonomy.
        taxonomyEntries *contentTree

        // Resources stored per bundle below a common prefix, e.g. "/blog/post__hb_".
        resources *contentTree
}

func (m *contentMap) AddFiles(fis ...hugofs.FileMetaInfo) error <span class="cov8" title="1">{
        for _, fi := range fis </span><span class="cov8" title="1">{
                if err := m.addFile(fi); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m *contentMap) AddFilesBundle(header hugofs.FileMetaInfo, resources ...hugofs.FileMetaInfo) error <span class="cov8" title="1">{
        var (
                meta       = header.Meta()
                classifier = meta.Classifier
                isBranch   = classifier == files.ContentClassBranch
                bundlePath = m.getBundleDir(meta)

                n = m.newContentNodeFromFi(header)
                b = m.newKeyBuilder()

                section string
        )

        if isBranch </span><span class="cov8" title="1">{
                // Either a section or a taxonomy node.
                section = bundlePath
                if tc := m.cfg.getTaxonomyConfig(section); !tc.IsZero() </span><span class="cov8" title="1">{
                        term := strings.TrimPrefix(strings.TrimPrefix(section, "/"+tc.plural), "/")

                        n.viewInfo = &amp;contentBundleViewInfo{
                                name:       tc,
                                termKey:    term,
                                termOrigin: term,
                        }

                        n.viewInfo.ref = n
                        b.WithTaxonomy(section).Insert(n)
                }</span> else<span class="cov8" title="1"> {
                        b.WithSection(section).Insert(n)
                }</span>
        } else<span class="cov8" title="1"> {
                // A regular page. Attach it to its section.
                section, _ = m.getOrCreateSection(n, bundlePath)
                b = b.WithSection(section).ForPage(bundlePath).Insert(n)
        }</span>

        <span class="cov8" title="1">if m.cfg.isRebuild </span><span class="cov8" title="1">{
                // The resource owner will be either deleted or overwritten on rebuilds,
                // but make sure we handle deletion of resources (images etc.) as well.
                b.ForResource("").DeleteAll()
        }</span>

        <span class="cov8" title="1">for _, r := range resources </span><span class="cov8" title="1">{
                rb := b.ForResource(cleanTreeKey(r.Meta().Path))
                rb.Insert(&amp;contentNode{fi: r})
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *contentMap) CreateMissingNodes() error <span class="cov8" title="1">{
        // Create missing home and root sections
        rootSections := make(map[string]interface{})
        trackRootSection := func(s string, b *contentNode) </span><span class="cov8" title="1">{
                parts := strings.Split(s, "/")
                if len(parts) &gt; 2 </span><span class="cov8" title="1">{
                        root := strings.TrimSuffix(parts[1], cmBranchSeparator)
                        if root != "" </span><span class="cov8" title="1">{
                                if _, found := rootSections[root]; !found </span><span class="cov8" title="1">{
                                        rootSections[root] = b
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">m.sections.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                n := v.(*contentNode)

                if s == "/" </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">trackRootSection(s, n)
                return false</span>
        })

        <span class="cov8" title="1">m.pages.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                trackRootSection(s, v.(*contentNode))
                return false
        }</span>)

        <span class="cov8" title="1">if _, found := rootSections["/"]; !found </span><span class="cov8" title="1">{
                rootSections["/"] = true
        }</span>

        <span class="cov8" title="1">for sect, v := range rootSections </span><span class="cov8" title="1">{
                var sectionPath string
                if n, ok := v.(*contentNode); ok &amp;&amp; n.path != "" </span><span class="cov8" title="1">{
                        sectionPath = n.path
                        firstSlash := strings.Index(sectionPath, "/")
                        if firstSlash != -1 </span><span class="cov8" title="1">{
                                sectionPath = sectionPath[:firstSlash]
                        }</span>
                }
                <span class="cov8" title="1">sect = cleanSectionTreeKey(sect)
                _, found := m.sections.Get(sect)
                if !found </span><span class="cov8" title="1">{
                        m.sections.Insert(sect, &amp;contentNode{path: sectionPath})
                }</span>
        }

        <span class="cov8" title="1">for _, view := range m.cfg.taxonomyConfig </span><span class="cov8" title="1">{
                s := cleanSectionTreeKey(view.plural)
                _, found := m.taxonomies.Get(s)
                if !found </span><span class="cov8" title="1">{
                        b := &amp;contentNode{
                                viewInfo: &amp;contentBundleViewInfo{
                                        name: view,
                                },
                        }
                        b.viewInfo.ref = b
                        m.taxonomies.Insert(s, b)
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (m *contentMap) getBundleDir(meta *hugofs.FileMeta) string <span class="cov8" title="1">{
        dir := cleanTreeKey(filepath.Dir(meta.Path))

        switch meta.Classifier </span>{
        case files.ContentClassContent:<span class="cov8" title="1">
                return path.Join(dir, meta.TranslationBaseName)</span>
        default:<span class="cov8" title="1">
                return dir</span>
        }
}

func (m *contentMap) newContentNodeFromFi(fi hugofs.FileMetaInfo) *contentNode <span class="cov8" title="1">{
        return &amp;contentNode{
                fi:   fi,
                path: strings.TrimPrefix(filepath.ToSlash(fi.Meta().Path), "/"),
        }
}</span>

func (m *contentMap) getFirstSection(s string) (string, *contentNode) <span class="cov8" title="1">{
        s = helpers.AddTrailingSlash(s)
        for </span><span class="cov8" title="1">{
                k, v, found := m.sections.LongestPrefix(s)

                if !found </span><span class="cov0" title="0">{
                        return "", nil
                }</span>

                <span class="cov8" title="1">if strings.Count(k, "/") &lt;= 2 </span><span class="cov8" title="1">{
                        return k, v.(*contentNode)
                }</span>

                <span class="cov8" title="1">s = helpers.AddTrailingSlash(path.Dir(strings.TrimSuffix(s, "/")))</span>

        }
}

func (m *contentMap) newKeyBuilder() *cmInsertKeyBuilder <span class="cov8" title="1">{
        return &amp;cmInsertKeyBuilder{m: m}
}</span>

func (m *contentMap) getOrCreateSection(n *contentNode, s string) (string, *contentNode) <span class="cov8" title="1">{
        level := strings.Count(s, "/")
        k, b := m.getSection(s)

        mustCreate := false

        if k == "" </span><span class="cov8" title="1">{
                mustCreate = true
        }</span> else<span class="cov8" title="1"> if level &gt; 1 &amp;&amp; k == "/" </span><span class="cov8" title="1">{
                // We found the home section, but this page needs to be placed in
                // the root, e.g. "/blog", section.
                mustCreate = true
        }</span>

        <span class="cov8" title="1">if mustCreate </span><span class="cov8" title="1">{
                k = cleanSectionTreeKey(s[:strings.Index(s[1:], "/")+1])

                b = &amp;contentNode{
                        path: n.rootSection(),
                }

                m.sections.Insert(k, b)
        }</span>

        <span class="cov8" title="1">return k, b</span>
}

func (m *contentMap) getPage(section, name string) *contentNode <span class="cov8" title="1">{
        section = helpers.AddTrailingSlash(section)
        key := section + cmBranchSeparator + name + cmLeafSeparator

        v, found := m.pages.Get(key)
        if found </span><span class="cov8" title="1">{
                return v.(*contentNode)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *contentMap) getSection(s string) (string, *contentNode) <span class="cov8" title="1">{
        s = helpers.AddTrailingSlash(path.Dir(strings.TrimSuffix(s, "/")))

        k, v, found := m.sections.LongestPrefix(s)

        if found </span><span class="cov8" title="1">{
                return k, v.(*contentNode)
        }</span>
        <span class="cov8" title="1">return "", nil</span>
}

func (m *contentMap) getTaxonomyParent(s string) (string, *contentNode) <span class="cov8" title="1">{
        s = helpers.AddTrailingSlash(path.Dir(strings.TrimSuffix(s, "/")))
        k, v, found := m.taxonomies.LongestPrefix(s)

        if found </span><span class="cov8" title="1">{
                return k, v.(*contentNode)
        }</span>

        <span class="cov8" title="1">v, found = m.sections.Get("/")
        if found </span><span class="cov8" title="1">{
                return s, v.(*contentNode)
        }</span>

        <span class="cov0" title="0">return "", nil</span>
}

func (m *contentMap) addFile(fi hugofs.FileMetaInfo) error <span class="cov8" title="1">{
        b := m.newKeyBuilder()
        return b.WithFile(fi).Insert(m.newContentNodeFromFi(fi)).err
}</span>

func cleanTreeKey(k string) string <span class="cov8" title="1">{
        k = "/" + strings.ToLower(strings.Trim(path.Clean(filepath.ToSlash(k)), "./"))
        return k
}</span>

func cleanSectionTreeKey(k string) string <span class="cov8" title="1">{
        k = cleanTreeKey(k)
        if k != "/" </span><span class="cov8" title="1">{
                k += "/"
        }</span>

        <span class="cov8" title="1">return k</span>
}

func (m *contentMap) onSameLevel(s1, s2 string) bool <span class="cov8" title="1">{
        return strings.Count(s1, "/") == strings.Count(s2, "/")
}</span>

func (m *contentMap) deleteBundleMatching(matches func(b *contentNode) bool) <span class="cov8" title="1">{
        // Check sections first
        s := m.sections.getMatch(matches)
        if s != "" </span><span class="cov0" title="0">{
                m.deleteSectionByPath(s)
                return
        }</span>

        <span class="cov8" title="1">s = m.pages.getMatch(matches)
        if s != "" </span><span class="cov8" title="1">{
                m.deletePage(s)
                return
        }</span>

        <span class="cov8" title="1">s = m.resources.getMatch(matches)
        if s != "" </span><span class="cov0" title="0">{
                m.resources.Delete(s)
        }</span>
}

// Deletes any empty root section that's not backed by a content file.
func (m *contentMap) deleteOrphanSections() <span class="cov8" title="1">{
        var sectionsToDelete []string

        m.sections.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                n := v.(*contentNode)

                if n.fi != nil </span><span class="cov8" title="1">{
                        // Section may be empty, but is backed by a content file.
                        return false
                }</span>

                <span class="cov8" title="1">if s == "/" || strings.Count(s, "/") &gt; 2 </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">prefixBundle := s + cmBranchSeparator

                if !(m.sections.hasBelow(s) || m.pages.hasBelow(prefixBundle) || m.resources.hasBelow(prefixBundle)) </span><span class="cov8" title="1">{
                        sectionsToDelete = append(sectionsToDelete, s)
                }</span>

                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">for _, s := range sectionsToDelete </span><span class="cov8" title="1">{
                m.sections.Delete(s)
        }</span>
}

func (m *contentMap) deletePage(s string) <span class="cov8" title="1">{
        m.pages.DeletePrefix(s)
        m.resources.DeletePrefix(s)
}</span>

func (m *contentMap) deleteSectionByPath(s string) <span class="cov8" title="1">{
        if !strings.HasSuffix(s, "/") </span><span class="cov0" title="0">{
                panic("section must end with a slash")</span>
        }
        <span class="cov8" title="1">if !strings.HasPrefix(s, "/") </span><span class="cov0" title="0">{
                panic("section must start with a slash")</span>
        }
        <span class="cov8" title="1">m.sections.DeletePrefix(s)
        m.pages.DeletePrefix(s)
        m.resources.DeletePrefix(s)</span>
}

func (m *contentMap) deletePageByPath(s string) <span class="cov0" title="0">{
        m.pages.Walk(func(s string, v interface{}) bool </span><span class="cov0" title="0">{
                fmt.Println("S", s)

                return false
        }</span>)
}

func (m *contentMap) deleteTaxonomy(s string) <span class="cov8" title="1">{
        m.taxonomies.DeletePrefix(s)
}</span>

func (m *contentMap) reduceKeyPart(dir, filename string) string <span class="cov8" title="1">{
        dir, filename = filepath.ToSlash(dir), filepath.ToSlash(filename)
        dir, filename = strings.TrimPrefix(dir, "/"), strings.TrimPrefix(filename, "/")

        return strings.TrimPrefix(strings.TrimPrefix(filename, dir), "/")
}</span>

func (m *contentMap) splitKey(k string) []string <span class="cov8" title="1">{
        if k == "" || k == "/" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return strings.Split(k, "/")[1:]</span>
}

func (m *contentMap) testDump() string <span class="cov8" title="1">{
        var sb strings.Builder

        for i, r := range []*contentTree{m.pages, m.sections, m.resources} </span><span class="cov8" title="1">{
                sb.WriteString(fmt.Sprintf("Tree %d:\n", i))
                r.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                        sb.WriteString("\t" + s + "\n")
                        return false
                }</span>)
        }

        <span class="cov8" title="1">for i, r := range []*contentTree{m.pages, m.sections} </span><span class="cov8" title="1">{
                r.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                        c := v.(*contentNode)
                        cpToString := func(c *contentNode) string </span><span class="cov8" title="1">{
                                var sb strings.Builder
                                if c.p != nil </span><span class="cov0" title="0">{
                                        sb.WriteString("|p:" + c.p.Title())
                                }</span>
                                <span class="cov8" title="1">if c.fi != nil </span><span class="cov8" title="1">{
                                        sb.WriteString("|f:" + filepath.ToSlash(c.fi.Meta().Path))
                                }</span>
                                <span class="cov8" title="1">return sb.String()</span>
                        }
                        <span class="cov8" title="1">sb.WriteString(path.Join(m.cfg.lang, r.Name) + s + cpToString(c) + "\n")

                        resourcesPrefix := s

                        if i == 1 </span><span class="cov8" title="1">{
                                resourcesPrefix += cmLeafSeparator

                                m.pages.WalkPrefix(s+cmBranchSeparator, func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                                        sb.WriteString("\t - P: " + filepath.ToSlash((v.(*contentNode).fi.(hugofs.FileMetaInfo)).Meta().Filename) + "\n")
                                        return false
                                }</span>)
                        }

                        <span class="cov8" title="1">m.resources.WalkPrefix(resourcesPrefix, func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                                sb.WriteString("\t - R: " + filepath.ToSlash((v.(*contentNode).fi.(hugofs.FileMetaInfo)).Meta().Filename) + "\n")
                                return false
                        }</span>)

                        <span class="cov8" title="1">return false</span>
                })
        }

        <span class="cov8" title="1">return sb.String()</span>
}

type contentMapConfig struct {
        lang                 string
        taxonomyConfig       []viewName
        taxonomyDisabled     bool
        taxonomyTermDisabled bool
        pageDisabled         bool
        isRebuild            bool
}

func (cfg contentMapConfig) getTaxonomyConfig(s string) (v viewName) <span class="cov8" title="1">{
        s = strings.TrimPrefix(s, "/")
        if s == "" </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for _, n := range cfg.taxonomyConfig </span><span class="cov8" title="1">{
                if strings.HasPrefix(s, n.plural) </span><span class="cov8" title="1">{
                        return n
                }</span>
        }

        <span class="cov8" title="1">return</span>
}

type contentNode struct {
        p *pageState

        // Set for taxonomy nodes.
        viewInfo *contentBundleViewInfo

        // Set if source is a file.
        // We will soon get other sources.
        fi hugofs.FileMetaInfo

        // The source path. Unix slashes. No leading slash.
        path string
}

func (b *contentNode) rootSection() string <span class="cov8" title="1">{
        if b.path == "" </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">firstSlash := strings.Index(b.path, "/")
        if firstSlash == -1 </span><span class="cov8" title="1">{
                return b.path
        }</span>
        <span class="cov8" title="1">return b.path[:firstSlash]</span>
}

type contentTree struct {
        Name string
        *radix.Tree
}

type contentTrees []*contentTree

func (t contentTrees) DeletePrefix(prefix string) int <span class="cov8" title="1">{
        var count int
        for _, tree := range t </span><span class="cov8" title="1">{
                tree.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                        return false
                }</span>)
                <span class="cov8" title="1">count += tree.DeletePrefix(prefix)</span>
        }
        <span class="cov8" title="1">return count</span>
}

type contentTreeNodeCallback func(s string, n *contentNode) bool

func newContentTreeFilter(fn func(n *contentNode) bool) contentTreeNodeCallback <span class="cov8" title="1">{
        return func(s string, n *contentNode) bool </span><span class="cov8" title="1">{
                return fn(n)
        }</span>
}

var (
        contentTreeNoListAlwaysFilter = func(s string, n *contentNode) bool <span class="cov8" title="1">{
                if n.p == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">return n.p.m.noListAlways()</span>
        }

        contentTreeNoRenderFilter = func(s string, n *contentNode) bool <span class="cov8" title="1">{
                if n.p == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">return n.p.m.noRender()</span>
        }

        contentTreeNoLinkFilter = func(s string, n *contentNode) bool <span class="cov8" title="1">{
                if n.p == nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">return n.p.m.noLink()</span>
        }
)

func (c *contentTree) WalkQuery(query pageMapQuery, walkFn contentTreeNodeCallback) <span class="cov8" title="1">{
        filter := query.Filter
        if filter == nil </span><span class="cov8" title="1">{
                filter = contentTreeNoListAlwaysFilter
        }</span>
        <span class="cov8" title="1">if query.Prefix != "" </span><span class="cov8" title="1">{
                c.WalkBelow(query.Prefix, func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                        n := v.(*contentNode)
                        if filter != nil &amp;&amp; filter(s, n) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">return walkFn(s, n)</span>
                })

                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">c.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                n := v.(*contentNode)
                if filter != nil &amp;&amp; filter(s, n) </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">return walkFn(s, n)</span>
        })
}

func (c contentTrees) WalkRenderable(fn contentTreeNodeCallback) <span class="cov8" title="1">{
        query := pageMapQuery{Filter: contentTreeNoRenderFilter}
        for _, tree := range c </span><span class="cov8" title="1">{
                tree.WalkQuery(query, fn)
        }</span>
}

func (c contentTrees) WalkLinkable(fn contentTreeNodeCallback) <span class="cov8" title="1">{
        query := pageMapQuery{Filter: contentTreeNoLinkFilter}
        for _, tree := range c </span><span class="cov8" title="1">{
                tree.WalkQuery(query, fn)
        }</span>
}

func (c contentTrees) Walk(fn contentTreeNodeCallback) <span class="cov8" title="1">{
        for _, tree := range c </span><span class="cov8" title="1">{
                tree.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                        n := v.(*contentNode)
                        return fn(s, n)
                }</span>)
        }
}

func (c contentTrees) WalkPrefix(prefix string, fn contentTreeNodeCallback) <span class="cov8" title="1">{
        for _, tree := range c </span><span class="cov8" title="1">{
                tree.WalkPrefix(prefix, func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                        n := v.(*contentNode)
                        return fn(s, n)
                }</span>)
        }
}

// WalkBelow walks the tree below the given prefix, i.e. it skips the
// node with the given prefix as key.
func (c *contentTree) WalkBelow(prefix string, fn radix.WalkFn) <span class="cov8" title="1">{
        c.Tree.WalkPrefix(prefix, func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                if s == prefix </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">return fn(s, v)</span>
        })
}

func (c *contentTree) getMatch(matches func(b *contentNode) bool) string <span class="cov8" title="1">{
        var match string
        c.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                n, ok := v.(*contentNode)
                if !ok </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">if matches(n) </span><span class="cov8" title="1">{
                        match = s
                        return true
                }</span>

                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">return match</span>
}

func (c *contentTree) hasBelow(s1 string) bool <span class="cov8" title="1">{
        var t bool
        c.WalkBelow(s1, func(s2 string, v interface{}) bool </span><span class="cov8" title="1">{
                t = true
                return true
        }</span>)
        <span class="cov8" title="1">return t</span>
}

func (c *contentTree) printKeys() <span class="cov0" title="0">{
        c.Walk(func(s string, v interface{}) bool </span><span class="cov0" title="0">{
                fmt.Println(s)
                return false
        }</span>)
}

func (c *contentTree) printKeysPrefix(prefix string) <span class="cov0" title="0">{
        c.WalkPrefix(prefix, func(s string, v interface{}) bool </span><span class="cov0" title="0">{
                fmt.Println(s)
                return false
        }</span>)
}

// contentTreeRef points to a node in the given tree.
type contentTreeRef struct {
        m   *pageMap
        t   *contentTree
        n   *contentNode
        key string
}

func (c *contentTreeRef) getCurrentSection() (string, *contentNode) <span class="cov8" title="1">{
        if c.isSection() </span><span class="cov8" title="1">{
                return c.key, c.n
        }</span>
        <span class="cov8" title="1">return c.getSection()</span>
}

func (c *contentTreeRef) isSection() bool <span class="cov8" title="1">{
        return c.t == c.m.sections
}</span>

func (c *contentTreeRef) getSection() (string, *contentNode) <span class="cov8" title="1">{
        if c.t == c.m.taxonomies </span><span class="cov8" title="1">{
                return c.m.getTaxonomyParent(c.key)
        }</span>
        <span class="cov8" title="1">return c.m.getSection(c.key)</span>
}

func (c *contentTreeRef) getPages() page.Pages <span class="cov8" title="1">{
        var pas page.Pages
        c.m.collectPages(
                pageMapQuery{
                        Prefix: c.key + cmBranchSeparator,
                        Filter: c.n.p.m.getListFilter(true),
                },
                func(c *contentNode) </span><span class="cov8" title="1">{
                        pas = append(pas, c.p)
                }</span>,
        )
        <span class="cov8" title="1">page.SortByDefault(pas)

        return pas</span>
}

func (c *contentTreeRef) getPagesRecursive() page.Pages <span class="cov8" title="1">{
        var pas page.Pages

        query := pageMapQuery{
                Filter: c.n.p.m.getListFilter(true),
        }

        query.Prefix = c.key
        c.m.collectPages(query, func(c *contentNode) </span><span class="cov8" title="1">{
                pas = append(pas, c.p)
        }</span>)

        <span class="cov8" title="1">page.SortByDefault(pas)

        return pas</span>
}

func (c *contentTreeRef) getPagesAndSections() page.Pages <span class="cov8" title="1">{
        var pas page.Pages

        query := pageMapQuery{
                Filter: c.n.p.m.getListFilter(true),
                Prefix: c.key,
        }

        c.m.collectPagesAndSections(query, func(c *contentNode) </span><span class="cov8" title="1">{
                pas = append(pas, c.p)
        }</span>)

        <span class="cov8" title="1">page.SortByDefault(pas)

        return pas</span>
}

func (c *contentTreeRef) getSections() page.Pages <span class="cov8" title="1">{
        var pas page.Pages

        query := pageMapQuery{
                Filter: c.n.p.m.getListFilter(true),
                Prefix: c.key,
        }

        c.m.collectSections(query, func(c *contentNode) </span><span class="cov8" title="1">{
                pas = append(pas, c.p)
        }</span>)

        <span class="cov8" title="1">page.SortByDefault(pas)

        return pas</span>
}

type contentTreeReverseIndex struct {
        t []*contentTree
        *contentTreeReverseIndexMap
}

type contentTreeReverseIndexMap struct {
        m      map[interface{}]*contentNode
        init   sync.Once
        initFn func(*contentTree, map[interface{}]*contentNode)
}

func (c *contentTreeReverseIndex) Reset() <span class="cov8" title="1">{
        c.contentTreeReverseIndexMap = &amp;contentTreeReverseIndexMap{
                initFn: c.initFn,
        }
}</span>

func (c *contentTreeReverseIndex) Get(key interface{}) *contentNode <span class="cov8" title="1">{
        c.init.Do(func() </span><span class="cov8" title="1">{
                c.m = make(map[interface{}]*contentNode)
                for _, tree := range c.t </span><span class="cov8" title="1">{
                        c.initFn(tree, c.m)
                }</span>
        })
        <span class="cov8" title="1">return c.m[key]</span>
}
</pre>
		
		<pre class="file" id="file108" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "context"
        "fmt"
        "path"
        "path/filepath"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/resources"

        "github.com/gohugoio/hugo/common/hugio"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/hugofs/files"
        "github.com/gohugoio/hugo/parser/pageparser"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/common/para"
        "github.com/pkg/errors"
)

func newPageMaps(h *HugoSites) *pageMaps <span class="cov8" title="1">{
        mps := make([]*pageMap, len(h.Sites))
        for i, s := range h.Sites </span><span class="cov8" title="1">{
                mps[i] = s.pageMap
        }</span>
        <span class="cov8" title="1">return &amp;pageMaps{
                workers: para.New(h.numWorkers),
                pmaps:   mps,
        }</span>
}

type pageMap struct {
        s *Site
        *contentMap
}

func (m *pageMap) Len() int <span class="cov0" title="0">{
        l := 0
        for _, t := range m.contentMap.pageTrees </span><span class="cov0" title="0">{
                l += t.Len()
        }</span>
        <span class="cov0" title="0">return l</span>
}

func (m *pageMap) createMissingTaxonomyNodes() error <span class="cov8" title="1">{
        if m.cfg.taxonomyDisabled </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">m.taxonomyEntries.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                n := v.(*contentNode)
                vi := n.viewInfo
                k := cleanSectionTreeKey(vi.name.plural + "/" + vi.termKey)

                if _, found := m.taxonomies.Get(k); !found </span><span class="cov8" title="1">{
                        vic := &amp;contentBundleViewInfo{
                                name:       vi.name,
                                termKey:    vi.termKey,
                                termOrigin: vi.termOrigin,
                        }
                        m.taxonomies.Insert(k, &amp;contentNode{viewInfo: vic})
                }</span>
                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">return nil</span>
}

func (m *pageMap) newPageFromContentNode(n *contentNode, parentBucket *pagesMapBucket, owner *pageState) (*pageState, error) <span class="cov8" title="1">{
        if n.fi == nil </span><span class="cov0" title="0">{
                panic("FileInfo must (currently) be set")</span>
        }

        <span class="cov8" title="1">f, err := newFileInfo(m.s.SourceSpec, n.fi)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">meta := n.fi.Meta()
        content := func() (hugio.ReadSeekCloser, error) </span><span class="cov8" title="1">{
                return meta.Open()
        }</span>

        <span class="cov8" title="1">bundled := owner != nil
        s := m.s

        sections := s.sectionsFromFile(f)

        kind := s.kindFromFileInfoOrSections(f, sections)
        if kind == page.KindTerm </span><span class="cov8" title="1">{
                s.PathSpec.MakePathsSanitized(sections)
        }</span>

        <span class="cov8" title="1">metaProvider := &amp;pageMeta{kind: kind, sections: sections, bundled: bundled, s: s, f: f}

        ps, err := newPageBase(metaProvider)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if n.fi.Meta().IsRootFile </span><span class="cov8" title="1">{
                // Make sure that the bundle/section we start walking from is always
                // rendered.
                // This is only relevant in server fast render mode.
                ps.forceRender = true
        }</span>

        <span class="cov8" title="1">n.p = ps
        if ps.IsNode() </span><span class="cov8" title="1">{
                ps.bucket = newPageBucket(ps)
        }</span>

        <span class="cov8" title="1">gi, err := s.h.gitInfoForPage(ps)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to load Git data")
        }</span>
        <span class="cov8" title="1">ps.gitInfo = gi

        r, err := content()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">defer r.Close()

        parseResult, err := pageparser.Parse(
                r,
                pageparser.Config{EnableEmoji: s.siteCfg.enableEmoji},
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ps.pageContent = pageContent{
                source: rawPageContent{
                        parsed:         parseResult,
                        posMainContent: -1,
                        posSummaryEnd:  -1,
                        posBodyStart:   -1,
                },
        }

        ps.shortcodeState = newShortcodeHandler(ps, ps.s, nil)

        if err := ps.mapContent(parentBucket, metaProvider); err != nil </span><span class="cov8" title="1">{
                return nil, ps.wrapError(err)
        }</span>

        <span class="cov8" title="1">if err := metaProvider.applyDefaultValues(n); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ps.init.Add(func() (interface{}, error) </span><span class="cov8" title="1">{
                pp, err := newPagePaths(s, ps, metaProvider)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">outputFormatsForPage := ps.m.outputFormats()

                // Prepare output formats for all sites.
                // We do this even if this page does not get rendered on
                // its own. It may be referenced via .Site.GetPage and
                // it will then need an output format.
                ps.pageOutputs = make([]*pageOutput, len(ps.s.h.renderFormats))
                created := make(map[string]*pageOutput)
                shouldRenderPage := !ps.m.noRender()

                for i, f := range ps.s.h.renderFormats </span><span class="cov8" title="1">{
                        if po, found := created[f.Name]; found </span><span class="cov8" title="1">{
                                ps.pageOutputs[i] = po
                                continue</span>
                        }

                        <span class="cov8" title="1">render := shouldRenderPage
                        if render </span><span class="cov8" title="1">{
                                _, render = outputFormatsForPage.GetByName(f.Name)
                        }</span>

                        <span class="cov8" title="1">po := newPageOutput(ps, pp, f, render)

                        // Create a content provider for the first,
                        // we may be able to reuse it.
                        if i == 0 </span><span class="cov8" title="1">{
                                contentProvider, err := newPageContentOutput(ps, po)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">po.initContentProvider(contentProvider)</span>
                        }

                        <span class="cov8" title="1">ps.pageOutputs[i] = po
                        created[f.Name] = po</span>

                }

                <span class="cov8" title="1">if err := ps.initCommonProviders(pp); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">ps.parent = owner

        return ps, nil</span>
}

func (m *pageMap) newResource(fim hugofs.FileMetaInfo, owner *pageState) (resource.Resource, error) <span class="cov8" title="1">{
        if owner == nil </span><span class="cov0" title="0">{
                panic("owner is nil")</span>
        }
        // TODO(bep) consolidate with multihost logic + clean up
        <span class="cov8" title="1">outputFormats := owner.m.outputFormats()
        seen := make(map[string]bool)
        var targetBasePaths []string
        // Make sure bundled resources are published to all of the output formats'
        // sub paths.
        for _, f := range outputFormats </span><span class="cov8" title="1">{
                p := f.Path
                if seen[p] </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[p] = true
                targetBasePaths = append(targetBasePaths, p)</span>

        }

        <span class="cov8" title="1">meta := fim.Meta()
        r := func() (hugio.ReadSeekCloser, error) </span><span class="cov8" title="1">{
                return meta.Open()
        }</span>

        <span class="cov8" title="1">target := strings.TrimPrefix(meta.Path, owner.File().Dir())

        return owner.s.ResourceSpec.New(
                resources.ResourceSourceDescriptor{
                        TargetPaths:        owner.getTargetPaths,
                        OpenReadSeekCloser: r,
                        FileInfo:           fim,
                        RelTargetFilename:  target,
                        TargetBasePaths:    targetBasePaths,
                        LazyPublish:        !owner.m.buildConfig.PublishResources,
                })</span>
}

func (m *pageMap) createSiteTaxonomies() error <span class="cov8" title="1">{
        m.s.taxonomies = make(TaxonomyList)
        var walkErr error
        m.taxonomies.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                n := v.(*contentNode)
                t := n.viewInfo

                viewName := t.name

                if t.termKey == "" </span><span class="cov8" title="1">{
                        m.s.taxonomies[viewName.plural] = make(Taxonomy)
                }</span> else<span class="cov8" title="1"> {
                        taxonomy := m.s.taxonomies[viewName.plural]
                        if taxonomy == nil </span><span class="cov0" title="0">{
                                walkErr = errors.Errorf("missing taxonomy: %s", viewName.plural)
                                return true
                        }</span>
                        <span class="cov8" title="1">m.taxonomyEntries.WalkPrefix(s, func(ss string, v interface{}) bool </span><span class="cov8" title="1">{
                                b2 := v.(*contentNode)
                                info := b2.viewInfo
                                taxonomy.add(info.termKey, page.NewWeightedPage(info.weight, info.ref.p, n.p))

                                return false
                        }</span>)
                }

                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">for _, taxonomy := range m.s.taxonomies </span><span class="cov8" title="1">{
                for _, v := range taxonomy </span><span class="cov8" title="1">{
                        v.Sort()
                }</span>
        }

        <span class="cov8" title="1">return walkErr</span>
}

func (m *pageMap) createListAllPages() page.Pages <span class="cov8" title="1">{
        pages := make(page.Pages, 0)

        m.contentMap.pageTrees.Walk(func(s string, n *contentNode) bool </span><span class="cov8" title="1">{
                if n.p == nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("BUG: page not set for %q", s))</span>
                }
                <span class="cov8" title="1">if contentTreeNoListAlwaysFilter(s, n) </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">pages = append(pages, n.p)
                return false</span>
        })

        <span class="cov8" title="1">page.SortByDefault(pages)
        return pages</span>
}

func (m *pageMap) assemblePages() error <span class="cov8" title="1">{
        m.taxonomyEntries.DeletePrefix("/")

        if err := m.assembleSections(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var err error

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">m.pages.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                n := v.(*contentNode)

                var shouldBuild bool

                defer func() </span><span class="cov8" title="1">{
                        // Make sure we always rebuild the view cache.
                        if shouldBuild &amp;&amp; err == nil &amp;&amp; n.p != nil </span><span class="cov8" title="1">{
                                m.attachPageToViews(s, n)
                        }</span>
                }()

                <span class="cov8" title="1">if n.p != nil </span><span class="cov8" title="1">{
                        // A rebuild
                        shouldBuild = true
                        return false
                }</span>

                <span class="cov8" title="1">var parent *contentNode
                var parentBucket *pagesMapBucket

                _, parent = m.getSection(s)
                if parent == nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("BUG: parent not set for %q", s))</span>
                }
                <span class="cov8" title="1">parentBucket = parent.p.bucket

                n.p, err = m.newPageFromContentNode(n, parentBucket, nil)
                if err != nil </span><span class="cov8" title="1">{
                        return true
                }</span>

                <span class="cov8" title="1">shouldBuild = !(n.p.Kind() == page.KindPage &amp;&amp; m.cfg.pageDisabled) &amp;&amp; m.s.shouldBuild(n.p)
                if !shouldBuild </span><span class="cov8" title="1">{
                        m.deletePage(s)
                        return false
                }</span>

                <span class="cov8" title="1">n.p.treeRef = &amp;contentTreeRef{
                        m:   m,
                        t:   m.pages,
                        n:   n,
                        key: s,
                }

                if err = m.assembleResources(s, n.p, parentBucket); err != nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">m.deleteOrphanSections()

        return err</span>
}

func (m *pageMap) assembleResources(s string, p *pageState, parentBucket *pagesMapBucket) error <span class="cov8" title="1">{
        var err error

        m.resources.WalkPrefix(s, func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                n := v.(*contentNode)
                meta := n.fi.Meta()
                classifier := meta.Classifier
                var r resource.Resource
                switch classifier </span>{
                case files.ContentClassContent:<span class="cov8" title="1">
                        var rp *pageState
                        rp, err = m.newPageFromContentNode(n, parentBucket, p)
                        if err != nil </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov8" title="1">rp.m.resourcePath = filepath.ToSlash(strings.TrimPrefix(rp.File().Path(), p.File().Dir()))
                        r = rp</span>

                case files.ContentClassFile:<span class="cov8" title="1">
                        r, err = m.newResource(n.fi, p)
                        if err != nil </span><span class="cov0" title="0">{
                                return true
                        }</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("invalid classifier: %q", classifier))</span>
                }

                <span class="cov8" title="1">p.resources = append(p.resources, r)
                return false</span>
        })

        <span class="cov8" title="1">return err</span>
}

func (m *pageMap) assembleSections() error <span class="cov8" title="1">{
        var sectionsToDelete []string
        var err error

        m.sections.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                n := v.(*contentNode)
                var shouldBuild bool

                defer func() </span><span class="cov8" title="1">{
                        // Make sure we always rebuild the view cache.
                        if shouldBuild &amp;&amp; err == nil &amp;&amp; n.p != nil </span><span class="cov8" title="1">{
                                m.attachPageToViews(s, n)
                                if n.p.IsHome() </span><span class="cov8" title="1">{
                                        m.s.home = n.p
                                }</span>
                        }
                }()

                <span class="cov8" title="1">sections := m.splitKey(s)

                if n.p != nil </span><span class="cov8" title="1">{
                        if n.p.IsHome() </span><span class="cov8" title="1">{
                                m.s.home = n.p
                        }</span>
                        <span class="cov8" title="1">shouldBuild = true
                        return false</span>
                }

                <span class="cov8" title="1">var parent *contentNode
                var parentBucket *pagesMapBucket

                if s != "/" </span><span class="cov8" title="1">{
                        _, parent = m.getSection(s)
                        if parent == nil || parent.p == nil </span><span class="cov0" title="0">{
                                panic(fmt.Sprintf("BUG: parent not set for %q", s))</span>
                        }
                }

                <span class="cov8" title="1">if parent != nil </span><span class="cov8" title="1">{
                        parentBucket = parent.p.bucket
                }</span> else<span class="cov8" title="1"> if s == "/" </span><span class="cov8" title="1">{
                        parentBucket = m.s.siteBucket
                }</span>

                <span class="cov8" title="1">kind := page.KindSection
                if s == "/" </span><span class="cov8" title="1">{
                        kind = page.KindHome
                }</span>

                <span class="cov8" title="1">if n.fi != nil </span><span class="cov8" title="1">{
                        n.p, err = m.newPageFromContentNode(n, parentBucket, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return true
                        }</span>
                } else<span class="cov8" title="1"> {
                        n.p = m.s.newPage(n, parentBucket, kind, "", sections...)
                }</span>

                <span class="cov8" title="1">shouldBuild = m.s.shouldBuild(n.p)
                if !shouldBuild </span><span class="cov8" title="1">{
                        sectionsToDelete = append(sectionsToDelete, s)
                        return false
                }</span>

                <span class="cov8" title="1">n.p.treeRef = &amp;contentTreeRef{
                        m:   m,
                        t:   m.sections,
                        n:   n,
                        key: s,
                }

                if err = m.assembleResources(s+cmLeafSeparator, n.p, parentBucket); err != nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">for _, s := range sectionsToDelete </span><span class="cov8" title="1">{
                m.deleteSectionByPath(s)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (m *pageMap) assembleTaxonomies() error <span class="cov8" title="1">{
        var taxonomiesToDelete []string
        var err error

        m.taxonomies.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                n := v.(*contentNode)

                if n.p != nil </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">kind := n.viewInfo.kind()
                sections := n.viewInfo.sections()

                _, parent := m.getTaxonomyParent(s)
                if parent == nil || parent.p == nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("BUG: parent not set for %q", s))</span>
                }
                <span class="cov8" title="1">parentBucket := parent.p.bucket

                if n.fi != nil </span><span class="cov8" title="1">{
                        n.p, err = m.newPageFromContentNode(n, parent.p.bucket, nil)
                        if err != nil </span><span class="cov0" title="0">{
                                return true
                        }</span>
                } else<span class="cov8" title="1"> {
                        title := ""
                        if kind == page.KindTerm </span><span class="cov8" title="1">{
                                title = n.viewInfo.term()
                        }</span>
                        <span class="cov8" title="1">n.p = m.s.newPage(n, parent.p.bucket, kind, title, sections...)</span>
                }

                <span class="cov8" title="1">if !m.s.shouldBuild(n.p) </span><span class="cov8" title="1">{
                        taxonomiesToDelete = append(taxonomiesToDelete, s)
                        return false
                }</span>

                <span class="cov8" title="1">n.p.treeRef = &amp;contentTreeRef{
                        m:   m,
                        t:   m.taxonomies,
                        n:   n,
                        key: s,
                }

                if err = m.assembleResources(s+cmLeafSeparator, n.p, parentBucket); err != nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">for _, s := range taxonomiesToDelete </span><span class="cov8" title="1">{
                m.deleteTaxonomy(s)
        }</span>

        <span class="cov8" title="1">return err</span>
}

func (m *pageMap) attachPageToViews(s string, b *contentNode) <span class="cov8" title="1">{
        if m.cfg.taxonomyDisabled </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">for _, viewName := range m.cfg.taxonomyConfig </span><span class="cov8" title="1">{
                vals := types.ToStringSlicePreserveString(getParam(b.p, viewName.plural, false))
                if vals == nil </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">w := getParamToLower(b.p, viewName.plural+"_weight")
                weight, err := cast.ToIntE(w)
                if err != nil </span><span class="cov0" title="0">{
                        m.s.Log.Errorf("Unable to convert taxonomy weight %#v to int for %q", w, b.p.Pathc())
                        // weight will equal zero, so let the flow continue
                }</span>

                <span class="cov8" title="1">for i, v := range vals </span><span class="cov8" title="1">{
                        termKey := m.s.getTaxonomyKey(v)

                        bv := &amp;contentNode{
                                viewInfo: &amp;contentBundleViewInfo{
                                        ordinal:    i,
                                        name:       viewName,
                                        termKey:    termKey,
                                        termOrigin: v,
                                        weight:     weight,
                                        ref:        b,
                                },
                        }

                        var key string
                        if strings.HasSuffix(s, "/") </span><span class="cov8" title="1">{
                                key = cleanSectionTreeKey(path.Join(viewName.plural, termKey, s))
                        }</span> else<span class="cov8" title="1"> {
                                key = cleanTreeKey(path.Join(viewName.plural, termKey, s))
                        }</span>
                        <span class="cov8" title="1">m.taxonomyEntries.Insert(key, bv)</span>
                }
        }
}

type pageMapQuery struct {
        Prefix string
        Filter contentTreeNodeCallback
}

func (m *pageMap) collectPages(query pageMapQuery, fn func(c *contentNode)) error <span class="cov8" title="1">{
        if query.Filter == nil </span><span class="cov8" title="1">{
                query.Filter = contentTreeNoListAlwaysFilter
        }</span>

        <span class="cov8" title="1">m.pages.WalkQuery(query, func(s string, n *contentNode) bool </span><span class="cov8" title="1">{
                fn(n)
                return false
        }</span>)

        <span class="cov8" title="1">return nil</span>
}

func (m *pageMap) collectPagesAndSections(query pageMapQuery, fn func(c *contentNode)) error <span class="cov8" title="1">{
        if err := m.collectSections(query, fn); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">query.Prefix = query.Prefix + cmBranchSeparator
        if err := m.collectPages(query, fn); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (m *pageMap) collectSections(query pageMapQuery, fn func(c *contentNode)) error <span class="cov8" title="1">{
        level := strings.Count(query.Prefix, "/")

        return m.collectSectionsFn(query, func(s string, c *contentNode) bool </span><span class="cov8" title="1">{
                if strings.Count(s, "/") != level+1 </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">fn(c)

                return false</span>
        })
}

func (m *pageMap) collectSectionsFn(query pageMapQuery, fn func(s string, c *contentNode) bool) error <span class="cov8" title="1">{
        if !strings.HasSuffix(query.Prefix, "/") </span><span class="cov0" title="0">{
                query.Prefix += "/"
        }</span>

        <span class="cov8" title="1">m.sections.WalkQuery(query, func(s string, n *contentNode) bool </span><span class="cov8" title="1">{
                return fn(s, n)
        }</span>)

        <span class="cov8" title="1">return nil</span>
}

func (m *pageMap) collectSectionsRecursiveIncludingSelf(query pageMapQuery, fn func(c *contentNode)) error <span class="cov8" title="1">{
        return m.collectSectionsFn(query, func(s string, c *contentNode) bool </span><span class="cov8" title="1">{
                fn(c)
                return false
        }</span>)
}

func (m *pageMap) collectTaxonomies(prefix string, fn func(c *contentNode)) error <span class="cov8" title="1">{
        m.taxonomies.WalkQuery(pageMapQuery{Prefix: prefix}, func(s string, n *contentNode) bool </span><span class="cov8" title="1">{
                fn(n)
                return false
        }</span>)
        <span class="cov8" title="1">return nil</span>
}

// withEveryBundlePage applies fn to every Page, including those bundled inside
// leaf bundles.
func (m *pageMap) withEveryBundlePage(fn func(p *pageState) bool) <span class="cov8" title="1">{
        m.bundleTrees.Walk(func(s string, n *contentNode) bool </span><span class="cov8" title="1">{
                if n.p != nil </span><span class="cov8" title="1">{
                        return fn(n.p)
                }</span>
                <span class="cov8" title="1">return false</span>
        })
}

type pageMaps struct {
        workers *para.Workers
        pmaps   []*pageMap
}

// deleteSection deletes the entire section from s.
func (m *pageMaps) deleteSection(s string) <span class="cov8" title="1">{
        m.withMaps(func(pm *pageMap) error </span><span class="cov8" title="1">{
                pm.deleteSectionByPath(s)
                return nil
        }</span>)
}

func (m *pageMaps) AssemblePages() error <span class="cov8" title="1">{
        return m.withMaps(func(pm *pageMap) error </span><span class="cov8" title="1">{
                if err := pm.CreateMissingNodes(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := pm.assemblePages(); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := pm.createMissingTaxonomyNodes(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Handle any new sections created in the step above.
                <span class="cov8" title="1">if err := pm.assembleSections(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if pm.s.home == nil </span><span class="cov8" title="1">{
                        // Home is disabled, everything is.
                        pm.bundleTrees.DeletePrefix("")
                        return nil
                }</span>

                <span class="cov8" title="1">if err := pm.assembleTaxonomies(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if err := pm.createSiteTaxonomies(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">sw := &amp;sectionWalker{m: pm.contentMap}
                a := sw.applyAggregates()
                _, mainSectionsSet := pm.s.s.Info.Params()["mainsections"]
                if !mainSectionsSet &amp;&amp; a.mainSection != "" </span><span class="cov8" title="1">{
                        mainSections := []string{strings.TrimRight(a.mainSection, "/")}
                        pm.s.s.Info.Params()["mainSections"] = mainSections
                        pm.s.s.Info.Params()["mainsections"] = mainSections
                }</span>

                <span class="cov8" title="1">pm.s.lastmod = a.datesAll.Lastmod()
                if resource.IsZeroDates(pm.s.home) </span><span class="cov8" title="1">{
                        pm.s.home.m.Dates = a.datesAll
                }</span>

                <span class="cov8" title="1">return nil</span>
        })
}

func (m *pageMaps) walkBundles(fn func(n *contentNode) bool) <span class="cov8" title="1">{
        _ = m.withMaps(func(pm *pageMap) error </span><span class="cov8" title="1">{
                pm.bundleTrees.Walk(func(s string, n *contentNode) bool </span><span class="cov8" title="1">{
                        return fn(n)
                }</span>)
                <span class="cov8" title="1">return nil</span>
        })
}

func (m *pageMaps) walkBranchesPrefix(prefix string, fn func(s string, n *contentNode) bool) <span class="cov8" title="1">{
        _ = m.withMaps(func(pm *pageMap) error </span><span class="cov8" title="1">{
                pm.branchTrees.WalkPrefix(prefix, func(s string, n *contentNode) bool </span><span class="cov8" title="1">{
                        return fn(s, n)
                }</span>)
                <span class="cov8" title="1">return nil</span>
        })
}

func (m *pageMaps) withMaps(fn func(pm *pageMap) error) error <span class="cov8" title="1">{
        g, _ := m.workers.Start(context.Background())
        for _, pm := range m.pmaps </span><span class="cov8" title="1">{
                pm := pm
                g.Run(func() error </span><span class="cov8" title="1">{
                        return fn(pm)
                }</span>)
        }
        <span class="cov8" title="1">return g.Wait()</span>
}

type pagesMapBucket struct {
        // Cascading front matter.
        cascade map[page.PageMatcher]maps.Params

        owner *pageState // The branch node

        *pagesMapBucketPages
}

type pagesMapBucketPages struct {
        pagesInit sync.Once
        pages     page.Pages

        pagesAndSectionsInit sync.Once
        pagesAndSections     page.Pages

        sectionsInit sync.Once
        sections     page.Pages
}

func (b *pagesMapBucket) getPages() page.Pages <span class="cov8" title="1">{
        b.pagesInit.Do(func() </span><span class="cov8" title="1">{
                b.pages = b.owner.treeRef.getPages()
                page.SortByDefault(b.pages)
        }</span>)
        <span class="cov8" title="1">return b.pages</span>
}

func (b *pagesMapBucket) getPagesRecursive() page.Pages <span class="cov8" title="1">{
        pages := b.owner.treeRef.getPagesRecursive()
        page.SortByDefault(pages)
        return pages
}</span>

func (b *pagesMapBucket) getPagesAndSections() page.Pages <span class="cov8" title="1">{
        b.pagesAndSectionsInit.Do(func() </span><span class="cov8" title="1">{
                b.pagesAndSections = b.owner.treeRef.getPagesAndSections()
        }</span>)
        <span class="cov8" title="1">return b.pagesAndSections</span>
}

func (b *pagesMapBucket) getSections() page.Pages <span class="cov8" title="1">{
        b.sectionsInit.Do(func() </span><span class="cov8" title="1">{
                if b.owner.treeRef == nil </span><span class="cov8" title="1">{
                        return
                }</span>
                <span class="cov8" title="1">b.sections = b.owner.treeRef.getSections()</span>
        })

        <span class="cov8" title="1">return b.sections</span>
}

func (b *pagesMapBucket) getTaxonomies() page.Pages <span class="cov8" title="1">{
        b.sectionsInit.Do(func() </span><span class="cov8" title="1">{
                var pas page.Pages
                ref := b.owner.treeRef
                ref.m.collectTaxonomies(ref.key, func(c *contentNode) </span><span class="cov8" title="1">{
                        pas = append(pas, c.p)
                }</span>)
                <span class="cov8" title="1">page.SortByDefault(pas)
                b.sections = pas</span>
        })

        <span class="cov8" title="1">return b.sections</span>
}

func (b *pagesMapBucket) getTaxonomyEntries() page.Pages <span class="cov8" title="1">{
        var pas page.Pages
        ref := b.owner.treeRef
        viewInfo := ref.n.viewInfo
        prefix := strings.ToLower("/" + viewInfo.name.plural + "/" + viewInfo.termKey + "/")
        ref.m.taxonomyEntries.WalkPrefix(prefix, func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                n := v.(*contentNode)
                pas = append(pas, n.viewInfo.ref.p)
                return false
        }</span>)
        <span class="cov8" title="1">page.SortByDefault(pas)
        return pas</span>
}

type sectionAggregate struct {
        datesAll             resource.Dates
        datesSection         resource.Dates
        pageCount            int
        mainSection          string
        mainSectionPageCount int
}

type sectionAggregateHandler struct {
        sectionAggregate
        sectionPageCount int

        // Section
        b *contentNode
        s string
}

func (h *sectionAggregateHandler) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("%s/%s - %d - %s", h.sectionAggregate.datesAll, h.sectionAggregate.datesSection, h.sectionPageCount, h.s)
}</span>

func (h *sectionAggregateHandler) isRootSection() bool <span class="cov8" title="1">{
        return h.s != "/" &amp;&amp; strings.Count(h.s, "/") == 2
}</span>

func (h *sectionAggregateHandler) handleNested(v sectionWalkHandler) error <span class="cov8" title="1">{
        nested := v.(*sectionAggregateHandler)
        h.sectionPageCount += nested.pageCount
        h.pageCount += h.sectionPageCount
        h.datesAll.UpdateDateAndLastmodIfAfter(nested.datesAll)
        h.datesSection.UpdateDateAndLastmodIfAfter(nested.datesAll)
        return nil
}</span>

func (h *sectionAggregateHandler) handlePage(s string, n *contentNode) error <span class="cov8" title="1">{
        h.sectionPageCount++

        var d resource.Dated
        if n.p != nil </span><span class="cov8" title="1">{
                d = n.p
        }</span> else<span class="cov8" title="1"> if n.viewInfo != nil &amp;&amp; n.viewInfo.ref != nil </span><span class="cov8" title="1">{
                d = n.viewInfo.ref.p
        }</span> else<span class="cov0" title="0"> {
                return nil
        }</span>

        <span class="cov8" title="1">h.datesAll.UpdateDateAndLastmodIfAfter(d)
        h.datesSection.UpdateDateAndLastmodIfAfter(d)
        return nil</span>
}

func (h *sectionAggregateHandler) handleSectionPost() error <span class="cov8" title="1">{
        if h.sectionPageCount &gt; h.mainSectionPageCount &amp;&amp; h.isRootSection() </span><span class="cov8" title="1">{
                h.mainSectionPageCount = h.sectionPageCount
                h.mainSection = strings.TrimPrefix(h.s, "/")
        }</span>

        <span class="cov8" title="1">if resource.IsZeroDates(h.b.p) </span><span class="cov8" title="1">{
                h.b.p.m.Dates = h.datesSection
        }</span>

        <span class="cov8" title="1">h.datesSection = resource.Dates{}

        return nil</span>
}

func (h *sectionAggregateHandler) handleSectionPre(s string, b *contentNode) error <span class="cov8" title="1">{
        h.s = s
        h.b = b
        h.sectionPageCount = 0
        h.datesAll.UpdateDateAndLastmodIfAfter(b.p)
        return nil
}</span>

type sectionWalkHandler interface {
        handleNested(v sectionWalkHandler) error
        handlePage(s string, b *contentNode) error
        handleSectionPost() error
        handleSectionPre(s string, b *contentNode) error
}

type sectionWalker struct {
        err error
        m   *contentMap
}

func (w *sectionWalker) applyAggregates() *sectionAggregateHandler <span class="cov8" title="1">{
        return w.walkLevel("/", func() sectionWalkHandler </span><span class="cov8" title="1">{
                return &amp;sectionAggregateHandler{}
        }</span>).(*sectionAggregateHandler)
}

func (w *sectionWalker) walkLevel(prefix string, createVisitor func() sectionWalkHandler) sectionWalkHandler <span class="cov8" title="1">{
        level := strings.Count(prefix, "/")

        visitor := createVisitor()

        w.m.taxonomies.WalkBelow(prefix, func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                currentLevel := strings.Count(s, "/")

                if currentLevel &gt; level+1 </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">n := v.(*contentNode)

                if w.err = visitor.handleSectionPre(s, n); w.err != nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov8" title="1">if currentLevel == 2 </span><span class="cov8" title="1">{
                        nested := w.walkLevel(s, createVisitor)
                        if w.err = visitor.handleNested(nested); w.err != nil </span><span class="cov0" title="0">{
                                return true
                        }</span>
                } else<span class="cov8" title="1"> {
                        w.m.taxonomyEntries.WalkPrefix(s, func(ss string, v interface{}) bool </span><span class="cov8" title="1">{
                                n := v.(*contentNode)
                                w.err = visitor.handlePage(ss, n)
                                return w.err != nil
                        }</span>)
                }

                <span class="cov8" title="1">w.err = visitor.handleSectionPost()

                return w.err != nil</span>
        })

        <span class="cov8" title="1">w.m.sections.WalkBelow(prefix, func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                currentLevel := strings.Count(s, "/")
                if currentLevel &gt; level+1 </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">n := v.(*contentNode)

                if w.err = visitor.handleSectionPre(s, n); w.err != nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov8" title="1">w.m.pages.WalkPrefix(s+cmBranchSeparator, func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                        w.err = visitor.handlePage(s, v.(*contentNode))
                        return w.err != nil
                }</span>)

                <span class="cov8" title="1">if w.err != nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov8" title="1">nested := w.walkLevel(s, createVisitor)
                if w.err = visitor.handleNested(nested); w.err != nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov8" title="1">w.err = visitor.handleSectionPost()

                return w.err != nil</span>
        })

        <span class="cov8" title="1">return visitor</span>
}

type viewName struct {
        singular string // e.g. "category"
        plural   string // e.g. "categories"
}

func (v viewName) IsZero() bool <span class="cov8" title="1">{
        return v.singular == ""
}</span>
</pre>
		
		<pre class="file" id="file109" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "strings"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/source"
)

// fileInfo implements the File and ReadableFile interface.
var (
        _ source.File = (*fileInfo)(nil)
)

type fileInfo struct {
        source.File

        overriddenLang string
}

func (fi *fileInfo) Open() (afero.File, error) <span class="cov0" title="0">{
        f, err := fi.FileInfo().Meta().Open()
        if err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, "fileInfo")
        }</span>

        <span class="cov0" title="0">return f, err</span>
}

func (fi *fileInfo) Lang() string <span class="cov0" title="0">{
        if fi.overriddenLang != "" </span><span class="cov0" title="0">{
                return fi.overriddenLang
        }</span>
        <span class="cov0" title="0">return fi.File.Lang()</span>
}

func (fi *fileInfo) String() string <span class="cov8" title="1">{
        if fi == nil || fi.File == nil </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov0" title="0">return fi.Path()</span>
}

// TODO(bep) rename
func newFileInfo(sp *source.SourceSpec, fi hugofs.FileMetaInfo) (*fileInfo, error) <span class="cov8" title="1">{
        baseFi, err := sp.NewFileInfo(fi)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">f := &amp;fileInfo{
                File: baseFi,
        }

        return f, nil</span>
}

type bundleDirType int

const (
        bundleNot bundleDirType = iota

        // All from here are bundles in one form or another.
        bundleLeaf
        bundleBranch
)

// Returns the given file's name's bundle type and whether it is a content
// file or not.
func classifyBundledFile(name string) (bundleDirType, bool) <span class="cov8" title="1">{
        if !files.IsContentFile(name) </span><span class="cov0" title="0">{
                return bundleNot, false
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(name, "_index.") </span><span class="cov0" title="0">{
                return bundleBranch, true
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(name, "index.") </span><span class="cov0" title="0">{
                return bundleLeaf, true
        }</span>

        <span class="cov8" title="1">return bundleNot, true</span>
}

func (b bundleDirType) String() string <span class="cov0" title="0">{
        switch b </span>{
        case bundleNot:<span class="cov0" title="0">
                return "Not a bundle"</span>
        case bundleLeaf:<span class="cov0" title="0">
                return "Regular bundle"</span>
        case bundleBranch:<span class="cov0" title="0">
                return "Branch bundle"</span>
        }

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file110" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package filesystems provides the fine grained file systems used by Hugo. These
// are typically virtual filesystems that are composites of project and theme content.
package filesystems

import (
        "fmt"
        "io"
        "os"
        "path"
        "path/filepath"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/htesting"
        "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/gohugoio/hugo/common/types"

        "github.com/gohugoio/hugo/common/loggers"
        "github.com/rogpeppe/go-internal/lockedfile"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/modules"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/hugolib/paths"
        "github.com/spf13/afero"
)

const (
        // Used to control concurrency between multiple Hugo instances, e.g.
        // a running server and building new content with 'hugo new'.
        // It's placed in the project root.
        lockFileBuild = ".hugo_build.lock"
)

var filePathSeparator = string(filepath.Separator)

// BaseFs contains the core base filesystems used by Hugo. The name "base" is used
// to underline that even if they can be composites, they all have a base path set to a specific
// resource folder, e.g "/my-project/content". So, no absolute filenames needed.
type BaseFs struct {

        // SourceFilesystems contains the different source file systems.
        *SourceFilesystems

        // The project source.
        SourceFs afero.Fs

        // The filesystem used to publish the rendered site.
        // This usually maps to /my-project/public.
        PublishFs afero.Fs

        theBigFs *filesystemsCollector

        // Locks.
        buildMu      *lockedfile.Mutex // &lt;project&gt;/.hugo_build.lock
        buildMuTests sync.Mutex        // Used in tests.
}

// Tries to acquire a build lock.
func (fs *BaseFs) LockBuild() (unlock func(), err error) <span class="cov0" title="0">{
        if htesting.IsTest </span><span class="cov0" title="0">{
                fs.buildMuTests.Lock()
                return func() </span><span class="cov0" title="0">{
                        fs.buildMuTests.Unlock()
                }</span>, nil
        }
        <span class="cov0" title="0">return fs.buildMu.Lock()</span>
}

// TODO(bep) we can get regular files in here and that is fine, but
// we need to clean up the naming.
func (fs *BaseFs) WatchDirs() []hugofs.FileMetaInfo <span class="cov0" title="0">{
        var dirs []hugofs.FileMetaInfo
        for _, dir := range fs.AllDirs() </span><span class="cov0" title="0">{
                if dir.Meta().Watch </span><span class="cov0" title="0">{
                        dirs = append(dirs, dir)
                }</span>
        }
        <span class="cov0" title="0">return dirs</span>
}

func (fs *BaseFs) AllDirs() []hugofs.FileMetaInfo <span class="cov0" title="0">{
        var dirs []hugofs.FileMetaInfo
        for _, dirSet := range [][]hugofs.FileMetaInfo{
                fs.Archetypes.Dirs,
                fs.I18n.Dirs,
                fs.Data.Dirs,
                fs.Content.Dirs,
                fs.Assets.Dirs,
                fs.Layouts.Dirs,
                // fs.Resources.Dirs,
                fs.StaticDirs,
        } </span><span class="cov0" title="0">{
                dirs = append(dirs, dirSet...)
        }</span>

        <span class="cov0" title="0">return dirs</span>
}

// RelContentDir tries to create a path relative to the content root from
// the given filename. The return value is the path and language code.
func (b *BaseFs) RelContentDir(filename string) string <span class="cov8" title="1">{
        for _, dir := range b.SourceFilesystems.Content.Dirs </span><span class="cov8" title="1">{
                dirname := dir.Meta().Filename
                if strings.HasPrefix(filename, dirname) </span><span class="cov8" title="1">{
                        rel := path.Join(dir.Meta().Path, strings.TrimPrefix(filename, dirname))
                        return strings.TrimPrefix(rel, filePathSeparator)
                }</span>
        }
        // Either not a content dir or already relative.
        <span class="cov0" title="0">return filename</span>
}

// AbsProjectContentDir tries to construct a filename below the most
// relevant content directory.
func (b *BaseFs) AbsProjectContentDir(filename string) (string, string, error) <span class="cov0" title="0">{
        isAbs := filepath.IsAbs(filename)
        for _, dir := range b.SourceFilesystems.Content.Dirs </span><span class="cov0" title="0">{
                meta := dir.Meta()
                if !meta.IsProject </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if isAbs </span><span class="cov0" title="0">{
                        if strings.HasPrefix(filename, meta.Filename) </span><span class="cov0" title="0">{
                                return strings.TrimPrefix(filename, meta.Filename), filename, nil
                        }</span>
                } else<span class="cov0" title="0"> {
                        contentDir := strings.TrimPrefix(strings.TrimPrefix(meta.Filename, meta.BaseDir), filePathSeparator)
                        if strings.HasPrefix(filename, contentDir) </span><span class="cov0" title="0">{
                                relFilename := strings.TrimPrefix(filename, contentDir)
                                absFilename := filepath.Join(meta.Filename, relFilename)
                                return relFilename, absFilename, nil
                        }</span>
                }

        }

        <span class="cov0" title="0">if !isAbs </span><span class="cov0" title="0">{
                // A filename on the form "posts/mypage.md", put it inside
                // the first content folder, usually &lt;workDir&gt;/content.
                // Pick the last project dir (which is probably the most important one).
                contentDirs := b.SourceFilesystems.Content.Dirs
                for i := len(contentDirs) - 1; i &gt;= 0; i-- </span><span class="cov0" title="0">{
                        meta := contentDirs[i].Meta()
                        if meta.IsProject </span><span class="cov0" title="0">{
                                return filename, filepath.Join(meta.Filename, filename), nil
                        }</span>
                }
        }

        <span class="cov0" title="0">return "", "", errors.Errorf("could not determine content directory for %q", filename)</span>
}

// ResolveJSConfigFile resolves the JS-related config file to a absolute
// filename. One example of such would be postcss.config.js.
func (fs *BaseFs) ResolveJSConfigFile(name string) string <span class="cov0" title="0">{
        // First look in assets/_jsconfig
        fi, err := fs.Assets.Fs.Stat(filepath.Join(files.FolderJSConfig, name))
        if err == nil </span><span class="cov0" title="0">{
                return fi.(hugofs.FileMetaInfo).Meta().Filename
        }</span>
        // Fall back to the work dir.
        <span class="cov0" title="0">fi, err = fs.Work.Stat(name)
        if err == nil </span><span class="cov0" title="0">{
                return fi.(hugofs.FileMetaInfo).Meta().Filename
        }</span>

        <span class="cov0" title="0">return ""</span>
}

// SourceFilesystems contains the different source file systems. These can be
// composite file systems (theme and project etc.), and they have all root
// set to the source type the provides: data, i18n, static, layouts.
type SourceFilesystems struct {
        Content    *SourceFilesystem
        Data       *SourceFilesystem
        I18n       *SourceFilesystem
        Layouts    *SourceFilesystem
        Archetypes *SourceFilesystem
        Assets     *SourceFilesystem

        // Writable filesystem on top the project's resources directory,
        // with any sub module's resource fs layered below.
        ResourcesCache afero.Fs

        // The project folder.
        Work afero.Fs

        // When in multihost we have one static filesystem per language. The sync
        // static files is currently done outside of the Hugo build (where there is
        // a concept of a site per language).
        // When in non-multihost mode there will be one entry in this map with a blank key.
        Static map[string]*SourceFilesystem

        // All the /static dirs (including themes/modules).
        StaticDirs []hugofs.FileMetaInfo
}

// FileSystems returns the FileSystems relevant for the change detection
// in server mode.
// Note: This does currently not return any static fs.
func (s *SourceFilesystems) FileSystems() []*SourceFilesystem <span class="cov0" title="0">{
        return []*SourceFilesystem{
                s.Content,
                s.Data,
                s.I18n,
                s.Layouts,
                s.Archetypes,
                // TODO(bep) static
        }
}</span>

// A SourceFilesystem holds the filesystem for a given source type in Hugo (data,
// i18n, layouts, static) and additional metadata to be able to use that filesystem
// in server mode.
type SourceFilesystem struct {
        // Name matches one in files.ComponentFolders
        Name string

        // This is a virtual composite filesystem. It expects path relative to a context.
        Fs afero.Fs

        // This filesystem as separate root directories, starting from project and down
        // to the themes/modules.
        Dirs []hugofs.FileMetaInfo

        // When syncing a source folder to the target (e.g. /public), this may
        // be set to publish into a subfolder. This is used for static syncing
        // in multihost mode.
        PublishFolder string
}

// ContentStaticAssetFs will create a new composite filesystem from the content,
// static, and asset filesystems. The site language is needed to pick the correct static filesystem.
// The order is content, static and then assets.
// TODO(bep) check usage
func (s SourceFilesystems) ContentStaticAssetFs(lang string) afero.Fs <span class="cov0" title="0">{
        staticFs := s.StaticFs(lang)

        base := afero.NewCopyOnWriteFs(s.Assets.Fs, staticFs)
        return afero.NewCopyOnWriteFs(base, s.Content.Fs)
}</span>

// StaticFs returns the static filesystem for the given language.
// This can be a composite filesystem.
func (s SourceFilesystems) StaticFs(lang string) afero.Fs <span class="cov8" title="1">{
        var staticFs afero.Fs = hugofs.NoOpFs

        if fs, ok := s.Static[lang]; ok </span><span class="cov8" title="1">{
                staticFs = fs.Fs
        }</span> else<span class="cov8" title="1"> if fs, ok := s.Static[""]; ok </span><span class="cov8" title="1">{
                staticFs = fs.Fs
        }</span>

        <span class="cov8" title="1">return staticFs</span>
}

// StatResource looks for a resource in these filesystems in order: static, assets and finally content.
// If found in any of them, it returns FileInfo and the relevant filesystem.
// Any non os.IsNotExist error will be returned.
// An os.IsNotExist error wil be returned only if all filesystems return such an error.
// Note that if we only wanted to find the file, we could create a composite Afero fs,
// but we also need to know which filesystem root it lives in.
func (s SourceFilesystems) StatResource(lang, filename string) (fi os.FileInfo, fs afero.Fs, err error) <span class="cov0" title="0">{
        for _, fsToCheck := range []afero.Fs{s.StaticFs(lang), s.Assets.Fs, s.Content.Fs} </span><span class="cov0" title="0">{
                fs = fsToCheck
                fi, err = fs.Stat(filename)
                if err == nil || !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return
                }</span>
        }
        // Not found.
        <span class="cov0" title="0">return</span>
}

// IsStatic returns true if the given filename is a member of one of the static
// filesystems.
func (s SourceFilesystems) IsStatic(filename string) bool <span class="cov8" title="1">{
        for _, staticFs := range s.Static </span><span class="cov8" title="1">{
                if staticFs.Contains(filename) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// IsContent returns true if the given filename is a member of the content filesystem.
func (s SourceFilesystems) IsContent(filename string) bool <span class="cov8" title="1">{
        return s.Content.Contains(filename)
}</span>

// IsLayout returns true if the given filename is a member of the layouts filesystem.
func (s SourceFilesystems) IsLayout(filename string) bool <span class="cov8" title="1">{
        return s.Layouts.Contains(filename)
}</span>

// IsData returns true if the given filename is a member of the data filesystem.
func (s SourceFilesystems) IsData(filename string) bool <span class="cov8" title="1">{
        return s.Data.Contains(filename)
}</span>

// IsAsset returns true if the given filename is a member of the asset filesystem.
func (s SourceFilesystems) IsAsset(filename string) bool <span class="cov8" title="1">{
        return s.Assets.Contains(filename)
}</span>

// IsI18n returns true if the given filename is a member of the i18n filesystem.
func (s SourceFilesystems) IsI18n(filename string) bool <span class="cov8" title="1">{
        return s.I18n.Contains(filename)
}</span>

// MakeStaticPathRelative makes an absolute static filename into a relative one.
// It will return an empty string if the filename is not a member of a static filesystem.
func (s SourceFilesystems) MakeStaticPathRelative(filename string) string <span class="cov0" title="0">{
        for _, staticFs := range s.Static </span><span class="cov0" title="0">{
                rel, _ := staticFs.MakePathRelative(filename)
                if rel != "" </span><span class="cov0" title="0">{
                        return rel
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

// MakePathRelative creates a relative path from the given filename.
func (d *SourceFilesystem) MakePathRelative(filename string) (string, bool) <span class="cov8" title="1">{
        for _, dir := range d.Dirs </span><span class="cov8" title="1">{
                meta := dir.(hugofs.FileMetaInfo).Meta()
                currentPath := meta.Filename

                if strings.HasPrefix(filename, currentPath) </span><span class="cov8" title="1">{
                        rel := strings.TrimPrefix(filename, currentPath)
                        if mp := meta.Path; mp != "" </span><span class="cov8" title="1">{
                                rel = filepath.Join(mp, rel)
                        }</span>
                        <span class="cov8" title="1">return strings.TrimPrefix(rel, filePathSeparator), true</span>
                }
        }
        <span class="cov0" title="0">return "", false</span>
}

func (d *SourceFilesystem) RealFilename(rel string) string <span class="cov0" title="0">{
        fi, err := d.Fs.Stat(rel)
        if err != nil </span><span class="cov0" title="0">{
                return rel
        }</span>
        <span class="cov0" title="0">if realfi, ok := fi.(hugofs.FileMetaInfo); ok </span><span class="cov0" title="0">{
                return realfi.Meta().Filename
        }</span>

        <span class="cov0" title="0">return rel</span>
}

// Contains returns whether the given filename is a member of the current filesystem.
func (d *SourceFilesystem) Contains(filename string) bool <span class="cov8" title="1">{
        for _, dir := range d.Dirs </span><span class="cov8" title="1">{
                if strings.HasPrefix(filename, dir.Meta().Filename) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// Path returns the mount relative path to the given filename if it is a member of
// of the current filesystem, an empty string if not.
func (d *SourceFilesystem) Path(filename string) string <span class="cov0" title="0">{
        for _, dir := range d.Dirs </span><span class="cov0" title="0">{
                meta := dir.Meta()
                if strings.HasPrefix(filename, meta.Filename) </span><span class="cov0" title="0">{
                        p := strings.TrimPrefix(strings.TrimPrefix(filename, meta.Filename), filePathSeparator)
                        if mountRoot := meta.MountRoot; mountRoot != "" </span><span class="cov0" title="0">{
                                return filepath.Join(mountRoot, p)
                        }</span>
                        <span class="cov0" title="0">return p</span>
                }
        }
        <span class="cov0" title="0">return ""</span>
}

// RealDirs gets a list of absolute paths to directories starting from the given
// path.
func (d *SourceFilesystem) RealDirs(from string) []string <span class="cov8" title="1">{
        var dirnames []string
        for _, dir := range d.Dirs </span><span class="cov8" title="1">{
                meta := dir.Meta()
                dirname := filepath.Join(meta.Filename, from)
                _, err := meta.Fs.Stat(from)

                if err == nil </span><span class="cov8" title="1">{
                        dirnames = append(dirnames, dirname)
                }</span>
        }
        <span class="cov8" title="1">return dirnames</span>
}

// WithBaseFs allows reuse of some potentially expensive to create parts that remain
// the same across sites/languages.
func WithBaseFs(b *BaseFs) func(*BaseFs) error <span class="cov0" title="0">{
        return func(bb *BaseFs) error </span><span class="cov0" title="0">{
                bb.theBigFs = b.theBigFs
                bb.SourceFilesystems = b.SourceFilesystems
                return nil
        }</span>
}

// NewBase builds the filesystems used by Hugo given the paths and options provided.NewBase
func NewBase(p *paths.Paths, logger loggers.Logger, options ...func(*BaseFs) error) (*BaseFs, error) <span class="cov8" title="1">{
        fs := p.Fs
        if logger == nil </span><span class="cov8" title="1">{
                logger = loggers.NewWarningLogger()
        }</span>

        // Make sure we always have the /public folder ready to use.
        <span class="cov8" title="1">if err := fs.Destination.MkdirAll(p.AbsPublishDir, 0777); err != nil &amp;&amp; !os.IsExist(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">publishFs := hugofs.NewBaseFileDecorator(afero.NewBasePathFs(fs.Destination, p.AbsPublishDir))
        sourceFs := hugofs.NewBaseFileDecorator(afero.NewBasePathFs(fs.Source, p.WorkingDir))

        b := &amp;BaseFs{
                SourceFs:  sourceFs,
                PublishFs: publishFs,
                buildMu:   lockedfile.MutexAt(filepath.Join(p.WorkingDir, lockFileBuild)),
        }

        for _, opt := range options </span><span class="cov0" title="0">{
                if err := opt(b); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if b.theBigFs != nil &amp;&amp; b.SourceFilesystems != nil </span><span class="cov0" title="0">{
                return b, nil
        }</span>

        <span class="cov8" title="1">builder := newSourceFilesystemsBuilder(p, logger, b)
        sourceFilesystems, err := builder.Build()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "build filesystems")
        }</span>

        <span class="cov8" title="1">b.SourceFilesystems = sourceFilesystems
        b.theBigFs = builder.theBigFs

        return b, nil</span>
}

type sourceFilesystemsBuilder struct {
        logger   loggers.Logger
        p        *paths.Paths
        sourceFs afero.Fs
        result   *SourceFilesystems
        theBigFs *filesystemsCollector
}

func newSourceFilesystemsBuilder(p *paths.Paths, logger loggers.Logger, b *BaseFs) *sourceFilesystemsBuilder <span class="cov8" title="1">{
        sourceFs := hugofs.NewBaseFileDecorator(p.Fs.Source)
        return &amp;sourceFilesystemsBuilder{p: p, logger: logger, sourceFs: sourceFs, theBigFs: b.theBigFs, result: &amp;SourceFilesystems{}}
}</span>

func (b *sourceFilesystemsBuilder) newSourceFilesystem(name string, fs afero.Fs, dirs []hugofs.FileMetaInfo) *SourceFilesystem <span class="cov8" title="1">{
        return &amp;SourceFilesystem{
                Name: name,
                Fs:   fs,
                Dirs: dirs,
        }
}</span>

func (b *sourceFilesystemsBuilder) Build() (*SourceFilesystems, error) <span class="cov8" title="1">{
        if b.theBigFs == nil </span><span class="cov8" title="1">{

                theBigFs, err := b.createMainOverlayFs(b.p)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "create main fs")
                }</span>

                <span class="cov8" title="1">b.theBigFs = theBigFs</span>
        }

        <span class="cov8" title="1">createView := func(componentID string) *SourceFilesystem </span><span class="cov8" title="1">{
                if b.theBigFs == nil || b.theBigFs.overlayMounts == nil </span><span class="cov0" title="0">{
                        return b.newSourceFilesystem(componentID, hugofs.NoOpFs, nil)
                }</span>

                <span class="cov8" title="1">dirs := b.theBigFs.overlayDirs[componentID]

                return b.newSourceFilesystem(componentID, afero.NewBasePathFs(b.theBigFs.overlayMounts, componentID), dirs)</span>
        }

        <span class="cov8" title="1">b.theBigFs.finalizeDirs()

        b.result.Archetypes = createView(files.ComponentFolderArchetypes)
        b.result.Layouts = createView(files.ComponentFolderLayouts)
        b.result.Assets = createView(files.ComponentFolderAssets)
        b.result.ResourcesCache = b.theBigFs.overlayResources

        // Data, i18n and content cannot use the overlay fs
        dataDirs := b.theBigFs.overlayDirs[files.ComponentFolderData]
        dataFs, err := hugofs.NewSliceFs(dataDirs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">b.result.Data = b.newSourceFilesystem(files.ComponentFolderData, dataFs, dataDirs)

        i18nDirs := b.theBigFs.overlayDirs[files.ComponentFolderI18n]
        i18nFs, err := hugofs.NewSliceFs(i18nDirs...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">b.result.I18n = b.newSourceFilesystem(files.ComponentFolderI18n, i18nFs, i18nDirs)

        contentDirs := b.theBigFs.overlayDirs[files.ComponentFolderContent]
        contentBfs := afero.NewBasePathFs(b.theBigFs.overlayMountsContent, files.ComponentFolderContent)

        contentFs, err := hugofs.NewLanguageFs(b.p.LanguagesDefaultFirst.AsOrdinalSet(), contentBfs)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "create content filesystem")
        }</span>

        <span class="cov8" title="1">b.result.Content = b.newSourceFilesystem(files.ComponentFolderContent, contentFs, contentDirs)

        b.result.Work = afero.NewReadOnlyFs(b.theBigFs.overlayFull)

        // Create static filesystem(s)
        ms := make(map[string]*SourceFilesystem)
        b.result.Static = ms
        b.result.StaticDirs = b.theBigFs.overlayDirs[files.ComponentFolderStatic]

        if b.theBigFs.staticPerLanguage != nil </span><span class="cov8" title="1">{
                // Multihost mode
                for k, v := range b.theBigFs.staticPerLanguage </span><span class="cov8" title="1">{
                        sfs := b.newSourceFilesystem(files.ComponentFolderStatic, v, b.result.StaticDirs)
                        sfs.PublishFolder = k
                        ms[k] = sfs
                }</span>
        } else<span class="cov8" title="1"> {
                bfs := afero.NewBasePathFs(b.theBigFs.overlayMountsStatic, files.ComponentFolderStatic)
                ms[""] = b.newSourceFilesystem(files.ComponentFolderStatic, bfs, b.result.StaticDirs)
        }</span>

        <span class="cov8" title="1">return b.result, nil</span>
}

func (b *sourceFilesystemsBuilder) createMainOverlayFs(p *paths.Paths) (*filesystemsCollector, error) <span class="cov8" title="1">{
        var staticFsMap map[string]afero.Fs
        if b.p.Cfg.GetBool("multihost") </span><span class="cov8" title="1">{
                staticFsMap = make(map[string]afero.Fs)
        }</span>

        <span class="cov8" title="1">collector := &amp;filesystemsCollector{
                sourceProject:     b.sourceFs,
                sourceModules:     hugofs.NewNoSymlinkFs(b.sourceFs, b.logger, false),
                overlayDirs:       make(map[string][]hugofs.FileMetaInfo),
                staticPerLanguage: staticFsMap,
        }

        mods := p.AllModules

        if len(mods) == 0 </span><span class="cov0" title="0">{
                return collector, nil
        }</span>

        <span class="cov8" title="1">modsReversed := make([]mountsDescriptor, len(mods))

        // The theme components are ordered from left to right.
        // We need to revert it to get the
        // overlay logic below working as expected, with the project on top.
        j := 0
        for i := len(mods) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                mod := mods[i]
                dir := mod.Dir()

                isMainProject := mod.Owner() == nil
                modsReversed[j] = mountsDescriptor{
                        Module:        mod,
                        dir:           dir,
                        isMainProject: isMainProject,
                }
                j++
        }</span>

        <span class="cov8" title="1">err := b.createOverlayFs(collector, modsReversed)

        return collector, err</span>
}

func (b *sourceFilesystemsBuilder) isContentMount(mnt modules.Mount) bool <span class="cov8" title="1">{
        return strings.HasPrefix(mnt.Target, files.ComponentFolderContent)
}</span>

func (b *sourceFilesystemsBuilder) isStaticMount(mnt modules.Mount) bool <span class="cov8" title="1">{
        return strings.HasPrefix(mnt.Target, files.ComponentFolderStatic)
}</span>

func (b *sourceFilesystemsBuilder) createModFs(
        collector *filesystemsCollector,
        md mountsDescriptor) error <span class="cov8" title="1">{
        var (
                fromTo        []hugofs.RootMapping
                fromToContent []hugofs.RootMapping
                fromToStatic  []hugofs.RootMapping
        )

        absPathify := func(path string) (string, string) </span><span class="cov8" title="1">{
                if filepath.IsAbs(path) </span><span class="cov0" title="0">{
                        return "", path
                }</span>
                <span class="cov8" title="1">return md.dir, paths.AbsPathify(md.dir, path)</span>
        }

        <span class="cov8" title="1">for _, mount := range md.Mounts() </span><span class="cov8" title="1">{

                mountWeight := 1
                if md.isMainProject </span><span class="cov8" title="1">{
                        mountWeight++
                }</span>

                <span class="cov8" title="1">inclusionFilter, err := glob.NewFilenameFilter(
                        types.ToStringSlicePreserveString(mount.IncludeFiles),
                        types.ToStringSlicePreserveString(mount.ExcludeFiles),
                )
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">base, filename := absPathify(mount.Source)

                rm := hugofs.RootMapping{
                        From:      mount.Target,
                        To:        filename,
                        ToBasedir: base,
                        Module:    md.Module.Path(),
                        IsProject: md.isMainProject,
                        Meta: &amp;hugofs.FileMeta{
                                Watch:           md.Watch(),
                                Weight:          mountWeight,
                                Classifier:      files.ContentClassContent,
                                InclusionFilter: inclusionFilter,
                        },
                }

                isContentMount := b.isContentMount(mount)

                lang := mount.Lang
                if lang == "" &amp;&amp; isContentMount </span><span class="cov0" title="0">{
                        lang = b.p.DefaultContentLanguage
                }</span>

                <span class="cov8" title="1">rm.Meta.Lang = lang

                if isContentMount </span><span class="cov8" title="1">{
                        fromToContent = append(fromToContent, rm)
                }</span> else<span class="cov8" title="1"> if b.isStaticMount(mount) </span><span class="cov8" title="1">{
                        fromToStatic = append(fromToStatic, rm)
                }</span> else<span class="cov8" title="1"> {
                        fromTo = append(fromTo, rm)
                }</span>
        }

        <span class="cov8" title="1">modBase := collector.sourceProject
        if !md.isMainProject </span><span class="cov8" title="1">{
                modBase = collector.sourceModules
        }</span>
        <span class="cov8" title="1">sourceStatic := hugofs.NewNoSymlinkFs(modBase, b.logger, true)

        rmfs, err := hugofs.NewRootMappingFs(modBase, fromTo...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rmfsContent, err := hugofs.NewRootMappingFs(modBase, fromToContent...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">rmfsStatic, err := hugofs.NewRootMappingFs(sourceStatic, fromToStatic...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // We need to keep the ordered list of directories for watching and
        // some special merge operations (data, i18n).
        <span class="cov8" title="1">collector.addDirs(rmfs)
        collector.addDirs(rmfsContent)
        collector.addDirs(rmfsStatic)

        if collector.staticPerLanguage != nil </span><span class="cov8" title="1">{
                for _, l := range b.p.Languages </span><span class="cov8" title="1">{
                        lang := l.Lang

                        lfs := rmfsStatic.Filter(func(rm hugofs.RootMapping) bool </span><span class="cov8" title="1">{
                                rlang := rm.Meta.Lang
                                return rlang == "" || rlang == lang
                        }</span>)

                        <span class="cov8" title="1">bfs := afero.NewBasePathFs(lfs, files.ComponentFolderStatic)

                        sfs, found := collector.staticPerLanguage[lang]
                        if found </span><span class="cov8" title="1">{
                                collector.staticPerLanguage[lang] = afero.NewCopyOnWriteFs(sfs, bfs)
                        }</span> else<span class="cov8" title="1"> {
                                collector.staticPerLanguage[lang] = bfs
                        }</span>
                }
        }

        <span class="cov8" title="1">getResourcesDir := func() string </span><span class="cov8" title="1">{
                if md.isMainProject </span><span class="cov8" title="1">{
                        return b.p.AbsResourcesDir
                }</span>
                <span class="cov8" title="1">_, filename := absPathify(files.FolderResources)
                return filename</span>
        }

        <span class="cov8" title="1">if collector.overlayMounts == nil </span><span class="cov8" title="1">{
                collector.overlayMounts = rmfs
                collector.overlayMountsContent = rmfsContent
                collector.overlayMountsStatic = rmfsStatic
                collector.overlayFull = afero.NewBasePathFs(modBase, md.dir)
                collector.overlayResources = afero.NewBasePathFs(modBase, getResourcesDir())
        }</span> else<span class="cov8" title="1"> {

                collector.overlayMounts = afero.NewCopyOnWriteFs(collector.overlayMounts, rmfs)
                collector.overlayMountsContent = hugofs.NewLanguageCompositeFs(collector.overlayMountsContent, rmfsContent)
                collector.overlayMountsStatic = hugofs.NewLanguageCompositeFs(collector.overlayMountsStatic, rmfsStatic)
                collector.overlayFull = afero.NewCopyOnWriteFs(collector.overlayFull, afero.NewBasePathFs(modBase, md.dir))
                collector.overlayResources = afero.NewCopyOnWriteFs(collector.overlayResources, afero.NewBasePathFs(modBase, getResourcesDir()))
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func printFs(fs afero.Fs, path string, w io.Writer) <span class="cov0" title="0">{
        if fs == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">afero.Walk(fs, path, func(path string, info os.FileInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if info.IsDir() </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov0" title="0">var filename string
                if fim, ok := info.(hugofs.FileMetaInfo); ok </span><span class="cov0" title="0">{
                        filename = fim.Meta().Filename
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(w, "    %q %q\n", path, filename)
                return nil</span>
        })
}

type filesystemsCollector struct {
        sourceProject afero.Fs // Source for project folders
        sourceModules afero.Fs // Source for modules/themes

        overlayMounts        afero.Fs
        overlayMountsContent afero.Fs
        overlayMountsStatic  afero.Fs
        overlayFull          afero.Fs
        overlayResources     afero.Fs

        // Maps component type (layouts, static, content etc.) an ordered list of
        // directories representing the overlay filesystems above.
        overlayDirs map[string][]hugofs.FileMetaInfo

        // Set if in multihost mode
        staticPerLanguage map[string]afero.Fs

        finalizerInit sync.Once
}

func (c *filesystemsCollector) addDirs(rfs *hugofs.RootMappingFs) <span class="cov8" title="1">{
        for _, componentFolder := range files.ComponentFolders </span><span class="cov8" title="1">{
                c.addDir(rfs, componentFolder)
        }</span>
}

func (c *filesystemsCollector) addDir(rfs *hugofs.RootMappingFs, componentFolder string) <span class="cov8" title="1">{
        dirs, err := rfs.Dirs(componentFolder)

        if err == nil </span><span class="cov8" title="1">{
                c.overlayDirs[componentFolder] = append(c.overlayDirs[componentFolder], dirs...)
        }</span>
}

func (c *filesystemsCollector) finalizeDirs() <span class="cov8" title="1">{
        c.finalizerInit.Do(func() </span><span class="cov8" title="1">{
                // Order the directories from top to bottom (project, theme a, theme ...).
                for _, dirs := range c.overlayDirs </span><span class="cov8" title="1">{
                        c.reverseFis(dirs)
                }</span>
        })
}

func (c *filesystemsCollector) reverseFis(fis []hugofs.FileMetaInfo) <span class="cov8" title="1">{
        for i := len(fis)/2 - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                opp := len(fis) - 1 - i
                fis[i], fis[opp] = fis[opp], fis[i]
        }</span>
}

type mountsDescriptor struct {
        modules.Module
        dir           string
        isMainProject bool
}

func (b *sourceFilesystemsBuilder) createOverlayFs(collector *filesystemsCollector, mounts []mountsDescriptor) error <span class="cov8" title="1">{
        if len(mounts) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">err := b.createModFs(collector, mounts[0])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(mounts) == 1 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return b.createOverlayFs(collector, mounts[1:])</span>
}
</pre>
		
		<pre class="file" id="file111" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "path/filepath"
        "strings"

        "github.com/bep/gitmap"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/resources/page"
)

type gitInfo struct {
        contentDir string
        repo       *gitmap.GitRepo
}

func (g *gitInfo) forPage(p page.Page) *gitmap.GitInfo <span class="cov8" title="1">{
        name := strings.TrimPrefix(filepath.ToSlash(p.File().Filename()), g.contentDir)
        name = strings.TrimPrefix(name, "/")

        return g.repo.Files[name]
}</span>

func newGitInfo(cfg config.Provider) (*gitInfo, error) <span class="cov8" title="1">{
        workingDir := cfg.GetString("workingDir")

        gitRepo, err := gitmap.Map(workingDir, "")
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;gitInfo{contentDir: gitRepo.TopLevelAbsPath, repo: gitRepo}, nil</span>
}
</pre>
		
		<pre class="file" id="file112" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "context"
        "io"
        "path/filepath"
        "sort"
        "strings"
        "sync"
        "sync/atomic"

        "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/fsnotify/fsnotify"

        "github.com/gohugoio/hugo/identity"

        radix "github.com/armon/go-radix"

        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/gohugoio/hugo/common/para"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/source"

        "github.com/bep/gitmap"
        "github.com/gohugoio/hugo/config"

        "github.com/gohugoio/hugo/publisher"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/lazy"

        "github.com/gohugoio/hugo/langs/i18n"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/page/pagemeta"
        "github.com/gohugoio/hugo/tpl"
        "github.com/gohugoio/hugo/tpl/tplimpl"
)

// HugoSites represents the sites to build. Each site represents a language.
type HugoSites struct {
        Sites []*Site

        multilingual *Multilingual

        // Multihost is set if multilingual and baseURL set on the language level.
        multihost bool

        // If this is running in the dev server.
        running bool

        // Render output formats for all sites.
        renderFormats output.Formats

        *deps.Deps

        gitInfo *gitInfo

        // As loaded from the /data dirs
        data map[string]interface{}

        contentInit sync.Once
        content     *pageMaps

        // Keeps track of bundle directories and symlinks to enable partial rebuilding.
        ContentChanges *contentChangeMap

        // File change events with filename stored in this map will be skipped.
        skipRebuildForFilenamesMu sync.Mutex
        skipRebuildForFilenames   map[string]bool

        init *hugoSitesInit

        workers    *para.Workers
        numWorkers int

        *fatalErrorHandler
        *testCounters
}

// ShouldSkipFileChangeEvent allows skipping filesystem event early before
// the build is started.
func (h *HugoSites) ShouldSkipFileChangeEvent(ev fsnotify.Event) bool <span class="cov0" title="0">{
        h.skipRebuildForFilenamesMu.Lock()
        defer h.skipRebuildForFilenamesMu.Unlock()
        return h.skipRebuildForFilenames[ev.Name]
}</span>

func (h *HugoSites) getContentMaps() *pageMaps <span class="cov8" title="1">{
        h.contentInit.Do(func() </span><span class="cov8" title="1">{
                h.content = newPageMaps(h)
        }</span>)
        <span class="cov8" title="1">return h.content</span>
}

// Only used in tests.
type testCounters struct {
        contentRenderCounter uint64
        pageRenderCounter    uint64
}

func (h *testCounters) IncrContentRender() <span class="cov8" title="1">{
        if h == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">atomic.AddUint64(&amp;h.contentRenderCounter, 1)</span>
}

func (h *testCounters) IncrPageRender() <span class="cov8" title="1">{
        if h == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">atomic.AddUint64(&amp;h.pageRenderCounter, 1)</span>
}

type fatalErrorHandler struct {
        mu sync.Mutex

        h *HugoSites

        err error

        done  bool
        donec chan bool // will be closed when done
}

// FatalError error is used in some rare situations where it does not make sense to
// continue processing, to abort as soon as possible and log the error.
func (f *fatalErrorHandler) FatalError(err error) <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()
        if !f.done </span><span class="cov8" title="1">{
                f.done = true
                close(f.donec)
        }</span>
        <span class="cov8" title="1">f.err = err</span>
}

func (f *fatalErrorHandler) getErr() error <span class="cov8" title="1">{
        f.mu.Lock()
        defer f.mu.Unlock()
        return f.err
}</span>

func (f *fatalErrorHandler) Done() &lt;-chan bool <span class="cov8" title="1">{
        return f.donec
}</span>

type hugoSitesInit struct {
        // Loads the data from all of the /data folders.
        data *lazy.Init

        // Performs late initialization (before render) of the templates.
        layouts *lazy.Init

        // Loads the Git info for all the pages if enabled.
        gitInfo *lazy.Init

        // Maps page translations.
        translations *lazy.Init
}

func (h *hugoSitesInit) Reset() <span class="cov8" title="1">{
        h.data.Reset()
        h.layouts.Reset()
        h.gitInfo.Reset()
        h.translations.Reset()
}</span>

func (h *HugoSites) Data() map[string]interface{} <span class="cov8" title="1">{
        if _, err := h.init.data.Do(); err != nil </span><span class="cov0" title="0">{
                h.SendError(errors.Wrap(err, "failed to load data"))
                return nil
        }</span>
        <span class="cov8" title="1">return h.data</span>
}

func (h *HugoSites) gitInfoForPage(p page.Page) (*gitmap.GitInfo, error) <span class="cov8" title="1">{
        if _, err := h.init.gitInfo.Do(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if h.gitInfo == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return h.gitInfo.forPage(p), nil</span>
}

func (h *HugoSites) siteInfos() page.Sites <span class="cov8" title="1">{
        infos := make(page.Sites, len(h.Sites))
        for i, site := range h.Sites </span><span class="cov8" title="1">{
                infos[i] = site.Info
        }</span>
        <span class="cov8" title="1">return infos</span>
}

func (h *HugoSites) pickOneAndLogTheRest(errors []error) error <span class="cov8" title="1">{
        if len(errors) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var i int

        for j, err := range errors </span><span class="cov8" title="1">{
                // If this is in server mode, we want to return an error to the client
                // with a file context, if possible.
                if herrors.UnwrapErrorWithFileContext(err) != nil </span><span class="cov8" title="1">{
                        i = j
                        break</span>
                }
        }

        // Log the rest, but add a threshold to avoid flooding the log.
        <span class="cov8" title="1">const errLogThreshold = 5

        for j, err := range errors </span><span class="cov8" title="1">{
                if j == i || err == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if j &gt;= errLogThreshold </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">h.Log.Errorln(err)</span>
        }

        <span class="cov8" title="1">return errors[i]</span>
}

func (h *HugoSites) IsMultihost() bool <span class="cov8" title="1">{
        return h != nil &amp;&amp; h.multihost
}</span>

// TODO(bep) consolidate
func (h *HugoSites) LanguageSet() map[string]int <span class="cov0" title="0">{
        set := make(map[string]int)
        for i, s := range h.Sites </span><span class="cov0" title="0">{
                set[s.language.Lang] = i
        }</span>
        <span class="cov0" title="0">return set</span>
}

func (h *HugoSites) NumLogErrors() int <span class="cov8" title="1">{
        if h == nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov8" title="1">return int(h.Log.LogCounters().ErrorCounter.Count())</span>
}

func (h *HugoSites) PrintProcessingStats(w io.Writer) <span class="cov0" title="0">{
        stats := make([]*helpers.ProcessingStats, len(h.Sites))
        for i := 0; i &lt; len(h.Sites); i++ </span><span class="cov0" title="0">{
                stats[i] = h.Sites[i].PathSpec.ProcessingStats
        }</span>
        <span class="cov0" title="0">helpers.ProcessingStatsTable(w, stats...)</span>
}

// GetContentPage finds a Page with content given the absolute filename.
// Returns nil if none found.
func (h *HugoSites) GetContentPage(filename string) page.Page <span class="cov8" title="1">{
        var p page.Page

        h.getContentMaps().walkBundles(func(b *contentNode) bool </span><span class="cov8" title="1">{
                if b.p == nil || b.fi == nil </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">if b.fi.Meta().Filename == filename </span><span class="cov8" title="1">{
                        p = b.p
                        return true
                }</span>

                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">return p</span>
}

// NewHugoSites creates a new collection of sites given the input sites, building
// a language configuration based on those.
func newHugoSites(cfg deps.DepsCfg, sites ...*Site) (*HugoSites, error) <span class="cov8" title="1">{
        if cfg.Language != nil </span><span class="cov0" title="0">{
                return nil, errors.New("Cannot provide Language in Cfg when sites are provided")
        }</span>

        // Return error at the end. Make the caller decide if it's fatal or not.
        <span class="cov8" title="1">var initErr error

        langConfig, err := newMultiLingualFromSites(cfg.Cfg, sites...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to create language config")
        }</span>

        <span class="cov8" title="1">var contentChangeTracker *contentChangeMap

        numWorkers := config.GetNumWorkerMultiplier()
        if numWorkers &gt; len(sites) </span><span class="cov8" title="1">{
                numWorkers = len(sites)
        }</span>
        <span class="cov8" title="1">var workers *para.Workers
        if numWorkers &gt; 1 </span><span class="cov8" title="1">{
                workers = para.New(numWorkers)
        }</span>

        <span class="cov8" title="1">h := &amp;HugoSites{
                running:                 cfg.Running,
                multilingual:            langConfig,
                multihost:               cfg.Cfg.GetBool("multihost"),
                Sites:                   sites,
                workers:                 workers,
                numWorkers:              numWorkers,
                skipRebuildForFilenames: make(map[string]bool),
                init: &amp;hugoSitesInit{
                        data:         lazy.New(),
                        layouts:      lazy.New(),
                        gitInfo:      lazy.New(),
                        translations: lazy.New(),
                },
        }

        h.fatalErrorHandler = &amp;fatalErrorHandler{
                h:     h,
                donec: make(chan bool),
        }

        h.init.data.Add(func() (interface{}, error) </span><span class="cov8" title="1">{
                err := h.loadData(h.PathSpec.BaseFs.Data.Dirs)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to load data")
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">h.init.layouts.Add(func() (interface{}, error) </span><span class="cov8" title="1">{
                for _, s := range h.Sites </span><span class="cov8" title="1">{
                        if err := s.Tmpl().(tpl.TemplateManager).MarkReady(); err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">h.init.translations.Add(func() (interface{}, error) </span><span class="cov8" title="1">{
                if len(h.Sites) &gt; 1 </span><span class="cov8" title="1">{
                        allTranslations := pagesToTranslationsMap(h.Sites)
                        assignTranslationsToPages(allTranslations, h.Sites)
                }</span>

                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">h.init.gitInfo.Add(func() (interface{}, error) </span><span class="cov8" title="1">{
                err := h.loadGitInfo()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to load Git info")
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">for _, s := range sites </span><span class="cov8" title="1">{
                s.h = h
        }</span>

        <span class="cov8" title="1">var l configLoader
        if err := l.applyDeps(cfg, sites...); err != nil </span><span class="cov8" title="1">{
                initErr = errors.Wrap(err, "add site dependencies")
        }</span>

        <span class="cov8" title="1">h.Deps = sites[0].Deps

        // Only needed in server mode.
        // TODO(bep) clean up the running vs watching terms
        if cfg.Running </span><span class="cov8" title="1">{
                contentChangeTracker = &amp;contentChangeMap{
                        pathSpec:      h.PathSpec,
                        symContent:    make(map[string]map[string]bool),
                        leafBundles:   radix.New(),
                        branchBundles: make(map[string]bool),
                }
                h.ContentChanges = contentChangeTracker
        }</span>

        <span class="cov8" title="1">return h, initErr</span>
}

func (h *HugoSites) loadGitInfo() error <span class="cov8" title="1">{
        if h.Cfg.GetBool("enableGitInfo") </span><span class="cov8" title="1">{
                gi, err := newGitInfo(h.Cfg)
                if err != nil </span><span class="cov0" title="0">{
                        h.Log.Errorln("Failed to read Git log:", err)
                }</span> else<span class="cov8" title="1"> {
                        h.gitInfo = gi
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (l configLoader) applyDeps(cfg deps.DepsCfg, sites ...*Site) error <span class="cov8" title="1">{
        if cfg.TemplateProvider == nil </span><span class="cov8" title="1">{
                cfg.TemplateProvider = tplimpl.DefaultTemplateProvider
        }</span>

        <span class="cov8" title="1">if cfg.TranslationProvider == nil </span><span class="cov8" title="1">{
                cfg.TranslationProvider = i18n.NewTranslationProvider()
        }</span>

        <span class="cov8" title="1">var (
                d   *deps.Deps
                err error
        )

        for _, s := range sites </span><span class="cov8" title="1">{
                if s.Deps != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">onCreated := func(d *deps.Deps) error </span><span class="cov8" title="1">{
                        s.Deps = d

                        // Set up the main publishing chain.
                        pub, err := publisher.NewDestinationPublisher(
                                d.ResourceSpec,
                                s.outputFormatsConfig,
                                s.mediaTypesConfig,
                        )
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">s.publisher = pub

                        if err := s.initializeSiteInfo(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">d.Site = s.Info

                        siteConfig, err := l.loadSiteConfig(s.language)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "load site config")
                        }</span>
                        <span class="cov8" title="1">s.siteConfigConfig = siteConfig

                        pm := &amp;pageMap{
                                contentMap: newContentMap(contentMapConfig{
                                        lang:                 s.Lang(),
                                        taxonomyConfig:       s.siteCfg.taxonomiesConfig.Values(),
                                        taxonomyDisabled:     !s.isEnabled(page.KindTerm),
                                        taxonomyTermDisabled: !s.isEnabled(page.KindTaxonomy),
                                        pageDisabled:         !s.isEnabled(page.KindPage),
                                }),
                                s: s,
                        }

                        s.PageCollections = newPageCollections(pm)

                        s.siteRefLinker, err = newSiteRefLinker(s.language, s)
                        return err</span>
                }

                <span class="cov8" title="1">cfg.Language = s.language
                cfg.MediaTypes = s.mediaTypesConfig
                cfg.OutputFormats = s.outputFormatsConfig

                if d == nil </span><span class="cov8" title="1">{
                        cfg.WithTemplate = s.withSiteTemplates(cfg.WithTemplate)

                        var err error
                        d, err = deps.New(cfg)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "create deps")
                        }</span>

                        <span class="cov8" title="1">d.OutputFormatsConfig = s.outputFormatsConfig

                        if err := onCreated(d); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "on created")
                        }</span>

                        <span class="cov8" title="1">if err = d.LoadResources(); err != nil </span><span class="cov8" title="1">{
                                return errors.Wrap(err, "load resources")
                        }</span>

                } else<span class="cov8" title="1"> {
                        d, err = d.ForLanguage(cfg, onCreated)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">d.OutputFormatsConfig = s.outputFormatsConfig</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// NewHugoSites creates HugoSites from the given config.
func NewHugoSites(cfg deps.DepsCfg) (*HugoSites, error) <span class="cov8" title="1">{
        if cfg.Logger == nil </span><span class="cov8" title="1">{
                cfg.Logger = loggers.NewErrorLogger()
        }</span>
        <span class="cov8" title="1">sites, err := createSitesFromConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "from config")
        }</span>
        <span class="cov8" title="1">return newHugoSites(cfg, sites...)</span>
}

func (s *Site) withSiteTemplates(withTemplates ...func(templ tpl.TemplateManager) error) func(templ tpl.TemplateManager) error <span class="cov8" title="1">{
        return func(templ tpl.TemplateManager) error </span><span class="cov8" title="1">{
                for _, wt := range withTemplates </span><span class="cov8" title="1">{
                        if wt == nil </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if err := wt(templ); err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">return nil</span>
        }
}

func createSitesFromConfig(cfg deps.DepsCfg) ([]*Site, error) <span class="cov8" title="1">{
        var sites []*Site

        languages := getLanguages(cfg.Cfg)

        for _, lang := range languages </span><span class="cov8" title="1">{
                if lang.Disabled </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">var s *Site
                var err error
                cfg.Language = lang
                s, err = newSite(cfg)

                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">sites = append(sites, s)</span>
        }

        <span class="cov8" title="1">return sites, nil</span>
}

// Reset resets the sites and template caches etc., making it ready for a full rebuild.
func (h *HugoSites) reset(config *BuildCfg) <span class="cov8" title="1">{
        if config.ResetState </span><span class="cov0" title="0">{
                for i, s := range h.Sites </span><span class="cov0" title="0">{
                        h.Sites[i] = s.reset()
                        if r, ok := s.Fs.Destination.(hugofs.Reseter); ok </span><span class="cov0" title="0">{
                                r.Reset()
                        }</span>
                }
        }

        <span class="cov8" title="1">h.fatalErrorHandler = &amp;fatalErrorHandler{
                h:     h,
                donec: make(chan bool),
        }

        h.init.Reset()</span>
}

// resetLogs resets the log counters etc. Used to do a new build on the same sites.
func (h *HugoSites) resetLogs() <span class="cov8" title="1">{
        h.Log.Reset()
        loggers.GlobalErrorCounter.Reset()
        for _, s := range h.Sites </span><span class="cov8" title="1">{
                s.Deps.Log.Reset()
                s.Deps.LogDistinct.Reset()
        }</span>
}

func (h *HugoSites) withSite(fn func(s *Site) error) error <span class="cov8" title="1">{
        if h.workers == nil </span><span class="cov8" title="1">{
                for _, s := range h.Sites </span><span class="cov8" title="1">{
                        if err := fn(s); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">g, _ := h.workers.Start(context.Background())
        for _, s := range h.Sites </span><span class="cov8" title="1">{
                s := s
                g.Run(func() error </span><span class="cov8" title="1">{
                        return fn(s)
                }</span>)
        }
        <span class="cov8" title="1">return g.Wait()</span>
}

func (h *HugoSites) createSitesFromConfig(cfg config.Provider) error <span class="cov0" title="0">{
        oldLangs, _ := h.Cfg.Get("languagesSorted").(langs.Languages)

        l := configLoader{cfg: h.Cfg}
        if err := l.loadLanguageSettings(oldLangs); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">depsCfg := deps.DepsCfg{Fs: h.Fs, Cfg: l.cfg}

        sites, err := createSitesFromConfig(depsCfg)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">langConfig, err := newMultiLingualFromSites(depsCfg.Cfg, sites...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">h.Sites = sites

        for _, s := range sites </span><span class="cov0" title="0">{
                s.h = h
        }</span>

        <span class="cov0" title="0">var cl configLoader
        if err := cl.applyDeps(depsCfg, sites...); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">h.Deps = sites[0].Deps

        h.multilingual = langConfig
        h.multihost = h.Deps.Cfg.GetBool("multihost")

        return nil</span>
}

func (h *HugoSites) toSiteInfos() []*SiteInfo <span class="cov8" title="1">{
        infos := make([]*SiteInfo, len(h.Sites))
        for i, s := range h.Sites </span><span class="cov8" title="1">{
                infos[i] = s.Info
        }</span>
        <span class="cov8" title="1">return infos</span>
}

// BuildCfg holds build options used to, as an example, skip the render step.
type BuildCfg struct {
        // Reset site state before build. Use to force full rebuilds.
        ResetState bool
        // If set, we re-create the sites from the given configuration before a build.
        // This is needed if new languages are added.
        NewConfig config.Provider
        // Skip rendering. Useful for testing.
        SkipRender bool
        // Use this to indicate what changed (for rebuilds).
        whatChanged *whatChanged

        // This is a partial re-render of some selected pages. This means
        // we should skip most of the processing.
        PartialReRender bool

        // Set in server mode when the last build failed for some reason.
        ErrRecovery bool

        // Recently visited URLs. This is used for partial re-rendering.
        RecentlyVisited map[string]bool

        // Can be set to build only with a sub set of the content source.
        ContentInclusionFilter *glob.FilenameFilter

        // Set when the buildlock is already acquired (e.g. the archetype content builder).
        NoBuildLock bool

        testCounters *testCounters
}

// shouldRender is used in the Fast Render Mode to determine if we need to re-render
// a Page: If it is recently visited (the home pages will always be in this set) or changed.
// Note that a page does not have to have a content page / file.
// For regular builds, this will allways return true.
// TODO(bep) rename/work this.
func (cfg *BuildCfg) shouldRender(p *pageState) bool <span class="cov8" title="1">{
        if p.forceRender </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if len(cfg.RecentlyVisited) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">if cfg.RecentlyVisited[p.RelPermalink()] </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if cfg.whatChanged != nil &amp;&amp; !p.File().IsZero() </span><span class="cov0" title="0">{
                return cfg.whatChanged.files[p.File().Filename()]
        }</span>

        <span class="cov0" title="0">return false</span>
}

func (h *HugoSites) renderCrossSitesSitemap() error <span class="cov8" title="1">{
        if !h.multilingual.enabled() || h.IsMultihost() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">sitemapEnabled := false
        for _, s := range h.Sites </span><span class="cov8" title="1">{
                if s.isEnabled(kindSitemap) </span><span class="cov8" title="1">{
                        sitemapEnabled = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !sitemapEnabled </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">s := h.Sites[0]

        templ := s.lookupLayouts("sitemapindex.xml", "_default/sitemapindex.xml", "_internal/_default/sitemapindex.xml")

        return s.renderAndWriteXML(&amp;s.PathSpec.ProcessingStats.Sitemaps, "sitemapindex",
                s.siteCfg.sitemap.Filename, h.toSiteInfos(), templ)</span>
}

func (h *HugoSites) renderCrossSitesRobotsTXT() error <span class="cov8" title="1">{
        if h.multihost </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if !h.Cfg.GetBool("enableRobotsTXT") </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">s := h.Sites[0]

        p, err := newPageStandalone(&amp;pageMeta{
                s:    s,
                kind: kindRobotsTXT,
                urlPaths: pagemeta.URLPath{
                        URL: "robots.txt",
                },
        },
                output.RobotsTxtFormat)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !p.render </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">templ := s.lookupLayouts("robots.txt", "_default/robots.txt", "_internal/_default/robots.txt")

        return s.renderAndWritePage(&amp;s.PathSpec.ProcessingStats.Pages, "Robots Txt", "robots.txt", p, templ)</span>
}

func (h *HugoSites) removePageByFilename(filename string) <span class="cov8" title="1">{
        h.getContentMaps().withMaps(func(m *pageMap) error </span><span class="cov8" title="1">{
                m.deleteBundleMatching(func(b *contentNode) bool </span><span class="cov8" title="1">{
                        if b.p == nil </span><span class="cov8" title="1">{
                                return false
                        }</span>

                        <span class="cov8" title="1">if b.fi == nil </span><span class="cov8" title="1">{
                                return false
                        }</span>

                        <span class="cov8" title="1">return b.fi.Meta().Filename == filename</span>
                })
                <span class="cov8" title="1">return nil</span>
        })
}

func (h *HugoSites) createPageCollections() error <span class="cov8" title="1">{
        allPages := newLazyPagesFactory(func() page.Pages </span><span class="cov8" title="1">{
                var pages page.Pages
                for _, s := range h.Sites </span><span class="cov8" title="1">{
                        pages = append(pages, s.Pages()...)
                }</span>

                <span class="cov8" title="1">page.SortByDefault(pages)

                return pages</span>
        })

        <span class="cov8" title="1">allRegularPages := newLazyPagesFactory(func() page.Pages </span><span class="cov0" title="0">{
                return h.findPagesByKindIn(page.KindPage, allPages.get())
        }</span>)

        <span class="cov8" title="1">for _, s := range h.Sites </span><span class="cov8" title="1">{
                s.PageCollections.allPages = allPages
                s.PageCollections.allRegularPages = allRegularPages
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *Site) preparePagesForRender(isRenderingSite bool, idx int) error <span class="cov8" title="1">{
        var err error
        s.pageMap.withEveryBundlePage(func(p *pageState) bool </span><span class="cov8" title="1">{
                if err = p.initOutputFormat(isRenderingSite, idx); err != nil </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov8" title="1">return false</span>
        })
        <span class="cov8" title="1">return nil</span>
}

// Pages returns all pages for all sites.
func (h *HugoSites) Pages() page.Pages <span class="cov0" title="0">{
        return h.Sites[0].AllPages()
}</span>

func (h *HugoSites) loadData(fis []hugofs.FileMetaInfo) (err error) <span class="cov8" title="1">{
        spec := source.NewSourceSpec(h.PathSpec, nil, nil)

        h.data = make(map[string]interface{})
        for _, fi := range fis </span><span class="cov8" title="1">{
                fileSystem := spec.NewFilesystemFromFileMetaInfo(fi)
                files, err := fileSystem.Files()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, r := range files </span><span class="cov8" title="1">{
                        if err := h.handleDataFile(r); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return</span>
}

func (h *HugoSites) handleDataFile(r source.File) error <span class="cov8" title="1">{
        var current map[string]interface{}

        f, err := r.FileInfo().Meta().Open()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "data: failed to open %q:", r.LogicalName())
        }</span>
        <span class="cov8" title="1">defer f.Close()

        // Crawl in data tree to insert data
        current = h.data
        keyParts := strings.Split(r.Dir(), helpers.FilePathSeparator)

        for _, key := range keyParts </span><span class="cov8" title="1">{
                if key != "" </span><span class="cov8" title="1">{
                        if _, ok := current[key]; !ok </span><span class="cov8" title="1">{
                                current[key] = make(map[string]interface{})
                        }</span>
                        <span class="cov8" title="1">current = current[key].(map[string]interface{})</span>
                }
        }

        <span class="cov8" title="1">data, err := h.readData(r)
        if err != nil </span><span class="cov0" title="0">{
                return h.errWithFileContext(err, r)
        }</span>

        <span class="cov8" title="1">if data == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        // filepath.Walk walks the files in lexical order, '/' comes before '.'
        <span class="cov8" title="1">higherPrecedentData := current[r.BaseFileName()]

        switch data.(type) </span>{
        case nil:<span class="cov0" title="0"></span>
        case map[string]interface{}:<span class="cov8" title="1">

                switch higherPrecedentData.(type) </span>{
                case nil:<span class="cov8" title="1">
                        current[r.BaseFileName()] = data</span>
                case map[string]interface{}:<span class="cov8" title="1">
                        // merge maps: insert entries from data for keys that
                        // don't already exist in higherPrecedentData
                        higherPrecedentMap := higherPrecedentData.(map[string]interface{})
                        for key, value := range data.(map[string]interface{}) </span><span class="cov8" title="1">{
                                if _, exists := higherPrecedentMap[key]; exists </span><span class="cov8" title="1">{
                                        // this warning could happen if
                                        // 1. A theme uses the same key; the main data folder wins
                                        // 2. A sub folder uses the same key: the sub folder wins
                                        // TODO(bep) figure out a way to detect 2) above and make that a WARN
                                        h.Log.Infof("Data for key '%s' in path '%s' is overridden by higher precedence data already in the data tree", key, r.Path())
                                }</span> else<span class="cov8" title="1"> {
                                        higherPrecedentMap[key] = value
                                }</span>
                        }
                default:<span class="cov8" title="1">
                        // can't merge: higherPrecedentData is not a map
                        h.Log.Warnf("The %T data from '%s' overridden by "+
                                "higher precedence %T data already in the data tree", data, r.Path(), higherPrecedentData)</span>
                }

        case []interface{}:<span class="cov8" title="1">
                if higherPrecedentData == nil </span><span class="cov8" title="1">{
                        current[r.BaseFileName()] = data
                }</span> else<span class="cov8" title="1"> {
                        // we don't merge array data
                        h.Log.Warnf("The %T data from '%s' overridden by "+
                                "higher precedence %T data already in the data tree", data, r.Path(), higherPrecedentData)
                }</span>

        default:<span class="cov0" title="0">
                h.Log.Errorf("unexpected data type %T in file %s", data, r.LogicalName())</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (h *HugoSites) errWithFileContext(err error, f source.File) error <span class="cov0" title="0">{
        fim, ok := f.FileInfo().(hugofs.FileMetaInfo)
        if !ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">realFilename := fim.Meta().Filename

        err, _ = herrors.WithFileContextForFile(
                err,
                realFilename,
                realFilename,
                h.SourceSpec.Fs.Source,
                herrors.SimpleLineMatcher)

        return err</span>
}

func (h *HugoSites) readData(f source.File) (interface{}, error) <span class="cov8" title="1">{
        file, err := f.FileInfo().Meta().Open()
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "readData: failed to open data file")
        }</span>
        <span class="cov8" title="1">defer file.Close()
        content := helpers.ReaderToBytes(file)

        format := metadecoders.FormatFromString(f.Extension())
        return metadecoders.Default.Unmarshal(content, format)</span>
}

func (h *HugoSites) findPagesByKindIn(kind string, inPages page.Pages) page.Pages <span class="cov0" title="0">{
        return h.Sites[0].findPagesByKindIn(kind, inPages)
}</span>

func (h *HugoSites) resetPageState() <span class="cov8" title="1">{
        h.getContentMaps().walkBundles(func(n *contentNode) bool </span><span class="cov8" title="1">{
                if n.p == nil </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">p := n.p
                for _, po := range p.pageOutputs </span><span class="cov8" title="1">{
                        if po.cp == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">po.cp.Reset()</span>
                }

                <span class="cov8" title="1">return false</span>
        })
}

func (h *HugoSites) resetPageStateFromEvents(idset identity.Identities) <span class="cov8" title="1">{
        h.getContentMaps().walkBundles(func(n *contentNode) bool </span><span class="cov8" title="1">{
                if n.p == nil </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">p := n.p
        OUTPUTS:
                for _, po := range p.pageOutputs </span><span class="cov8" title="1">{
                        if po.cp == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">for id := range idset </span><span class="cov8" title="1">{
                                if po.cp.dependencyTracker.Search(id) != nil </span><span class="cov8" title="1">{
                                        po.cp.Reset()
                                        continue OUTPUTS</span>
                                }
                        }
                }

                <span class="cov8" title="1">if p.shortcodeState == nil </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">for _, s := range p.shortcodeState.shortcodes </span><span class="cov8" title="1">{
                        for _, templ := range s.templs </span><span class="cov8" title="1">{
                                sid := templ.(identity.Manager)
                                for id := range idset </span><span class="cov8" title="1">{
                                        if sid.Search(id) != nil </span><span class="cov8" title="1">{
                                                for _, po := range p.pageOutputs </span><span class="cov8" title="1">{
                                                        if po.cp != nil </span><span class="cov8" title="1">{
                                                                po.cp.Reset()
                                                        }</span>
                                                }
                                                <span class="cov8" title="1">return false</span>
                                        }
                                }
                        }
                }
                <span class="cov8" title="1">return false</span>
        })
}

// Used in partial reloading to determine if the change is in a bundle.
type contentChangeMap struct {
        mu sync.RWMutex

        // Holds directories with leaf bundles.
        leafBundles *radix.Tree

        // Holds directories with branch bundles.
        branchBundles map[string]bool

        pathSpec *helpers.PathSpec

        // Hugo supports symlinked content (both directories and files). This
        // can lead to situations where the same file can be referenced from several
        // locations in /content -- which is really cool, but also means we have to
        // go an extra mile to handle changes.
        // This map is only used in watch mode.
        // It maps either file to files or the real dir to a set of content directories
        // where it is in use.
        symContentMu sync.Mutex
        symContent   map[string]map[string]bool
}

func (m *contentChangeMap) add(dirname string, tp bundleDirType) <span class="cov8" title="1">{
        m.mu.Lock()
        if !strings.HasSuffix(dirname, helpers.FilePathSeparator) </span><span class="cov8" title="1">{
                dirname += helpers.FilePathSeparator
        }</span>
        <span class="cov8" title="1">switch tp </span>{
        case bundleBranch:<span class="cov8" title="1">
                m.branchBundles[dirname] = true</span>
        case bundleLeaf:<span class="cov8" title="1">
                m.leafBundles.Insert(dirname, true)</span>
        default:<span class="cov0" title="0">
                m.mu.Unlock()
                panic("invalid bundle type")</span>
        }
        <span class="cov8" title="1">m.mu.Unlock()</span>
}

func (m *contentChangeMap) resolveAndRemove(filename string) (string, bundleDirType) <span class="cov8" title="1">{
        m.mu.RLock()
        defer m.mu.RUnlock()

        // Bundles share resources, so we need to start from the virtual root.
        relFilename := m.pathSpec.RelContentDir(filename)
        dir, name := filepath.Split(relFilename)
        if !strings.HasSuffix(dir, helpers.FilePathSeparator) </span><span class="cov8" title="1">{
                dir += helpers.FilePathSeparator
        }</span>

        <span class="cov8" title="1">if _, found := m.branchBundles[dir]; found </span><span class="cov8" title="1">{
                delete(m.branchBundles, dir)
                return dir, bundleBranch
        }</span>

        <span class="cov8" title="1">if key, _, found := m.leafBundles.LongestPrefix(dir); found </span><span class="cov8" title="1">{
                m.leafBundles.Delete(key)
                dir = string(key)
                return dir, bundleLeaf
        }</span>

        <span class="cov8" title="1">fileTp, isContent := classifyBundledFile(name)
        if isContent &amp;&amp; fileTp != bundleNot </span><span class="cov0" title="0">{
                // A new bundle.
                return dir, fileTp
        }</span>

        <span class="cov8" title="1">return dir, bundleNot</span>
}

func (m *contentChangeMap) addSymbolicLinkMapping(fim hugofs.FileMetaInfo) <span class="cov8" title="1">{
        meta := fim.Meta()
        if !meta.IsSymlink </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov0" title="0">m.symContentMu.Lock()

        from, to := meta.Filename, meta.OriginalFilename
        if fim.IsDir() </span><span class="cov0" title="0">{
                if !strings.HasSuffix(from, helpers.FilePathSeparator) </span><span class="cov0" title="0">{
                        from += helpers.FilePathSeparator
                }</span>
        }

        <span class="cov0" title="0">mm, found := m.symContent[from]

        if !found </span><span class="cov0" title="0">{
                mm = make(map[string]bool)
                m.symContent[from] = mm
        }</span>
        <span class="cov0" title="0">mm[to] = true
        m.symContentMu.Unlock()</span>
}

func (m *contentChangeMap) GetSymbolicLinkMappings(dir string) []string <span class="cov0" title="0">{
        mm, found := m.symContent[dir]
        if !found </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">dirs := make([]string, len(mm))
        i := 0
        for dir := range mm </span><span class="cov0" title="0">{
                dirs[i] = dir
                i++
        }</span>

        <span class="cov0" title="0">sort.Strings(dirs)

        return dirs</span>
}
</pre>
		
		<pre class="file" id="file113" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
        "runtime/trace"
        "strings"

        "github.com/gohugoio/hugo/publisher"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/common/para"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/resources/postpub"

        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/output"

        "github.com/pkg/errors"

        "github.com/fsnotify/fsnotify"
        "github.com/gohugoio/hugo/helpers"
)

// Build builds all sites. If filesystem events are provided,
// this is considered to be a potential partial rebuild.
func (h *HugoSites) Build(config BuildCfg, events ...fsnotify.Event) error <span class="cov8" title="1">{
        ctx, task := trace.NewTask(context.Background(), "Build")
        defer task.End()

        if !config.NoBuildLock </span><span class="cov8" title="1">{
                unlock, err := h.BaseFs.LockBuild()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to acquire a build lock")
                }</span>
                <span class="cov8" title="1">defer unlock()</span>
        }

        <span class="cov8" title="1">errCollector := h.StartErrorCollector()
        errs := make(chan error)

        go func(from, to chan error) </span><span class="cov8" title="1">{
                var errors []error
                i := 0
                for e := range from </span><span class="cov8" title="1">{
                        i++
                        if i &gt; 50 </span><span class="cov0" title="0">{
                                break</span>
                        }
                        <span class="cov8" title="1">errors = append(errors, e)</span>
                }
                <span class="cov8" title="1">to &lt;- h.pickOneAndLogTheRest(errors)

                close(to)</span>
        }(errCollector, errs)

        <span class="cov8" title="1">if h.Metrics != nil </span><span class="cov0" title="0">{
                h.Metrics.Reset()
        }</span>

        <span class="cov8" title="1">h.testCounters = config.testCounters

        // Need a pointer as this may be modified.
        conf := &amp;config

        if conf.whatChanged == nil </span><span class="cov8" title="1">{
                // Assume everything has changed
                conf.whatChanged = &amp;whatChanged{source: true}
        }</span>

        <span class="cov8" title="1">var prepareErr error

        if !config.PartialReRender </span><span class="cov8" title="1">{
                prepare := func() error </span><span class="cov8" title="1">{
                        init := func(conf *BuildCfg) error </span><span class="cov8" title="1">{
                                for _, s := range h.Sites </span><span class="cov8" title="1">{
                                        s.Deps.BuildStartListeners.Notify()
                                }</span>

                                <span class="cov8" title="1">if len(events) &gt; 0 </span><span class="cov8" title="1">{
                                        // Rebuild
                                        if err := h.initRebuild(conf); err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "initRebuild")
                                        }</span>
                                } else<span class="cov0" title="0"> {
                                        if err := h.initSites(conf); err != nil </span><span class="cov0" title="0">{
                                                return errors.Wrap(err, "initSites")
                                        }</span>
                                }

                                <span class="cov8" title="1">return nil</span>
                        }

                        <span class="cov8" title="1">var err error

                        f := func() </span><span class="cov8" title="1">{
                                err = h.process(conf, init, events...)
                        }</span>
                        <span class="cov8" title="1">trace.WithRegion(ctx, "process", f)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "process")
                        }</span>

                        <span class="cov8" title="1">f = func() </span><span class="cov8" title="1">{
                                err = h.assemble(conf)
                        }</span>
                        <span class="cov8" title="1">trace.WithRegion(ctx, "assemble", f)
                        if err != nil </span><span class="cov8" title="1">{
                                return err
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                }

                <span class="cov8" title="1">f := func() </span><span class="cov8" title="1">{
                        prepareErr = prepare()
                }</span>
                <span class="cov8" title="1">trace.WithRegion(ctx, "prepare", f)
                if prepareErr != nil </span><span class="cov8" title="1">{
                        h.SendError(prepareErr)
                }</span>

        }

        <span class="cov8" title="1">if prepareErr == nil </span><span class="cov8" title="1">{
                var err error
                f := func() </span><span class="cov8" title="1">{
                        err = h.render(conf)
                }</span>
                <span class="cov8" title="1">trace.WithRegion(ctx, "render", f)
                if err != nil </span><span class="cov8" title="1">{
                        h.SendError(err)
                }</span>

                <span class="cov8" title="1">if err = h.postProcess(); err != nil </span><span class="cov0" title="0">{
                        h.SendError(err)
                }</span>
        }

        <span class="cov8" title="1">if h.Metrics != nil </span><span class="cov0" title="0">{
                var b bytes.Buffer
                h.Metrics.WriteMetrics(&amp;b)

                h.Log.Printf("\nTemplate Metrics:\n\n")
                h.Log.Println(b.String())
        }</span>

        <span class="cov8" title="1">select </span>{
        // Make sure the channel always gets something.
        case errCollector &lt;- nil:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0"></span>
        }
        <span class="cov8" title="1">close(errCollector)

        err := &lt;-errs
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := h.fatalErrorHandler.getErr(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">errorCount := h.Log.LogCounters().ErrorCounter.Count()
        if errorCount &gt; 0 </span><span class="cov8" title="1">{
                return fmt.Errorf("logged %d error(s)", errorCount)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Build lifecycle methods below.
// The order listed matches the order of execution.

func (h *HugoSites) initSites(config *BuildCfg) error <span class="cov0" title="0">{
        h.reset(config)

        if config.NewConfig != nil </span><span class="cov0" title="0">{
                if err := h.createSitesFromConfig(config.NewConfig); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (h *HugoSites) initRebuild(config *BuildCfg) error <span class="cov8" title="1">{
        if config.NewConfig != nil </span><span class="cov0" title="0">{
                return errors.New("rebuild does not support 'NewConfig'")
        }</span>

        <span class="cov8" title="1">if config.ResetState </span><span class="cov0" title="0">{
                return errors.New("rebuild does not support 'ResetState'")
        }</span>

        <span class="cov8" title="1">if !h.running </span><span class="cov0" title="0">{
                return errors.New("rebuild called when not in watch mode")
        }</span>

        <span class="cov8" title="1">for _, s := range h.Sites </span><span class="cov8" title="1">{
                s.resetBuildState(config.whatChanged.source)
        }</span>

        <span class="cov8" title="1">h.reset(config)
        h.resetLogs()
        helpers.InitLoggers()

        return nil</span>
}

func (h *HugoSites) process(config *BuildCfg, init func(config *BuildCfg) error, events ...fsnotify.Event) error <span class="cov8" title="1">{
        // We should probably refactor the Site and pull up most of the logic from there to here,
        // but that seems like a daunting task.
        // So for now, if there are more than one site (language),
        // we pre-process the first one, then configure all the sites based on that.

        firstSite := h.Sites[0]

        if len(events) &gt; 0 </span><span class="cov8" title="1">{
                // This is a rebuild
                return firstSite.processPartial(config, init, events)
        }</span>

        <span class="cov8" title="1">return firstSite.process(*config)</span>
}

func (h *HugoSites) assemble(bcfg *BuildCfg) error <span class="cov8" title="1">{
        if len(h.Sites) &gt; 1 </span><span class="cov8" title="1">{
                // The first is initialized during process; initialize the rest
                for _, site := range h.Sites[1:] </span><span class="cov8" title="1">{
                        if err := site.initializeSiteInfo(); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">if !bcfg.whatChanged.source </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if err := h.getContentMaps().AssemblePages(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if err := h.createPageCollections(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (h *HugoSites) render(config *BuildCfg) error <span class="cov8" title="1">{
        if _, err := h.init.layouts.Do(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">siteRenderContext := &amp;siteRenderContext{cfg: config, multihost: h.multihost}

        if !config.PartialReRender </span><span class="cov8" title="1">{
                h.renderFormats = output.Formats{}
                h.withSite(func(s *Site) error </span><span class="cov8" title="1">{
                        s.initRenderFormats()
                        return nil
                }</span>)

                <span class="cov8" title="1">for _, s := range h.Sites </span><span class="cov8" title="1">{
                        h.renderFormats = append(h.renderFormats, s.renderFormats...)
                }</span>
        }

        <span class="cov8" title="1">i := 0
        for _, s := range h.Sites </span><span class="cov8" title="1">{
                for siteOutIdx, renderFormat := range s.renderFormats </span><span class="cov8" title="1">{
                        siteRenderContext.outIdx = siteOutIdx
                        siteRenderContext.sitesOutIdx = i
                        i++

                        select </span>{
                        case &lt;-h.Done():<span class="cov8" title="1">
                                return nil</span>
                        default:<span class="cov8" title="1">
                                for _, s2 := range h.Sites </span><span class="cov8" title="1">{
                                        // We render site by site, but since the content is lazily rendered
                                        // and a site can "borrow" content from other sites, every site
                                        // needs this set.
                                        s2.rc = &amp;siteRenderingContext{Format: renderFormat}

                                        if err := s2.preparePagesForRender(s == s2, siteRenderContext.sitesOutIdx); err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                }

                                <span class="cov8" title="1">if !config.SkipRender </span><span class="cov8" title="1">{
                                        if config.PartialReRender </span><span class="cov0" title="0">{
                                                if err := s.renderPages(siteRenderContext); err != nil </span><span class="cov0" title="0">{
                                                        return err
                                                }</span>
                                        } else<span class="cov8" title="1"> {
                                                if err := s.render(siteRenderContext); err != nil </span><span class="cov8" title="1">{
                                                        return err
                                                }</span>
                                        }
                                }
                        }

                }
        }

        <span class="cov8" title="1">if !config.SkipRender </span><span class="cov8" title="1">{
                if err := h.renderCrossSitesSitemap(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if err := h.renderCrossSitesRobotsTXT(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (h *HugoSites) postProcess() error <span class="cov8" title="1">{
        // Make sure to write any build stats to disk first so it's available
        // to the post processors.
        if err := h.writeBuildStats(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // This will only be set when js.Build have been triggered with
        // imports that resolves to the project or a module.
        // Write a jsconfig.json file to the project's /asset directory
        // to help JS intellisense in VS Code etc.
        <span class="cov8" title="1">if !h.ResourceSpec.BuildConfig.NoJSConfigInAssets &amp;&amp; h.BaseFs.Assets.Dirs != nil </span><span class="cov8" title="1">{
                fi, err := h.BaseFs.Assets.Fs.Stat("")
                if err != nil </span><span class="cov0" title="0">{
                        h.Log.Warnf("Failed to resolve jsconfig.json dir: %s", err)
                }</span> else<span class="cov8" title="1"> {
                        m := fi.(hugofs.FileMetaInfo).Meta()
                        assetsDir := m.SourceRoot
                        if strings.HasPrefix(assetsDir, h.ResourceSpec.WorkingDir) </span><span class="cov8" title="1">{
                                if jsConfig := h.ResourceSpec.JSConfigBuilder.Build(assetsDir); jsConfig != nil </span><span class="cov0" title="0">{

                                        b, err := json.MarshalIndent(jsConfig, "", " ")
                                        if err != nil </span><span class="cov0" title="0">{
                                                h.Log.Warnf("Failed to create jsconfig.json: %s", err)
                                        }</span> else<span class="cov0" title="0"> {
                                                filename := filepath.Join(assetsDir, "jsconfig.json")
                                                if h.running </span><span class="cov0" title="0">{
                                                        h.skipRebuildForFilenamesMu.Lock()
                                                        h.skipRebuildForFilenames[filename] = true
                                                        h.skipRebuildForFilenamesMu.Unlock()
                                                }</span>
                                                // Make sure it's  written to the OS fs as this is used by
                                                // editors.
                                                <span class="cov0" title="0">if err := afero.WriteFile(hugofs.Os, filename, b, 0666); err != nil </span><span class="cov0" title="0">{
                                                        h.Log.Warnf("Failed to write jsconfig.json: %s", err)
                                                }</span>
                                        }
                                }
                        }

                }
        }

        <span class="cov8" title="1">var toPostProcess []postpub.PostPublishedResource
        for _, r := range h.ResourceSpec.PostProcessResources </span><span class="cov8" title="1">{
                toPostProcess = append(toPostProcess, r)
        }</span>

        <span class="cov8" title="1">if len(toPostProcess) == 0 </span><span class="cov8" title="1">{
                // Nothing more to do.
                return nil
        }</span>

        <span class="cov8" title="1">workers := para.New(config.GetNumWorkerMultiplier())
        g, _ := workers.Start(context.Background())

        handleFile := func(filename string) error </span><span class="cov8" title="1">{
                content, err := afero.ReadFile(h.BaseFs.PublishFs, filename)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">k := 0
                changed := false

                for </span><span class="cov8" title="1">{
                        l := bytes.Index(content[k:], []byte(postpub.PostProcessPrefix))
                        if l == -1 </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">m := bytes.Index(content[k+l:], []byte(postpub.PostProcessSuffix)) + len(postpub.PostProcessSuffix)

                        low, high := k+l, k+l+m

                        field := content[low:high]

                        forward := l + m

                        for i, r := range toPostProcess </span><span class="cov8" title="1">{
                                if r == nil </span><span class="cov0" title="0">{
                                        panic(fmt.Sprintf("resource %d to post process is nil", i+1))</span>
                                }
                                <span class="cov8" title="1">v, ok := r.GetFieldString(string(field))
                                if ok </span><span class="cov8" title="1">{
                                        content = append(content[:low], append([]byte(v), content[high:]...)...)
                                        changed = true
                                        forward = len(v)
                                        break</span>
                                }
                        }

                        <span class="cov8" title="1">k += forward</span>
                }

                <span class="cov8" title="1">if changed </span><span class="cov8" title="1">{
                        return afero.WriteFile(h.BaseFs.PublishFs, filename, content, 0666)
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">_ = afero.Walk(h.BaseFs.PublishFs, "", func(path string, info os.FileInfo, err error) error </span><span class="cov8" title="1">{
                if info == nil || info.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">if !strings.HasSuffix(path, "html") </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">g.Run(func() error </span><span class="cov8" title="1">{
                        return handleFile(path)
                }</span>)

                <span class="cov8" title="1">return nil</span>
        })

        // Prepare for a new build.
        <span class="cov8" title="1">for _, s := range h.Sites </span><span class="cov8" title="1">{
                s.ResourceSpec.PostProcessResources = make(map[string]postpub.PostPublishedResource)
        }</span>

        <span class="cov8" title="1">return g.Wait()</span>
}

type publishStats struct {
        CSSClasses string `json:"cssClasses"`
}

func (h *HugoSites) writeBuildStats() error <span class="cov8" title="1">{
        if !h.ResourceSpec.BuildConfig.WriteStats </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">htmlElements := &amp;publisher.HTMLElements{}
        for _, s := range h.Sites </span><span class="cov8" title="1">{
                stats := s.publisher.PublishStats()
                htmlElements.Merge(stats.HTMLElements)
        }</span>

        <span class="cov8" title="1">htmlElements.Sort()

        stats := publisher.PublishStats{
                HTMLElements: *htmlElements,
        }

        js, err := json.MarshalIndent(stats, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">filename := filepath.Join(h.WorkingDir, "hugo_stats.json")

        // Make sure it's always written to the OS fs.
        if err := afero.WriteFile(hugofs.Os, filename, js, 0666); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write to the destination, too, if a mem fs is in play.
        <span class="cov8" title="1">if h.Fs.Source != hugofs.Os </span><span class="cov8" title="1">{
                if err := afero.WriteFile(h.Fs.Destination, filename, js, 0666); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file114" style="display: none">package hugolib

import (
        "bytes"
        "fmt"
        "io"
        "os"
        "path/filepath"
        "strings"
        "sync"
        "testing"

        jww "github.com/spf13/jwalterweatherman"

        qt "github.com/frankban/quicktest"
        "github.com/fsnotify/fsnotify"
        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/hexec"
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/config/security"
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/htesting"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/spf13/afero"
        "golang.org/x/tools/txtar"
)

func NewIntegrationTestBuilder(conf IntegrationTestConfig) *IntegrationTestBuilder <span class="cov0" title="0">{
        data := txtar.Parse([]byte(conf.TxtarString))

        c, ok := conf.T.(*qt.C)
        if !ok </span><span class="cov0" title="0">{
                c = qt.New(conf.T)
        }</span>

        <span class="cov0" title="0">if conf.NeedsOsFS </span><span class="cov0" title="0">{
                doClean := true
                tempDir, clean, err := htesting.CreateTempDir(hugofs.Os, "hugo-integration-test")
                c.Assert(err, qt.IsNil)
                conf.WorkingDir = filepath.Join(tempDir, conf.WorkingDir)
                if doClean </span><span class="cov0" title="0">{
                        c.Cleanup(clean)
                }</span>
        }

        <span class="cov0" title="0">return &amp;IntegrationTestBuilder{
                Cfg:  conf,
                C:    c,
                data: data,
        }</span>
}

// IntegrationTestBuilder is a (partial) rewrite of sitesBuilder.
// The main problem with the "old" one was that it was that the test data was often a little hidden,
// so it became hard to look at a test and determine what it should do, especially coming back to the
// test after a year or so.
type IntegrationTestBuilder struct {
        *qt.C

        data *txtar.Archive

        fs *hugofs.Fs
        H  *HugoSites

        Cfg IntegrationTestConfig

        changedFiles []string
        createdFiles []string
        removedFiles []string
        renamedFiles []string

        buildCount int
        counters   *testCounters
        logBuff    lockingBuffer

        builderInit sync.Once
}

type lockingBuffer struct {
        sync.Mutex
        bytes.Buffer
}

func (b *lockingBuffer) Write(p []byte) (n int, err error) <span class="cov0" title="0">{
        b.Lock()
        n, err = b.Buffer.Write(p)
        b.Unlock()
        return
}</span>

func (s *IntegrationTestBuilder) AssertLogContains(text string) <span class="cov0" title="0">{
        s.Helper()
        s.Assert(s.logBuff.String(), qt.Contains, text)
}</span>

func (s *IntegrationTestBuilder) AssertBuildCountData(count int) <span class="cov0" title="0">{
        s.Helper()
        s.Assert(s.H.init.data.InitCount(), qt.Equals, count)
}</span>

func (s *IntegrationTestBuilder) AssertBuildCountGitInfo(count int) <span class="cov0" title="0">{
        s.Helper()
        s.Assert(s.H.init.gitInfo.InitCount(), qt.Equals, count)
}</span>

func (s *IntegrationTestBuilder) AssertBuildCountLayouts(count int) <span class="cov0" title="0">{
        s.Helper()
        s.Assert(s.H.init.layouts.InitCount(), qt.Equals, count)
}</span>

func (s *IntegrationTestBuilder) AssertBuildCountTranslations(count int) <span class="cov0" title="0">{
        s.Helper()
        s.Assert(s.H.init.translations.InitCount(), qt.Equals, count)
}</span>

func (s *IntegrationTestBuilder) AssertFileContent(filename string, matches ...string) <span class="cov0" title="0">{
        s.Helper()
        content := strings.TrimSpace(s.FileContent(filename))
        for _, m := range matches </span><span class="cov0" title="0">{
                lines := strings.Split(m, "\n")
                for _, match := range lines </span><span class="cov0" title="0">{
                        match = strings.TrimSpace(match)
                        if match == "" || strings.HasPrefix(match, "#") </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">s.Assert(content, qt.Contains, match, qt.Commentf(content))</span>
                }
        }
}

func (s *IntegrationTestBuilder) AssertDestinationExists(filename string, b bool) <span class="cov0" title="0">{
        checker := qt.IsTrue
        if !b </span><span class="cov0" title="0">{
                checker = qt.IsFalse
        }</span>
        <span class="cov0" title="0">s.Assert(s.destinationExists(filepath.Clean(filename)), checker)</span>
}

func (s *IntegrationTestBuilder) destinationExists(filename string) bool <span class="cov0" title="0">{
        b, err := helpers.Exists(filename, s.fs.Destination)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">return b</span>
}

func (s *IntegrationTestBuilder) AssertIsFileError(err error) <span class="cov0" title="0">{
        var ferr *herrors.ErrorWithFileContext
        s.Assert(err, qt.ErrorAs, &amp;ferr)
}</span>

func (s *IntegrationTestBuilder) AssertRenderCountContent(count int) <span class="cov0" title="0">{
        s.Helper()
        s.Assert(s.counters.contentRenderCounter, qt.Equals, uint64(count))
}</span>

func (s *IntegrationTestBuilder) AssertRenderCountPage(count int) <span class="cov0" title="0">{
        s.Helper()
        s.Assert(s.counters.pageRenderCounter, qt.Equals, uint64(count))
}</span>

func (s *IntegrationTestBuilder) Build() *IntegrationTestBuilder <span class="cov0" title="0">{
        s.Helper()
        _, err := s.BuildE()
        if s.Cfg.Verbose </span><span class="cov0" title="0">{
                fmt.Println(s.logBuff.String())
        }</span>
        <span class="cov0" title="0">s.Assert(err, qt.IsNil)
        return s</span>
}

func (s *IntegrationTestBuilder) BuildE() (*IntegrationTestBuilder, error) <span class="cov0" title="0">{
        s.Helper()
        s.initBuilder()
        err := s.build(BuildCfg{})
        return s, err
}</span>

type IntegrationTestDebugConfig struct {
        Out io.Writer

        PrintDestinationFs bool
        PrintPagemap       bool

        PrefixDestinationFs string
        PrefixPagemap       string
}

func (s *IntegrationTestBuilder) EditFileReplace(filename string, replacementFunc func(s string) string) *IntegrationTestBuilder <span class="cov0" title="0">{
        absFilename := s.absFilename(filename)
        b, err := afero.ReadFile(s.fs.Source, absFilename)
        s.Assert(err, qt.IsNil)
        s.changedFiles = append(s.changedFiles, absFilename)
        oldContent := string(b)
        s.writeSource(absFilename, replacementFunc(oldContent))
        return s
}</span>

func (s *IntegrationTestBuilder) EditFiles(filenameContent ...string) *IntegrationTestBuilder <span class="cov0" title="0">{
        for i := 0; i &lt; len(filenameContent); i += 2 </span><span class="cov0" title="0">{
                filename, content := filepath.FromSlash(filenameContent[i]), filenameContent[i+1]
                absFilename := s.absFilename(filename)
                s.changedFiles = append(s.changedFiles, absFilename)
                s.writeSource(absFilename, content)
        }</span>
        <span class="cov0" title="0">return s</span>
}

func (s *IntegrationTestBuilder) AddFiles(filenameContent ...string) *IntegrationTestBuilder <span class="cov0" title="0">{
        for i := 0; i &lt; len(filenameContent); i += 2 </span><span class="cov0" title="0">{
                filename, content := filepath.FromSlash(filenameContent[i]), filenameContent[i+1]
                absFilename := s.absFilename(filename)
                s.createdFiles = append(s.createdFiles, absFilename)
                s.writeSource(absFilename, content)
        }</span>
        <span class="cov0" title="0">return s</span>
}

func (s *IntegrationTestBuilder) RemoveFiles(filenames ...string) *IntegrationTestBuilder <span class="cov0" title="0">{
        for _, filename := range filenames </span><span class="cov0" title="0">{
                absFilename := s.absFilename(filename)
                s.removedFiles = append(s.removedFiles, absFilename)
                s.Assert(s.fs.Source.Remove(absFilename), qt.IsNil)

        }</span>

        <span class="cov0" title="0">return s</span>
}

func (s *IntegrationTestBuilder) RenameFile(old, new string) *IntegrationTestBuilder <span class="cov0" title="0">{
        absOldFilename := s.absFilename(old)
        absNewFilename := s.absFilename(new)
        s.renamedFiles = append(s.renamedFiles, absOldFilename)
        s.createdFiles = append(s.createdFiles, absNewFilename)
        s.Assert(s.fs.Source.Rename(absOldFilename, absNewFilename), qt.IsNil)
        return s
}</span>

func (s *IntegrationTestBuilder) FileContent(filename string) string <span class="cov0" title="0">{
        s.Helper()
        filename = filepath.FromSlash(filename)
        if !strings.HasPrefix(filename, s.Cfg.WorkingDir) </span><span class="cov0" title="0">{
                filename = filepath.Join(s.Cfg.WorkingDir, filename)
        }</span>
        <span class="cov0" title="0">return s.readDestination(s, s.fs, filename)</span>
}

func (s *IntegrationTestBuilder) initBuilder() <span class="cov0" title="0">{
        s.builderInit.Do(func() </span><span class="cov0" title="0">{
                var afs afero.Fs
                if s.Cfg.NeedsOsFS </span><span class="cov0" title="0">{
                        afs = afero.NewOsFs()
                }</span> else<span class="cov0" title="0"> {
                        afs = afero.NewMemMapFs()
                }</span>

                <span class="cov0" title="0">if s.Cfg.LogLevel == 0 </span><span class="cov0" title="0">{
                        s.Cfg.LogLevel = jww.LevelWarn
                }</span>

                <span class="cov0" title="0">logger := loggers.NewBasicLoggerForWriter(s.Cfg.LogLevel, &amp;s.logBuff)

                fs := hugofs.NewFrom(afs, config.New())

                for _, f := range s.data.Files </span><span class="cov0" title="0">{
                        filename := filepath.Join(s.Cfg.WorkingDir, f.Name)
                        s.Assert(afs.MkdirAll(filepath.Dir(filename), 0777), qt.IsNil)
                        s.Assert(afero.WriteFile(afs, filename, bytes.TrimSuffix(f.Data, []byte("\n")), 0666), qt.IsNil)
                }</span>

                <span class="cov0" title="0">cfg, _, err := LoadConfig(
                        ConfigSourceDescriptor{
                                WorkingDir: s.Cfg.WorkingDir,
                                Fs:         afs,
                                Logger:     logger,
                                Environ:    []string{},
                                Filename:   "config.toml",
                        },
                        func(cfg config.Provider) error </span><span class="cov0" title="0">{
                                return nil
                        }</span>,
                )

                <span class="cov0" title="0">s.Assert(err, qt.IsNil)

                cfg.Set("workingDir", s.Cfg.WorkingDir)

                depsCfg := deps.DepsCfg{Cfg: cfg, Fs: fs, Running: s.Cfg.Running, Logger: logger}
                sites, err := NewHugoSites(depsCfg)
                s.Assert(err, qt.IsNil)

                s.H = sites
                s.fs = fs

                if s.Cfg.NeedsNpmInstall </span><span class="cov0" title="0">{
                        wd, _ := os.Getwd()
                        s.Assert(os.Chdir(s.Cfg.WorkingDir), qt.IsNil)
                        s.C.Cleanup(func() </span><span class="cov0" title="0">{ os.Chdir(wd) }</span>)
                        <span class="cov0" title="0">sc := security.DefaultConfig
                        sc.Exec.Allow = security.NewWhitelist("npm")
                        ex := hexec.New(sc)
                        command, err := ex.New("npm", "install")
                        s.Assert(err, qt.IsNil)
                        s.Assert(command.Run(), qt.IsNil)</span>

                }
        })
}

func (s *IntegrationTestBuilder) absFilename(filename string) string <span class="cov0" title="0">{
        filename = filepath.FromSlash(filename)
        if filepath.IsAbs(filename) </span><span class="cov0" title="0">{
                return filename
        }</span>
        <span class="cov0" title="0">if s.Cfg.WorkingDir != "" &amp;&amp; !strings.HasPrefix(filename, s.Cfg.WorkingDir) </span><span class="cov0" title="0">{
                filename = filepath.Join(s.Cfg.WorkingDir, filename)
        }</span>
        <span class="cov0" title="0">return filename</span>
}

func (s *IntegrationTestBuilder) build(cfg BuildCfg) error <span class="cov0" title="0">{
        s.Helper()
        defer func() </span><span class="cov0" title="0">{
                s.changedFiles = nil
                s.createdFiles = nil
                s.removedFiles = nil
                s.renamedFiles = nil
        }</span>()

        <span class="cov0" title="0">changeEvents := s.changeEvents()
        s.logBuff.Reset()
        s.counters = &amp;testCounters{}
        cfg.testCounters = s.counters

        if s.buildCount &gt; 0 &amp;&amp; (len(changeEvents) == 0) </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">s.buildCount++

        err := s.H.Build(cfg, changeEvents...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">logErrorCount := s.H.NumLogErrors()
        if logErrorCount &gt; 0 </span><span class="cov0" title="0">{
                return fmt.Errorf("logged %d error(s): %s", logErrorCount, s.logBuff.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (s *IntegrationTestBuilder) changeEvents() []fsnotify.Event <span class="cov0" title="0">{
        var events []fsnotify.Event
        for _, v := range s.removedFiles </span><span class="cov0" title="0">{
                events = append(events, fsnotify.Event{
                        Name: v,
                        Op:   fsnotify.Remove,
                })
        }</span>
        <span class="cov0" title="0">for _, v := range s.renamedFiles </span><span class="cov0" title="0">{
                events = append(events, fsnotify.Event{
                        Name: v,
                        Op:   fsnotify.Rename,
                })
        }</span>
        <span class="cov0" title="0">for _, v := range s.changedFiles </span><span class="cov0" title="0">{
                events = append(events, fsnotify.Event{
                        Name: v,
                        Op:   fsnotify.Write,
                })
        }</span>
        <span class="cov0" title="0">for _, v := range s.createdFiles </span><span class="cov0" title="0">{
                events = append(events, fsnotify.Event{
                        Name: v,
                        Op:   fsnotify.Create,
                })
        }</span>

        <span class="cov0" title="0">return events</span>
}

func (s *IntegrationTestBuilder) readDestination(t testing.TB, fs *hugofs.Fs, filename string) string <span class="cov0" title="0">{
        t.Helper()
        return s.readFileFromFs(t, fs.Destination, filename)
}</span>

func (s *IntegrationTestBuilder) readFileFromFs(t testing.TB, fs afero.Fs, filename string) string <span class="cov0" title="0">{
        t.Helper()
        filename = filepath.Clean(filename)
        b, err := afero.ReadFile(fs, filename)
        if err != nil </span><span class="cov0" title="0">{
                // Print some debug info
                hadSlash := strings.HasPrefix(filename, helpers.FilePathSeparator)
                start := 0
                if hadSlash </span><span class="cov0" title="0">{
                        start = 1
                }</span>
                <span class="cov0" title="0">end := start + 1

                parts := strings.Split(filename, helpers.FilePathSeparator)
                if parts[start] == "work" </span><span class="cov0" title="0">{
                        end++
                }</span>

                <span class="cov0" title="0">s.Assert(err, qt.IsNil)</span>

        }
        <span class="cov0" title="0">return string(b)</span>
}

func (s *IntegrationTestBuilder) writeSource(filename, content string) <span class="cov0" title="0">{
        s.Helper()
        s.writeToFs(s.fs.Source, filename, content)
}</span>

func (s *IntegrationTestBuilder) writeToFs(fs afero.Fs, filename, content string) <span class="cov0" title="0">{
        s.Helper()
        if err := afero.WriteFile(fs, filepath.FromSlash(filename), []byte(content), 0755); err != nil </span><span class="cov0" title="0">{
                s.Fatalf("Failed to write file: %s", err)
        }</span>
}

type IntegrationTestConfig struct {
        T testing.TB

        // The files to use on txtar format, see
        // https://pkg.go.dev/golang.org/x/exp/cmd/txtar
        TxtarString string

        // Whether to simulate server mode.
        Running bool

        // Will print the log buffer after the build
        Verbose bool

        LogLevel jww.Threshold

        // Whether it needs the real file system (e.g. for js.Build tests).
        NeedsOsFS bool

        // Whether to run npm install before Build.
        NeedsNpmInstall bool

        WorkingDir string
}
</pre>
		
		<pre class="file" id="file115" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "errors"
        "sync"

        "github.com/gohugoio/hugo/langs"

        "github.com/gohugoio/hugo/config"
)

// Multilingual manages the all languages used in a multilingual site.
type Multilingual struct {
        Languages langs.Languages

        DefaultLang *langs.Language

        langMap     map[string]*langs.Language
        langMapInit sync.Once
}

// Language returns the Language associated with the given string.
func (ml *Multilingual) Language(lang string) *langs.Language <span class="cov0" title="0">{
        ml.langMapInit.Do(func() </span><span class="cov0" title="0">{
                ml.langMap = make(map[string]*langs.Language)
                for _, l := range ml.Languages </span><span class="cov0" title="0">{
                        ml.langMap[l.Lang] = l
                }</span>
        })
        <span class="cov0" title="0">return ml.langMap[lang]</span>
}

func getLanguages(cfg config.Provider) langs.Languages <span class="cov8" title="1">{
        if cfg.IsSet("languagesSorted") </span><span class="cov8" title="1">{
                return cfg.Get("languagesSorted").(langs.Languages)
        }</span>

        <span class="cov0" title="0">return langs.Languages{langs.NewDefaultLanguage(cfg)}</span>
}

func newMultiLingualFromSites(cfg config.Provider, sites ...*Site) (*Multilingual, error) <span class="cov8" title="1">{
        languages := make(langs.Languages, len(sites))

        for i, s := range sites </span><span class="cov8" title="1">{
                if s.language == nil </span><span class="cov0" title="0">{
                        return nil, errors.New("missing language for site")
                }</span>
                <span class="cov8" title="1">languages[i] = s.language</span>
        }

        <span class="cov8" title="1">defaultLang := cfg.GetString("defaultContentLanguage")

        if defaultLang == "" </span><span class="cov0" title="0">{
                defaultLang = "en"
        }</span>

        <span class="cov8" title="1">return &amp;Multilingual{Languages: languages, DefaultLang: langs.NewLanguage(defaultLang, cfg)}, nil</span>
}

func (ml *Multilingual) enabled() bool <span class="cov8" title="1">{
        return len(ml.Languages) &gt; 1
}</span>

func (s *Site) multilingualEnabled() bool <span class="cov8" title="1">{
        if s.h == nil </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">return s.h.multilingual != nil &amp;&amp; s.h.multilingual.enabled()</span>
}
</pre>
		
		<pre class="file" id="file116" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "bytes"
        "fmt"
        "os"
        "path"
        "path/filepath"
        "sort"
        "strings"

        "github.com/gohugoio/hugo/identity"

        "github.com/gohugoio/hugo/markup/converter"

        "github.com/gohugoio/hugo/tpl"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/bep/gitmap"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/gohugoio/hugo/parser/pageparser"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/output"

        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/source"

        "github.com/gohugoio/hugo/common/collections"
        "github.com/gohugoio/hugo/common/text"
        "github.com/gohugoio/hugo/markup/converter/hooks"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"
)

var (
        _ page.Page           = (*pageState)(nil)
        _ collections.Grouper = (*pageState)(nil)
        _ collections.Slicer  = (*pageState)(nil)
)

var (
        pageTypesProvider = resource.NewResourceTypesProvider(media.OctetType, pageResourceType)
        nopPageOutput     = &amp;pageOutput{
                pagePerOutputProviders:  nopPagePerOutput,
                ContentProvider:         page.NopPage,
                TableOfContentsProvider: page.NopPage,
        }
)

// pageContext provides contextual information about this page, for error
// logging and similar.
type pageContext interface {
        posOffset(offset int) text.Position
        wrapError(err error) error
        getContentConverter() converter.Converter
        addDependency(dep identity.Provider)
}

// wrapErr adds some context to the given error if possible.
func wrapErr(err error, ctx interface{}) error <span class="cov0" title="0">{
        if pc, ok := ctx.(pageContext); ok </span><span class="cov0" title="0">{
                return pc.wrapError(err)
        }</span>
        <span class="cov0" title="0">return err</span>
}

type pageSiteAdapter struct {
        p page.Page
        s *Site
}

func (pa pageSiteAdapter) GetPageWithTemplateInfo(info tpl.Info, ref string) (page.Page, error) <span class="cov8" title="1">{
        p, err := pa.GetPage(ref)
        if p != nil </span><span class="cov8" title="1">{
                // Track pages referenced by templates/shortcodes
                // when in server mode.
                if im, ok := info.(identity.Manager); ok </span><span class="cov8" title="1">{
                        im.Add(p)
                }</span>
        }
        <span class="cov8" title="1">return p, err</span>
}

func (pa pageSiteAdapter) GetPage(ref string) (page.Page, error) <span class="cov8" title="1">{
        p, err := pa.s.getPageNew(pa.p, ref)
        if p == nil </span><span class="cov8" title="1">{
                // The nil struct has meaning in some situations, mostly to avoid breaking
                // existing sites doing $nilpage.IsDescendant($p), which will always return
                // false.
                p = page.NilPage
        }</span>
        <span class="cov8" title="1">return p, err</span>
}

type pageState struct {
        // This slice will be of same length as the number of global slice of output
        // formats (for all sites).
        pageOutputs []*pageOutput

        // This will be shifted out when we start to render a new output format.
        *pageOutput

        // Common for all output formats.
        *pageCommon
}

func (p *pageState) Err() error <span class="cov0" title="0">{
        return nil
}</span>

// Eq returns whether the current page equals the given page.
// This is what's invoked when doing `{{ if eq $page $otherPage }}`
func (p *pageState) Eq(other interface{}) bool <span class="cov8" title="1">{
        pp, err := unwrapPage(other)
        if err != nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return p == pp</span>
}

func (p *pageState) GetIdentity() identity.Identity <span class="cov8" title="1">{
        return identity.NewPathIdentity(files.ComponentFolderContent, filepath.FromSlash(p.Pathc()))
}</span>

func (p *pageState) GitInfo() *gitmap.GitInfo <span class="cov8" title="1">{
        return p.gitInfo
}</span>

// GetTerms gets the terms defined on this page in the given taxonomy.
// The pages returned will be ordered according to the front matter.
func (p *pageState) GetTerms(taxonomy string) page.Pages <span class="cov8" title="1">{
        if p.treeRef == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">m := p.s.pageMap

        taxonomy = strings.ToLower(taxonomy)
        prefix := cleanSectionTreeKey(taxonomy)
        self := strings.TrimPrefix(p.treeRef.key, "/")

        var pas page.Pages

        m.taxonomies.WalkQuery(pageMapQuery{Prefix: prefix}, func(s string, n *contentNode) bool </span><span class="cov8" title="1">{
                key := s + self
                if tn, found := m.taxonomyEntries.Get(key); found </span><span class="cov8" title="1">{
                        vi := tn.(*contentNode).viewInfo
                        pas = append(pas, pageWithOrdinal{pageState: n.p, ordinal: vi.ordinal})
                }</span>
                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">page.SortByDefault(pas)

        return pas</span>
}

func (p *pageState) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return page.MarshalPageToJSON(p)
}</span>

func (p *pageState) getPages() page.Pages <span class="cov8" title="1">{
        b := p.bucket
        if b == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return b.getPages()</span>
}

func (p *pageState) getPagesRecursive() page.Pages <span class="cov8" title="1">{
        b := p.bucket
        if b == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return b.getPagesRecursive()</span>
}

func (p *pageState) getPagesAndSections() page.Pages <span class="cov8" title="1">{
        b := p.bucket
        if b == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return b.getPagesAndSections()</span>
}

func (p *pageState) RegularPagesRecursive() page.Pages <span class="cov8" title="1">{
        p.regularPagesRecursiveInit.Do(func() </span><span class="cov8" title="1">{
                var pages page.Pages
                switch p.Kind() </span>{
                case page.KindSection:<span class="cov8" title="1">
                        pages = p.getPagesRecursive()</span>
                default:<span class="cov8" title="1">
                        pages = p.RegularPages()</span>
                }
                <span class="cov8" title="1">p.regularPagesRecursive = pages</span>
        })
        <span class="cov8" title="1">return p.regularPagesRecursive</span>
}

func (p *pageState) PagesRecursive() page.Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *pageState) RegularPages() page.Pages <span class="cov8" title="1">{
        p.regularPagesInit.Do(func() </span><span class="cov8" title="1">{
                var pages page.Pages

                switch p.Kind() </span>{
                case page.KindPage:<span class="cov8" title="1"></span>
                case page.KindSection, page.KindHome, page.KindTaxonomy:<span class="cov8" title="1">
                        pages = p.getPages()</span>
                case page.KindTerm:<span class="cov8" title="1">
                        all := p.Pages()
                        for _, p := range all </span><span class="cov8" title="1">{
                                if p.IsPage() </span><span class="cov8" title="1">{
                                        pages = append(pages, p)
                                }</span>
                        }
                default:<span class="cov0" title="0">
                        pages = p.s.RegularPages()</span>
                }

                <span class="cov8" title="1">p.regularPages = pages</span>
        })

        <span class="cov8" title="1">return p.regularPages</span>
}

func (p *pageState) Pages() page.Pages <span class="cov8" title="1">{
        p.pagesInit.Do(func() </span><span class="cov8" title="1">{
                var pages page.Pages

                switch p.Kind() </span>{
                case page.KindPage:<span class="cov8" title="1"></span>
                case page.KindSection, page.KindHome:<span class="cov8" title="1">
                        pages = p.getPagesAndSections()</span>
                case page.KindTerm:<span class="cov8" title="1">
                        pages = p.bucket.getTaxonomyEntries()</span>
                case page.KindTaxonomy:<span class="cov8" title="1">
                        pages = p.bucket.getTaxonomies()</span>
                default:<span class="cov8" title="1">
                        pages = p.s.Pages()</span>
                }

                <span class="cov8" title="1">p.pages = pages</span>
        })

        <span class="cov8" title="1">return p.pages</span>
}

// RawContent returns the un-rendered source content without
// any leading front matter.
func (p *pageState) RawContent() string <span class="cov8" title="1">{
        if p.source.parsed == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov8" title="1">start := p.source.posMainContent
        if start == -1 </span><span class="cov0" title="0">{
                start = 0
        }</span>
        <span class="cov8" title="1">return string(p.source.parsed.Input()[start:])</span>
}

func (p *pageState) sortResources() <span class="cov8" title="1">{
        sort.SliceStable(p.resources, func(i, j int) bool </span><span class="cov8" title="1">{
                ri, rj := p.resources[i], p.resources[j]
                if ri.ResourceType() &lt; rj.ResourceType() </span><span class="cov8" title="1">{
                        return true
                }</span>

                <span class="cov8" title="1">p1, ok1 := ri.(page.Page)
                p2, ok2 := rj.(page.Page)

                if ok1 != ok2 </span><span class="cov8" title="1">{
                        return ok2
                }</span>

                <span class="cov8" title="1">if ok1 </span><span class="cov8" title="1">{
                        return page.DefaultPageSort(p1, p2)
                }</span>

                // Make sure not to use RelPermalink or any of the other methods that
                // trigger lazy publishing.
                <span class="cov8" title="1">return ri.Name() &lt; rj.Name()</span>
        })
}

func (p *pageState) Resources() resource.Resources <span class="cov8" title="1">{
        p.resourcesInit.Do(func() </span><span class="cov8" title="1">{
                p.sortResources()
                if len(p.m.resourcesMetadata) &gt; 0 </span><span class="cov8" title="1">{
                        resources.AssignMetadata(p.m.resourcesMetadata, p.resources...)
                        p.sortResources()
                }</span>
        })
        <span class="cov8" title="1">return p.resources</span>
}

func (p *pageState) HasShortcode(name string) bool <span class="cov8" title="1">{
        if p.shortcodeState == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">return p.shortcodeState.nameSet[name]</span>
}

func (p *pageState) Site() page.Site <span class="cov8" title="1">{
        return p.s.Info
}</span>

func (p *pageState) String() string <span class="cov8" title="1">{
        if sourceRef := p.sourceRef(); sourceRef != "" </span><span class="cov8" title="1">{
                return fmt.Sprintf("Page(%s)", sourceRef)
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("Page(%q)", p.Title())</span>
}

// IsTranslated returns whether this content file is translated to
// other language(s).
func (p *pageState) IsTranslated() bool <span class="cov8" title="1">{
        p.s.h.init.translations.Do()
        return len(p.translations) &gt; 0
}</span>

// TranslationKey returns the key used to map language translations of this page.
// It will use the translationKey set in front matter if set, or the content path and
// filename (excluding any language code and extension), e.g. "about/index".
// The Page Kind is always prepended.
func (p *pageState) TranslationKey() string <span class="cov8" title="1">{
        p.translationKeyInit.Do(func() </span><span class="cov8" title="1">{
                if p.m.translationKey != "" </span><span class="cov8" title="1">{
                        p.translationKey = p.Kind() + "/" + p.m.translationKey
                }</span> else<span class="cov8" title="1"> if p.IsPage() &amp;&amp; !p.File().IsZero() </span><span class="cov8" title="1">{
                        p.translationKey = path.Join(p.Kind(), filepath.ToSlash(p.File().Dir()), p.File().TranslationBaseName())
                }</span> else<span class="cov8" title="1"> if p.IsNode() </span><span class="cov8" title="1">{
                        p.translationKey = path.Join(p.Kind(), p.SectionsPath())
                }</span>
        })

        <span class="cov8" title="1">return p.translationKey</span>
}

// AllTranslations returns all translations, including the current Page.
func (p *pageState) AllTranslations() page.Pages <span class="cov8" title="1">{
        p.s.h.init.translations.Do()
        return p.allTranslations
}</span>

// Translations returns the translations excluding the current Page.
func (p *pageState) Translations() page.Pages <span class="cov8" title="1">{
        p.s.h.init.translations.Do()
        return p.translations
}</span>

func (ps *pageState) initCommonProviders(pp pagePaths) error <span class="cov8" title="1">{
        if ps.IsPage() </span><span class="cov8" title="1">{
                ps.posNextPrev = &amp;nextPrev{init: ps.s.init.prevNext}
                ps.posNextPrevSection = &amp;nextPrev{init: ps.s.init.prevNextInSection}
                ps.InSectionPositioner = newPagePositionInSection(ps.posNextPrevSection)
                ps.Positioner = newPagePosition(ps.posNextPrev)
        }</span>

        <span class="cov8" title="1">ps.OutputFormatsProvider = pp
        ps.targetPathDescriptor = pp.targetPathDescriptor
        ps.RefProvider = newPageRef(ps)
        ps.SitesProvider = ps.s.Info

        return nil</span>
}

func (p *pageState) createRenderHooks(f output.Format) (hooks.Renderers, error) <span class="cov8" title="1">{
        layoutDescriptor := p.getLayoutDescriptor()
        layoutDescriptor.RenderingHook = true
        layoutDescriptor.LayoutOverride = false
        layoutDescriptor.Layout = ""

        var renderers hooks.Renderers

        layoutDescriptor.Kind = "render-link"
        templ, templFound, err := p.s.Tmpl().LookupLayout(layoutDescriptor, f)
        if err != nil </span><span class="cov0" title="0">{
                return renderers, err
        }</span>
        <span class="cov8" title="1">if templFound </span><span class="cov8" title="1">{
                renderers.LinkRenderer = hookRenderer{
                        templateHandler: p.s.Tmpl(),
                        SearchProvider:  templ.(identity.SearchProvider),
                        templ:           templ,
                }
        }</span>

        <span class="cov8" title="1">layoutDescriptor.Kind = "render-image"
        templ, templFound, err = p.s.Tmpl().LookupLayout(layoutDescriptor, f)
        if err != nil </span><span class="cov0" title="0">{
                return renderers, err
        }</span>
        <span class="cov8" title="1">if templFound </span><span class="cov8" title="1">{
                renderers.ImageRenderer = hookRenderer{
                        templateHandler: p.s.Tmpl(),
                        SearchProvider:  templ.(identity.SearchProvider),
                        templ:           templ,
                }
        }</span>

        <span class="cov8" title="1">layoutDescriptor.Kind = "render-heading"
        templ, templFound, err = p.s.Tmpl().LookupLayout(layoutDescriptor, f)
        if err != nil </span><span class="cov0" title="0">{
                return renderers, err
        }</span>
        <span class="cov8" title="1">if templFound </span><span class="cov8" title="1">{
                renderers.HeadingRenderer = hookRenderer{
                        templateHandler: p.s.Tmpl(),
                        SearchProvider:  templ.(identity.SearchProvider),
                        templ:           templ,
                }
        }</span>

        <span class="cov8" title="1">return renderers, nil</span>
}

func (p *pageState) getLayoutDescriptor() output.LayoutDescriptor <span class="cov8" title="1">{
        p.layoutDescriptorInit.Do(func() </span><span class="cov8" title="1">{
                var section string
                sections := p.SectionsEntries()

                switch p.Kind() </span>{
                case page.KindSection:<span class="cov8" title="1">
                        if len(sections) &gt; 0 </span><span class="cov8" title="1">{
                                section = sections[0]
                        }</span>
                case page.KindTaxonomy, page.KindTerm:<span class="cov8" title="1">
                        b := p.getTreeRef().n
                        section = b.viewInfo.name.singular</span>
                default:<span class="cov8" title="1"></span>
                }

                <span class="cov8" title="1">p.layoutDescriptor = output.LayoutDescriptor{
                        Kind:    p.Kind(),
                        Type:    p.Type(),
                        Lang:    p.Language().Lang,
                        Layout:  p.Layout(),
                        Section: section,
                }</span>
        })

        <span class="cov8" title="1">return p.layoutDescriptor</span>
}

func (p *pageState) resolveTemplate(layouts ...string) (tpl.Template, bool, error) <span class="cov8" title="1">{
        f := p.outputFormat()

        if len(layouts) == 0 </span><span class="cov8" title="1">{
                selfLayout := p.selfLayoutForOutput(f)
                if selfLayout != "" </span><span class="cov0" title="0">{
                        templ, found := p.s.Tmpl().Lookup(selfLayout)
                        return templ, found, nil
                }</span>
        }

        <span class="cov8" title="1">d := p.getLayoutDescriptor()

        if len(layouts) &gt; 0 </span><span class="cov8" title="1">{
                d.Layout = layouts[0]
                d.LayoutOverride = true
        }</span>

        <span class="cov8" title="1">return p.s.Tmpl().LookupLayout(d, f)</span>
}

// This is serialized
func (p *pageState) initOutputFormat(isRenderingSite bool, idx int) error <span class="cov8" title="1">{
        if err := p.shiftToOutputFormat(isRenderingSite, idx); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// Must be run after the site section tree etc. is built and ready.
func (p *pageState) initPage() error <span class="cov8" title="1">{
        if _, err := p.init.Do(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (p *pageState) renderResources() (err error) <span class="cov8" title="1">{
        p.resourcesPublishInit.Do(func() </span><span class="cov8" title="1">{
                var toBeDeleted []int

                for i, r := range p.Resources() </span><span class="cov8" title="1">{

                        if _, ok := r.(page.Page); ok </span><span class="cov8" title="1">{
                                // Pages gets rendered with the owning page but we count them here.
                                p.s.PathSpec.ProcessingStats.Incr(&amp;p.s.PathSpec.ProcessingStats.Pages)
                                continue</span>
                        }

                        <span class="cov8" title="1">src, ok := r.(resource.Source)
                        if !ok </span><span class="cov0" title="0">{
                                err = errors.Errorf("Resource %T does not support resource.Source", src)
                                return
                        }</span>

                        <span class="cov8" title="1">if err := src.Publish(); err != nil </span><span class="cov0" title="0">{
                                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        // The resource has been deleted from the file system.
                                        // This should be extremely rare, but can happen on live reload in server
                                        // mode when the same resource is member of different page bundles.
                                        toBeDeleted = append(toBeDeleted, i)
                                }</span> else<span class="cov0" title="0"> {
                                        p.s.Log.Errorf("Failed to publish Resource for page %q: %s", p.pathOrTitle(), err)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                p.s.PathSpec.ProcessingStats.Incr(&amp;p.s.PathSpec.ProcessingStats.Files)
                        }</span>
                }

                <span class="cov8" title="1">for _, i := range toBeDeleted </span><span class="cov0" title="0">{
                        p.deleteResource(i)
                }</span>
        })

        <span class="cov8" title="1">return</span>
}

func (p *pageState) deleteResource(i int) <span class="cov0" title="0">{
        p.resources = append(p.resources[:i], p.resources[i+1:]...)
}</span>

func (p *pageState) getTargetPaths() page.TargetPaths <span class="cov8" title="1">{
        return p.targetPaths()
}</span>

func (p *pageState) setTranslations(pages page.Pages) <span class="cov8" title="1">{
        p.allTranslations = pages
        page.SortByLanguage(p.allTranslations)
        translations := make(page.Pages, 0)
        for _, t := range p.allTranslations </span><span class="cov8" title="1">{
                if !t.Eq(p) </span><span class="cov8" title="1">{
                        translations = append(translations, t)
                }</span>
        }
        <span class="cov8" title="1">p.translations = translations</span>
}

func (p *pageState) AlternativeOutputFormats() page.OutputFormats <span class="cov8" title="1">{
        f := p.outputFormat()
        var o page.OutputFormats
        for _, of := range p.OutputFormats() </span><span class="cov8" title="1">{
                if of.Format.NotAlternative || of.Format.Name == f.Name </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">o = append(o, of)</span>
        }
        <span class="cov8" title="1">return o</span>
}

type renderStringOpts struct {
        Display string
        Markup  string
}

var defaultRenderStringOpts = renderStringOpts{
        Display: "inline",
        Markup:  "", // Will inherit the page's value when not set.
}

func (p *pageState) addDependency(dep identity.Provider) <span class="cov8" title="1">{
        if !p.s.running() || p.pageOutput.cp == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">p.pageOutput.cp.dependencyTracker.Add(dep)</span>
}

// wrapError adds some more context to the given error if possible/needed
func (p *pageState) wrapError(err error) error <span class="cov8" title="1">{
        if _, ok := err.(*herrors.ErrorWithFileContext); ok </span><span class="cov0" title="0">{
                // Preserve the first file context.
                return err
        }</span>
        <span class="cov8" title="1">var filename string
        if !p.File().IsZero() </span><span class="cov8" title="1">{
                filename = p.File().Filename()
        }</span>

        <span class="cov8" title="1">err, _ = herrors.WithFileContextForFile(
                err,
                filename,
                filename,
                p.s.SourceSpec.Fs.Source,
                herrors.SimpleLineMatcher)

        return err</span>
}

func (p *pageState) getContentConverter() converter.Converter <span class="cov8" title="1">{
        var err error
        p.m.contentConverterInit.Do(func() </span><span class="cov8" title="1">{
                markup := p.m.markup
                if markup == "html" </span><span class="cov8" title="1">{
                        // Only used for shortcode inner content.
                        markup = "markdown"
                }</span>
                <span class="cov8" title="1">p.m.contentConverter, err = p.m.newContentConverter(p, markup, p.m.renderingConfigOverrides)</span>
        })

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                p.s.Log.Errorln("Failed to create content converter:", err)
        }</span>
        <span class="cov8" title="1">return p.m.contentConverter</span>
}

func (p *pageState) mapContent(bucket *pagesMapBucket, meta *pageMeta) error <span class="cov8" title="1">{
        s := p.shortcodeState

        rn := &amp;pageContentMap{
                items: make([]interface{}, 0, 20),
        }

        iter := p.source.parsed.Iterator()

        fail := func(err error, i pageparser.Item) error </span><span class="cov8" title="1">{
                return p.parseError(err, iter.Input(), i.Pos)
        }</span>

        // the parser is guaranteed to return items in proper order or fail, so …
        // … it's safe to keep some "global" state
        <span class="cov8" title="1">var currShortcode shortcode
        var ordinal int
        var frontMatterSet bool

Loop:
        for </span><span class="cov8" title="1">{
                it := iter.Next()

                switch </span>{
                case it.Type == pageparser.TypeIgnore:<span class="cov8" title="1"></span>
                case it.IsFrontMatter():<span class="cov8" title="1">
                        f := pageparser.FormatFromFrontMatterType(it.Type)
                        m, err := metadecoders.Default.UnmarshalToMap(it.Val, f)
                        if err != nil </span><span class="cov8" title="1">{
                                if fe, ok := err.(herrors.FileError); ok </span><span class="cov8" title="1">{
                                        return herrors.ToFileErrorWithOffset(fe, iter.LineNumber()-1)
                                }</span> else<span class="cov0" title="0"> {
                                        return err
                                }</span>
                        }

                        <span class="cov8" title="1">if err := meta.setMetadata(bucket, p, m); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">frontMatterSet = true

                        next := iter.Peek()
                        if !next.IsDone() </span><span class="cov8" title="1">{
                                p.source.posMainContent = next.Pos
                        }</span>

                        <span class="cov8" title="1">if !p.s.shouldBuild(p) </span><span class="cov8" title="1">{
                                // Nothing more to do.
                                return nil
                        }</span>

                case it.Type == pageparser.TypeLeadSummaryDivider:<span class="cov8" title="1">
                        posBody := -1
                        f := func(item pageparser.Item) bool </span><span class="cov8" title="1">{
                                if posBody == -1 &amp;&amp; !item.IsDone() </span><span class="cov8" title="1">{
                                        posBody = item.Pos
                                }</span>

                                <span class="cov8" title="1">if item.IsNonWhitespace() </span><span class="cov8" title="1">{
                                        p.truncated = true

                                        // Done
                                        return false
                                }</span>
                                <span class="cov0" title="0">return true</span>
                        }
                        <span class="cov8" title="1">iter.PeekWalk(f)

                        p.source.posSummaryEnd = it.Pos
                        p.source.posBodyStart = posBody
                        p.source.hasSummaryDivider = true

                        if meta.markup != "html" </span><span class="cov8" title="1">{
                                // The content will be rendered by Blackfriday or similar,
                                // and we need to track the summary.
                                rn.AddReplacement(internalSummaryDividerPre, it)
                        }</span>

                // Handle shortcode
                case it.IsLeftShortcodeDelim():<span class="cov8" title="1">
                        // let extractShortcode handle left delim (will do so recursively)
                        iter.Backup()

                        currShortcode, err := s.extractShortcode(ordinal, 0, iter)
                        if err != nil </span><span class="cov8" title="1">{
                                return fail(errors.Wrap(err, "failed to extract shortcode"), it)
                        }</span>

                        <span class="cov8" title="1">currShortcode.pos = it.Pos
                        currShortcode.length = iter.Current().Pos - it.Pos
                        if currShortcode.placeholder == "" </span><span class="cov8" title="1">{
                                currShortcode.placeholder = createShortcodePlaceholder("s", currShortcode.ordinal)
                        }</span>

                        <span class="cov8" title="1">if currShortcode.name != "" </span><span class="cov8" title="1">{
                                s.nameSet[currShortcode.name] = true
                        }</span>

                        <span class="cov8" title="1">if currShortcode.params == nil </span><span class="cov8" title="1">{
                                var s []string
                                currShortcode.params = s
                        }</span>

                        <span class="cov8" title="1">currShortcode.placeholder = createShortcodePlaceholder("s", ordinal)
                        ordinal++
                        s.shortcodes = append(s.shortcodes, currShortcode)

                        rn.AddShortcode(currShortcode)</span>

                case it.Type == pageparser.TypeEmoji:<span class="cov8" title="1">
                        if emoji := helpers.Emoji(it.ValStr()); emoji != nil </span><span class="cov8" title="1">{
                                rn.AddReplacement(emoji, it)
                        }</span> else<span class="cov8" title="1"> {
                                rn.AddBytes(it)
                        }</span>
                case it.IsEOF():<span class="cov8" title="1">
                        break Loop</span>
                case it.IsError():<span class="cov0" title="0">
                        err := fail(errors.WithStack(errors.New(it.ValStr())), it)
                        currShortcode.err = err
                        return err</span>

                default:<span class="cov8" title="1">
                        rn.AddBytes(it)</span>
                }
        }

        <span class="cov8" title="1">if !frontMatterSet </span><span class="cov8" title="1">{
                // Page content without front matter. Assign default front matter from
                // cascades etc.
                if err := meta.setMetadata(bucket, p, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">p.cmap = rn

        return nil</span>
}

func (p *pageState) errorf(err error, format string, a ...interface{}) error <span class="cov8" title="1">{
        if herrors.UnwrapErrorWithFileContext(err) != nil </span><span class="cov8" title="1">{
                // More isn't always better.
                return err
        }</span>
        <span class="cov0" title="0">args := append([]interface{}{p.Language().Lang, p.pathOrTitle()}, a...)
        format = "[%s] page %q: " + format
        if err == nil </span><span class="cov0" title="0">{
                errors.Errorf(format, args...)
                return fmt.Errorf(format, args...)
        }</span>
        <span class="cov0" title="0">return errors.Wrapf(err, format, args...)</span>
}

func (p *pageState) outputFormat() (f output.Format) <span class="cov8" title="1">{
        if p.pageOutput == nil </span><span class="cov0" title="0">{
                panic("no pageOutput")</span>
        }
        <span class="cov8" title="1">return p.pageOutput.f</span>
}

func (p *pageState) parseError(err error, input []byte, offset int) error <span class="cov8" title="1">{
        if herrors.UnwrapFileError(err) != nil </span><span class="cov8" title="1">{
                // Use the most specific location.
                return err
        }</span>
        <span class="cov8" title="1">pos := p.posFromInput(input, offset)
        return herrors.NewFileError("md", -1, pos.LineNumber, pos.ColumnNumber, err)</span>
}

func (p *pageState) pathOrTitle() string <span class="cov8" title="1">{
        if !p.File().IsZero() </span><span class="cov8" title="1">{
                return p.File().Filename()
        }</span>

        <span class="cov0" title="0">if p.Pathc() != "" </span><span class="cov0" title="0">{
                return p.Pathc()
        }</span>

        <span class="cov0" title="0">return p.Title()</span>
}

func (p *pageState) posFromPage(offset int) text.Position <span class="cov0" title="0">{
        return p.posFromInput(p.source.parsed.Input(), offset)
}</span>

func (p *pageState) posFromInput(input []byte, offset int) text.Position <span class="cov8" title="1">{
        lf := []byte("\n")
        input = input[:offset]
        lineNumber := bytes.Count(input, lf) + 1
        endOfLastLine := bytes.LastIndex(input, lf)

        return text.Position{
                Filename:     p.pathOrTitle(),
                LineNumber:   lineNumber,
                ColumnNumber: offset - endOfLastLine,
                Offset:       offset,
        }
}</span>

func (p *pageState) posOffset(offset int) text.Position <span class="cov8" title="1">{
        return p.posFromInput(p.source.parsed.Input(), offset)
}</span>

// shiftToOutputFormat is serialized. The output format idx refers to the
// full set of output formats for all sites.
func (p *pageState) shiftToOutputFormat(isRenderingSite bool, idx int) error <span class="cov8" title="1">{
        if err := p.initPage(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(p.pageOutputs) == 1 </span><span class="cov8" title="1">{
                idx = 0
        }</span>

        <span class="cov8" title="1">p.pageOutput = p.pageOutputs[idx]
        if p.pageOutput == nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("pageOutput is nil for output idx %d", idx))</span>
        }

        // Reset any built paginator. This will trigger when re-rendering pages in
        // server mode.
        <span class="cov8" title="1">if isRenderingSite &amp;&amp; p.pageOutput.paginator != nil &amp;&amp; p.pageOutput.paginator.current != nil </span><span class="cov8" title="1">{
                p.pageOutput.paginator.reset()
        }</span>

        <span class="cov8" title="1">if isRenderingSite </span><span class="cov8" title="1">{
                cp := p.pageOutput.cp
                if cp == nil </span><span class="cov8" title="1">{
                        // Look for content to reuse.
                        for i := 0; i &lt; len(p.pageOutputs); i++ </span><span class="cov8" title="1">{
                                if i == idx </span><span class="cov8" title="1">{
                                        continue</span>
                                }
                                <span class="cov8" title="1">po := p.pageOutputs[i]

                                if po.cp != nil &amp;&amp; po.cp.reuse </span><span class="cov8" title="1">{
                                        cp = po.cp
                                        break</span>
                                }
                        }
                }

                <span class="cov8" title="1">if cp == nil </span><span class="cov8" title="1">{
                        var err error
                        cp, err = newPageContentOutput(p, p.pageOutput)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">p.pageOutput.initContentProvider(cp)</span>
        } else<span class="cov8" title="1"> {
                // We attempt to assign pageContentOutputs while preparing each site
                // for rendering and before rendering each site. This lets us share
                // content between page outputs to conserve resources. But if a template
                // unexpectedly calls a method of a ContentProvider that is not yet
                // initialized, we assign a LazyContentProvider that performs the
                // initialization just in time.
                if lcp, ok := (p.pageOutput.ContentProvider.(*page.LazyContentProvider)); ok </span><span class="cov8" title="1">{
                        lcp.Reset()
                }</span> else<span class="cov8" title="1"> {
                        lcp = page.NewLazyContentProvider(func() (page.OutputFormatContentProvider, error) </span><span class="cov8" title="1">{
                                cp, err := newPageContentOutput(p, p.pageOutput)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">return cp, nil</span>
                        })
                        <span class="cov8" title="1">p.pageOutput.ContentProvider = lcp
                        p.pageOutput.TableOfContentsProvider = lcp
                        p.pageOutput.PageRenderProvider = lcp</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

// sourceRef returns the reference used by GetPage and ref/relref shortcodes to refer to
// this page. It is prefixed with a "/".
//
// For pages that have a source file, it is returns the path to this file as an
// absolute path rooted in this site's content dir.
// For pages that do not (sections without content page etc.), it returns the
// virtual path, consistent with where you would add a source file.
func (p *pageState) sourceRef() string <span class="cov8" title="1">{
        if !p.File().IsZero() </span><span class="cov8" title="1">{
                sourcePath := p.File().Path()
                if sourcePath != "" </span><span class="cov8" title="1">{
                        return "/" + filepath.ToSlash(sourcePath)
                }</span>
        }

        <span class="cov8" title="1">if len(p.SectionsEntries()) &gt; 0 </span><span class="cov8" title="1">{
                // no backing file, return the virtual source path
                return "/" + p.SectionsPath()
        }</span>

        <span class="cov8" title="1">return ""</span>
}

func (s *Site) sectionsFromFile(fi source.File) []string <span class="cov8" title="1">{
        dirname := fi.Dir()

        dirname = strings.Trim(dirname, helpers.FilePathSeparator)
        if dirname == "" </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">parts := strings.Split(dirname, helpers.FilePathSeparator)

        if fii, ok := fi.(*fileInfo); ok </span><span class="cov8" title="1">{
                if len(parts) &gt; 0 &amp;&amp; fii.FileInfo().Meta().Classifier == files.ContentClassLeaf </span><span class="cov8" title="1">{
                        // my-section/mybundle/index.md =&gt; my-section
                        return parts[:len(parts)-1]
                }</span>
        }

        <span class="cov8" title="1">return parts</span>
}

var (
        _ page.Page         = (*pageWithOrdinal)(nil)
        _ collections.Order = (*pageWithOrdinal)(nil)
        _ pageWrapper       = (*pageWithOrdinal)(nil)
)

type pageWithOrdinal struct {
        ordinal int
        *pageState
}

func (p pageWithOrdinal) Ordinal() int <span class="cov8" title="1">{
        return p.ordinal
}</span>

func (p pageWithOrdinal) page() page.Page <span class="cov0" title="0">{
        return p.pageState
}</span>
</pre>
		
		<pre class="file" id="file117" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "sync"

        "github.com/bep/gitmap"
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/compare"
        "github.com/gohugoio/hugo/lazy"
        "github.com/gohugoio/hugo/navigation"
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"
)

type treeRefProvider interface {
        getTreeRef() *contentTreeRef
}

func (p *pageCommon) getTreeRef() *contentTreeRef <span class="cov8" title="1">{
        return p.treeRef
}</span>

type nextPrevProvider interface {
        getNextPrev() *nextPrev
}

func (p *pageCommon) getNextPrev() *nextPrev <span class="cov8" title="1">{
        return p.posNextPrev
}</span>

type nextPrevInSectionProvider interface {
        getNextPrevInSection() *nextPrev
}

func (p *pageCommon) getNextPrevInSection() *nextPrev <span class="cov8" title="1">{
        return p.posNextPrevSection
}</span>

type pageCommon struct {
        s *Site
        m *pageMeta

        bucket  *pagesMapBucket
        treeRef *contentTreeRef

        // Lazily initialized dependencies.
        init *lazy.Init

        // All of these represents the common parts of a page.Page
        maps.Scratcher
        navigation.PageMenusProvider
        page.AuthorProvider
        page.AlternativeOutputFormatsProvider
        page.ChildCareProvider
        page.FileProvider
        page.GetPageProvider
        page.GitInfoProvider
        page.InSectionPositioner
        page.OutputFormatsProvider
        page.PageMetaProvider
        page.Positioner
        page.RawContentProvider
        page.RelatedKeywordsProvider
        page.RefProvider
        page.ShortcodeInfoProvider
        page.SitesProvider
        page.TranslationsProvider
        page.TreeProvider
        resource.LanguageProvider
        resource.ResourceDataProvider
        resource.ResourceMetaProvider
        resource.ResourceParamsProvider
        resource.ResourceTypeProvider
        resource.MediaTypeProvider
        resource.TranslationKeyProvider
        compare.Eqer

        // Describes how paths and URLs for this page and its descendants
        // should look like.
        targetPathDescriptor page.TargetPathDescriptor

        layoutDescriptor     output.LayoutDescriptor
        layoutDescriptorInit sync.Once

        // The parsed page content.
        pageContent

        // Set if feature enabled and this is in a Git repo.
        gitInfo *gitmap.GitInfo

        // Positional navigation
        posNextPrev        *nextPrev
        posNextPrevSection *nextPrev

        // Menus
        pageMenus *pageMenus

        // Internal use
        page.InternalDependencies

        // The children. Regular pages will have none.
        *pagePages

        // Any bundled resources
        resources            resource.Resources
        resourcesInit        sync.Once
        resourcesPublishInit sync.Once

        translations    page.Pages
        allTranslations page.Pages

        // Calculated an cached translation mapping key
        translationKey     string
        translationKeyInit sync.Once

        // Will only be set for bundled pages.
        parent *pageState

        // Set in fast render mode to force render a given page.
        forceRender bool
}

type pagePages struct {
        pagesInit sync.Once
        pages     page.Pages

        regularPagesInit          sync.Once
        regularPages              page.Pages
        regularPagesRecursiveInit sync.Once
        regularPagesRecursive     page.Pages
}
</pre>
		
		<pre class="file" id="file118" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"

        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/parser/pageparser"
)

var (
        internalSummaryDividerBase      = "HUGOMORE42"
        internalSummaryDividerBaseBytes = []byte(internalSummaryDividerBase)
        internalSummaryDividerPre       = []byte("\n\n" + internalSummaryDividerBase + "\n\n")
)

// The content related items on a Page.
type pageContent struct {
        selfLayout string
        truncated  bool

        cmap *pageContentMap

        shortcodeState *shortcodeHandler

        source rawPageContent
}

// returns the content to be processed by Blackfriday or similar.
func (p pageContent) contentToRender(renderedShortcodes map[string]string) []byte <span class="cov8" title="1">{
        source := p.source.parsed.Input()

        c := make([]byte, 0, len(source)+(len(source)/10))

        for _, it := range p.cmap.items </span><span class="cov8" title="1">{
                switch v := it.(type) </span>{
                case pageparser.Item:<span class="cov8" title="1">
                        c = append(c, source[v.Pos:v.Pos+len(v.Val)]...)</span>
                case pageContentReplacement:<span class="cov8" title="1">
                        c = append(c, v.val...)</span>
                case *shortcode:<span class="cov8" title="1">
                        if !v.insertPlaceholder() </span><span class="cov8" title="1">{
                                // Insert the rendered shortcode.
                                renderedShortcode, found := renderedShortcodes[v.placeholder]
                                if !found </span><span class="cov0" title="0">{
                                        // This should never happen.
                                        panic(fmt.Sprintf("rendered shortcode %q not found", v.placeholder))</span>
                                }

                                <span class="cov8" title="1">c = append(c, []byte(renderedShortcode)...)</span>

                        } else<span class="cov8" title="1"> {
                                // Insert the placeholder so we can insert the content after
                                // markdown processing.
                                c = append(c, []byte(v.placeholder)...)
                        }</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("unknown item type %T", it))</span>
                }
        }

        <span class="cov8" title="1">return c</span>
}

func (p pageContent) selfLayoutForOutput(f output.Format) string <span class="cov8" title="1">{
        if p.selfLayout == "" </span><span class="cov8" title="1">{
                return ""
        }</span>
        <span class="cov0" title="0">return p.selfLayout + f.Name</span>
}

type rawPageContent struct {
        hasSummaryDivider bool

        // The AST of the parsed page. Contains information about:
        // shortcodes, front matter, summary indicators.
        parsed pageparser.Result

        // Returns the position in bytes after any front matter.
        posMainContent int

        // These are set if we're able to determine this from the source.
        posSummaryEnd int
        posBodyStart  int
}

type pageContentReplacement struct {
        val []byte

        source pageparser.Item
}

type pageContentMap struct {

        // If not, we can skip any pre-rendering of shortcodes.
        hasMarkdownShortcode bool

        // Indicates whether we must do placeholder replacements.
        hasNonMarkdownShortcode bool

        //  *shortcode, pageContentReplacement or pageparser.Item
        items []interface{}
}

func (p *pageContentMap) AddBytes(item pageparser.Item) <span class="cov8" title="1">{
        p.items = append(p.items, item)
}</span>

func (p *pageContentMap) AddReplacement(val []byte, source pageparser.Item) <span class="cov8" title="1">{
        p.items = append(p.items, pageContentReplacement{val: val, source: source})
}</span>

func (p *pageContentMap) AddShortcode(s *shortcode) <span class="cov8" title="1">{
        p.items = append(p.items, s)
        if s.insertPlaceholder() </span><span class="cov8" title="1">{
                p.hasNonMarkdownShortcode = true
        }</span> else<span class="cov8" title="1"> {
                p.hasMarkdownShortcode = true
        }</span>
}
</pre>
		
		<pre class="file" id="file119" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "sync"

        "github.com/gohugoio/hugo/resources/page"
)

type pageData struct {
        *pageState

        dataInit sync.Once
        data     page.Data
}

func (p *pageData) Data() interface{} <span class="cov8" title="1">{
        p.dataInit.Do(func() </span><span class="cov8" title="1">{
                p.data = make(page.Data)

                if p.Kind() == page.KindPage </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">switch p.Kind() </span>{
                case page.KindTerm:<span class="cov8" title="1">
                        b := p.treeRef.n
                        name := b.viewInfo.name
                        termKey := b.viewInfo.termKey

                        taxonomy := p.s.Taxonomies()[name.plural].Get(termKey)

                        p.data[name.singular] = taxonomy
                        p.data["Singular"] = name.singular
                        p.data["Plural"] = name.plural
                        p.data["Term"] = b.viewInfo.term()</span>
                case page.KindTaxonomy:<span class="cov8" title="1">
                        b := p.treeRef.n
                        name := b.viewInfo.name

                        p.data["Singular"] = name.singular
                        p.data["Plural"] = name.plural
                        p.data["Terms"] = p.s.Taxonomies()[name.plural]
                        // keep the following just for legacy reasons
                        p.data["OrderedIndex"] = p.data["Terms"]
                        p.data["Index"] = p.data["Terms"]</span>
                }

                // Assign the function to the map to make sure it is lazily initialized
                <span class="cov8" title="1">p.data["pages"] = p.Pages</span>
        })

        <span class="cov8" title="1">return p.data</span>
}
</pre>
		
		<pre class="file" id="file120" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "sync"

        "github.com/gohugoio/hugo/navigation"
)

type pageMenus struct {
        p *pageState

        q navigation.MenuQueryProvider

        pmInit sync.Once
        pm     navigation.PageMenus
}

func (p *pageMenus) HasMenuCurrent(menuID string, me *navigation.MenuEntry) bool <span class="cov8" title="1">{
        p.p.s.init.menus.Do()
        p.init()
        return p.q.HasMenuCurrent(menuID, me)
}</span>

func (p *pageMenus) IsMenuCurrent(menuID string, inme *navigation.MenuEntry) bool <span class="cov8" title="1">{
        p.p.s.init.menus.Do()
        p.init()
        return p.q.IsMenuCurrent(menuID, inme)
}</span>

func (p *pageMenus) Menus() navigation.PageMenus <span class="cov8" title="1">{
        // There is a reverse dependency here. initMenus will, once, build the
        // site menus and update any relevant page.
        p.p.s.init.menus.Do()

        return p.menus()
}</span>

func (p *pageMenus) menus() navigation.PageMenus <span class="cov8" title="1">{
        p.init()
        return p.pm
}</span>

func (p *pageMenus) init() <span class="cov8" title="1">{
        p.pmInit.Do(func() </span><span class="cov8" title="1">{
                p.q = navigation.NewMenuQueryProvider(
                        p,
                        p.p.s,
                        p.p,
                )

                var err error
                p.pm, err = navigation.PageMenusFromPage(p.p)
                if err != nil </span><span class="cov0" title="0">{
                        p.p.s.Log.Errorln(p.p.wrapError(err))
                }</span>
        })
}
</pre>
		
		<pre class="file" id="file121" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "path"
        "path/filepath"
        "regexp"
        "strings"
        "sync"
        "time"

        "github.com/gohugoio/hugo/langs"

        "github.com/gobuffalo/flect"
        "github.com/gohugoio/hugo/markup/converter"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/common/hugo"

        "github.com/gohugoio/hugo/related"

        "github.com/gohugoio/hugo/source"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/page/pagemeta"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/spf13/cast"
)

var cjkRe = regexp.MustCompile(`\p{Han}|\p{Hangul}|\p{Hiragana}|\p{Katakana}`)

type pageMeta struct {
        // kind is the discriminator that identifies the different page types
        // in the different page collections. This can, as an example, be used
        // to to filter regular pages, find sections etc.
        // Kind will, for the pages available to the templates, be one of:
        // page, home, section, taxonomy and term.
        // It is of string type to make it easy to reason about in
        // the templates.
        kind string

        // This is a standalone page not part of any page collection. These
        // include sitemap, robotsTXT and similar. It will have no pageOutputs, but
        // a fixed pageOutput.
        standalone bool

        draft       bool // Only published when running with -D flag
        buildConfig pagemeta.BuildConfig

        bundleType files.ContentClass

        // Params contains configuration defined in the params section of page frontmatter.
        params map[string]interface{}

        title     string
        linkTitle string

        summary string

        resourcePath string

        weight int

        markup      string
        contentType string

        // whether the content is in a CJK language.
        isCJKLanguage bool

        layout string

        aliases []string

        description string
        keywords    []string

        urlPaths pagemeta.URLPath

        resource.Dates

        // Set if this page is bundled inside another.
        bundled bool

        // A key that maps to translation(s) of this page. This value is fetched
        // from the page front matter.
        translationKey string

        // From front matter.
        configuredOutputFormats output.Formats

        // This is the raw front matter metadata that is going to be assigned to
        // the Resources above.
        resourcesMetadata []map[string]interface{}

        f source.File

        sections []string

        // Sitemap overrides from front matter.
        sitemap config.Sitemap

        s *Site

        renderingConfigOverrides map[string]interface{}
        contentConverterInit     sync.Once
        contentConverter         converter.Converter
}

func (p *pageMeta) Aliases() []string <span class="cov8" title="1">{
        return p.aliases
}</span>

func (p *pageMeta) Author() page.Author <span class="cov0" title="0">{
        authors := p.Authors()

        for _, author := range authors </span><span class="cov0" title="0">{
                return author
        }</span>
        <span class="cov0" title="0">return page.Author{}</span>
}

func (p *pageMeta) Authors() page.AuthorList <span class="cov0" title="0">{
        authorKeys, ok := p.params["authors"]
        if !ok </span><span class="cov0" title="0">{
                return page.AuthorList{}
        }</span>
        <span class="cov0" title="0">authors := authorKeys.([]string)
        if len(authors) &lt; 1 || len(p.s.Info.Authors) &lt; 1 </span><span class="cov0" title="0">{
                return page.AuthorList{}
        }</span>

        <span class="cov0" title="0">al := make(page.AuthorList)
        for _, author := range authors </span><span class="cov0" title="0">{
                a, ok := p.s.Info.Authors[author]
                if ok </span><span class="cov0" title="0">{
                        al[author] = a
                }</span>
        }
        <span class="cov0" title="0">return al</span>
}

func (p *pageMeta) BundleType() files.ContentClass <span class="cov8" title="1">{
        return p.bundleType
}</span>

func (p *pageMeta) Description() string <span class="cov8" title="1">{
        return p.description
}</span>

func (p *pageMeta) Lang() string <span class="cov8" title="1">{
        return p.s.Lang()
}</span>

func (p *pageMeta) Draft() bool <span class="cov8" title="1">{
        return p.draft
}</span>

func (p *pageMeta) File() source.File <span class="cov8" title="1">{
        return p.f
}</span>

func (p *pageMeta) IsHome() bool <span class="cov8" title="1">{
        return p.Kind() == page.KindHome
}</span>

func (p *pageMeta) Keywords() []string <span class="cov8" title="1">{
        return p.keywords
}</span>

func (p *pageMeta) Kind() string <span class="cov8" title="1">{
        return p.kind
}</span>

func (p *pageMeta) Layout() string <span class="cov8" title="1">{
        return p.layout
}</span>

func (p *pageMeta) LinkTitle() string <span class="cov8" title="1">{
        if p.linkTitle != "" </span><span class="cov0" title="0">{
                return p.linkTitle
        }</span>

        <span class="cov8" title="1">return p.Title()</span>
}

func (p *pageMeta) Name() string <span class="cov8" title="1">{
        if p.resourcePath != "" </span><span class="cov8" title="1">{
                return p.resourcePath
        }</span>
        <span class="cov8" title="1">return p.Title()</span>
}

func (p *pageMeta) IsNode() bool <span class="cov8" title="1">{
        return !p.IsPage()
}</span>

func (p *pageMeta) IsPage() bool <span class="cov8" title="1">{
        return p.Kind() == page.KindPage
}</span>

// Param is a convenience method to do lookups in Page's and Site's Params map,
// in that order.
//
// This method is also implemented on SiteInfo.
// TODO(bep) interface
func (p *pageMeta) Param(key interface{}) (interface{}, error) <span class="cov8" title="1">{
        return resource.Param(p, p.s.Info.Params(), key)
}</span>

func (p *pageMeta) Params() maps.Params <span class="cov8" title="1">{
        return p.params
}</span>

func (p *pageMeta) Path() string <span class="cov8" title="1">{
        if !p.File().IsZero() </span><span class="cov8" title="1">{
                const example = `
  {{ $path := "" }}
  {{ with .File }}
        {{ $path = .Path }}
  {{ else }}
        {{ $path = .Path }}
  {{ end }}
`
                helpers.Deprecated(".Path when the page is backed by a file", "We plan to use Path for a canonical source path and you probably want to check the source is a file. To get the current behaviour, you can use a construct similar to the one below:\n"+example, false)

        }</span>

        <span class="cov8" title="1">return p.Pathc()</span>
}

// This is just a bridge method, use Path in templates.
func (p *pageMeta) Pathc() string <span class="cov8" title="1">{
        if !p.File().IsZero() </span><span class="cov8" title="1">{
                return p.File().Path()
        }</span>
        <span class="cov8" title="1">return p.SectionsPath()</span>
}

// RelatedKeywords implements the related.Document interface needed for fast page searches.
func (p *pageMeta) RelatedKeywords(cfg related.IndexConfig) ([]related.Keyword, error) <span class="cov8" title="1">{
        v, err := p.Param(cfg.Name)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return cfg.ToKeywords(v)</span>
}

func (p *pageMeta) IsSection() bool <span class="cov8" title="1">{
        return p.Kind() == page.KindSection
}</span>

func (p *pageMeta) Section() string <span class="cov8" title="1">{
        if p.IsHome() </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if p.IsNode() </span><span class="cov8" title="1">{
                if len(p.sections) == 0 </span><span class="cov0" title="0">{
                        // May be a sitemap or similar.
                        return ""
                }</span>
                <span class="cov8" title="1">return p.sections[0]</span>
        }

        <span class="cov8" title="1">if !p.File().IsZero() </span><span class="cov8" title="1">{
                return p.File().Section()
        }</span>

        <span class="cov0" title="0">panic("invalid page state")</span>
}

func (p *pageMeta) SectionsEntries() []string <span class="cov8" title="1">{
        return p.sections
}</span>

func (p *pageMeta) SectionsPath() string <span class="cov8" title="1">{
        return path.Join(p.SectionsEntries()...)
}</span>

func (p *pageMeta) Sitemap() config.Sitemap <span class="cov8" title="1">{
        return p.sitemap
}</span>

func (p *pageMeta) Title() string <span class="cov8" title="1">{
        return p.title
}</span>

const defaultContentType = "page"

func (p *pageMeta) Type() string <span class="cov8" title="1">{
        if p.contentType != "" </span><span class="cov8" title="1">{
                return p.contentType
        }</span>

        <span class="cov8" title="1">if sect := p.Section(); sect != "" </span><span class="cov8" title="1">{
                return sect
        }</span>

        <span class="cov8" title="1">return defaultContentType</span>
}

func (p *pageMeta) Weight() int <span class="cov8" title="1">{
        return p.weight
}</span>

func (pm *pageMeta) mergeBucketCascades(b1, b2 *pagesMapBucket) <span class="cov8" title="1">{
        if b1.cascade == nil </span><span class="cov8" title="1">{
                b1.cascade = make(map[page.PageMatcher]maps.Params)
        }</span>

        <span class="cov8" title="1">if b2 != nil &amp;&amp; b2.cascade != nil </span><span class="cov8" title="1">{
                for k, v := range b2.cascade </span><span class="cov8" title="1">{

                        vv, found := b1.cascade[k]
                        if !found </span><span class="cov8" title="1">{
                                b1.cascade[k] = v
                        }</span> else<span class="cov8" title="1"> {
                                // Merge
                                for ck, cv := range v </span><span class="cov8" title="1">{
                                        if _, found := vv[ck]; !found </span><span class="cov8" title="1">{
                                                vv[ck] = cv
                                        }</span>
                                }
                        }
                }
        }
}

func (pm *pageMeta) setMetadata(parentBucket *pagesMapBucket, p *pageState, frontmatter map[string]interface{}) error <span class="cov8" title="1">{
        pm.params = make(maps.Params)

        if frontmatter == nil &amp;&amp; (parentBucket == nil || parentBucket.cascade == nil) </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">if frontmatter != nil </span><span class="cov8" title="1">{
                // Needed for case insensitive fetching of params values
                maps.PrepareParams(frontmatter)
                if p.bucket != nil </span><span class="cov8" title="1">{
                        // Check for any cascade define on itself.
                        if cv, found := frontmatter["cascade"]; found </span><span class="cov8" title="1">{
                                var err error
                                p.bucket.cascade, err = page.DecodeCascade(cv)
                                if err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        } else<span class="cov8" title="1"> {
                frontmatter = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">var cascade map[page.PageMatcher]maps.Params

        if p.bucket != nil </span><span class="cov8" title="1">{
                if parentBucket != nil </span><span class="cov8" title="1">{
                        // Merge missing keys from parent into this.
                        pm.mergeBucketCascades(p.bucket, parentBucket)
                }</span>
                <span class="cov8" title="1">cascade = p.bucket.cascade</span>
        } else<span class="cov8" title="1"> if parentBucket != nil </span><span class="cov8" title="1">{
                cascade = parentBucket.cascade
        }</span>

        <span class="cov8" title="1">for m, v := range cascade </span><span class="cov8" title="1">{
                if !m.Matches(p) </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">for kk, vv := range v </span><span class="cov8" title="1">{
                        if _, found := frontmatter[kk]; !found </span><span class="cov8" title="1">{
                                frontmatter[kk] = vv
                        }</span>
                }
        }

        <span class="cov8" title="1">var mtime time.Time
        var contentBaseName string
        if !p.File().IsZero() </span><span class="cov8" title="1">{
                contentBaseName = p.File().ContentBaseName()
                if p.File().FileInfo() != nil </span><span class="cov8" title="1">{
                        mtime = p.File().FileInfo().ModTime()
                }</span>
        }

        <span class="cov8" title="1">var gitAuthorDate time.Time
        if p.gitInfo != nil </span><span class="cov8" title="1">{
                gitAuthorDate = p.gitInfo.AuthorDate
        }</span>

        <span class="cov8" title="1">descriptor := &amp;pagemeta.FrontMatterDescriptor{
                Frontmatter:   frontmatter,
                Params:        pm.params,
                Dates:         &amp;pm.Dates,
                PageURLs:      &amp;pm.urlPaths,
                BaseFilename:  contentBaseName,
                ModTime:       mtime,
                GitAuthorDate: gitAuthorDate,
                Location:      langs.GetLocation(pm.s.Language()),
        }

        // Handle the date separately
        // TODO(bep) we need to "do more" in this area so this can be split up and
        // more easily tested without the Page, but the coupling is strong.
        err := pm.s.frontmatterHandler.HandleDates(descriptor)
        if err != nil </span><span class="cov0" title="0">{
                p.s.Log.Errorf("Failed to handle dates for page %q: %s", p.pathOrTitle(), err)
        }</span>

        <span class="cov8" title="1">pm.buildConfig, err = pagemeta.DecodeBuildConfig(frontmatter["_build"])
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var sitemapSet bool

        var draft, published, isCJKLanguage *bool
        for k, v := range frontmatter </span><span class="cov8" title="1">{
                loki := strings.ToLower(k)

                if loki == "published" </span><span class="cov8" title="1">{ // Intentionally undocumented
                        vv, err := cast.ToBoolE(v)
                        if err == nil </span><span class="cov0" title="0">{
                                published = &amp;vv
                        }</span>
                        // published may also be a date
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">if pm.s.frontmatterHandler.IsDateKey(loki) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">switch loki </span>{
                case "title":<span class="cov8" title="1">
                        pm.title = cast.ToString(v)
                        pm.params[loki] = pm.title</span>
                case "linktitle":<span class="cov0" title="0">
                        pm.linkTitle = cast.ToString(v)
                        pm.params[loki] = pm.linkTitle</span>
                case "summary":<span class="cov8" title="1">
                        pm.summary = cast.ToString(v)
                        pm.params[loki] = pm.summary</span>
                case "description":<span class="cov8" title="1">
                        pm.description = cast.ToString(v)
                        pm.params[loki] = pm.description</span>
                case "slug":<span class="cov8" title="1">
                        // Don't start or end with a -
                        pm.urlPaths.Slug = strings.Trim(cast.ToString(v), "-")
                        pm.params[loki] = pm.Slug()</span>
                case "url":<span class="cov8" title="1">
                        url := cast.ToString(v)
                        if strings.HasPrefix(url, "http://") || strings.HasPrefix(url, "https://") </span><span class="cov0" title="0">{
                                return fmt.Errorf("URLs with protocol (http*) not supported: %q. In page %q", url, p.pathOrTitle())
                        }</span>
                        <span class="cov8" title="1">lang := p.s.GetLanguagePrefix()
                        if lang != "" &amp;&amp; !strings.HasPrefix(url, "/") &amp;&amp; strings.HasPrefix(url, lang+"/") </span><span class="cov0" title="0">{
                                if strings.HasPrefix(hugo.CurrentVersion.String(), "0.55") </span><span class="cov0" title="0">{
                                        // We added support for page relative URLs in Hugo 0.55 and
                                        // this may get its language path added twice.
                                        // TODO(bep) eventually remove this.
                                        p.s.Log.Warnf(`Front matter in %q with the url %q with no leading / has what looks like the language prefix added. In Hugo 0.55 we added support for page relative URLs in front matter, no language prefix needed. Check the URL and consider to either add a leading / or remove the language prefix.`, p.pathOrTitle(), url)
                                }</span>
                        }
                        <span class="cov8" title="1">pm.urlPaths.URL = url
                        pm.params[loki] = url</span>
                case "type":<span class="cov8" title="1">
                        pm.contentType = cast.ToString(v)
                        pm.params[loki] = pm.contentType</span>
                case "keywords":<span class="cov0" title="0">
                        pm.keywords = cast.ToStringSlice(v)
                        pm.params[loki] = pm.keywords</span>
                case "headless":<span class="cov8" title="1">
                        // Legacy setting for leaf bundles.
                        // This is since Hugo 0.63 handled in a more general way for all
                        // pages.
                        isHeadless := cast.ToBool(v)
                        pm.params[loki] = isHeadless
                        if p.File().TranslationBaseName() == "index" &amp;&amp; isHeadless </span><span class="cov8" title="1">{
                                pm.buildConfig.List = pagemeta.Never
                                pm.buildConfig.Render = pagemeta.Never
                        }</span>
                case "outputs":<span class="cov8" title="1">
                        o := cast.ToStringSlice(v)
                        if len(o) &gt; 0 </span><span class="cov8" title="1">{
                                // Output formats are explicitly set in front matter, use those.
                                outFormats, err := p.s.outputFormatsConfig.GetByNames(o...)

                                if err != nil </span><span class="cov0" title="0">{
                                        p.s.Log.Errorf("Failed to resolve output formats: %s", err)
                                }</span> else<span class="cov8" title="1"> {
                                        pm.configuredOutputFormats = outFormats
                                        pm.params[loki] = outFormats
                                }</span>

                        }
                case "draft":<span class="cov8" title="1">
                        draft = new(bool)
                        *draft = cast.ToBool(v)</span>
                case "layout":<span class="cov8" title="1">
                        pm.layout = cast.ToString(v)
                        pm.params[loki] = pm.layout</span>
                case "markup":<span class="cov8" title="1">
                        pm.markup = cast.ToString(v)
                        pm.params[loki] = pm.markup</span>
                case "weight":<span class="cov8" title="1">
                        pm.weight = cast.ToInt(v)
                        pm.params[loki] = pm.weight</span>
                case "aliases":<span class="cov8" title="1">
                        pm.aliases = cast.ToStringSlice(v)
                        for i, alias := range pm.aliases </span><span class="cov8" title="1">{
                                if strings.HasPrefix(alias, "http://") || strings.HasPrefix(alias, "https://") </span><span class="cov0" title="0">{
                                        return fmt.Errorf("http* aliases not supported: %q", alias)
                                }</span>
                                <span class="cov8" title="1">pm.aliases[i] = filepath.ToSlash(alias)</span>
                        }
                        <span class="cov8" title="1">pm.params[loki] = pm.aliases</span>
                case "sitemap":<span class="cov0" title="0">
                        p.m.sitemap = config.DecodeSitemap(p.s.siteCfg.sitemap, maps.ToStringMap(v))
                        pm.params[loki] = p.m.sitemap
                        sitemapSet = true</span>
                case "iscjklanguage":<span class="cov8" title="1">
                        isCJKLanguage = new(bool)
                        *isCJKLanguage = cast.ToBool(v)</span>
                case "translationkey":<span class="cov8" title="1">
                        pm.translationKey = cast.ToString(v)
                        pm.params[loki] = pm.translationKey</span>
                case "resources":<span class="cov8" title="1">
                        var resources []map[string]interface{}
                        handled := true

                        switch vv := v.(type) </span>{
                        case []map[interface{}]interface{}:<span class="cov0" title="0">
                                for _, vvv := range vv </span><span class="cov0" title="0">{
                                        resources = append(resources, maps.ToStringMap(vvv))
                                }</span>
                        case []map[string]interface{}:<span class="cov0" title="0">
                                resources = append(resources, vv...)</span>
                        case []interface{}:<span class="cov8" title="1">
                                for _, vvv := range vv </span><span class="cov8" title="1">{
                                        switch vvvv := vvv.(type) </span>{
                                        case map[interface{}]interface{}:<span class="cov0" title="0">
                                                resources = append(resources, maps.ToStringMap(vvvv))</span>
                                        case map[string]interface{}:<span class="cov8" title="1">
                                                resources = append(resources, vvvv)</span>
                                        }
                                }
                        default:<span class="cov0" title="0">
                                handled = false</span>
                        }

                        <span class="cov8" title="1">if handled </span><span class="cov8" title="1">{
                                pm.params[loki] = resources
                                pm.resourcesMetadata = resources
                                break</span>
                        }
                        <span class="cov0" title="0">fallthrough</span>

                default:<span class="cov8" title="1">
                        // If not one of the explicit values, store in Params
                        switch vv := v.(type) </span>{
                        case bool:<span class="cov8" title="1">
                                pm.params[loki] = vv</span>
                        case string:<span class="cov8" title="1">
                                pm.params[loki] = vv</span>
                        case int64, int32, int16, int8, int:<span class="cov8" title="1">
                                pm.params[loki] = vv</span>
                        case float64, float32:<span class="cov8" title="1">
                                pm.params[loki] = vv</span>
                        case time.Time:<span class="cov8" title="1">
                                pm.params[loki] = vv</span>
                        default:<span class="cov8" title="1"> // handle array of strings as well
                                switch vvv := vv.(type) </span>{
                                case []interface{}:<span class="cov8" title="1">
                                        if len(vvv) &gt; 0 </span><span class="cov8" title="1">{
                                                switch vvv[0].(type) </span>{
                                                case map[interface{}]interface{}:<span class="cov0" title="0"> // Proper parsing structured array from YAML based FrontMatter
                                                        pm.params[loki] = vvv</span>
                                                case map[string]interface{}:<span class="cov8" title="1"> // Proper parsing structured array from JSON based FrontMatter
                                                        pm.params[loki] = vvv</span>
                                                case []interface{}:<span class="cov0" title="0">
                                                        pm.params[loki] = vvv</span>
                                                default:<span class="cov8" title="1">
                                                        a := make([]string, len(vvv))
                                                        for i, u := range vvv </span><span class="cov8" title="1">{
                                                                a[i] = cast.ToString(u)
                                                        }</span>

                                                        <span class="cov8" title="1">pm.params[loki] = a</span>
                                                }
                                        } else<span class="cov0" title="0"> {
                                                pm.params[loki] = []string{}
                                        }</span>
                                default:<span class="cov8" title="1">
                                        pm.params[loki] = vv</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">if !sitemapSet </span><span class="cov8" title="1">{
                pm.sitemap = p.s.siteCfg.sitemap
        }</span>

        <span class="cov8" title="1">pm.markup = p.s.ContentSpec.ResolveMarkup(pm.markup)

        if draft != nil &amp;&amp; published != nil </span><span class="cov0" title="0">{
                pm.draft = *draft
                p.m.s.Log.Warnf("page %q has both draft and published settings in its frontmatter. Using draft.", p.File().Filename())
        }</span> else<span class="cov8" title="1"> if draft != nil </span><span class="cov8" title="1">{
                pm.draft = *draft
        }</span> else<span class="cov8" title="1"> if published != nil </span><span class="cov0" title="0">{
                pm.draft = !*published
        }</span>
        <span class="cov8" title="1">pm.params["draft"] = pm.draft

        if isCJKLanguage != nil </span><span class="cov8" title="1">{
                pm.isCJKLanguage = *isCJKLanguage
        }</span> else<span class="cov8" title="1"> if p.s.siteCfg.hasCJKLanguage &amp;&amp; p.source.parsed != nil </span><span class="cov8" title="1">{
                if cjkRe.Match(p.source.parsed.Input()) </span><span class="cov8" title="1">{
                        pm.isCJKLanguage = true
                }</span> else<span class="cov8" title="1"> {
                        pm.isCJKLanguage = false
                }</span>
        }

        <span class="cov8" title="1">pm.params["iscjklanguage"] = p.m.isCJKLanguage

        return nil</span>
}

func (p *pageMeta) noListAlways() bool <span class="cov8" title="1">{
        return p.buildConfig.List != pagemeta.Always
}</span>

func (p *pageMeta) getListFilter(local bool) contentTreeNodeCallback <span class="cov8" title="1">{
        return newContentTreeFilter(func(n *contentNode) bool </span><span class="cov8" title="1">{
                if n == nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov8" title="1">var shouldList bool
                switch n.p.m.buildConfig.List </span>{
                case pagemeta.Always:<span class="cov8" title="1">
                        shouldList = true</span>
                case pagemeta.Never:<span class="cov8" title="1">
                        shouldList = false</span>
                case pagemeta.ListLocally:<span class="cov8" title="1">
                        shouldList = local</span>
                }

                <span class="cov8" title="1">return !shouldList</span>
        })
}

func (p *pageMeta) noRender() bool <span class="cov8" title="1">{
        return p.buildConfig.Render != pagemeta.Always
}</span>

func (p *pageMeta) noLink() bool <span class="cov8" title="1">{
        return p.buildConfig.Render == pagemeta.Never
}</span>

func (p *pageMeta) applyDefaultValues(n *contentNode) error <span class="cov8" title="1">{
        if p.buildConfig.IsZero() </span><span class="cov8" title="1">{
                p.buildConfig, _ = pagemeta.DecodeBuildConfig(nil)
        }</span>

        <span class="cov8" title="1">if !p.s.isEnabled(p.Kind()) </span><span class="cov8" title="1">{
                (&amp;p.buildConfig).Disable()
        }</span>

        <span class="cov8" title="1">if p.markup == "" </span><span class="cov8" title="1">{
                if !p.File().IsZero() </span><span class="cov8" title="1">{
                        // Fall back to file extension
                        p.markup = p.s.ContentSpec.ResolveMarkup(p.File().Ext())
                }</span>
                <span class="cov8" title="1">if p.markup == "" </span><span class="cov8" title="1">{
                        p.markup = "markdown"
                }</span>
        }

        <span class="cov8" title="1">if p.title == "" &amp;&amp; p.f.IsZero() </span><span class="cov8" title="1">{
                switch p.Kind() </span>{
                case page.KindHome:<span class="cov8" title="1">
                        p.title = p.s.Info.title</span>
                case page.KindSection:<span class="cov8" title="1">
                        var sectionName string
                        if n != nil </span><span class="cov8" title="1">{
                                sectionName = n.rootSection()
                        }</span> else<span class="cov0" title="0"> {
                                sectionName = p.sections[0]
                        }</span>

                        <span class="cov8" title="1">sectionName = helpers.FirstUpper(sectionName)
                        if p.s.Cfg.GetBool("pluralizeListTitles") </span><span class="cov8" title="1">{
                                p.title = flect.Pluralize(sectionName)
                        }</span> else<span class="cov8" title="1"> {
                                p.title = sectionName
                        }</span>
                case page.KindTerm:<span class="cov0" title="0">
                        // TODO(bep) improve
                        key := p.sections[len(p.sections)-1]
                        p.title = strings.Replace(p.s.titleFunc(key), "-", " ", -1)</span>
                case page.KindTaxonomy:<span class="cov8" title="1">
                        p.title = p.s.titleFunc(p.sections[0])</span>
                case kind404:<span class="cov8" title="1">
                        p.title = "404 Page not found"</span>

                }
        }

        <span class="cov8" title="1">if p.IsNode() </span><span class="cov8" title="1">{
                p.bundleType = files.ContentClassBranch
        }</span> else<span class="cov8" title="1"> {
                source := p.File()
                if fi, ok := source.(*fileInfo); ok </span><span class="cov8" title="1">{
                        class := fi.FileInfo().Meta().Classifier
                        switch class </span>{
                        case files.ContentClassBranch, files.ContentClassLeaf:<span class="cov8" title="1">
                                p.bundleType = class</span>
                        }
                }
        }

        <span class="cov8" title="1">if !p.f.IsZero() </span><span class="cov8" title="1">{
                var renderingConfigOverrides map[string]interface{}
                bfParam := getParamToLower(p, "blackfriday")
                if bfParam != nil </span><span class="cov8" title="1">{
                        renderingConfigOverrides = maps.ToStringMap(bfParam)
                }</span>

                <span class="cov8" title="1">p.renderingConfigOverrides = renderingConfigOverrides</span>

        }

        <span class="cov8" title="1">return nil</span>
}

func (p *pageMeta) newContentConverter(ps *pageState, markup string, renderingConfigOverrides map[string]interface{}) (converter.Converter, error) <span class="cov8" title="1">{
        if ps == nil </span><span class="cov0" title="0">{
                panic("no Page provided")</span>
        }
        <span class="cov8" title="1">cp := p.s.ContentSpec.Converters.Get(markup)
        if cp == nil </span><span class="cov0" title="0">{
                return converter.NopConverter, errors.Errorf("no content renderer found for markup %q", p.markup)
        }</span>

        <span class="cov8" title="1">var id string
        var filename string
        var path string
        if !p.f.IsZero() </span><span class="cov8" title="1">{
                id = p.f.UniqueID()
                filename = p.f.Filename()
                path = p.f.Path()
        }</span> else<span class="cov8" title="1"> {
                path = p.Pathc()
        }</span>

        <span class="cov8" title="1">cpp, err := cp.New(
                converter.DocumentContext{
                        Document:        newPageForRenderHook(ps),
                        DocumentID:      id,
                        DocumentName:    path,
                        Filename:        filename,
                        ConfigOverrides: renderingConfigOverrides,
                },
        )
        if err != nil </span><span class="cov0" title="0">{
                return converter.NopConverter, err
        }</span>

        <span class="cov8" title="1">return cpp, nil</span>
}

// The output formats this page will be rendered to.
func (m *pageMeta) outputFormats() output.Formats <span class="cov8" title="1">{
        if len(m.configuredOutputFormats) &gt; 0 </span><span class="cov8" title="1">{
                return m.configuredOutputFormats
        }</span>

        <span class="cov8" title="1">return m.s.outputFormats[m.Kind()]</span>
}

func (p *pageMeta) Slug() string <span class="cov8" title="1">{
        return p.urlPaths.Slug
}</span>

func getParam(m resource.ResourceParamsProvider, key string, stringToLower bool) interface{} <span class="cov8" title="1">{
        v := m.Params()[strings.ToLower(key)]

        if v == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">switch val := v.(type) </span>{
        case bool:<span class="cov0" title="0">
                return val</span>
        case string:<span class="cov8" title="1">
                if stringToLower </span><span class="cov0" title="0">{
                        return strings.ToLower(val)
                }</span>
                <span class="cov8" title="1">return val</span>
        case int64, int32, int16, int8, int:<span class="cov8" title="1">
                return cast.ToInt(v)</span>
        case float64, float32:<span class="cov8" title="1">
                return cast.ToFloat64(v)</span>
        case time.Time:<span class="cov0" title="0">
                return val</span>
        case []string:<span class="cov8" title="1">
                if stringToLower </span><span class="cov0" title="0">{
                        return helpers.SliceToLower(val)
                }</span>
                <span class="cov8" title="1">return v</span>
        default:<span class="cov8" title="1">
                return v</span>
        }
}

func getParamToLower(m resource.ResourceParamsProvider, key string) interface{} <span class="cov8" title="1">{
        return getParam(m, key, true)
}</span>
</pre>
		
		<pre class="file" id="file122" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "html/template"
        "strings"

        "github.com/gohugoio/hugo/common/hugo"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/output"

        "github.com/gohugoio/hugo/lazy"

        "github.com/gohugoio/hugo/resources/page"
)

func newPageBase(metaProvider *pageMeta) (*pageState, error) <span class="cov8" title="1">{
        if metaProvider.s == nil </span><span class="cov0" title="0">{
                panic("must provide a Site")</span>
        }

        <span class="cov8" title="1">s := metaProvider.s

        ps := &amp;pageState{
                pageOutput: nopPageOutput,
                pageCommon: &amp;pageCommon{
                        FileProvider:            metaProvider,
                        AuthorProvider:          metaProvider,
                        Scratcher:               maps.NewScratcher(),
                        Positioner:              page.NopPage,
                        InSectionPositioner:     page.NopPage,
                        ResourceMetaProvider:    metaProvider,
                        ResourceParamsProvider:  metaProvider,
                        PageMetaProvider:        metaProvider,
                        RelatedKeywordsProvider: metaProvider,
                        OutputFormatsProvider:   page.NopPage,
                        ResourceTypeProvider:    pageTypesProvider,
                        MediaTypeProvider:       pageTypesProvider,
                        RefProvider:             page.NopPage,
                        ShortcodeInfoProvider:   page.NopPage,
                        LanguageProvider:        s,
                        pagePages:               &amp;pagePages{},

                        InternalDependencies: s,
                        init:                 lazy.New(),
                        m:                    metaProvider,
                        s:                    s,
                },
        }

        siteAdapter := pageSiteAdapter{s: s, p: ps}

        ps.pageMenus = &amp;pageMenus{p: ps}
        ps.PageMenusProvider = ps.pageMenus
        ps.GetPageProvider = siteAdapter
        ps.GitInfoProvider = ps
        ps.TranslationsProvider = ps
        ps.ResourceDataProvider = &amp;pageData{pageState: ps}
        ps.RawContentProvider = ps
        ps.ChildCareProvider = ps
        ps.TreeProvider = pageTree{p: ps}
        ps.Eqer = ps
        ps.TranslationKeyProvider = ps
        ps.ShortcodeInfoProvider = ps
        ps.AlternativeOutputFormatsProvider = ps

        return ps, nil</span>
}

func newPageBucket(p *pageState) *pagesMapBucket <span class="cov8" title="1">{
        return &amp;pagesMapBucket{owner: p, pagesMapBucketPages: &amp;pagesMapBucketPages{}}
}</span>

func newPageFromMeta(
        n *contentNode,
        parentBucket *pagesMapBucket,
        meta map[string]interface{},
        metaProvider *pageMeta) (*pageState, error) <span class="cov8" title="1">{
        if metaProvider.f == nil </span><span class="cov8" title="1">{
                metaProvider.f = page.NewZeroFile(metaProvider.s.LogDistinct)
        }</span>

        <span class="cov8" title="1">ps, err := newPageBase(metaProvider)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">bucket := parentBucket

        if ps.IsNode() </span><span class="cov8" title="1">{
                ps.bucket = newPageBucket(ps)
        }</span>

        <span class="cov8" title="1">if meta != nil || parentBucket != nil </span><span class="cov8" title="1">{
                if err := metaProvider.setMetadata(bucket, ps, meta); err != nil </span><span class="cov0" title="0">{
                        return nil, ps.wrapError(err)
                }</span>
        }

        <span class="cov8" title="1">if err := metaProvider.applyDefaultValues(n); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ps.init.Add(func() (interface{}, error) </span><span class="cov8" title="1">{
                pp, err := newPagePaths(metaProvider.s, ps, metaProvider)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">makeOut := func(f output.Format, render bool) *pageOutput </span><span class="cov8" title="1">{
                        return newPageOutput(ps, pp, f, render)
                }</span>

                <span class="cov8" title="1">shouldRenderPage := !ps.m.noRender()

                if ps.m.standalone </span><span class="cov8" title="1">{
                        ps.pageOutput = makeOut(ps.m.outputFormats()[0], shouldRenderPage)
                }</span> else<span class="cov8" title="1"> {
                        outputFormatsForPage := ps.m.outputFormats()

                        // Prepare output formats for all sites.
                        // We do this even if this page does not get rendered on
                        // its own. It may be referenced via .Site.GetPage and
                        // it will then need an output format.
                        ps.pageOutputs = make([]*pageOutput, len(ps.s.h.renderFormats))
                        created := make(map[string]*pageOutput)
                        for i, f := range ps.s.h.renderFormats </span><span class="cov8" title="1">{
                                po, found := created[f.Name]
                                if !found </span><span class="cov8" title="1">{
                                        render := shouldRenderPage
                                        if render </span><span class="cov8" title="1">{
                                                _, render = outputFormatsForPage.GetByName(f.Name)
                                        }</span>
                                        <span class="cov8" title="1">po = makeOut(f, render)
                                        created[f.Name] = po</span>
                                }
                                <span class="cov8" title="1">ps.pageOutputs[i] = po</span>
                        }
                }

                <span class="cov8" title="1">if err := ps.initCommonProviders(pp); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">return ps, err</span>
}

// Used by the legacy 404, sitemap and robots.txt rendering
func newPageStandalone(m *pageMeta, f output.Format) (*pageState, error) <span class="cov8" title="1">{
        m.configuredOutputFormats = output.Formats{f}
        m.standalone = true
        p, err := newPageFromMeta(nil, nil, nil, m)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := p.initPage(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return p, nil</span>
}

type pageDeprecatedWarning struct {
        p *pageState
}

func (p *pageDeprecatedWarning) IsDraft() bool          <span class="cov0" title="0">{ return p.p.m.draft }</span>
func (p *pageDeprecatedWarning) Hugo() hugo.Info        <span class="cov0" title="0">{ return p.p.s.Info.Hugo() }</span>
func (p *pageDeprecatedWarning) LanguagePrefix() string <span class="cov0" title="0">{ return p.p.s.Info.LanguagePrefix }</span>
func (p *pageDeprecatedWarning) GetParam(key string) interface{} <span class="cov0" title="0">{
        return p.p.m.params[strings.ToLower(key)]
}</span>

func (p *pageDeprecatedWarning) RSSLink() template.URL <span class="cov0" title="0">{
        f := p.p.OutputFormats().Get("RSS")
        if f == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return template.URL(f.Permalink())</span>
}

func (p *pageDeprecatedWarning) URL() string <span class="cov0" title="0">{
        if p.p.IsPage() &amp;&amp; p.p.m.urlPaths.URL != "" </span><span class="cov0" title="0">{
                // This is the url set in front matter
                return p.p.m.urlPaths.URL
        }</span>
        // Fall back to the relative permalink.
        <span class="cov0" title="0">return p.p.RelPermalink()</span>
}
</pre>
		
		<pre class="file" id="file123" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"
)

func newPageOutput(
        ps *pageState,
        pp pagePaths,
        f output.Format,
        render bool) *pageOutput <span class="cov8" title="1">{
        var targetPathsProvider targetPathsHolder
        var linksProvider resource.ResourceLinksProvider

        ft, found := pp.targetPaths[f.Name]
        if !found </span><span class="cov8" title="1">{
                // Link to the main output format
                ft = pp.targetPaths[pp.firstOutputFormat.Format.Name]
        }</span>
        <span class="cov8" title="1">targetPathsProvider = ft
        linksProvider = ft

        var paginatorProvider page.PaginatorProvider = page.NopPage
        var pag *pagePaginator

        if render &amp;&amp; ps.IsNode() </span><span class="cov8" title="1">{
                pag = newPagePaginator(ps)
                paginatorProvider = pag
        }</span>

        <span class="cov8" title="1">providers := struct {
                page.PaginatorProvider
                resource.ResourceLinksProvider
                targetPather
        }{
                paginatorProvider,
                linksProvider,
                targetPathsProvider,
        }

        po := &amp;pageOutput{
                f:                       f,
                pagePerOutputProviders:  providers,
                ContentProvider:         page.NopPage,
                TableOfContentsProvider: page.NopPage,
                PageRenderProvider:      page.NopPage,
                render:                  render,
                paginator:               pag,
        }

        return po</span>
}

// We create a pageOutput for every output format combination, even if this
// particular page isn't configured to be rendered to that format.
type pageOutput struct {
        // Set if this page isn't configured to be rendered to this format.
        render bool

        f output.Format

        // Only set if render is set.
        // Note that this will be lazily initialized, so only used if actually
        // used in template(s).
        paginator *pagePaginator

        // These interface provides the functionality that is specific for this
        // output format.
        pagePerOutputProviders
        page.ContentProvider
        page.TableOfContentsProvider
        page.PageRenderProvider

        // May be nil.
        cp *pageContentOutput
}

func (p *pageOutput) initContentProvider(cp *pageContentOutput) <span class="cov8" title="1">{
        if cp == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">p.ContentProvider = cp
        p.TableOfContentsProvider = cp
        p.PageRenderProvider = cp
        p.cp = cp</span>
}

func (p *pageOutput) enablePlaceholders() <span class="cov8" title="1">{
        if p.cp != nil </span><span class="cov8" title="1">{
                p.cp.enablePlaceholders()
        }</span>
}
</pre>
		
		<pre class="file" id="file124" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "sync"

        "github.com/gohugoio/hugo/resources/page"
)

func newPagePaginator(source *pageState) *pagePaginator <span class="cov8" title="1">{
        return &amp;pagePaginator{
                source:            source,
                pagePaginatorInit: &amp;pagePaginatorInit{},
        }
}</span>

type pagePaginator struct {
        *pagePaginatorInit
        source *pageState
}

type pagePaginatorInit struct {
        init    sync.Once
        current *page.Pager
}

// reset resets the paginator to allow for a rebuild.
func (p *pagePaginator) reset() <span class="cov8" title="1">{
        p.pagePaginatorInit = &amp;pagePaginatorInit{}
}</span>

func (p *pagePaginator) Paginate(seq interface{}, options ...interface{}) (*page.Pager, error) <span class="cov8" title="1">{
        var initErr error
        p.init.Do(func() </span><span class="cov8" title="1">{
                pagerSize, err := page.ResolvePagerSize(p.source.s.Cfg, options...)
                if err != nil </span><span class="cov0" title="0">{
                        initErr = err
                        return
                }</span>

                <span class="cov8" title="1">pd := p.source.targetPathDescriptor
                pd.Type = p.source.outputFormat()
                paginator, err := page.Paginate(pd, seq, pagerSize)
                if err != nil </span><span class="cov0" title="0">{
                        initErr = err
                        return
                }</span>

                <span class="cov8" title="1">p.current = paginator.Pagers()[0]</span>
        })

        <span class="cov8" title="1">if initErr != nil </span><span class="cov0" title="0">{
                return nil, initErr
        }</span>

        <span class="cov8" title="1">return p.current, nil</span>
}

func (p *pagePaginator) Paginator(options ...interface{}) (*page.Pager, error) <span class="cov8" title="1">{
        var initErr error
        p.init.Do(func() </span><span class="cov8" title="1">{
                pagerSize, err := page.ResolvePagerSize(p.source.s.Cfg, options...)
                if err != nil </span><span class="cov0" title="0">{
                        initErr = err
                        return
                }</span>

                <span class="cov8" title="1">pd := p.source.targetPathDescriptor
                pd.Type = p.source.outputFormat()

                var pages page.Pages

                switch p.source.Kind() </span>{
                case page.KindHome:<span class="cov8" title="1">
                        // From Hugo 0.57 we made home.Pages() work like any other
                        // section. To avoid the default paginators for the home page
                        // changing in the wild, we make this a special case.
                        pages = p.source.s.RegularPages()</span>
                case page.KindTerm, page.KindTaxonomy:<span class="cov8" title="1">
                        pages = p.source.Pages()</span>
                default:<span class="cov8" title="1">
                        pages = p.source.RegularPages()</span>
                }

                <span class="cov8" title="1">paginator, err := page.Paginate(pd, pages, pagerSize)
                if err != nil </span><span class="cov0" title="0">{
                        initErr = err
                        return
                }</span>

                <span class="cov8" title="1">p.current = paginator.Pagers()[0]</span>
        })

        <span class="cov8" title="1">if initErr != nil </span><span class="cov0" title="0">{
                return nil, initErr
        }</span>

        <span class="cov8" title="1">return p.current, nil</span>
}
</pre>
		
		<pre class="file" id="file125" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "net/url"
        "strings"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/resources/page"
)

func newPagePaths(
        s *Site,
        p page.Page,
        pm *pageMeta) (pagePaths, error) <span class="cov8" title="1">{
        targetPathDescriptor, err := createTargetPathDescriptor(s, p, pm)
        if err != nil </span><span class="cov0" title="0">{
                return pagePaths{}, err
        }</span>

        <span class="cov8" title="1">outputFormats := pm.outputFormats()
        if len(outputFormats) == 0 </span><span class="cov0" title="0">{
                return pagePaths{}, nil
        }</span>

        <span class="cov8" title="1">if pm.noRender() </span><span class="cov8" title="1">{
                outputFormats = outputFormats[:1]
        }</span>

        <span class="cov8" title="1">pageOutputFormats := make(page.OutputFormats, len(outputFormats))
        targets := make(map[string]targetPathsHolder)

        for i, f := range outputFormats </span><span class="cov8" title="1">{
                desc := targetPathDescriptor
                desc.Type = f
                paths := page.CreateTargetPaths(desc)

                var relPermalink, permalink string

                // If a page is headless or bundled in another,
                // it will not get published on its own and it will have no links.
                // We also check the build options if it's set to not render or have
                // a link.
                if !pm.noLink() &amp;&amp; !pm.bundled </span><span class="cov8" title="1">{
                        relPermalink = paths.RelPermalink(s.PathSpec)
                        permalink = paths.PermalinkForOutputFormat(s.PathSpec, f)
                }</span>

                <span class="cov8" title="1">pageOutputFormats[i] = page.NewOutputFormat(relPermalink, permalink, len(outputFormats) == 1, f)

                // Use the main format for permalinks, usually HTML.
                permalinksIndex := 0
                if f.Permalinkable </span><span class="cov8" title="1">{
                        // Unless it's permalinkable
                        permalinksIndex = i
                }</span>

                <span class="cov8" title="1">targets[f.Name] = targetPathsHolder{
                        paths:        paths,
                        OutputFormat: pageOutputFormats[permalinksIndex],
                }</span>

        }

        <span class="cov8" title="1">var out page.OutputFormats
        if !pm.noLink() </span><span class="cov8" title="1">{
                out = pageOutputFormats
        }</span>

        <span class="cov8" title="1">return pagePaths{
                outputFormats:        out,
                firstOutputFormat:    pageOutputFormats[0],
                targetPaths:          targets,
                targetPathDescriptor: targetPathDescriptor,
        }, nil</span>
}

type pagePaths struct {
        outputFormats     page.OutputFormats
        firstOutputFormat page.OutputFormat

        targetPaths          map[string]targetPathsHolder
        targetPathDescriptor page.TargetPathDescriptor
}

func (l pagePaths) OutputFormats() page.OutputFormats <span class="cov8" title="1">{
        return l.outputFormats
}</span>

func createTargetPathDescriptor(s *Site, p page.Page, pm *pageMeta) (page.TargetPathDescriptor, error) <span class="cov8" title="1">{
        var (
                dir             string
                baseName        string
                contentBaseName string
        )

        d := s.Deps

        if !p.File().IsZero() </span><span class="cov8" title="1">{
                dir = p.File().Dir()
                baseName = p.File().TranslationBaseName()
                contentBaseName = p.File().ContentBaseName()
        }</span>

        <span class="cov8" title="1">if baseName != contentBaseName </span><span class="cov8" title="1">{
                // See https://github.com/gohugoio/hugo/issues/4870
                // A leaf bundle
                dir = strings.TrimSuffix(dir, contentBaseName+helpers.FilePathSeparator)
                baseName = contentBaseName
        }</span>

        <span class="cov8" title="1">alwaysInSubDir := p.Kind() == kindSitemap

        desc := page.TargetPathDescriptor{
                PathSpec:    d.PathSpec,
                Kind:        p.Kind(),
                Sections:    p.SectionsEntries(),
                UglyURLs:    s.Info.uglyURLs(p),
                ForcePrefix: s.h.IsMultihost() || alwaysInSubDir,
                Dir:         dir,
                URL:         pm.urlPaths.URL,
        }

        if pm.Slug() != "" </span><span class="cov8" title="1">{
                desc.BaseName = pm.Slug()
        }</span> else<span class="cov8" title="1"> {
                desc.BaseName = baseName
        }</span>

        <span class="cov8" title="1">desc.PrefixFilePath = s.getLanguageTargetPathLang(alwaysInSubDir)
        desc.PrefixLink = s.getLanguagePermalinkLang(alwaysInSubDir)

        // Expand only page.KindPage and page.KindTaxonomy; don't expand other Kinds of Pages
        // like page.KindSection or page.KindTaxonomyTerm because they are "shallower" and
        // the permalink configuration values are likely to be redundant, e.g.
        // naively expanding /category/:slug/ would give /category/categories/ for
        // the "categories" page.KindTaxonomyTerm.
        if p.Kind() == page.KindPage || p.Kind() == page.KindTerm </span><span class="cov8" title="1">{
                opath, err := d.ResourceSpec.Permalinks.Expand(p.Section(), p)
                if err != nil </span><span class="cov0" title="0">{
                        return desc, err
                }</span>

                <span class="cov8" title="1">if opath != "" </span><span class="cov8" title="1">{
                        opath, _ = url.QueryUnescape(opath)
                        desc.ExpandedPermalink = opath
                }</span>

        }

        <span class="cov8" title="1">return desc, nil</span>
}
</pre>
		
		<pre class="file" id="file126" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "bytes"
        "context"
        "fmt"
        "html/template"
        "runtime/debug"
        "strings"
        "sync"
        "unicode/utf8"

        "github.com/gohugoio/hugo/identity"
        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"
        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/markup/converter/hooks"

        "github.com/gohugoio/hugo/markup/converter"

        "github.com/gohugoio/hugo/lazy"

        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/tpl"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"
)

var (
        nopTargetPath    = targetPathsHolder{}
        nopPagePerOutput = struct {
                resource.ResourceLinksProvider
                page.ContentProvider
                page.PageRenderProvider
                page.PaginatorProvider
                page.TableOfContentsProvider
                page.AlternativeOutputFormatsProvider

                targetPather
        }{
                page.NopPage,
                page.NopPage,
                page.NopPage,
                page.NopPage,
                page.NopPage,
                page.NopPage,
                nopTargetPath,
        }
)

var pageContentOutputDependenciesID = identity.KeyValueIdentity{Key: "pageOutput", Value: "dependencies"}

func newPageContentOutput(p *pageState, po *pageOutput) (*pageContentOutput, error) <span class="cov8" title="1">{
        parent := p.init

        var dependencyTracker identity.Manager
        if p.s.running() </span><span class="cov8" title="1">{
                dependencyTracker = identity.NewManager(pageContentOutputDependenciesID)
        }</span>

        <span class="cov8" title="1">cp := &amp;pageContentOutput{
                dependencyTracker: dependencyTracker,
                p:                 p,
                f:                 po.f,
                renderHooks:       &amp;renderHooks{},
        }

        initContent := func() (err error) </span><span class="cov8" title="1">{
                p.s.h.IncrContentRender()

                if p.cmap == nil </span><span class="cov8" title="1">{
                        // Nothing to do.
                        return nil
                }</span>
                <span class="cov8" title="1">defer func() </span><span class="cov8" title="1">{
                        // See https://github.com/gohugoio/hugo/issues/6210
                        if r := recover(); r != nil </span><span class="cov0" title="0">{
                                err = fmt.Errorf("%s", r)
                                p.s.Log.Errorf("[BUG] Got panic:\n%s\n%s", r, string(debug.Stack()))
                        }</span>
                }()

                <span class="cov8" title="1">if err := po.cp.initRenderHooks(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">var hasShortcodeVariants bool

                f := po.f
                cp.contentPlaceholders, hasShortcodeVariants, err = p.shortcodeState.renderShortcodesForPage(p, f)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>

                <span class="cov8" title="1">enableReuse := !(hasShortcodeVariants || cp.renderHooksHaveVariants)

                if enableReuse </span><span class="cov8" title="1">{
                        // Reuse this for the other output formats.
                        // We may improve on this, but we really want to avoid re-rendering the content
                        // to all output formats.
                        // The current rule is that if you need output format-aware shortcodes or
                        // content rendering hooks, create a output format-specific template, e.g.
                        // myshortcode.amp.html.
                        cp.enableReuse()
                }</span>

                <span class="cov8" title="1">cp.workContent = p.contentToRender(cp.contentPlaceholders)

                isHTML := cp.p.m.markup == "html"

                if !isHTML </span><span class="cov8" title="1">{
                        r, err := cp.renderContent(cp.workContent, true)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">cp.workContent = r.Bytes()

                        if tocProvider, ok := r.(converter.TableOfContentsProvider); ok </span><span class="cov8" title="1">{
                                cfg := p.s.ContentSpec.Converters.GetMarkupConfig()
                                cp.tableOfContents = template.HTML(
                                        tocProvider.TableOfContents().ToHTML(
                                                cfg.TableOfContents.StartLevel,
                                                cfg.TableOfContents.EndLevel,
                                                cfg.TableOfContents.Ordered,
                                        ),
                                )
                        }</span> else<span class="cov8" title="1"> {
                                tmpContent, tmpTableOfContents := helpers.ExtractTOC(cp.workContent)
                                cp.tableOfContents = helpers.BytesToHTML(tmpTableOfContents)
                                cp.workContent = tmpContent
                        }</span>
                }

                <span class="cov8" title="1">if cp.placeholdersEnabled </span><span class="cov8" title="1">{
                        // ToC was accessed via .Page.TableOfContents in the shortcode,
                        // at a time when the ToC wasn't ready.
                        cp.contentPlaceholders[tocShortcodePlaceholder] = string(cp.tableOfContents)
                }</span>

                <span class="cov8" title="1">if p.cmap.hasNonMarkdownShortcode || cp.placeholdersEnabled </span><span class="cov8" title="1">{
                        // There are one or more replacement tokens to be replaced.
                        cp.workContent, err = replaceShortcodeTokens(cp.workContent, cp.contentPlaceholders)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">if cp.p.source.hasSummaryDivider </span><span class="cov8" title="1">{
                        if isHTML </span><span class="cov8" title="1">{
                                src := p.source.parsed.Input()

                                // Use the summary sections as they are provided by the user.
                                if p.source.posSummaryEnd != -1 </span><span class="cov8" title="1">{
                                        cp.summary = helpers.BytesToHTML(src[p.source.posMainContent:p.source.posSummaryEnd])
                                }</span>

                                <span class="cov8" title="1">if cp.p.source.posBodyStart != -1 </span><span class="cov8" title="1">{
                                        cp.workContent = src[cp.p.source.posBodyStart:]
                                }</span>

                        } else<span class="cov8" title="1"> {
                                summary, content, err := splitUserDefinedSummaryAndContent(cp.p.m.markup, cp.workContent)
                                if err != nil </span><span class="cov0" title="0">{
                                        cp.p.s.Log.Errorf("Failed to set user defined summary for page %q: %s", cp.p.pathOrTitle(), err)
                                }</span> else<span class="cov8" title="1"> {
                                        cp.workContent = content
                                        cp.summary = helpers.BytesToHTML(summary)
                                }</span>
                        }
                } else<span class="cov8" title="1"> if cp.p.m.summary != "" </span><span class="cov8" title="1">{
                        b, err := cp.renderContent([]byte(cp.p.m.summary), false)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">html := cp.p.s.ContentSpec.TrimShortHTML(b.Bytes())
                        cp.summary = helpers.BytesToHTML(html)</span>
                }

                <span class="cov8" title="1">cp.content = helpers.BytesToHTML(cp.workContent)

                return nil</span>
        }

        // Recursive loops can only happen in content files with template code (shortcodes etc.)
        // Avoid creating new goroutines if we don't have to.
        <span class="cov8" title="1">needTimeout := p.shortcodeState.hasShortcodes() || cp.renderHooks != nil

        if needTimeout </span><span class="cov8" title="1">{
                cp.initMain = parent.BranchWithTimeout(p.s.siteCfg.timeout, func(ctx context.Context) (interface{}, error) </span><span class="cov8" title="1">{
                        return nil, initContent()
                }</span>)
        } else<span class="cov0" title="0"> {
                cp.initMain = parent.Branch(func() (interface{}, error) </span><span class="cov0" title="0">{
                        return nil, initContent()
                }</span>)
        }

        <span class="cov8" title="1">cp.initPlain = cp.initMain.Branch(func() (interface{}, error) </span><span class="cov8" title="1">{
                cp.plain = helpers.StripHTML(string(cp.content))
                cp.plainWords = strings.Fields(cp.plain)
                cp.setWordCounts(p.m.isCJKLanguage)

                if err := cp.setAutoSummary(); err != nil </span><span class="cov0" title="0">{
                        return err, nil
                }</span>

                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">return cp, nil</span>
}

type renderHooks struct {
        hooks hooks.Renderers
        init  sync.Once
}

// pageContentOutput represents the Page content for a given output format.
type pageContentOutput struct {
        f output.Format

        // If we can reuse this for other output formats.
        reuse     bool
        reuseInit sync.Once

        p *pageState

        // Lazy load dependencies
        initMain  *lazy.Init
        initPlain *lazy.Init

        placeholdersEnabled     bool
        placeholdersEnabledInit sync.Once

        renderHooks *renderHooks

        // Set if there are more than one output format variant
        renderHooksHaveVariants bool // TODO(bep) reimplement this in another way, consolidate with shortcodes

        // Content state

        workContent       []byte
        dependencyTracker identity.Manager // Set in server mode.

        // Temporary storage of placeholders mapped to their content.
        // These are shortcodes etc. Some of these will need to be replaced
        // after any markup is rendered, so they share a common prefix.
        contentPlaceholders map[string]string

        // Content sections
        content         template.HTML
        summary         template.HTML
        tableOfContents template.HTML

        truncated bool

        plainWords     []string
        plain          string
        fuzzyWordCount int
        wordCount      int
        readingTime    int
}

func (p *pageContentOutput) trackDependency(id identity.Provider) <span class="cov8" title="1">{
        if p.dependencyTracker != nil </span><span class="cov8" title="1">{
                p.dependencyTracker.Add(id)
        }</span>
}

func (p *pageContentOutput) Reset() <span class="cov8" title="1">{
        if p.dependencyTracker != nil </span><span class="cov8" title="1">{
                p.dependencyTracker.Reset()
        }</span>
        <span class="cov8" title="1">p.initMain.Reset()
        p.initPlain.Reset()
        p.renderHooks = &amp;renderHooks{}</span>
}

func (p *pageContentOutput) Content() (interface{}, error) <span class="cov8" title="1">{
        if p.p.s.initInit(p.initMain, p.p) </span><span class="cov8" title="1">{
                return p.content, nil
        }</span>
        <span class="cov8" title="1">return nil, nil</span>
}

func (p *pageContentOutput) FuzzyWordCount() int <span class="cov8" title="1">{
        p.p.s.initInit(p.initPlain, p.p)
        return p.fuzzyWordCount
}</span>

func (p *pageContentOutput) Len() int <span class="cov8" title="1">{
        p.p.s.initInit(p.initMain, p.p)
        return len(p.content)
}</span>

func (p *pageContentOutput) Plain() string <span class="cov8" title="1">{
        p.p.s.initInit(p.initPlain, p.p)
        return p.plain
}</span>

func (p *pageContentOutput) PlainWords() []string <span class="cov8" title="1">{
        p.p.s.initInit(p.initPlain, p.p)
        return p.plainWords
}</span>

func (p *pageContentOutput) ReadingTime() int <span class="cov8" title="1">{
        p.p.s.initInit(p.initPlain, p.p)
        return p.readingTime
}</span>

func (p *pageContentOutput) Summary() template.HTML <span class="cov8" title="1">{
        p.p.s.initInit(p.initMain, p.p)
        if !p.p.source.hasSummaryDivider </span><span class="cov8" title="1">{
                p.p.s.initInit(p.initPlain, p.p)
        }</span>
        <span class="cov8" title="1">return p.summary</span>
}

func (p *pageContentOutput) TableOfContents() template.HTML <span class="cov8" title="1">{
        p.p.s.initInit(p.initMain, p.p)
        return p.tableOfContents
}</span>

func (p *pageContentOutput) Truncated() bool <span class="cov8" title="1">{
        if p.p.truncated </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">p.p.s.initInit(p.initPlain, p.p)
        return p.truncated</span>
}

func (p *pageContentOutput) WordCount() int <span class="cov8" title="1">{
        p.p.s.initInit(p.initPlain, p.p)
        return p.wordCount
}</span>

func (p *pageContentOutput) RenderString(args ...interface{}) (template.HTML, error) <span class="cov8" title="1">{
        if len(args) &lt; 1 || len(args) &gt; 2 </span><span class="cov0" title="0">{
                return "", errors.New("want 1 or 2 arguments")
        }</span>

        <span class="cov8" title="1">var s string
        opts := defaultRenderStringOpts
        sidx := 1

        if len(args) == 1 </span><span class="cov8" title="1">{
                sidx = 0
        }</span> else<span class="cov8" title="1"> {
                m, ok := args[0].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return "", errors.New("first argument must be a map")
                }</span>

                <span class="cov8" title="1">if err := mapstructure.WeakDecode(m, &amp;opts); err != nil </span><span class="cov0" title="0">{
                        return "", errors.WithMessage(err, "failed to decode options")
                }</span>
        }

        <span class="cov8" title="1">var err error
        s, err = cast.ToStringE(args[sidx])
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if err = p.initRenderHooks(); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">conv := p.p.getContentConverter()
        if opts.Markup != "" &amp;&amp; opts.Markup != p.p.m.markup </span><span class="cov8" title="1">{
                var err error
                // TODO(bep) consider cache
                conv, err = p.p.m.newContentConverter(p.p, opts.Markup, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return "", p.p.wrapError(err)
                }</span>
        }

        <span class="cov8" title="1">c, err := p.renderContentWithConverter(conv, []byte(s), false)
        if err != nil </span><span class="cov0" title="0">{
                return "", p.p.wrapError(err)
        }</span>

        <span class="cov8" title="1">b := c.Bytes()

        if opts.Display == "inline" </span><span class="cov8" title="1">{
                // We may have to rethink this in the future when we get other
                // renderers.
                b = p.p.s.ContentSpec.TrimShortHTML(b)
        }</span>

        <span class="cov8" title="1">return template.HTML(string(b)), nil</span>
}

func (p *pageContentOutput) RenderWithTemplateInfo(info tpl.Info, layout ...string) (template.HTML, error) <span class="cov0" title="0">{
        p.p.addDependency(info)
        return p.Render(layout...)
}</span>

func (p *pageContentOutput) Render(layout ...string) (template.HTML, error) <span class="cov8" title="1">{
        templ, found, err := p.p.resolveTemplate(layout...)
        if err != nil </span><span class="cov0" title="0">{
                return "", p.p.wrapError(err)
        }</span>

        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">p.p.addDependency(templ.(tpl.Info))

        // Make sure to send the *pageState and not the *pageContentOutput to the template.
        res, err := executeToString(p.p.s.Tmpl(), templ, p.p)
        if err != nil </span><span class="cov0" title="0">{
                return "", p.p.wrapError(errors.Wrapf(err, "failed to execute template %q v", layout))
        }</span>
        <span class="cov8" title="1">return template.HTML(res), nil</span>
}

func (p *pageContentOutput) initRenderHooks() error <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var initErr error

        p.renderHooks.init.Do(func() </span><span class="cov8" title="1">{
                ps := p.p

                c := ps.getContentConverter()
                if c == nil || !c.Supports(converter.FeatureRenderHooks) </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">h, err := ps.createRenderHooks(p.f)
                if err != nil </span><span class="cov0" title="0">{
                        initErr = err
                        return
                }</span>
                <span class="cov8" title="1">p.renderHooks.hooks = h

                if !p.renderHooksHaveVariants || h.IsZero() </span><span class="cov8" title="1">{
                        // Check if there is a different render hooks template
                        // for any of the other page output formats.
                        // If not, we can reuse this.
                        for _, po := range ps.pageOutputs </span><span class="cov8" title="1">{
                                if po.f.Name != p.f.Name </span><span class="cov8" title="1">{
                                        h2, err := ps.createRenderHooks(po.f)
                                        if err != nil </span><span class="cov0" title="0">{
                                                initErr = err
                                                return
                                        }</span>

                                        <span class="cov8" title="1">if h2.IsZero() </span><span class="cov8" title="1">{
                                                continue</span>
                                        }

                                        <span class="cov8" title="1">if p.renderHooks.hooks.IsZero() </span><span class="cov8" title="1">{
                                                p.renderHooks.hooks = h2
                                        }</span>

                                        <span class="cov8" title="1">p.renderHooksHaveVariants = !h2.Eq(p.renderHooks.hooks)

                                        if p.renderHooksHaveVariants </span><span class="cov8" title="1">{
                                                break</span>
                                        }

                                }
                        }
                }
        })

        <span class="cov8" title="1">return initErr</span>
}

func (p *pageContentOutput) setAutoSummary() error <span class="cov8" title="1">{
        if p.p.source.hasSummaryDivider || p.p.m.summary != "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var summary string
        var truncated bool

        if p.p.m.isCJKLanguage </span><span class="cov8" title="1">{
                summary, truncated = p.p.s.ContentSpec.TruncateWordsByRune(p.plainWords)
        }</span> else<span class="cov8" title="1"> {
                summary, truncated = p.p.s.ContentSpec.TruncateWordsToWholeSentence(p.plain)
        }</span>
        <span class="cov8" title="1">p.summary = template.HTML(summary)

        p.truncated = truncated

        return nil</span>
}

func (cp *pageContentOutput) renderContent(content []byte, renderTOC bool) (converter.Result, error) <span class="cov8" title="1">{
        c := cp.p.getContentConverter()
        return cp.renderContentWithConverter(c, content, renderTOC)
}</span>

func (cp *pageContentOutput) renderContentWithConverter(c converter.Converter, content []byte, renderTOC bool) (converter.Result, error) <span class="cov8" title="1">{
        r, err := c.Convert(
                converter.RenderContext{
                        Src:         content,
                        RenderTOC:   renderTOC,
                        RenderHooks: cp.renderHooks.hooks,
                })

        if err == nil </span><span class="cov8" title="1">{
                if ids, ok := r.(identity.IdentitiesProvider); ok </span><span class="cov8" title="1">{
                        for _, v := range ids.GetIdentities() </span><span class="cov8" title="1">{
                                cp.trackDependency(v)
                        }</span>
                }
        }

        <span class="cov8" title="1">return r, err</span>
}

func (p *pageContentOutput) setWordCounts(isCJKLanguage bool) <span class="cov8" title="1">{
        if isCJKLanguage </span><span class="cov8" title="1">{
                p.wordCount = 0
                for _, word := range p.plainWords </span><span class="cov8" title="1">{
                        runeCount := utf8.RuneCountInString(word)
                        if len(word) == runeCount </span><span class="cov8" title="1">{
                                p.wordCount++
                        }</span> else<span class="cov8" title="1"> {
                                p.wordCount += runeCount
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                p.wordCount = helpers.TotalWords(p.plain)
        }</span>

        // TODO(bep) is set in a test. Fix that.
        <span class="cov8" title="1">if p.fuzzyWordCount == 0 </span><span class="cov8" title="1">{
                p.fuzzyWordCount = (p.wordCount + 100) / 100 * 100
        }</span>

        <span class="cov8" title="1">if isCJKLanguage </span><span class="cov8" title="1">{
                p.readingTime = (p.wordCount + 500) / 501
        }</span> else<span class="cov8" title="1"> {
                p.readingTime = (p.wordCount + 212) / 213
        }</span>
}

// A callback to signal that we have inserted a placeholder into the rendered
// content. This avoids doing extra replacement work.
func (p *pageContentOutput) enablePlaceholders() <span class="cov8" title="1">{
        p.placeholdersEnabledInit.Do(func() </span><span class="cov8" title="1">{
                p.placeholdersEnabled = true
        }</span>)
}

func (p *pageContentOutput) enableReuse() <span class="cov8" title="1">{
        p.reuseInit.Do(func() </span><span class="cov8" title="1">{
                p.reuse = true
        }</span>)
}

// these will be shifted out when rendering a given output format.
type pagePerOutputProviders interface {
        targetPather
        page.PaginatorProvider
        resource.ResourceLinksProvider
}

type targetPather interface {
        targetPaths() page.TargetPaths
}

type targetPathsHolder struct {
        paths page.TargetPaths
        page.OutputFormat
}

func (t targetPathsHolder) targetPaths() page.TargetPaths <span class="cov8" title="1">{
        return t.paths
}</span>

func executeToString(h tpl.TemplateHandler, templ tpl.Template, data interface{}) (string, error) <span class="cov8" title="1">{
        b := bp.GetBuffer()
        defer bp.PutBuffer(b)
        if err := h.Execute(templ, b, data); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return b.String(), nil</span>
}

func splitUserDefinedSummaryAndContent(markup string, c []byte) (summary []byte, content []byte, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("summary split failed: %s", r)
                }</span>
        }()

        <span class="cov8" title="1">startDivider := bytes.Index(c, internalSummaryDividerBaseBytes)

        if startDivider == -1 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">startTag := "p"
        switch markup </span>{
        case "asciidocext":<span class="cov0" title="0">
                startTag = "div"</span>
        }

        // Walk back and forward to the surrounding tags.
        <span class="cov8" title="1">start := bytes.LastIndex(c[:startDivider], []byte("&lt;"+startTag))
        end := bytes.Index(c[startDivider:], []byte("&lt;/"+startTag))

        if start == -1 </span><span class="cov0" title="0">{
                start = startDivider
        }</span> else<span class="cov8" title="1"> {
                start = startDivider - (startDivider - start)
        }</span>

        <span class="cov8" title="1">if end == -1 </span><span class="cov0" title="0">{
                end = startDivider + len(internalSummaryDividerBase)
        }</span> else<span class="cov8" title="1"> {
                end = startDivider + end + len(startTag) + 3
        }</span>

        <span class="cov8" title="1">var addDiv bool

        switch markup </span>{
        case "rst":<span class="cov0" title="0">
                addDiv = true</span>
        }

        <span class="cov8" title="1">withoutDivider := append(c[:start], bytes.Trim(c[end:], "\n")...)

        if len(withoutDivider) &gt; 0 </span><span class="cov8" title="1">{
                summary = bytes.TrimSpace(withoutDivider[:start])
        }</span>

        <span class="cov8" title="1">if addDiv </span><span class="cov0" title="0">{
                // For the rst
                summary = append(append([]byte(nil), summary...), []byte("&lt;/div&gt;")...)
        }</span>

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">content = bytes.TrimSpace(withoutDivider)

        return</span>
}
</pre>
		
		<pre class="file" id="file127" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/gohugoio/hugo/lazy"
        "github.com/gohugoio/hugo/resources/page"
)

func newPagePosition(n *nextPrev) pagePosition <span class="cov8" title="1">{
        return pagePosition{nextPrev: n}
}</span>

func newPagePositionInSection(n *nextPrev) pagePositionInSection <span class="cov8" title="1">{
        return pagePositionInSection{nextPrev: n}
}</span>

type nextPrev struct {
        init     *lazy.Init
        prevPage page.Page
        nextPage page.Page
}

func (n *nextPrev) next() page.Page <span class="cov8" title="1">{
        n.init.Do()
        return n.nextPage
}</span>

func (n *nextPrev) prev() page.Page <span class="cov8" title="1">{
        n.init.Do()
        return n.prevPage
}</span>

type pagePosition struct {
        *nextPrev
}

func (p pagePosition) Next() page.Page <span class="cov8" title="1">{
        return p.next()
}</span>

func (p pagePosition) NextPage() page.Page <span class="cov0" title="0">{
        return p.Next()
}</span>

func (p pagePosition) Prev() page.Page <span class="cov8" title="1">{
        return p.prev()
}</span>

func (p pagePosition) PrevPage() page.Page <span class="cov0" title="0">{
        return p.Prev()
}</span>

type pagePositionInSection struct {
        *nextPrev
}

func (p pagePositionInSection) NextInSection() page.Page <span class="cov8" title="1">{
        return p.next()
}</span>

func (p pagePositionInSection) PrevInSection() page.Page <span class="cov8" title="1">{
        return p.prev()
}</span>
</pre>
		
		<pre class="file" id="file128" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"

        "github.com/gohugoio/hugo/common/text"

        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"
)

func newPageRef(p *pageState) pageRef <span class="cov8" title="1">{
        return pageRef{p: p}
}</span>

type pageRef struct {
        p *pageState
}

func (p pageRef) Ref(argsm map[string]interface{}) (string, error) <span class="cov8" title="1">{
        return p.ref(argsm, p.p)
}</span>

func (p pageRef) RefFrom(argsm map[string]interface{}, source interface{}) (string, error) <span class="cov8" title="1">{
        return p.ref(argsm, source)
}</span>

func (p pageRef) RelRef(argsm map[string]interface{}) (string, error) <span class="cov8" title="1">{
        return p.relRef(argsm, p.p)
}</span>

func (p pageRef) RelRefFrom(argsm map[string]interface{}, source interface{}) (string, error) <span class="cov8" title="1">{
        return p.relRef(argsm, source)
}</span>

func (p pageRef) decodeRefArgs(args map[string]interface{}) (refArgs, *Site, error) <span class="cov8" title="1">{
        var ra refArgs
        err := mapstructure.WeakDecode(args, &amp;ra)
        if err != nil </span><span class="cov0" title="0">{
                return ra, nil, nil
        }</span>

        <span class="cov8" title="1">s := p.p.s

        if ra.Lang != "" &amp;&amp; ra.Lang != p.p.s.Language().Lang </span><span class="cov8" title="1">{
                // Find correct site
                found := false
                for _, ss := range p.p.s.h.Sites </span><span class="cov8" title="1">{
                        if ss.Lang() == ra.Lang </span><span class="cov8" title="1">{
                                found = true
                                s = ss
                        }</span>
                }

                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        p.p.s.siteRefLinker.logNotFound(ra.Path, fmt.Sprintf("no site found with lang %q", ra.Lang), nil, text.Position{})
                        return ra, nil, nil
                }</span>
        }

        <span class="cov8" title="1">return ra, s, nil</span>
}

func (p pageRef) ref(argsm map[string]interface{}, source interface{}) (string, error) <span class="cov8" title="1">{
        args, s, err := p.decodeRefArgs(argsm)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "invalid arguments to Ref")
        }</span>

        <span class="cov8" title="1">if s == nil </span><span class="cov0" title="0">{
                return p.p.s.siteRefLinker.notFoundURL, nil
        }</span>

        <span class="cov8" title="1">if args.Path == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return s.refLink(args.Path, source, false, args.OutputFormat)</span>
}

func (p pageRef) relRef(argsm map[string]interface{}, source interface{}) (string, error) <span class="cov8" title="1">{
        args, s, err := p.decodeRefArgs(argsm)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.Wrap(err, "invalid arguments to Ref")
        }</span>

        <span class="cov8" title="1">if s == nil </span><span class="cov0" title="0">{
                return p.p.s.siteRefLinker.notFoundURL, nil
        }</span>

        <span class="cov8" title="1">if args.Path == "" </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return s.refLink(args.Path, source, true, args.OutputFormat)</span>
}

type refArgs struct {
        Path         string
        Lang         string
        OutputFormat string
}
</pre>
		
		<pre class="file" id="file129" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "path"
        "strings"

        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/resources/page"
)

type pageTree struct {
        p *pageState
}

func (pt pageTree) IsAncestor(other interface{}) (bool, error) <span class="cov8" title="1">{
        if pt.p == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">tp, ok := other.(treeRefProvider)
        if !ok </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">ref1, ref2 := pt.p.getTreeRef(), tp.getTreeRef()

        if ref1 != nil &amp;&amp; ref1.key == "/" </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if ref1 == nil || ref2 == nil </span><span class="cov8" title="1">{
                if ref1 == nil </span><span class="cov8" title="1">{
                        // A 404 or other similar standalone page.
                        return false, nil
                }</span>

                <span class="cov0" title="0">return ref1.n.p.IsHome(), nil</span>
        }

        <span class="cov8" title="1">if ref1.key == ref2.key </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(ref2.key, ref1.key) </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">return strings.HasPrefix(ref2.key, ref1.key+cmBranchSeparator), nil</span>
}

func (pt pageTree) CurrentSection() page.Page <span class="cov8" title="1">{
        p := pt.p

        if p.IsHome() || p.IsSection() </span><span class="cov8" title="1">{
                return p
        }</span>

        <span class="cov8" title="1">return p.Parent()</span>
}

func (pt pageTree) IsDescendant(other interface{}) (bool, error) <span class="cov8" title="1">{
        if pt.p == nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">tp, ok := other.(treeRefProvider)
        if !ok </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">ref1, ref2 := pt.p.getTreeRef(), tp.getTreeRef()

        if ref2 != nil &amp;&amp; ref2.key == "/" </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if ref1 == nil || ref2 == nil </span><span class="cov8" title="1">{
                if ref2 == nil </span><span class="cov8" title="1">{
                        // A 404 or other similar standalone page.
                        return false, nil
                }</span>

                <span class="cov0" title="0">return ref2.n.p.IsHome(), nil</span>
        }

        <span class="cov8" title="1">if ref1.key == ref2.key </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(ref1.key, ref2.key) </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">return strings.HasPrefix(ref1.key, ref2.key+cmBranchSeparator), nil</span>
}

func (pt pageTree) FirstSection() page.Page <span class="cov8" title="1">{
        ref := pt.p.getTreeRef()
        if ref == nil </span><span class="cov8" title="1">{
                return pt.p.s.home
        }</span>
        <span class="cov8" title="1">key := ref.key

        if !ref.isSection() </span><span class="cov8" title="1">{
                key = path.Dir(key)
        }</span>

        <span class="cov8" title="1">_, b := ref.m.getFirstSection(key)
        if b == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return b.p</span>
}

func (pt pageTree) InSection(other interface{}) (bool, error) <span class="cov8" title="1">{
        if pt.p == nil || types.IsNil(other) </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov8" title="1">tp, ok := other.(treeRefProvider)
        if !ok </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">ref1, ref2 := pt.p.getTreeRef(), tp.getTreeRef()

        if ref1 == nil || ref2 == nil </span><span class="cov8" title="1">{
                if ref1 == nil </span><span class="cov0" title="0">{
                        // A 404 or other similar standalone page.
                        return false, nil
                }</span>
                <span class="cov8" title="1">return ref1.n.p.IsHome(), nil</span>
        }

        <span class="cov8" title="1">s1, _ := ref1.getCurrentSection()
        s2, _ := ref2.getCurrentSection()

        return s1 == s2, nil</span>
}

func (pt pageTree) Page() page.Page <span class="cov8" title="1">{
        return pt.p
}</span>

func (pt pageTree) Parent() page.Page <span class="cov8" title="1">{
        p := pt.p

        if p.parent != nil </span><span class="cov8" title="1">{
                return p.parent
        }</span>

        <span class="cov8" title="1">if pt.p.IsHome() </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">tree := p.getTreeRef()

        if tree == nil || pt.p.Kind() == page.KindTaxonomy </span><span class="cov8" title="1">{
                return pt.p.s.home
        }</span>

        <span class="cov8" title="1">_, b := tree.getSection()
        if b == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">return b.p</span>
}

func (pt pageTree) Sections() page.Pages <span class="cov8" title="1">{
        if pt.p.bucket == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return pt.p.bucket.getSections()</span>
}
</pre>
		
		<pre class="file" id="file130" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "strings"

        "github.com/gohugoio/hugo/resources/page"
)

// This is all the kinds we can expect to find in .Site.Pages.
var allKindsInPages = []string{page.KindPage, page.KindHome, page.KindSection, page.KindTerm, page.KindTaxonomy}

const (

        // Temporary state.
        kindUnknown = "unknown"

        // The following are (currently) temporary nodes,
        // i.e. nodes we create just to render in isolation.
        kindRSS       = "RSS"
        kindSitemap   = "sitemap"
        kindRobotsTXT = "robotsTXT"
        kind404       = "404"

        pageResourceType = "page"
)

var kindMap = map[string]string{
        strings.ToLower(kindRSS):       kindRSS,
        strings.ToLower(kindSitemap):   kindSitemap,
        strings.ToLower(kindRobotsTXT): kindRobotsTXT,
        strings.ToLower(kind404):       kind404,
}

func getKind(s string) string <span class="cov8" title="1">{
        if pkind := page.GetKind(s); pkind != "" </span><span class="cov8" title="1">{
                return pkind
        }</span>
        <span class="cov0" title="0">return kindMap[strings.ToLower(s)]</span>
}
</pre>
		
		<pre class="file" id="file131" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/resources/page"
)

// Wraps a Page.
type pageWrapper interface {
        page() page.Page
}

// unwrapPage is used in equality checks and similar.
func unwrapPage(in interface{}) (page.Page, error) <span class="cov8" title="1">{
        switch v := in.(type) </span>{
        case *pageState:<span class="cov8" title="1">
                return v, nil</span>
        case pageWrapper:<span class="cov8" title="1">
                return v.page(), nil</span>
        case page.Page:<span class="cov0" title="0">
                return v, nil</span>
        case nil:<span class="cov0" title="0">
                return nil, nil</span>
        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unwrapPage: %T not supported", in)</span>
        }
}

func mustUnwrapPage(in interface{}) page.Page <span class="cov8" title="1">{
        p, err := unwrapPage(in)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return p</span>
}
</pre>
		
		<pre class="file" id="file132" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "path"
        "path/filepath"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/common/paths"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/resources/page"
)

// PageCollections contains the page collections for a site.
type PageCollections struct {
        pageMap *pageMap

        // Lazy initialized page collections
        pages           *lazyPagesFactory
        regularPages    *lazyPagesFactory
        allPages        *lazyPagesFactory
        allRegularPages *lazyPagesFactory
}

// Pages returns all pages.
// This is for the current language only.
func (c *PageCollections) Pages() page.Pages <span class="cov8" title="1">{
        return c.pages.get()
}</span>

// RegularPages returns all the regular pages.
// This is for the current language only.
func (c *PageCollections) RegularPages() page.Pages <span class="cov8" title="1">{
        return c.regularPages.get()
}</span>

// AllPages returns all pages for all languages.
func (c *PageCollections) AllPages() page.Pages <span class="cov8" title="1">{
        return c.allPages.get()
}</span>

// AllPages returns all regular pages for all languages.
func (c *PageCollections) AllRegularPages() page.Pages <span class="cov0" title="0">{
        return c.allRegularPages.get()
}</span>

type lazyPagesFactory struct {
        pages page.Pages

        init    sync.Once
        factory page.PagesFactory
}

func (l *lazyPagesFactory) get() page.Pages <span class="cov8" title="1">{
        l.init.Do(func() </span><span class="cov8" title="1">{
                l.pages = l.factory()
        }</span>)
        <span class="cov8" title="1">return l.pages</span>
}

func newLazyPagesFactory(factory page.PagesFactory) *lazyPagesFactory <span class="cov8" title="1">{
        return &amp;lazyPagesFactory{factory: factory}
}</span>

func newPageCollections(m *pageMap) *PageCollections <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                panic("must provide a pageMap")</span>
        }

        <span class="cov8" title="1">c := &amp;PageCollections{pageMap: m}

        c.pages = newLazyPagesFactory(func() page.Pages </span><span class="cov8" title="1">{
                return m.createListAllPages()
        }</span>)

        <span class="cov8" title="1">c.regularPages = newLazyPagesFactory(func() page.Pages </span><span class="cov8" title="1">{
                return c.findPagesByKindIn(page.KindPage, c.pages.get())
        }</span>)

        <span class="cov8" title="1">return c</span>
}

// This is an adapter func for the old API with Kind as first argument.
// This is invoked when you do .Site.GetPage. We drop the Kind and fails
// if there are more than 2 arguments, which would be ambiguous.
func (c *PageCollections) getPageOldVersion(ref ...string) (page.Page, error) <span class="cov8" title="1">{
        var refs []string
        for _, r := range ref </span><span class="cov8" title="1">{
                // A common construct in the wild is
                // .Site.GetPage "home" "" or
                // .Site.GetPage "home" "/"
                if r != "" &amp;&amp; r != "/" </span><span class="cov8" title="1">{
                        refs = append(refs, r)
                }</span>
        }

        <span class="cov8" title="1">var key string

        if len(refs) &gt; 2 </span><span class="cov0" title="0">{
                // This was allowed in Hugo &lt;= 0.44, but we cannot support this with the
                // new API. This should be the most unusual case.
                return nil, fmt.Errorf(`too many arguments to .Site.GetPage: %v. Use lookups on the form {{ .Site.GetPage "/posts/mypage-md" }}`, ref)
        }</span>

        <span class="cov8" title="1">if len(refs) == 0 || refs[0] == page.KindHome </span><span class="cov8" title="1">{
                key = "/"
        }</span> else<span class="cov8" title="1"> if len(refs) == 1 </span><span class="cov8" title="1">{
                if len(ref) == 2 &amp;&amp; refs[0] == page.KindSection </span><span class="cov8" title="1">{
                        // This is an old style reference to the "Home Page section".
                        // Typically fetched via {{ .Site.GetPage "section" .Section }}
                        // See https://github.com/gohugoio/hugo/issues/4989
                        key = "/"
                }</span> else<span class="cov8" title="1"> {
                        key = refs[0]
                }</span>
        } else<span class="cov8" title="1"> {
                key = refs[1]
        }</span>

        <span class="cov8" title="1">key = filepath.ToSlash(key)
        if !strings.HasPrefix(key, "/") </span><span class="cov8" title="1">{
                key = "/" + key
        }</span>

        <span class="cov8" title="1">return c.getPageNew(nil, key)</span>
}

//         Only used in tests.
func (c *PageCollections) getPage(typ string, sections ...string) page.Page <span class="cov8" title="1">{
        refs := append([]string{typ}, path.Join(sections...))
        p, _ := c.getPageOldVersion(refs...)
        return p
}</span>

// getPageRef resolves a Page from ref/relRef, with a slightly more comprehensive
// search path than getPageNew.
func (c *PageCollections) getPageRef(context page.Page, ref string) (page.Page, error) <span class="cov8" title="1">{
        n, err := c.getContentNode(context, true, ref)
        if err != nil || n == nil || n.p == nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return n.p, nil</span>
}

func (c *PageCollections) getPageNew(context page.Page, ref string) (page.Page, error) <span class="cov8" title="1">{
        n, err := c.getContentNode(context, false, ref)
        if err != nil || n == nil || n.p == nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return n.p, nil</span>
}

func (c *PageCollections) getSectionOrPage(ref string) (*contentNode, string) <span class="cov8" title="1">{
        var n *contentNode

        pref := helpers.AddTrailingSlash(ref)
        s, v, found := c.pageMap.sections.LongestPrefix(pref)

        if found </span><span class="cov8" title="1">{
                n = v.(*contentNode)
        }</span>

        <span class="cov8" title="1">if found &amp;&amp; s == pref </span><span class="cov8" title="1">{
                // A section
                return n, ""
        }</span>

        <span class="cov8" title="1">m := c.pageMap

        filename := strings.TrimPrefix(strings.TrimPrefix(ref, s), "/")
        langSuffix := "." + m.s.Lang()

        // Trim both extension and any language code.
        name := paths.PathNoExt(filename)
        name = strings.TrimSuffix(name, langSuffix)

        // These are reserved bundle names and will always be stored by their owning
        // folder name.
        name = strings.TrimSuffix(name, "/index")
        name = strings.TrimSuffix(name, "/_index")

        if !found </span><span class="cov0" title="0">{
                return nil, name
        }</span>

        // Check if it's a section with filename provided.
        <span class="cov8" title="1">if !n.p.File().IsZero() &amp;&amp; n.p.File().LogicalName() == filename </span><span class="cov8" title="1">{
                return n, name
        }</span>

        <span class="cov8" title="1">return m.getPage(s, name), name</span>
}

// For Ref/Reflink and .Site.GetPage do simple name lookups for the potentially ambigous myarticle.md and /myarticle.md,
// but not when we get ./myarticle*, section/myarticle.
func shouldDoSimpleLookup(ref string) bool <span class="cov8" title="1">{
        if ref[0] == '.' </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">slashCount := strings.Count(ref, "/")

        if slashCount &gt; 1 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return slashCount == 0 || ref[0] == '/'</span>
}

func (c *PageCollections) getContentNode(context page.Page, isReflink bool, ref string) (*contentNode, error) <span class="cov8" title="1">{
        ref = filepath.ToSlash(strings.ToLower(strings.TrimSpace(ref)))

        if ref == "" </span><span class="cov8" title="1">{
                ref = "/"
        }</span>

        <span class="cov8" title="1">inRef := ref
        navUp := strings.HasPrefix(ref, "..")
        var doSimpleLookup bool
        if isReflink || context == nil </span><span class="cov8" title="1">{
                doSimpleLookup = shouldDoSimpleLookup(ref)
        }</span>

        <span class="cov8" title="1">if context != nil &amp;&amp; !strings.HasPrefix(ref, "/") </span><span class="cov8" title="1">{
                // Try the page-relative path.
                var base string
                if context.File().IsZero() </span><span class="cov8" title="1">{
                        base = context.SectionsPath()
                }</span> else<span class="cov8" title="1"> {
                        meta := context.File().FileInfo().Meta()
                        base = filepath.ToSlash(filepath.Dir(meta.Path))
                        if meta.Classifier == files.ContentClassLeaf </span><span class="cov8" title="1">{
                                // Bundles are stored in subfolders e.g. blog/mybundle/index.md,
                                // so if the user has not explicitly asked to go up,
                                // look on the "blog" level.
                                if !navUp </span><span class="cov8" title="1">{
                                        base = path.Dir(base)
                                }</span>
                        }
                }
                <span class="cov8" title="1">ref = path.Join("/", strings.ToLower(base), ref)</span>
        }

        <span class="cov8" title="1">if !strings.HasPrefix(ref, "/") </span><span class="cov8" title="1">{
                ref = "/" + ref
        }</span>

        <span class="cov8" title="1">m := c.pageMap

        // It's either a section, a page in a section or a taxonomy node.
        // Start with the most likely:
        n, name := c.getSectionOrPage(ref)
        if n != nil </span><span class="cov8" title="1">{
                return n, nil
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(inRef, "/") </span><span class="cov8" title="1">{
                // Many people will have "post/foo.md" in their content files.
                if n, _ := c.getSectionOrPage("/" + inRef); n != nil </span><span class="cov8" title="1">{
                        return n, nil
                }</span>
        }

        // Check if it's a taxonomy node
        <span class="cov8" title="1">pref := helpers.AddTrailingSlash(ref)
        s, v, found := m.taxonomies.LongestPrefix(pref)

        if found </span><span class="cov8" title="1">{
                if !m.onSameLevel(pref, s) </span><span class="cov8" title="1">{
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return v.(*contentNode), nil</span>
        }

        <span class="cov8" title="1">getByName := func(s string) (*contentNode, error) </span><span class="cov8" title="1">{
                n := m.pageReverseIndex.Get(s)
                if n != nil </span><span class="cov8" title="1">{
                        if n == ambiguousContentNode </span><span class="cov8" title="1">{
                                return nil, fmt.Errorf("page reference %q is ambiguous", ref)
                        }</span>
                        <span class="cov8" title="1">return n, nil</span>
                }

                <span class="cov8" title="1">return nil, nil</span>
        }

        <span class="cov8" title="1">var module string
        if context != nil &amp;&amp; !context.File().IsZero() </span><span class="cov8" title="1">{
                module = context.File().FileInfo().Meta().Module
        }</span>

        <span class="cov8" title="1">if module == "" &amp;&amp; !c.pageMap.s.home.File().IsZero() </span><span class="cov8" title="1">{
                module = c.pageMap.s.home.File().FileInfo().Meta().Module
        }</span>

        <span class="cov8" title="1">if module != "" </span><span class="cov8" title="1">{
                n, err := getByName(module + ref)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if n != nil </span><span class="cov8" title="1">{
                        return n, nil
                }</span>
        }

        <span class="cov8" title="1">if !doSimpleLookup </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        // Ref/relref supports this potentially ambigous lookup.
        <span class="cov8" title="1">return getByName(path.Base(name))</span>
}

func (*PageCollections) findPagesByKindIn(kind string, inPages page.Pages) page.Pages <span class="cov8" title="1">{
        var pages page.Pages
        for _, p := range inPages </span><span class="cov8" title="1">{
                if p.Kind() == kind </span><span class="cov8" title="1">{
                        pages = append(pages, p)
                }</span>
        }
        <span class="cov8" title="1">return pages</span>
}
</pre>
		
		<pre class="file" id="file133" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "context"
        "fmt"
        "os"
        pth "path"
        "path/filepath"
        "reflect"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/parser/pageparser"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/source"

        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/spf13/afero"
)

const (
        walkIsRootFileMetaKey = "walkIsRootFileMetaKey"
)

func newPagesCollector(
        sp *source.SourceSpec,
        contentMap *pageMaps,
        logger loggers.Logger,
        contentTracker *contentChangeMap,
        proc pagesCollectorProcessorProvider, filenames ...string) *pagesCollector <span class="cov8" title="1">{
        return &amp;pagesCollector{
                fs:         sp.SourceFs,
                contentMap: contentMap,
                proc:       proc,
                sp:         sp,
                logger:     logger,
                filenames:  filenames,
                tracker:    contentTracker,
        }
}</span>

type contentDirKey struct {
        dirname  string
        filename string
        tp       bundleDirType
}

type fileinfoBundle struct {
        header    hugofs.FileMetaInfo
        resources []hugofs.FileMetaInfo
}

func (b *fileinfoBundle) containsResource(name string) bool <span class="cov8" title="1">{
        for _, r := range b.resources </span><span class="cov8" title="1">{
                if r.Name() == name </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

type pageBundles map[string]*fileinfoBundle

type pagesCollector struct {
        sp     *source.SourceSpec
        fs     afero.Fs
        logger loggers.Logger

        contentMap *pageMaps

        // Ordered list (bundle headers first) used in partial builds.
        filenames []string

        // Content files tracker used in partial builds.
        tracker *contentChangeMap

        proc pagesCollectorProcessorProvider
}

// isCascadingEdit returns whether the dir represents a cascading edit.
// That is, if a front matter cascade section is removed, added or edited.
// If this is the case we must re-evaluate its descendants.
func (c *pagesCollector) isCascadingEdit(dir contentDirKey) (bool, string) <span class="cov8" title="1">{
        // This is either a section or a taxonomy node. Find it.
        prefix := cleanTreeKey(dir.dirname)

        section := "/"
        var isCascade bool

        c.contentMap.walkBranchesPrefix(prefix, func(s string, n *contentNode) bool </span><span class="cov8" title="1">{
                if n.fi == nil || dir.filename != n.fi.Meta().Filename </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">f, err := n.fi.Meta().Open()
                if err != nil </span><span class="cov0" title="0">{
                        // File may have been removed, assume a cascading edit.
                        // Some false positives is not too bad.
                        isCascade = true
                        return true
                }</span>

                <span class="cov8" title="1">pf, err := pageparser.ParseFrontMatterAndContent(f)
                f.Close()
                if err != nil </span><span class="cov0" title="0">{
                        isCascade = true
                        return true
                }</span>

                <span class="cov8" title="1">if n.p == nil || n.p.bucket == nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov8" title="1">section = s

                maps.PrepareParams(pf.FrontMatter)
                cascade1, ok := pf.FrontMatter["cascade"]
                hasCascade := n.p.bucket.cascade != nil &amp;&amp; len(n.p.bucket.cascade) &gt; 0
                if !ok </span><span class="cov8" title="1">{
                        isCascade = hasCascade

                        return true
                }</span>

                <span class="cov8" title="1">if !hasCascade </span><span class="cov0" title="0">{
                        isCascade = true
                        return true
                }</span>

                <span class="cov8" title="1">for _, v := range n.p.bucket.cascade </span><span class="cov8" title="1">{
                        isCascade = !reflect.DeepEqual(cascade1, v)
                        if isCascade </span><span class="cov8" title="1">{
                                break</span>
                        }
                }

                <span class="cov8" title="1">return true</span>
        })

        <span class="cov8" title="1">return isCascade, section</span>
}

// Collect.
func (c *pagesCollector) Collect() (collectErr error) <span class="cov8" title="1">{
        c.proc.Start(context.Background())
        defer func() </span><span class="cov8" title="1">{
                err := c.proc.Wait()
                if collectErr == nil </span><span class="cov8" title="1">{
                        collectErr = err
                }</span>
        }()

        <span class="cov8" title="1">if len(c.filenames) == 0 </span><span class="cov8" title="1">{
                // Collect everything.
                collectErr = c.collectDir("", false, nil)
        }</span> else<span class="cov8" title="1"> {
                for _, pm := range c.contentMap.pmaps </span><span class="cov8" title="1">{
                        pm.cfg.isRebuild = true
                }</span>
                <span class="cov8" title="1">dirs := make(map[contentDirKey]bool)
                for _, filename := range c.filenames </span><span class="cov8" title="1">{
                        dir, btype := c.tracker.resolveAndRemove(filename)
                        dirs[contentDirKey{dir, filename, btype}] = true
                }</span>

                <span class="cov8" title="1">for dir := range dirs </span><span class="cov8" title="1">{
                        for _, pm := range c.contentMap.pmaps </span><span class="cov8" title="1">{
                                pm.s.ResourceSpec.DeleteBySubstring(dir.dirname)
                        }</span>

                        <span class="cov8" title="1">switch dir.tp </span>{
                        case bundleLeaf:<span class="cov8" title="1">
                                collectErr = c.collectDir(dir.dirname, true, nil)</span>
                        case bundleBranch:<span class="cov8" title="1">
                                isCascading, section := c.isCascadingEdit(dir)

                                if isCascading </span><span class="cov8" title="1">{
                                        c.contentMap.deleteSection(section)
                                }</span>
                                <span class="cov8" title="1">collectErr = c.collectDir(dir.dirname, !isCascading, nil)</span>
                        default:<span class="cov8" title="1">
                                // We always start from a directory.
                                collectErr = c.collectDir(dir.dirname, true, func(fim hugofs.FileMetaInfo) bool </span><span class="cov8" title="1">{
                                        return dir.filename == fim.Meta().Filename
                                }</span>)
                        }

                        <span class="cov8" title="1">if collectErr != nil </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

        }

        <span class="cov8" title="1">return</span>
}

func (c *pagesCollector) isBundleHeader(fi hugofs.FileMetaInfo) bool <span class="cov8" title="1">{
        class := fi.Meta().Classifier
        return class == files.ContentClassLeaf || class == files.ContentClassBranch
}</span>

func (c *pagesCollector) getLang(fi hugofs.FileMetaInfo) string <span class="cov8" title="1">{
        lang := fi.Meta().Lang
        if lang != "" </span><span class="cov8" title="1">{
                return lang
        }</span>

        <span class="cov0" title="0">return c.sp.DefaultContentLanguage</span>
}

func (c *pagesCollector) addToBundle(info hugofs.FileMetaInfo, btyp bundleDirType, bundles pageBundles) error <span class="cov8" title="1">{
        getBundle := func(lang string) *fileinfoBundle </span><span class="cov8" title="1">{
                return bundles[lang]
        }</span>

        <span class="cov8" title="1">cloneBundle := func(lang string) *fileinfoBundle </span><span class="cov8" title="1">{
                // Every bundled content file needs a content file header.
                // Use the default content language if found, else just
                // pick one.
                var (
                        source *fileinfoBundle
                        found  bool
                )

                source, found = bundles[c.sp.DefaultContentLanguage]
                if !found </span><span class="cov0" title="0">{
                        for _, b := range bundles </span><span class="cov0" title="0">{
                                source = b
                                break</span>
                        }
                }

                <span class="cov8" title="1">if source == nil </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("no source found, %d", len(bundles)))</span>
                }

                <span class="cov8" title="1">clone := c.cloneFileInfo(source.header)
                clone.Meta().Lang = lang

                return &amp;fileinfoBundle{
                        header: clone,
                }</span>
        }

        <span class="cov8" title="1">lang := c.getLang(info)
        bundle := getBundle(lang)
        isBundleHeader := c.isBundleHeader(info)
        if bundle != nil &amp;&amp; isBundleHeader </span><span class="cov8" title="1">{
                // index.md file inside a bundle, see issue 6208.
                info.Meta().Classifier = files.ContentClassContent
                isBundleHeader = false
        }</span>
        <span class="cov8" title="1">classifier := info.Meta().Classifier
        isContent := classifier == files.ContentClassContent
        if bundle == nil </span><span class="cov8" title="1">{
                if isBundleHeader </span><span class="cov8" title="1">{
                        bundle = &amp;fileinfoBundle{header: info}
                        bundles[lang] = bundle
                }</span> else<span class="cov8" title="1"> {
                        if btyp == bundleBranch </span><span class="cov8" title="1">{
                                // No special logic for branch bundles.
                                // Every language needs its own _index.md file.
                                // Also, we only clone bundle headers for lonesome, bundled,
                                // content files.
                                return c.handleFiles(info)
                        }</span>

                        <span class="cov8" title="1">if isContent </span><span class="cov8" title="1">{
                                bundle = cloneBundle(lang)
                                bundles[lang] = bundle
                        }</span>
                }
        }

        <span class="cov8" title="1">if !isBundleHeader &amp;&amp; bundle != nil </span><span class="cov8" title="1">{
                bundle.resources = append(bundle.resources, info)
        }</span>

        <span class="cov8" title="1">if classifier == files.ContentClassFile </span><span class="cov8" title="1">{
                translations := info.Meta().Translations

                for lang, b := range bundles </span><span class="cov8" title="1">{
                        if !stringSliceContains(lang, translations...) &amp;&amp; !b.containsResource(info.Name()) </span><span class="cov8" title="1">{

                                // Clone and add it to the bundle.
                                clone := c.cloneFileInfo(info)
                                clone.Meta().Lang = lang
                                b.resources = append(b.resources, clone)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (c *pagesCollector) cloneFileInfo(fi hugofs.FileMetaInfo) hugofs.FileMetaInfo <span class="cov8" title="1">{
        return hugofs.NewFileMetaInfo(fi, hugofs.NewFileMeta())
}</span>

func (c *pagesCollector) collectDir(dirname string, partial bool, inFilter func(fim hugofs.FileMetaInfo) bool) error <span class="cov8" title="1">{
        fi, err := c.fs.Stat(dirname)
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // May have been deleted.
                        return nil
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">handleDir := func(
                btype bundleDirType,
                dir hugofs.FileMetaInfo,
                path string,
                readdir []hugofs.FileMetaInfo) error </span><span class="cov8" title="1">{
                if btype &gt; bundleNot &amp;&amp; c.tracker != nil </span><span class="cov8" title="1">{
                        c.tracker.add(path, btype)
                }</span>

                <span class="cov8" title="1">if btype == bundleBranch </span><span class="cov8" title="1">{
                        if err := c.handleBundleBranch(readdir); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        // A branch bundle is only this directory level, so keep walking.
                        <span class="cov8" title="1">return nil</span>
                } else<span class="cov8" title="1"> if btype == bundleLeaf </span><span class="cov8" title="1">{
                        if err := c.handleBundleLeaf(dir, path, readdir); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">return nil</span>
                }

                <span class="cov8" title="1">if err := c.handleFiles(readdir...); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">filter := func(fim hugofs.FileMetaInfo) bool </span><span class="cov8" title="1">{
                if fim.Meta().SkipDir </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">if c.sp.IgnoreFile(fim.Meta().Filename) </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">if inFilter != nil </span><span class="cov8" title="1">{
                        return inFilter(fim)
                }</span>
                <span class="cov8" title="1">return true</span>
        }

        <span class="cov8" title="1">preHook := func(dir hugofs.FileMetaInfo, path string, readdir []hugofs.FileMetaInfo) ([]hugofs.FileMetaInfo, error) </span><span class="cov8" title="1">{
                var btype bundleDirType

                filtered := readdir[:0]
                for _, fi := range readdir </span><span class="cov8" title="1">{
                        if filter(fi) </span><span class="cov8" title="1">{
                                filtered = append(filtered, fi)

                                if c.tracker != nil </span><span class="cov8" title="1">{
                                        // Track symlinks.
                                        c.tracker.addSymbolicLinkMapping(fi)
                                }</span>
                        }
                }
                <span class="cov8" title="1">walkRoot := dir.Meta().IsRootFile
                readdir = filtered

                // We merge language directories, so there can be duplicates, but they
                // will be ordered, most important first.
                var duplicates []int
                seen := make(map[string]bool)

                for i, fi := range readdir </span><span class="cov8" title="1">{

                        if fi.IsDir() </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">meta := fi.Meta()
                        meta.IsRootFile = walkRoot
                        class := meta.Classifier
                        translationBase := meta.TranslationBaseNameWithExt
                        key := pth.Join(meta.Lang, translationBase)

                        if seen[key] </span><span class="cov8" title="1">{
                                duplicates = append(duplicates, i)
                                continue</span>
                        }
                        <span class="cov8" title="1">seen[key] = true

                        var thisBtype bundleDirType

                        switch class </span>{
                        case files.ContentClassLeaf:<span class="cov8" title="1">
                                thisBtype = bundleLeaf</span>
                        case files.ContentClassBranch:<span class="cov8" title="1">
                                thisBtype = bundleBranch</span>
                        }

                        // Folders with both index.md and _index.md type of files have
                        // undefined behaviour and can never work.
                        // The branch variant will win because of sort order, but log
                        // a warning about it.
                        <span class="cov8" title="1">if thisBtype &gt; bundleNot &amp;&amp; btype &gt; bundleNot &amp;&amp; thisBtype != btype </span><span class="cov8" title="1">{
                                c.logger.Warnf("Content directory %q have both index.* and _index.* files, pick one.", dir.Meta().Filename)
                                // Reclassify it so it will be handled as a content file inside the
                                // section, which is in line with the &lt;= 0.55 behaviour.
                                meta.Classifier = files.ContentClassContent
                        }</span> else<span class="cov8" title="1"> if thisBtype &gt; bundleNot </span><span class="cov8" title="1">{
                                btype = thisBtype
                        }</span>

                }

                <span class="cov8" title="1">if len(duplicates) &gt; 0 </span><span class="cov8" title="1">{
                        for i := len(duplicates) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                                idx := duplicates[i]
                                readdir = append(readdir[:idx], readdir[idx+1:]...)
                        }</span>
                }

                <span class="cov8" title="1">err := handleDir(btype, dir, path, readdir)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">if btype == bundleLeaf || partial </span><span class="cov8" title="1">{
                        return nil, filepath.SkipDir
                }</span>

                // Keep walking.
                <span class="cov8" title="1">return readdir, nil</span>
        }

        <span class="cov8" title="1">var postHook hugofs.WalkHook
        if c.tracker != nil </span><span class="cov8" title="1">{
                postHook = func(dir hugofs.FileMetaInfo, path string, readdir []hugofs.FileMetaInfo) ([]hugofs.FileMetaInfo, error) </span><span class="cov8" title="1">{
                        if c.tracker == nil </span><span class="cov0" title="0">{
                                // Nothing to do.
                                return readdir, nil
                        }</span>

                        <span class="cov8" title="1">return readdir, nil</span>
                }
        }

        <span class="cov8" title="1">wfn := func(path string, info hugofs.FileMetaInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">fim := fi.(hugofs.FileMetaInfo)
        // Make sure the pages in this directory gets re-rendered,
        // even in fast render mode.
        fim.Meta().IsRootFile = true

        w := hugofs.NewWalkway(hugofs.WalkwayConfig{
                Fs:       c.fs,
                Logger:   c.logger,
                Root:     dirname,
                Info:     fim,
                HookPre:  preHook,
                HookPost: postHook,
                WalkFn:   wfn,
        })

        return w.Walk()</span>
}

func (c *pagesCollector) handleBundleBranch(readdir []hugofs.FileMetaInfo) error <span class="cov8" title="1">{
        // Maps bundles to its language.
        bundles := pageBundles{}

        var contentFiles []hugofs.FileMetaInfo

        for _, fim := range readdir </span><span class="cov8" title="1">{

                if fim.IsDir() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">meta := fim.Meta()

                switch meta.Classifier </span>{
                case files.ContentClassContent:<span class="cov8" title="1">
                        contentFiles = append(contentFiles, fim)</span>
                default:<span class="cov8" title="1">
                        if err := c.addToBundle(fim, bundleBranch, bundles); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

        }

        // Make sure the section is created before its pages.
        <span class="cov8" title="1">if err := c.proc.Process(bundles); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.handleFiles(contentFiles...)</span>
}

func (c *pagesCollector) handleBundleLeaf(dir hugofs.FileMetaInfo, path string, readdir []hugofs.FileMetaInfo) error <span class="cov8" title="1">{
        // Maps bundles to its language.
        bundles := pageBundles{}

        walk := func(path string, info hugofs.FileMetaInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">if info.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">return c.addToBundle(info, bundleLeaf, bundles)</span>
        }

        // Start a new walker from the given path.
        <span class="cov8" title="1">w := hugofs.NewWalkway(hugofs.WalkwayConfig{
                Root:       path,
                Fs:         c.fs,
                Logger:     c.logger,
                Info:       dir,
                DirEntries: readdir,
                WalkFn:     walk,
        })

        if err := w.Walk(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return c.proc.Process(bundles)</span>
}

func (c *pagesCollector) handleFiles(fis ...hugofs.FileMetaInfo) error <span class="cov8" title="1">{
        for _, fi := range fis </span><span class="cov8" title="1">{
                if fi.IsDir() </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if err := c.proc.Process(fi); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func stringSliceContains(k string, values ...string) bool <span class="cov8" title="1">{
        for _, v := range values </span><span class="cov8" title="1">{
                if k == v </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}
</pre>
		
		<pre class="file" id="file134" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "context"
        "fmt"
        "path/filepath"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/source"

        "github.com/gohugoio/hugo/hugofs/files"
        "github.com/pkg/errors"
        "golang.org/x/sync/errgroup"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/hugofs"
)

func newPagesProcessor(h *HugoSites, sp *source.SourceSpec) *pagesProcessor <span class="cov8" title="1">{
        procs := make(map[string]pagesCollectorProcessorProvider)
        for _, s := range h.Sites </span><span class="cov8" title="1">{
                procs[s.Lang()] = &amp;sitePagesProcessor{
                        m:           s.pageMap,
                        errorSender: s.h,
                        itemChan:    make(chan interface{}, config.GetNumWorkerMultiplier()*2),
                }
        }</span>
        <span class="cov8" title="1">return &amp;pagesProcessor{
                procs: procs,
        }</span>
}

type pagesCollectorProcessorProvider interface {
        Process(item interface{}) error
        Start(ctx context.Context) context.Context
        Wait() error
}

type pagesProcessor struct {
        // Per language/Site
        procs map[string]pagesCollectorProcessorProvider
}

func (proc *pagesProcessor) Process(item interface{}) error <span class="cov8" title="1">{
        switch v := item.(type) </span>{
        // Page bundles mapped to their language.
        case pageBundles:<span class="cov8" title="1">
                for _, vv := range v </span><span class="cov8" title="1">{
                        proc.getProcFromFi(vv.header).Process(vv)
                }</span>
        case hugofs.FileMetaInfo:<span class="cov8" title="1">
                proc.getProcFromFi(v).Process(v)</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("unrecognized item type in Process: %T", item))</span>

        }

        <span class="cov8" title="1">return nil</span>
}

func (proc *pagesProcessor) Start(ctx context.Context) context.Context <span class="cov8" title="1">{
        for _, p := range proc.procs </span><span class="cov8" title="1">{
                ctx = p.Start(ctx)
        }</span>
        <span class="cov8" title="1">return ctx</span>
}

func (proc *pagesProcessor) Wait() error <span class="cov8" title="1">{
        var err error
        for _, p := range proc.procs </span><span class="cov8" title="1">{
                if e := p.Wait(); e != nil </span><span class="cov0" title="0">{
                        err = e
                }</span>
        }
        <span class="cov8" title="1">return err</span>
}

func (proc *pagesProcessor) getProcFromFi(fi hugofs.FileMetaInfo) pagesCollectorProcessorProvider <span class="cov8" title="1">{
        if p, found := proc.procs[fi.Meta().Lang]; found </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov8" title="1">return defaultPageProcessor</span>
}

type nopPageProcessor int

func (nopPageProcessor) Process(item interface{}) error <span class="cov8" title="1">{
        return nil
}</span>

func (nopPageProcessor) Start(ctx context.Context) context.Context <span class="cov0" title="0">{
        return context.Background()
}</span>

func (nopPageProcessor) Wait() error <span class="cov0" title="0">{
        return nil
}</span>

var defaultPageProcessor = new(nopPageProcessor)

type sitePagesProcessor struct {
        m           *pageMap
        errorSender herrors.ErrorSender

        ctx       context.Context
        itemChan  chan interface{}
        itemGroup *errgroup.Group
}

func (p *sitePagesProcessor) Process(item interface{}) error <span class="cov8" title="1">{
        select </span>{
        case &lt;-p.ctx.Done():<span class="cov0" title="0">
                return nil</span>
        default:<span class="cov8" title="1">
                p.itemChan &lt;- item</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (p *sitePagesProcessor) Start(ctx context.Context) context.Context <span class="cov8" title="1">{
        p.itemGroup, ctx = errgroup.WithContext(ctx)
        p.ctx = ctx
        p.itemGroup.Go(func() error </span><span class="cov8" title="1">{
                for item := range p.itemChan </span><span class="cov8" title="1">{
                        if err := p.doProcess(item); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        })
        <span class="cov8" title="1">return ctx</span>
}

func (p *sitePagesProcessor) Wait() error <span class="cov8" title="1">{
        close(p.itemChan)
        return p.itemGroup.Wait()
}</span>

func (p *sitePagesProcessor) copyFile(fim hugofs.FileMetaInfo) error <span class="cov8" title="1">{
        meta := fim.Meta()
        f, err := meta.Open()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "copyFile: failed to open")
        }</span>

        <span class="cov8" title="1">s := p.m.s

        target := filepath.Join(s.PathSpec.GetTargetLanguageBasePath(), meta.Path)

        defer f.Close()

        return s.publish(&amp;s.PathSpec.ProcessingStats.Files, target, f)</span>
}

func (p *sitePagesProcessor) doProcess(item interface{}) error <span class="cov8" title="1">{
        m := p.m
        switch v := item.(type) </span>{
        case *fileinfoBundle:<span class="cov8" title="1">
                if err := m.AddFilesBundle(v.header, v.resources...); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        case hugofs.FileMetaInfo:<span class="cov8" title="1">
                if p.shouldSkip(v) </span><span class="cov0" title="0">{
                        return nil
                }</span>
                <span class="cov8" title="1">meta := v.Meta()

                classifier := meta.Classifier
                switch classifier </span>{
                case files.ContentClassContent:<span class="cov8" title="1">
                        if err := m.AddFilesBundle(v); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                case files.ContentClassFile:<span class="cov8" title="1">
                        if err := p.copyFile(v); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("invalid classifier: %q", classifier))</span>
                }
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("unrecognized item type in Process: %T", item))</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (p *sitePagesProcessor) shouldSkip(fim hugofs.FileMetaInfo) bool <span class="cov8" title="1">{
        // TODO(ep) unify
        return p.m.s.SourceSpec.DisabledLanguages[fim.Meta().Lang]
}</span>
</pre>
		
		<pre class="file" id="file135" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package paths

import (
        "fmt"
        "net/url"
        "strings"
)

// A BaseURL in Hugo is normally on the form scheme://path, but the
// form scheme: is also valid (mailto:hugo@rules.com).
type BaseURL struct {
        url    *url.URL
        urlStr string
}

func (b BaseURL) String() string <span class="cov8" title="1">{
        if b.urlStr != "" </span><span class="cov8" title="1">{
                return b.urlStr
        }</span>
        <span class="cov8" title="1">return b.url.String()</span>
}

func (b BaseURL) Path() string <span class="cov8" title="1">{
        return b.url.Path
}</span>

// HostURL returns the URL to the host root without any path elements.
func (b BaseURL) HostURL() string <span class="cov8" title="1">{
        return strings.TrimSuffix(b.String(), b.Path())
}</span>

// WithProtocol returns the BaseURL prefixed with the given protocol.
// The Protocol is normally of the form "scheme://", i.e. "webcal://".
func (b BaseURL) WithProtocol(protocol string) (string, error) <span class="cov8" title="1">{
        u := b.URL()

        scheme := protocol
        isFullProtocol := strings.HasSuffix(scheme, "://")
        isOpaqueProtocol := strings.HasSuffix(scheme, ":")

        if isFullProtocol </span><span class="cov8" title="1">{
                scheme = strings.TrimSuffix(scheme, "://")
        }</span> else<span class="cov8" title="1"> if isOpaqueProtocol </span><span class="cov8" title="1">{
                scheme = strings.TrimSuffix(scheme, ":")
        }</span>

        <span class="cov8" title="1">u.Scheme = scheme

        if isFullProtocol &amp;&amp; u.Opaque != "" </span><span class="cov8" title="1">{
                u.Opaque = "//" + u.Opaque
        }</span> else<span class="cov8" title="1"> if isOpaqueProtocol &amp;&amp; u.Opaque == "" </span><span class="cov8" title="1">{
                return "", fmt.Errorf("cannot determine BaseURL for protocol %q", protocol)
        }</span>

        <span class="cov8" title="1">return u.String(), nil</span>
}

// URL returns a copy of the internal URL.
// The copy can be safely used and modified.
func (b BaseURL) URL() *url.URL <span class="cov8" title="1">{
        c := *b.url
        return &amp;c
}</span>

func newBaseURLFromString(b string) (BaseURL, error) <span class="cov8" title="1">{
        var result BaseURL

        base, err := url.Parse(b)
        if err != nil </span><span class="cov0" title="0">{
                return result, err
        }</span>

        <span class="cov8" title="1">return BaseURL{url: base, urlStr: base.String()}, nil</span>
}
</pre>
		
		<pre class="file" id="file136" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package paths

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/modules"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/hugofs"
)

var FilePathSeparator = string(filepath.Separator)

type Paths struct {
        Fs  *hugofs.Fs
        Cfg config.Provider

        BaseURL

        // If the baseURL contains a base path, e.g. https://example.com/docs, then "/docs" will be the BasePath.
        BasePath string

        // Directories
        // TODO(bep) when we have trimmed down most of the dirs usage outside of this package, make
        // these into an interface.
        ThemesDir  string
        WorkingDir string

        // Directories to store Resource related artifacts.
        AbsResourcesDir string

        AbsPublishDir string

        // pagination path handling
        PaginatePath string

        PublishDir string

        // When in multihost mode, this returns a list of base paths below PublishDir
        // for each language.
        MultihostTargetBasePaths []string

        DisablePathToLower bool
        RemovePathAccents  bool
        UglyURLs           bool
        CanonifyURLs       bool

        Language              *langs.Language
        Languages             langs.Languages
        LanguagesDefaultFirst langs.Languages

        // The PathSpec looks up its config settings in both the current language
        // and then in the global Viper config.
        // Some settings, the settings listed below, does not make sense to be set
        // on per-language-basis. We have no good way of protecting against this
        // other than a "white-list". See language.go.
        defaultContentLanguageInSubdir bool
        DefaultContentLanguage         string
        multilingual                   bool

        AllModules    modules.Modules
        ModulesClient *modules.Client
}

func New(fs *hugofs.Fs, cfg config.Provider) (*Paths, error) <span class="cov8" title="1">{
        baseURLstr := cfg.GetString("baseURL")
        baseURL, err := newBaseURLFromString(baseURLstr)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "Failed to create baseURL from %q:", baseURLstr)
        }</span>

        <span class="cov8" title="1">contentDir := filepath.Clean(cfg.GetString("contentDir"))
        workingDir := filepath.Clean(cfg.GetString("workingDir"))
        resourceDir := filepath.Clean(cfg.GetString("resourceDir"))
        publishDir := filepath.Clean(cfg.GetString("publishDir"))

        if publishDir == "" </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("publishDir not set")
        }</span>

        <span class="cov8" title="1">defaultContentLanguage := cfg.GetString("defaultContentLanguage")

        var (
                language              *langs.Language
                languages             langs.Languages
                languagesDefaultFirst langs.Languages
        )

        if l, ok := cfg.(*langs.Language); ok </span><span class="cov0" title="0">{
                language = l
        }</span>

        <span class="cov8" title="1">if l, ok := cfg.Get("languagesSorted").(langs.Languages); ok </span><span class="cov8" title="1">{
                languages = l
        }</span>

        <span class="cov8" title="1">if l, ok := cfg.Get("languagesSortedDefaultFirst").(langs.Languages); ok </span><span class="cov8" title="1">{
                languagesDefaultFirst = l
        }</span>

        //

        <span class="cov8" title="1">if len(languages) == 0 </span><span class="cov0" title="0">{
                // We have some old tests that does not test the entire chain, hence
                // they have no languages. So create one so we get the proper filesystem.
                languages = langs.Languages{&amp;langs.Language{Lang: "en", Cfg: cfg, ContentDir: contentDir}}
        }</span>

        <span class="cov8" title="1">absPublishDir := AbsPathify(workingDir, publishDir)
        if !strings.HasSuffix(absPublishDir, FilePathSeparator) </span><span class="cov8" title="1">{
                absPublishDir += FilePathSeparator
        }</span>
        // If root, remove the second '/'
        <span class="cov8" title="1">if absPublishDir == "//" </span><span class="cov0" title="0">{
                absPublishDir = FilePathSeparator
        }</span>
        <span class="cov8" title="1">absResourcesDir := AbsPathify(workingDir, resourceDir)
        if !strings.HasSuffix(absResourcesDir, FilePathSeparator) </span><span class="cov8" title="1">{
                absResourcesDir += FilePathSeparator
        }</span>
        <span class="cov8" title="1">if absResourcesDir == "//" </span><span class="cov0" title="0">{
                absResourcesDir = FilePathSeparator
        }</span>

        <span class="cov8" title="1">var multihostTargetBasePaths []string
        if languages.IsMultihost() </span><span class="cov0" title="0">{
                for _, l := range languages </span><span class="cov0" title="0">{
                        multihostTargetBasePaths = append(multihostTargetBasePaths, l.Lang)
                }</span>
        }

        <span class="cov8" title="1">p := &amp;Paths{
                Fs:      fs,
                Cfg:     cfg,
                BaseURL: baseURL,

                DisablePathToLower: cfg.GetBool("disablePathToLower"),
                RemovePathAccents:  cfg.GetBool("removePathAccents"),
                UglyURLs:           cfg.GetBool("uglyURLs"),
                CanonifyURLs:       cfg.GetBool("canonifyURLs"),

                ThemesDir:  cfg.GetString("themesDir"),
                WorkingDir: workingDir,

                AbsResourcesDir: absResourcesDir,
                AbsPublishDir:   absPublishDir,

                multilingual:                   cfg.GetBool("multilingual"),
                defaultContentLanguageInSubdir: cfg.GetBool("defaultContentLanguageInSubdir"),
                DefaultContentLanguage:         defaultContentLanguage,

                Language:                 language,
                Languages:                languages,
                LanguagesDefaultFirst:    languagesDefaultFirst,
                MultihostTargetBasePaths: multihostTargetBasePaths,

                PaginatePath: cfg.GetString("paginatePath"),
        }

        if cfg.IsSet("allModules") </span><span class="cov0" title="0">{
                p.AllModules = cfg.Get("allModules").(modules.Modules)
        }</span>

        <span class="cov8" title="1">if cfg.IsSet("modulesClient") </span><span class="cov0" title="0">{
                p.ModulesClient = cfg.Get("modulesClient").(*modules.Client)
        }</span>

        // TODO(bep) remove this, eventually
        <span class="cov8" title="1">p.PublishDir = absPublishDir

        return p, nil</span>
}

// GetBasePath returns any path element in baseURL if needed.
func (p *Paths) GetBasePath(isRelativeURL bool) string <span class="cov0" title="0">{
        if isRelativeURL &amp;&amp; p.CanonifyURLs </span><span class="cov0" title="0">{
                // The baseURL will be prepended later.
                return ""
        }</span>
        <span class="cov0" title="0">return p.BasePath</span>
}

func (p *Paths) Lang() string <span class="cov0" title="0">{
        if p == nil || p.Language == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return p.Language.Lang</span>
}

func (p *Paths) GetTargetLanguageBasePath() string <span class="cov0" title="0">{
        if p.Languages.IsMultihost() </span><span class="cov0" title="0">{
                // In a multihost configuration all assets will be published below the language code.
                return p.Lang()
        }</span>
        <span class="cov0" title="0">return p.GetLanguagePrefix()</span>
}

func (p *Paths) GetURLLanguageBasePath() string <span class="cov0" title="0">{
        if p.Languages.IsMultihost() </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return p.GetLanguagePrefix()</span>
}

func (p *Paths) GetLanguagePrefix() string <span class="cov0" title="0">{
        if !p.multilingual </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">defaultLang := p.DefaultContentLanguage
        defaultInSubDir := p.defaultContentLanguageInSubdir

        currentLang := p.Language.Lang
        if currentLang == "" || (currentLang == defaultLang &amp;&amp; !defaultInSubDir) </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return currentLang</span>
}

// GetLangSubDir returns the given language's subdir if needed.
func (p *Paths) GetLangSubDir(lang string) string <span class="cov0" title="0">{
        if !p.multilingual </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if p.Languages.IsMultihost() </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">if lang == "" || (lang == p.DefaultContentLanguage &amp;&amp; !p.defaultContentLanguageInSubdir) </span><span class="cov0" title="0">{
                return ""
        }</span>

        <span class="cov0" title="0">return lang</span>
}

// AbsPathify creates an absolute path if given a relative path. If already
// absolute, the path is just cleaned.
func (p *Paths) AbsPathify(inPath string) string <span class="cov0" title="0">{
        return AbsPathify(p.WorkingDir, inPath)
}</span>

// RelPathify trims any WorkingDir prefix from the given filename. If
// the filename is not considered to be absolute, the path is just cleaned.
func (p *Paths) RelPathify(filename string) string <span class="cov0" title="0">{
        filename = filepath.Clean(filename)
        if !filepath.IsAbs(filename) </span><span class="cov0" title="0">{
                return filename
        }</span>

        <span class="cov0" title="0">return strings.TrimPrefix(strings.TrimPrefix(filename, p.WorkingDir), FilePathSeparator)</span>
}

// AbsPathify creates an absolute path if given a working dir and a relative path.
// If already absolute, the path is just cleaned.
func AbsPathify(workingDir, inPath string) string <span class="cov8" title="1">{
        if filepath.IsAbs(inPath) </span><span class="cov0" title="0">{
                return filepath.Clean(inPath)
        }</span>
        <span class="cov8" title="1">return filepath.Join(workingDir, inPath)</span>
}
</pre>
		
		<pre class="file" id="file137" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

// GC requires a build first and must run on it's own. It is not thread safe.
func (h *HugoSites) GC() (int, error) <span class="cov0" title="0">{
        return h.Deps.FileCaches.Prune()
}</span>
</pre>
		
		<pre class="file" id="file138" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "bytes"
        "fmt"
        "html/template"
        "path"
        "reflect"
        "regexp"
        "sort"
        "strconv"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/parser/pageparser"
        "github.com/gohugoio/hugo/resources/page"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/common/text"
        "github.com/gohugoio/hugo/common/urls"
        "github.com/gohugoio/hugo/output"

        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/tpl"
)

var (
        _ urls.RefLinker  = (*ShortcodeWithPage)(nil)
        _ pageWrapper     = (*ShortcodeWithPage)(nil)
        _ text.Positioner = (*ShortcodeWithPage)(nil)
)

// ShortcodeWithPage is the "." context in a shortcode template.
type ShortcodeWithPage struct {
        Params        interface{}
        Inner         template.HTML
        Page          page.Page
        Parent        *ShortcodeWithPage
        Name          string
        IsNamedParams bool

        // Zero-based ordinal in relation to its parent. If the parent is the page itself,
        // this ordinal will represent the position of this shortcode in the page content.
        Ordinal int

        // pos is the position in bytes in the source file. Used for error logging.
        posInit   sync.Once
        posOffset int
        pos       text.Position

        scratch *maps.Scratch
}

// Position returns this shortcode's detailed position. Note that this information
// may be expensive to calculate, so only use this in error situations.
func (scp *ShortcodeWithPage) Position() text.Position <span class="cov8" title="1">{
        scp.posInit.Do(func() </span><span class="cov8" title="1">{
                if p, ok := mustUnwrapPage(scp.Page).(pageContext); ok </span><span class="cov8" title="1">{
                        scp.pos = p.posOffset(scp.posOffset)
                }</span>
        })
        <span class="cov8" title="1">return scp.pos</span>
}

// Site returns information about the current site.
func (scp *ShortcodeWithPage) Site() page.Site <span class="cov8" title="1">{
        return scp.Page.Site()
}</span>

// Ref is a shortcut to the Ref method on Page. It passes itself as a context
// to get better error messages.
func (scp *ShortcodeWithPage) Ref(args map[string]interface{}) (string, error) <span class="cov8" title="1">{
        return scp.Page.RefFrom(args, scp)
}</span>

// RelRef is a shortcut to the RelRef method on Page. It passes itself as a context
// to get better error messages.
func (scp *ShortcodeWithPage) RelRef(args map[string]interface{}) (string, error) <span class="cov8" title="1">{
        return scp.Page.RelRefFrom(args, scp)
}</span>

// Scratch returns a scratch-pad scoped for this shortcode. This can be used
// as a temporary storage for variables, counters etc.
func (scp *ShortcodeWithPage) Scratch() *maps.Scratch <span class="cov8" title="1">{
        if scp.scratch == nil </span><span class="cov8" title="1">{
                scp.scratch = maps.NewScratch()
        }</span>
        <span class="cov8" title="1">return scp.scratch</span>
}

// Get is a convenience method to look up shortcode parameters by its key.
func (scp *ShortcodeWithPage) Get(key interface{}) interface{} <span class="cov8" title="1">{
        if scp.Params == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if reflect.ValueOf(scp.Params).Len() == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var x reflect.Value

        switch key.(type) </span>{
        case int64, int32, int16, int8, int:<span class="cov8" title="1">
                if reflect.TypeOf(scp.Params).Kind() == reflect.Map </span><span class="cov8" title="1">{
                        // We treat this as a non error, so people can do similar to
                        // {{ $myParam := .Get "myParam" | default .Get 0 }}
                        // Without having to do additional checks.
                        return nil
                }</span> else<span class="cov8" title="1"> if reflect.TypeOf(scp.Params).Kind() == reflect.Slice </span><span class="cov8" title="1">{
                        idx := int(reflect.ValueOf(key).Int())
                        ln := reflect.ValueOf(scp.Params).Len()
                        if idx &gt; ln-1 </span><span class="cov8" title="1">{
                                return ""
                        }</span>
                        <span class="cov8" title="1">x = reflect.ValueOf(scp.Params).Index(idx)</span>
                }
        case string:<span class="cov8" title="1">
                if reflect.TypeOf(scp.Params).Kind() == reflect.Map </span><span class="cov8" title="1">{
                        x = reflect.ValueOf(scp.Params).MapIndex(reflect.ValueOf(key))
                        if !x.IsValid() </span><span class="cov8" title="1">{
                                return ""
                        }</span>
                } else<span class="cov8" title="1"> if reflect.TypeOf(scp.Params).Kind() == reflect.Slice </span><span class="cov8" title="1">{
                        // We treat this as a non error, so people can do similar to
                        // {{ $myParam := .Get "myParam" | default .Get 0 }}
                        // Without having to do additional checks.
                        return nil
                }</span>
        }

        <span class="cov8" title="1">return x.Interface()</span>
}

func (scp *ShortcodeWithPage) page() page.Page <span class="cov8" title="1">{
        return scp.Page
}</span>

// Note - this value must not contain any markup syntax
const shortcodePlaceholderPrefix = "HAHAHUGOSHORTCODE"

func createShortcodePlaceholder(id string, ordinal int) string <span class="cov8" title="1">{
        return shortcodePlaceholderPrefix + "-" + id + strconv.Itoa(ordinal) + "-HBHB"
}</span>

type shortcode struct {
        name      string
        isInline  bool          // inline shortcode. Any inner will be a Go template.
        isClosing bool          // whether a closing tag was provided
        inner     []interface{} // string or nested shortcode
        params    interface{}   // map or array
        ordinal   int
        err       error

        info   tpl.Info       // One of the output formats (arbitrary)
        templs []tpl.Template // All output formats

        // If set, the rendered shortcode is sent as part of the surrounding content
        // to Blackfriday and similar.
        // Before Hug0 0.55 we didn't send any shortcode output to the markup
        // renderer, and this flag told Hugo to process the {{ .Inner }} content
        // separately.
        // The old behaviour can be had by starting your shortcode template with:
        //    {{ $_hugo_config := `{ "version": 1 }`}}
        doMarkup bool

        // the placeholder in the source when passed to Blackfriday etc.
        // This also identifies the rendered shortcode.
        placeholder string

        pos    int // the position in bytes in the source file
        length int // the length in bytes in the source file
}

func (s shortcode) insertPlaceholder() bool <span class="cov8" title="1">{
        return !s.doMarkup || s.configVersion() == 1
}</span>

func (s shortcode) configVersion() int <span class="cov8" title="1">{
        if s.info == nil </span><span class="cov8" title="1">{
                // Not set for inline shortcodes.
                return 2
        }</span>

        <span class="cov8" title="1">return s.info.ParseInfo().Config.Version</span>
}

func (s shortcode) innerString() string <span class="cov8" title="1">{
        var sb strings.Builder

        for _, inner := range s.inner </span><span class="cov8" title="1">{
                sb.WriteString(inner.(string))
        }</span>

        <span class="cov8" title="1">return sb.String()</span>
}

func (sc shortcode) String() string <span class="cov8" title="1">{
        // for testing (mostly), so any change here will break tests!
        var params interface{}
        switch v := sc.params.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                // sort the keys so test assertions won't fail
                var keys []string
                for k := range v </span><span class="cov0" title="0">{
                        keys = append(keys, k)
                }</span>
                <span class="cov0" title="0">sort.Strings(keys)
                tmp := make(map[string]interface{})

                for _, k := range keys </span><span class="cov0" title="0">{
                        tmp[k] = v[k]
                }</span>
                <span class="cov0" title="0">params = tmp</span>

        default:<span class="cov8" title="1">
                // use it as is
                params = sc.params</span>
        }

        <span class="cov8" title="1">return fmt.Sprintf("%s(%q, %t){%s}", sc.name, params, sc.doMarkup, sc.inner)</span>
}

type shortcodeHandler struct {
        p *pageState

        s *Site

        // Ordered list of shortcodes for a page.
        shortcodes []*shortcode

        // All the shortcode names in this set.
        nameSet map[string]bool

        // Configuration
        enableInlineShortcodes bool
}

func newShortcodeHandler(p *pageState, s *Site, placeholderFunc func() string) *shortcodeHandler <span class="cov8" title="1">{
        sh := &amp;shortcodeHandler{
                p:                      p,
                s:                      s,
                enableInlineShortcodes: s.ExecHelper.Sec().EnableInlineShortcodes,
                shortcodes:             make([]*shortcode, 0, 4),
                nameSet:                make(map[string]bool),
        }

        return sh
}</span>

const (
        innerNewlineRegexp = "\n"
        innerCleanupRegexp = `\A&lt;p&gt;(.*)&lt;/p&gt;\n\z`
        innerCleanupExpand = "$1"
)

func renderShortcode(
        level int,
        s *Site,
        tplVariants tpl.TemplateVariants,
        sc *shortcode,
        parent *ShortcodeWithPage,
        p *pageState) (string, bool, error) <span class="cov8" title="1">{
        var tmpl tpl.Template

        // Tracks whether this shortcode or any of its children has template variations
        // in other languages or output formats. We are currently only interested in
        // the output formats, so we may get some false positives -- we
        // should improve on that.
        var hasVariants bool

        if sc.isInline </span><span class="cov8" title="1">{
                if !p.s.ExecHelper.Sec().EnableInlineShortcodes </span><span class="cov8" title="1">{
                        return "", false, nil
                }</span>
                <span class="cov8" title="1">templName := path.Join("_inline_shortcode", p.File().Path(), sc.name)
                if sc.isClosing </span><span class="cov8" title="1">{
                        templStr := sc.innerString()

                        var err error
                        tmpl, err = s.TextTmpl().Parse(templName, templStr)
                        if err != nil </span><span class="cov0" title="0">{
                                fe := herrors.ToFileError("html", err)
                                l1, l2 := p.posOffset(sc.pos).LineNumber, fe.Position().LineNumber
                                fe = herrors.ToFileErrorWithLineNumber(fe, l1+l2-1)
                                return "", false, p.wrapError(fe)
                        }</span>

                } else<span class="cov8" title="1"> {
                        // Re-use of shortcode defined earlier in the same page.
                        var found bool
                        tmpl, found = s.TextTmpl().Lookup(templName)
                        if !found </span><span class="cov0" title="0">{
                                return "", false, errors.Errorf("no earlier definition of shortcode %q found", sc.name)
                        }</span>
                }
        } else<span class="cov8" title="1"> {
                var found, more bool
                tmpl, found, more = s.Tmpl().LookupVariant(sc.name, tplVariants)
                if !found </span><span class="cov0" title="0">{
                        s.Log.Errorf("Unable to locate template for shortcode %q in page %q", sc.name, p.File().Path())
                        return "", false, nil
                }</span>
                <span class="cov8" title="1">hasVariants = hasVariants || more</span>
        }

        <span class="cov8" title="1">data := &amp;ShortcodeWithPage{Ordinal: sc.ordinal, posOffset: sc.pos, Params: sc.params, Page: newPageForShortcode(p), Parent: parent, Name: sc.name}
        if sc.params != nil </span><span class="cov8" title="1">{
                data.IsNamedParams = reflect.TypeOf(sc.params).Kind() == reflect.Map
        }</span>

        <span class="cov8" title="1">if len(sc.inner) &gt; 0 </span><span class="cov8" title="1">{
                var inner string
                for _, innerData := range sc.inner </span><span class="cov8" title="1">{
                        switch innerData := innerData.(type) </span>{
                        case string:<span class="cov8" title="1">
                                inner += innerData</span>
                        case *shortcode:<span class="cov8" title="1">
                                s, more, err := renderShortcode(level+1, s, tplVariants, innerData, data, p)
                                if err != nil </span><span class="cov0" title="0">{
                                        return "", false, err
                                }</span>
                                <span class="cov8" title="1">hasVariants = hasVariants || more
                                inner += s</span>
                        default:<span class="cov0" title="0">
                                s.Log.Errorf("Illegal state on shortcode rendering of %q in page %q. Illegal type in inner data: %s ",
                                        sc.name, p.File().Path(), reflect.TypeOf(innerData))
                                return "", false, nil</span>
                        }
                }

                // Pre Hugo 0.55 this was the behaviour even for the outer-most
                // shortcode.
                <span class="cov8" title="1">if sc.doMarkup &amp;&amp; (level &gt; 0 || sc.configVersion() == 1) </span><span class="cov8" title="1">{
                        var err error
                        b, err := p.pageOutput.cp.renderContent([]byte(inner), false)
                        if err != nil </span><span class="cov0" title="0">{
                                return "", false, err
                        }</span>

                        <span class="cov8" title="1">newInner := b.Bytes()

                        // If the type is “” (unknown) or “markdown”, we assume the markdown
                        // generation has been performed. Given the input: `a line`, markdown
                        // specifies the HTML `&lt;p&gt;a line&lt;/p&gt;\n`. When dealing with documents as a
                        // whole, this is OK. When dealing with an `{{ .Inner }}` block in Hugo,
                        // this is not so good. This code does two things:
                        //
                        // 1.  Check to see if inner has a newline in it. If so, the Inner data is
                        //     unchanged.
                        // 2   If inner does not have a newline, strip the wrapping &lt;p&gt; block and
                        //     the newline.
                        switch p.m.markup </span>{
                        case "", "markdown":<span class="cov8" title="1">
                                if match, _ := regexp.MatchString(innerNewlineRegexp, inner); !match </span><span class="cov8" title="1">{
                                        cleaner, err := regexp.Compile(innerCleanupRegexp)

                                        if err == nil </span><span class="cov8" title="1">{
                                                newInner = cleaner.ReplaceAll(newInner, []byte(innerCleanupExpand))
                                        }</span>
                                }
                        }

                        // TODO(bep) we may have plain text inner templates.
                        <span class="cov8" title="1">data.Inner = template.HTML(newInner)</span>
                } else<span class="cov8" title="1"> {
                        data.Inner = template.HTML(inner)
                }</span>

        }

        <span class="cov8" title="1">result, err := renderShortcodeWithPage(s.Tmpl(), tmpl, data)

        if err != nil &amp;&amp; sc.isInline </span><span class="cov0" title="0">{
                fe := herrors.ToFileError("html", err)
                l1, l2 := p.posFromPage(sc.pos).LineNumber, fe.Position().LineNumber
                fe = herrors.ToFileErrorWithLineNumber(fe, l1+l2-1)
                return "", false, fe
        }</span>

        <span class="cov8" title="1">return result, hasVariants, err</span>
}

func (s *shortcodeHandler) hasShortcodes() bool <span class="cov8" title="1">{
        return s != nil &amp;&amp; len(s.shortcodes) &gt; 0
}</span>

func (s *shortcodeHandler) renderShortcodesForPage(p *pageState, f output.Format) (map[string]string, bool, error) <span class="cov8" title="1">{
        rendered := make(map[string]string)

        tplVariants := tpl.TemplateVariants{
                Language:     p.Language().Lang,
                OutputFormat: f,
        }

        var hasVariants bool

        for _, v := range s.shortcodes </span><span class="cov8" title="1">{
                s, more, err := renderShortcode(0, s.s, tplVariants, v, nil, p)
                if err != nil </span><span class="cov8" title="1">{
                        err = p.parseError(errors.Wrapf(err, "failed to render shortcode %q", v.name), p.source.parsed.Input(), v.pos)
                        return nil, false, err
                }</span>
                <span class="cov8" title="1">hasVariants = hasVariants || more
                rendered[v.placeholder] = s</span>

        }

        <span class="cov8" title="1">return rendered, hasVariants, nil</span>
}

var errShortCodeIllegalState = errors.New("Illegal shortcode state")

func (s *shortcodeHandler) parseError(err error, input []byte, pos int) error <span class="cov8" title="1">{
        if s.p != nil </span><span class="cov8" title="1">{
                return s.p.parseError(err, input, pos)
        }</span>
        <span class="cov0" title="0">return err</span>
}

// pageTokens state:
// - before: positioned just before the shortcode start
// - after: shortcode(s) consumed (plural when they are nested)
func (s *shortcodeHandler) extractShortcode(ordinal, level int, pt *pageparser.Iterator) (*shortcode, error) <span class="cov8" title="1">{
        if s == nil </span><span class="cov0" title="0">{
                panic("handler nil")</span>
        }
        <span class="cov8" title="1">sc := &amp;shortcode{ordinal: ordinal}

        cnt := 0
        nestedOrdinal := 0
        nextLevel := level + 1

        fail := func(err error, i pageparser.Item) error </span><span class="cov8" title="1">{
                return s.parseError(err, pt.Input(), i.Pos)
        }</span>

<span class="cov8" title="1">Loop:
        for </span><span class="cov8" title="1">{
                currItem := pt.Next()
                switch </span>{
                case currItem.IsLeftShortcodeDelim():<span class="cov8" title="1">
                        next := pt.Peek()
                        if next.IsRightShortcodeDelim() </span><span class="cov8" title="1">{
                                // no name: {{&lt; &gt;}} or {{% %}}
                                return sc, errors.New("shortcode has no name")
                        }</span>
                        <span class="cov8" title="1">if next.IsShortcodeClose() </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if cnt &gt; 0 </span><span class="cov8" title="1">{
                                // nested shortcode; append it to inner content
                                pt.Backup()
                                nested, err := s.extractShortcode(nestedOrdinal, nextLevel, pt)
                                nestedOrdinal++
                                if nested != nil &amp;&amp; nested.name != "" </span><span class="cov8" title="1">{
                                        s.nameSet[nested.name] = true
                                }</span>

                                <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                                        sc.inner = append(sc.inner, nested)
                                }</span> else<span class="cov0" title="0"> {
                                        return sc, err
                                }</span>

                        } else<span class="cov8" title="1"> {
                                sc.doMarkup = currItem.IsShortcodeMarkupDelimiter()
                        }</span>

                        <span class="cov8" title="1">cnt++</span>

                case currItem.IsRightShortcodeDelim():<span class="cov8" title="1">
                        // we trust the template on this:
                        // if there's no inner, we're done
                        if !sc.isInline </span><span class="cov8" title="1">{
                                if sc.info == nil </span><span class="cov0" title="0">{
                                        // This should not happen.
                                        return sc, fail(errors.New("BUG: template info not set"), currItem)
                                }</span>
                                <span class="cov8" title="1">if !sc.info.ParseInfo().IsInner </span><span class="cov8" title="1">{
                                        return sc, nil
                                }</span>
                        }

                case currItem.IsShortcodeClose():<span class="cov8" title="1">
                        next := pt.Peek()
                        if !sc.isInline </span><span class="cov8" title="1">{
                                if sc.info == nil || !sc.info.ParseInfo().IsInner </span><span class="cov8" title="1">{
                                        if next.IsError() </span><span class="cov0" title="0">{
                                                // return that error, more specific
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">return sc, fail(errors.Errorf("shortcode %q has no .Inner, yet a closing tag was provided", next.Val), next)</span>
                                }
                        }
                        <span class="cov8" title="1">if next.IsRightShortcodeDelim() </span><span class="cov8" title="1">{
                                // self-closing
                                pt.Consume(1)
                        }</span> else<span class="cov8" title="1"> {
                                sc.isClosing = true
                                pt.Consume(2)
                        }</span>

                        <span class="cov8" title="1">return sc, nil</span>
                case currItem.IsText():<span class="cov8" title="1">
                        sc.inner = append(sc.inner, currItem.ValStr())</span>
                case currItem.Type == pageparser.TypeEmoji:<span class="cov8" title="1">
                        // TODO(bep) avoid the duplication of these "text cases", to prevent
                        // more of #6504 in the future.
                        val := currItem.ValStr()
                        if emoji := helpers.Emoji(val); emoji != nil </span><span class="cov8" title="1">{
                                sc.inner = append(sc.inner, string(emoji))
                        }</span> else<span class="cov8" title="1"> {
                                sc.inner = append(sc.inner, val)
                        }</span>
                case currItem.IsShortcodeName():<span class="cov8" title="1">

                        sc.name = currItem.ValStr()

                        // Used to check if the template expects inner content.
                        templs := s.s.Tmpl().LookupVariants(sc.name)
                        if templs == nil </span><span class="cov8" title="1">{
                                return nil, errors.Errorf("template for shortcode %q not found", sc.name)
                        }</span>

                        <span class="cov8" title="1">sc.info = templs[0].(tpl.Info)
                        sc.templs = templs</span>
                case currItem.IsInlineShortcodeName():<span class="cov8" title="1">
                        sc.name = currItem.ValStr()
                        sc.isInline = true</span>
                case currItem.IsShortcodeParam():<span class="cov8" title="1">
                        if !pt.IsValueNext() </span><span class="cov0" title="0">{
                                continue</span>
                        } else<span class="cov8" title="1"> if pt.Peek().IsShortcodeParamVal() </span><span class="cov8" title="1">{
                                // named params
                                if sc.params == nil </span><span class="cov8" title="1">{
                                        params := make(map[string]interface{})
                                        params[currItem.ValStr()] = pt.Next().ValTyped()
                                        sc.params = params
                                }</span> else<span class="cov8" title="1"> {
                                        if params, ok := sc.params.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                                                params[currItem.ValStr()] = pt.Next().ValTyped()
                                        }</span> else<span class="cov0" title="0"> {
                                                return sc, errShortCodeIllegalState
                                        }</span>
                                }
                        } else<span class="cov8" title="1"> {
                                // positional params
                                if sc.params == nil </span><span class="cov8" title="1">{
                                        var params []interface{}
                                        params = append(params, currItem.ValTyped())
                                        sc.params = params
                                }</span> else<span class="cov8" title="1"> {
                                        if params, ok := sc.params.([]interface{}); ok </span><span class="cov8" title="1">{
                                                params = append(params, currItem.ValTyped())
                                                sc.params = params
                                        }</span> else<span class="cov0" title="0"> {
                                                return sc, errShortCodeIllegalState
                                        }</span>
                                }
                        }
                case currItem.IsDone():<span class="cov8" title="1">
                        // handled by caller
                        pt.Backup()
                        break Loop</span>

                }
        }
        <span class="cov8" title="1">return sc, nil</span>
}

// Replace prefixed shortcode tokens with the real content.
// Note: This function will rewrite the input slice.
func replaceShortcodeTokens(source []byte, replacements map[string]string) ([]byte, error) <span class="cov8" title="1">{
        if len(replacements) == 0 </span><span class="cov8" title="1">{
                return source, nil
        }</span>

        <span class="cov8" title="1">start := 0

        pre := []byte(shortcodePlaceholderPrefix)
        post := []byte("HBHB")
        pStart := []byte("&lt;p&gt;")
        pEnd := []byte("&lt;/p&gt;")

        k := bytes.Index(source[start:], pre)

        for k != -1 </span><span class="cov8" title="1">{
                j := start + k
                postIdx := bytes.Index(source[j:], post)
                if postIdx &lt; 0 </span><span class="cov8" title="1">{
                        // this should never happen, but let the caller decide to panic or not
                        return nil, errors.New("illegal state in content; shortcode token missing end delim")
                }</span>

                <span class="cov8" title="1">end := j + postIdx + 4

                newVal := []byte(replacements[string(source[j:end])])

                // Issue #1148: Check for wrapping p-tags &lt;p&gt;
                if j &gt;= 3 &amp;&amp; bytes.Equal(source[j-3:j], pStart) </span><span class="cov8" title="1">{
                        if (k+4) &lt; len(source) &amp;&amp; bytes.Equal(source[end:end+4], pEnd) </span><span class="cov8" title="1">{
                                j -= 3
                                end += 4
                        }</span>
                }

                // This and other cool slice tricks: https://github.com/golang/go/wiki/SliceTricks
                <span class="cov8" title="1">source = append(source[:j], append(newVal, source[end:]...)...)
                start = j
                k = bytes.Index(source[start:], pre)</span>

        }

        <span class="cov8" title="1">return source, nil</span>
}

func renderShortcodeWithPage(h tpl.TemplateHandler, tmpl tpl.Template, data *ShortcodeWithPage) (string, error) <span class="cov8" title="1">{
        buffer := bp.GetBuffer()
        defer bp.PutBuffer(buffer)

        err := h.Execute(tmpl, buffer, data)
        if err != nil </span><span class="cov8" title="1">{
                return "", errors.Wrap(err, "failed to process shortcode")
        }</span>
        <span class="cov8" title="1">return buffer.String(), nil</span>
}
</pre>
		
		<pre class="file" id="file139" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "html/template"

        "github.com/gohugoio/hugo/resources/page"
)

var tocShortcodePlaceholder = createShortcodePlaceholder("TOC", 0)

// This is sent to the shortcodes. They cannot access the content
// they're a part of. It would cause an infinite regress.
//
// Go doesn't support virtual methods, so this careful dance is currently (I think)
// the best we can do.
type pageForShortcode struct {
        page.PageWithoutContent
        page.ContentProvider

        // We need to replace it after we have rendered it, so provide a
        // temporary placeholder.
        toc template.HTML

        p *pageState
}

func newPageForShortcode(p *pageState) page.Page <span class="cov8" title="1">{
        return &amp;pageForShortcode{
                PageWithoutContent: p,
                ContentProvider:    page.NopPage,
                toc:                template.HTML(tocShortcodePlaceholder),
                p:                  p,
        }
}</span>

func (p *pageForShortcode) page() page.Page <span class="cov8" title="1">{
        return p.PageWithoutContent.(page.Page)
}</span>

func (p *pageForShortcode) TableOfContents() template.HTML <span class="cov8" title="1">{
        p.p.enablePlaceholders()
        return p.toc
}</span>

// This is what is sent into the content render hooks (link, image).
type pageForRenderHooks struct {
        page.PageWithoutContent
        page.TableOfContentsProvider
        page.ContentProvider
}

func newPageForRenderHook(p *pageState) page.Page <span class="cov8" title="1">{
        return &amp;pageForRenderHooks{
                PageWithoutContent:      p,
                ContentProvider:         page.NopPage,
                TableOfContentsProvider: page.NopPage,
        }
}</span>

func (p *pageForRenderHooks) page() page.Page <span class="cov8" title="1">{
        return p.PageWithoutContent.(page.Page)
}</span>
</pre>
		
		<pre class="file" id="file140" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "html/template"
        "io"
        "log"
        "mime"
        "net/url"
        "os"
        "path"
        "path/filepath"
        "regexp"
        "runtime"
        "sort"
        "strconv"
        "strings"
        "time"

        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/modules"
        "golang.org/x/text/unicode/norm"

        "github.com/gohugoio/hugo/common/paths"

        "github.com/gohugoio/hugo/common/constants"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/gohugoio/hugo/resources"

        "github.com/gohugoio/hugo/identity"

        "github.com/gohugoio/hugo/markup/converter/hooks"

        "github.com/gohugoio/hugo/resources/resource"

        "github.com/gohugoio/hugo/markup/converter"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/text"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/publisher"
        _errors "github.com/pkg/errors"

        "github.com/gohugoio/hugo/langs"

        "github.com/gohugoio/hugo/resources/page"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/lazy"

        "github.com/gohugoio/hugo/media"

        "github.com/fsnotify/fsnotify"
        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/navigation"
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/related"
        "github.com/gohugoio/hugo/resources/page/pagemeta"
        "github.com/gohugoio/hugo/source"
        "github.com/gohugoio/hugo/tpl"

        "github.com/spf13/afero"
        "github.com/spf13/cast"
)

// Site contains all the information relevant for constructing a static
// site.  The basic flow of information is as follows:
//
// 1. A list of Files is parsed and then converted into Pages.
//
// 2. Pages contain sections (based on the file they were generated from),
//    aliases and slugs (included in a pages frontmatter) which are the
//    various targets that will get generated.  There will be canonical
//    listing.  The canonical path can be overruled based on a pattern.
//
// 3. Taxonomies are created via configuration and will present some aspect of
//    the final page and typically a perm url.
//
// 4. All Pages are passed through a template based on their desired
//    layout based on numerous different elements.
//
// 5. The entire collection of files is written to disk.
type Site struct {

        // The owning container. When multiple languages, there will be multiple
        // sites .
        h *HugoSites

        *PageCollections

        taxonomies TaxonomyList

        Sections Taxonomy
        Info     *SiteInfo

        language   *langs.Language
        siteBucket *pagesMapBucket

        siteCfg siteConfigHolder

        disabledKinds map[string]bool

        // Output formats defined in site config per Page Kind, or some defaults
        // if not set.
        // Output formats defined in Page front matter will override these.
        outputFormats map[string]output.Formats

        // All the output formats and media types available for this site.
        // These values will be merged from the Hugo defaults, the site config and,
        // finally, the language settings.
        outputFormatsConfig output.Formats
        mediaTypesConfig    media.Types

        siteConfigConfig SiteConfig

        // How to handle page front matter.
        frontmatterHandler pagemeta.FrontMatterHandler

        // We render each site for all the relevant output formats in serial with
        // this rendering context pointing to the current one.
        rc *siteRenderingContext

        // The output formats that we need to render this site in. This slice
        // will be fixed once set.
        // This will be the union of Site.Pages' outputFormats.
        // This slice will be sorted.
        renderFormats output.Formats

        // Logger etc.
        *deps.Deps `json:"-"`

        // The func used to title case titles.
        titleFunc func(s string) string

        relatedDocsHandler *page.RelatedDocsHandler
        siteRefLinker

        publisher publisher.Publisher

        menus navigation.Menus

        // Shortcut to the home page. Note that this may be nil if
        // home page, for some odd reason, is disabled.
        home *pageState

        // The last modification date of this site.
        lastmod time.Time

        // Lazily loaded site dependencies
        init *siteInit
}

func (s *Site) Taxonomies() TaxonomyList <span class="cov8" title="1">{
        s.init.taxonomies.Do()
        return s.taxonomies
}</span>

type taxonomiesConfig map[string]string

func (t taxonomiesConfig) Values() []viewName <span class="cov8" title="1">{
        var vals []viewName
        for k, v := range t </span><span class="cov8" title="1">{
                vals = append(vals, viewName{singular: k, plural: v})
        }</span>
        <span class="cov8" title="1">sort.Slice(vals, func(i, j int) bool </span><span class="cov8" title="1">{
                return vals[i].plural &lt; vals[j].plural
        }</span>)

        <span class="cov8" title="1">return vals</span>
}

type siteConfigHolder struct {
        sitemap          config.Sitemap
        taxonomiesConfig taxonomiesConfig
        timeout          time.Duration
        hasCJKLanguage   bool
        enableEmoji      bool
}

// Lazily loaded site dependencies.
type siteInit struct {
        prevNext          *lazy.Init
        prevNextInSection *lazy.Init
        menus             *lazy.Init
        taxonomies        *lazy.Init
}

func (init *siteInit) Reset() <span class="cov8" title="1">{
        init.prevNext.Reset()
        init.prevNextInSection.Reset()
        init.menus.Reset()
        init.taxonomies.Reset()
}</span>

func (s *Site) initInit(init *lazy.Init, pctx pageContext) bool <span class="cov8" title="1">{
        _, err := init.Do()
        if err != nil </span><span class="cov8" title="1">{
                s.h.FatalError(pctx.wrapError(err))
        }</span>
        <span class="cov8" title="1">return err == nil</span>
}

func (s *Site) prepareInits() <span class="cov8" title="1">{
        s.init = &amp;siteInit{}

        var init lazy.Init

        s.init.prevNext = init.Branch(func() (interface{}, error) </span><span class="cov8" title="1">{
                regularPages := s.RegularPages()
                for i, p := range regularPages </span><span class="cov8" title="1">{
                        np, ok := p.(nextPrevProvider)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">pos := np.getNextPrev()
                        if pos == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">pos.nextPage = nil
                        pos.prevPage = nil

                        if i &gt; 0 </span><span class="cov8" title="1">{
                                pos.nextPage = regularPages[i-1]
                        }</span>

                        <span class="cov8" title="1">if i &lt; len(regularPages)-1 </span><span class="cov8" title="1">{
                                pos.prevPage = regularPages[i+1]
                        }</span>
                }
                <span class="cov8" title="1">return nil, nil</span>
        })

        <span class="cov8" title="1">s.init.prevNextInSection = init.Branch(func() (interface{}, error) </span><span class="cov8" title="1">{
                var sections page.Pages
                s.home.treeRef.m.collectSectionsRecursiveIncludingSelf(pageMapQuery{Prefix: s.home.treeRef.key}, func(n *contentNode) </span><span class="cov8" title="1">{
                        sections = append(sections, n.p)
                }</span>)

                <span class="cov8" title="1">setNextPrev := func(pas page.Pages) </span><span class="cov8" title="1">{
                        for i, p := range pas </span><span class="cov8" title="1">{
                                np, ok := p.(nextPrevInSectionProvider)
                                if !ok </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">pos := np.getNextPrevInSection()
                                if pos == nil </span><span class="cov0" title="0">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">pos.nextPage = nil
                                pos.prevPage = nil

                                if i &gt; 0 </span><span class="cov8" title="1">{
                                        pos.nextPage = pas[i-1]
                                }</span>

                                <span class="cov8" title="1">if i &lt; len(pas)-1 </span><span class="cov8" title="1">{
                                        pos.prevPage = pas[i+1]
                                }</span>
                        }
                }

                <span class="cov8" title="1">for _, sect := range sections </span><span class="cov8" title="1">{
                        treeRef := sect.(treeRefProvider).getTreeRef()

                        var pas page.Pages
                        treeRef.m.collectPages(pageMapQuery{Prefix: treeRef.key + cmBranchSeparator}, func(c *contentNode) </span><span class="cov8" title="1">{
                                pas = append(pas, c.p)
                        }</span>)
                        <span class="cov8" title="1">page.SortByDefault(pas)

                        setNextPrev(pas)</span>
                }

                // The root section only goes one level down.
                <span class="cov8" title="1">treeRef := s.home.getTreeRef()

                var pas page.Pages
                treeRef.m.collectPages(pageMapQuery{Prefix: treeRef.key + cmBranchSeparator}, func(c *contentNode) </span><span class="cov8" title="1">{
                        pas = append(pas, c.p)
                }</span>)
                <span class="cov8" title="1">page.SortByDefault(pas)

                setNextPrev(pas)

                return nil, nil</span>
        })

        <span class="cov8" title="1">s.init.menus = init.Branch(func() (interface{}, error) </span><span class="cov8" title="1">{
                s.assembleMenus()
                return nil, nil
        }</span>)

        <span class="cov8" title="1">s.init.taxonomies = init.Branch(func() (interface{}, error) </span><span class="cov8" title="1">{
                err := s.pageMap.assembleTaxonomies()
                return nil, err
        }</span>)
}

type siteRenderingContext struct {
        output.Format
}

func (s *Site) Menus() navigation.Menus <span class="cov8" title="1">{
        s.init.menus.Do()
        return s.menus
}</span>

func (s *Site) initRenderFormats() <span class="cov8" title="1">{
        formatSet := make(map[string]bool)
        formats := output.Formats{}
        s.pageMap.pageTrees.WalkRenderable(func(s string, n *contentNode) bool </span><span class="cov8" title="1">{
                for _, f := range n.p.m.configuredOutputFormats </span><span class="cov8" title="1">{
                        if !formatSet[f.Name] </span><span class="cov8" title="1">{
                                formats = append(formats, f)
                                formatSet[f.Name] = true
                        }</span>
                }
                <span class="cov8" title="1">return false</span>
        })

        // Add the per kind configured output formats
        <span class="cov8" title="1">for _, kind := range allKindsInPages </span><span class="cov8" title="1">{
                if siteFormats, found := s.outputFormats[kind]; found </span><span class="cov8" title="1">{
                        for _, f := range siteFormats </span><span class="cov8" title="1">{
                                if !formatSet[f.Name] </span><span class="cov8" title="1">{
                                        formats = append(formats, f)
                                        formatSet[f.Name] = true
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">sort.Sort(formats)
        s.renderFormats = formats</span>
}

func (s *Site) GetRelatedDocsHandler() *page.RelatedDocsHandler <span class="cov8" title="1">{
        return s.relatedDocsHandler
}</span>

func (s *Site) Language() *langs.Language <span class="cov8" title="1">{
        return s.language
}</span>

func (s *Site) isEnabled(kind string) bool <span class="cov8" title="1">{
        if kind == kindUnknown </span><span class="cov0" title="0">{
                panic("Unknown kind")</span>
        }
        <span class="cov8" title="1">return !s.disabledKinds[kind]</span>
}

// reset returns a new Site prepared for rebuild.
func (s *Site) reset() *Site <span class="cov0" title="0">{
        return &amp;Site{
                Deps:                s.Deps,
                disabledKinds:       s.disabledKinds,
                titleFunc:           s.titleFunc,
                relatedDocsHandler:  s.relatedDocsHandler.Clone(),
                siteRefLinker:       s.siteRefLinker,
                outputFormats:       s.outputFormats,
                rc:                  s.rc,
                outputFormatsConfig: s.outputFormatsConfig,
                frontmatterHandler:  s.frontmatterHandler,
                mediaTypesConfig:    s.mediaTypesConfig,
                language:            s.language,
                siteBucket:          s.siteBucket,
                h:                   s.h,
                publisher:           s.publisher,
                siteConfigConfig:    s.siteConfigConfig,
                init:                s.init,
                PageCollections:     s.PageCollections,
                siteCfg:             s.siteCfg,
        }
}</span>

// newSite creates a new site with the given configuration.
func newSite(cfg deps.DepsCfg) (*Site, error) <span class="cov8" title="1">{
        if cfg.Language == nil </span><span class="cov0" title="0">{
                cfg.Language = langs.NewDefaultLanguage(cfg.Cfg)
        }</span>
        <span class="cov8" title="1">if cfg.Logger == nil </span><span class="cov0" title="0">{
                panic("logger must be set")</span>
        }

        <span class="cov8" title="1">ignoreErrors := cast.ToStringSlice(cfg.Language.Get("ignoreErrors"))
        ignorableLogger := loggers.NewIgnorableLogger(cfg.Logger, ignoreErrors...)

        disabledKinds := make(map[string]bool)
        for _, disabled := range cast.ToStringSlice(cfg.Language.Get("disableKinds")) </span><span class="cov8" title="1">{
                disabledKinds[disabled] = true
        }</span>

        <span class="cov8" title="1">if disabledKinds["taxonomyTerm"] </span><span class="cov8" title="1">{
                // Correct from the value it had before Hugo 0.73.0.
                if disabledKinds[page.KindTaxonomy] </span><span class="cov8" title="1">{
                        disabledKinds[page.KindTerm] = true
                }</span> else<span class="cov8" title="1"> {
                        disabledKinds[page.KindTaxonomy] = true
                }</span>

                <span class="cov8" title="1">delete(disabledKinds, "taxonomyTerm")</span>
        } else<span class="cov8" title="1"> if disabledKinds[page.KindTaxonomy] &amp;&amp; !disabledKinds[page.KindTerm] </span><span class="cov8" title="1">{
                // This is a potentially ambigous situation. It may be correct.
                ignorableLogger.Errorsf(constants.ErrIDAmbigousDisableKindTaxonomy, `You have the value 'taxonomy' in the disabledKinds list. In Hugo 0.73.0 we fixed these to be what most people expect (taxonomy and term).
But this also means that your site configuration may not do what you expect. If it is correct, you can suppress this message by following the instructions below.`)
        }</span>

        <span class="cov8" title="1">var (
                mediaTypesConfig    []map[string]interface{}
                outputFormatsConfig []map[string]interface{}

                siteOutputFormatsConfig output.Formats
                siteMediaTypesConfig    media.Types
                err                     error
        )

        // Add language last, if set, so it gets precedence.
        for _, cfg := range []config.Provider{cfg.Cfg, cfg.Language} </span><span class="cov8" title="1">{
                if cfg.IsSet("mediaTypes") </span><span class="cov8" title="1">{
                        mediaTypesConfig = append(mediaTypesConfig, cfg.GetStringMap("mediaTypes"))
                }</span>
                <span class="cov8" title="1">if cfg.IsSet("outputFormats") </span><span class="cov8" title="1">{
                        outputFormatsConfig = append(outputFormatsConfig, cfg.GetStringMap("outputFormats"))
                }</span>
        }

        <span class="cov8" title="1">siteMediaTypesConfig, err = media.DecodeTypes(mediaTypesConfig...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">siteOutputFormatsConfig, err = output.DecodeFormats(siteMediaTypesConfig, outputFormatsConfig...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rssDisabled := disabledKinds[kindRSS]
        if rssDisabled </span><span class="cov8" title="1">{
                // Legacy
                tmp := siteOutputFormatsConfig[:0]
                for _, x := range siteOutputFormatsConfig </span><span class="cov8" title="1">{
                        if !strings.EqualFold(x.Name, "rss") </span><span class="cov8" title="1">{
                                tmp = append(tmp, x)
                        }</span>
                }
                <span class="cov8" title="1">siteOutputFormatsConfig = tmp</span>
        }

        <span class="cov8" title="1">var siteOutputs map[string]interface{}
        if cfg.Language.IsSet("outputs") </span><span class="cov8" title="1">{
                siteOutputs = cfg.Language.GetStringMap("outputs")

                // Check and correct taxonomy kinds vs pre Hugo 0.73.0.
                v1, hasTaxonomyTerm := siteOutputs["taxonomyterm"]
                v2, hasTaxonomy := siteOutputs[page.KindTaxonomy]
                _, hasTerm := siteOutputs[page.KindTerm]
                if hasTaxonomy &amp;&amp; hasTaxonomyTerm </span><span class="cov8" title="1">{
                        siteOutputs[page.KindTaxonomy] = v1
                        siteOutputs[page.KindTerm] = v2
                        delete(siteOutputs, "taxonomyTerm")
                }</span> else<span class="cov8" title="1"> if hasTaxonomy &amp;&amp; !hasTerm </span><span class="cov8" title="1">{
                        // This is a potentially ambigous situation. It may be correct.
                        ignorableLogger.Errorsf(constants.ErrIDAmbigousOutputKindTaxonomy, `You have configured output formats for 'taxonomy' in your site configuration. In Hugo 0.73.0 we fixed these to be what most people expect (taxonomy and term).
But this also means that your site configuration may not do what you expect. If it is correct, you can suppress this message by following the instructions below.`)
                }</span>
                <span class="cov8" title="1">if !hasTaxonomy &amp;&amp; hasTaxonomyTerm </span><span class="cov8" title="1">{
                        siteOutputs[page.KindTaxonomy] = v1
                        delete(siteOutputs, "taxonomyterm")
                }</span>
        }

        <span class="cov8" title="1">outputFormats, err := createSiteOutputFormats(siteOutputFormatsConfig, siteOutputs, rssDisabled)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">taxonomies := cfg.Language.GetStringMapString("taxonomies")

        var relatedContentConfig related.Config

        if cfg.Language.IsSet("related") </span><span class="cov0" title="0">{
                relatedContentConfig, err = related.DecodeConfig(cfg.Language.GetParams("related"))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrap(err, "failed to decode related config")
                }</span>
        } else<span class="cov8" title="1"> {
                relatedContentConfig = related.DefaultConfig
                if _, found := taxonomies["tag"]; found </span><span class="cov8" title="1">{
                        relatedContentConfig.Add(related.IndexConfig{Name: "tags", Weight: 80})
                }</span>
        }

        <span class="cov8" title="1">titleFunc := helpers.GetTitleFunc(cfg.Language.GetString("titleCaseStyle"))

        frontMatterHandler, err := pagemeta.NewFrontmatterHandler(cfg.Logger, cfg.Cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">timeout := 30 * time.Second
        if cfg.Language.IsSet("timeout") </span><span class="cov8" title="1">{
                v := cfg.Language.Get("timeout")
                d, err := types.ToDurationE(v)
                if err == nil </span><span class="cov8" title="1">{
                        timeout = d
                }</span>
        }

        <span class="cov8" title="1">siteConfig := siteConfigHolder{
                sitemap:          config.DecodeSitemap(config.Sitemap{Priority: -1, Filename: "sitemap.xml"}, cfg.Language.GetStringMap("sitemap")),
                taxonomiesConfig: taxonomies,
                timeout:          timeout,
                hasCJKLanguage:   cfg.Language.GetBool("hasCJKLanguage"),
                enableEmoji:      cfg.Language.Cfg.GetBool("enableEmoji"),
        }

        var siteBucket *pagesMapBucket
        if cfg.Language.IsSet("cascade") </span><span class="cov8" title="1">{
                var err error
                cascade, err := page.DecodeCascade(cfg.Language.Get("cascade"))
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("failed to decode cascade config: %s", err)
                }</span>

                <span class="cov8" title="1">siteBucket = &amp;pagesMapBucket{
                        cascade: cascade,
                }</span>

        }

        <span class="cov8" title="1">s := &amp;Site{
                language:      cfg.Language,
                siteBucket:    siteBucket,
                disabledKinds: disabledKinds,

                outputFormats:       outputFormats,
                outputFormatsConfig: siteOutputFormatsConfig,
                mediaTypesConfig:    siteMediaTypesConfig,

                siteCfg: siteConfig,

                titleFunc: titleFunc,

                rc: &amp;siteRenderingContext{output.HTMLFormat},

                frontmatterHandler: frontMatterHandler,
                relatedDocsHandler: page.NewRelatedDocsHandler(relatedContentConfig),
        }

        s.prepareInits()

        return s, nil</span>
}

// NewSite creates a new site with the given dependency configuration.
// The site will have a template system loaded and ready to use.
// Note: This is mainly used in single site tests.
func NewSite(cfg deps.DepsCfg) (*Site, error) <span class="cov0" title="0">{
        s, err := newSite(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">var l configLoader
        if err = l.applyDeps(cfg, s); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return s, nil</span>
}

// NewSiteDefaultLang creates a new site in the default language.
// The site will have a template system loaded and ready to use.
// Note: This is mainly used in single site tests.
// TODO(bep) test refactor -- remove
func NewSiteDefaultLang(withTemplate ...func(templ tpl.TemplateManager) error) (*Site, error) <span class="cov0" title="0">{
        l := configLoader{cfg: config.New()}
        if err := l.applyConfigDefaults(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return newSiteForLang(langs.NewDefaultLanguage(l.cfg), withTemplate...)</span>
}

// NewEnglishSite creates a new site in English language.
// The site will have a template system loaded and ready to use.
// Note: This is mainly used in single site tests.
// TODO(bep) test refactor -- remove
func NewEnglishSite(withTemplate ...func(templ tpl.TemplateManager) error) (*Site, error) <span class="cov0" title="0">{
        l := configLoader{cfg: config.New()}
        if err := l.applyConfigDefaults(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return newSiteForLang(langs.NewLanguage("en", l.cfg), withTemplate...)</span>
}

// newSiteForLang creates a new site in the given language.
func newSiteForLang(lang *langs.Language, withTemplate ...func(templ tpl.TemplateManager) error) (*Site, error) <span class="cov0" title="0">{
        withTemplates := func(templ tpl.TemplateManager) error </span><span class="cov0" title="0">{
                for _, wt := range withTemplate </span><span class="cov0" title="0">{
                        if err := wt(templ); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">cfg := deps.DepsCfg{WithTemplate: withTemplates, Cfg: lang}

        return NewSiteForCfg(cfg)</span>
}

// NewSiteForCfg creates a new site for the given configuration.
// The site will have a template system loaded and ready to use.
// Note: This is mainly used in single site tests.
func NewSiteForCfg(cfg deps.DepsCfg) (*Site, error) <span class="cov8" title="1">{
        h, err := NewHugoSites(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return h.Sites[0], nil</span>
}

type SiteInfo struct {
        Authors page.AuthorList
        Social  SiteSocial

        hugoInfo     hugo.Info
        title        string
        RSSLink      string
        Author       map[string]interface{}
        LanguageCode string
        Copyright    string

        permalinks map[string]string

        LanguagePrefix string
        Languages      langs.Languages

        BuildDrafts bool

        canonifyURLs bool
        relativeURLs bool
        uglyURLs     func(p page.Page) bool

        owner                          *HugoSites
        s                              *Site
        language                       *langs.Language
        defaultContentLanguageInSubdir bool
        sectionPagesMenu               string
}

func (s *SiteInfo) Pages() page.Pages <span class="cov8" title="1">{
        return s.s.Pages()
}</span>

func (s *SiteInfo) RegularPages() page.Pages <span class="cov8" title="1">{
        return s.s.RegularPages()
}</span>

func (s *SiteInfo) AllPages() page.Pages <span class="cov0" title="0">{
        return s.s.AllPages()
}</span>

func (s *SiteInfo) AllRegularPages() page.Pages <span class="cov0" title="0">{
        return s.s.AllRegularPages()
}</span>

func (s *SiteInfo) LastChange() time.Time <span class="cov8" title="1">{
        return s.s.lastmod
}</span>

func (s *SiteInfo) Title() string <span class="cov8" title="1">{
        return s.title
}</span>

func (s *SiteInfo) Site() page.Site <span class="cov0" title="0">{
        return s
}</span>

func (s *SiteInfo) Menus() navigation.Menus <span class="cov8" title="1">{
        return s.s.Menus()
}</span>

// TODO(bep) type
func (s *SiteInfo) Taxonomies() interface{} <span class="cov8" title="1">{
        return s.s.Taxonomies()
}</span>

func (s *SiteInfo) Params() maps.Params <span class="cov8" title="1">{
        return s.s.Language().Params()
}</span>

func (s *SiteInfo) Data() map[string]interface{} <span class="cov8" title="1">{
        return s.s.h.Data()
}</span>

func (s *SiteInfo) Language() *langs.Language <span class="cov8" title="1">{
        return s.language
}</span>

func (s *SiteInfo) Config() SiteConfig <span class="cov8" title="1">{
        return s.s.siteConfigConfig
}</span>

func (s *SiteInfo) Hugo() hugo.Info <span class="cov8" title="1">{
        return s.hugoInfo
}</span>

// Sites is a convenience method to get all the Hugo sites/languages configured.
func (s *SiteInfo) Sites() page.Sites <span class="cov8" title="1">{
        return s.s.h.siteInfos()
}</span>

func (s *SiteInfo) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Site(%q)", s.title)
}</span>

func (s *SiteInfo) BaseURL() template.URL <span class="cov8" title="1">{
        return template.URL(s.s.PathSpec.BaseURL.String())
}</span>

// ServerPort returns the port part of the BaseURL, 0 if none found.
func (s *SiteInfo) ServerPort() int <span class="cov0" title="0">{
        ps := s.s.PathSpec.BaseURL.URL().Port()
        if ps == "" </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">p, err := strconv.Atoi(ps)
        if err != nil </span><span class="cov0" title="0">{
                return 0
        }</span>
        <span class="cov0" title="0">return p</span>
}

// GoogleAnalytics is kept here for historic reasons.
func (s *SiteInfo) GoogleAnalytics() string <span class="cov8" title="1">{
        return s.Config().Services.GoogleAnalytics.ID
}</span>

// DisqusShortname is kept here for historic reasons.
func (s *SiteInfo) DisqusShortname() string <span class="cov8" title="1">{
        return s.Config().Services.Disqus.Shortname
}</span>

// SiteSocial is a place to put social details on a site level. These are the
// standard keys that themes will expect to have available, but can be
// expanded to any others on a per site basis
// github
// facebook
// facebook_admin
// twitter
// twitter_domain
// pinterest
// instagram
// youtube
// linkedin
type SiteSocial map[string]string

// Param is a convenience method to do lookups in SiteInfo's Params map.
//
// This method is also implemented on Page.
func (s *SiteInfo) Param(key interface{}) (interface{}, error) <span class="cov8" title="1">{
        return resource.Param(s, nil, key)
}</span>

func (s *SiteInfo) IsMultiLingual() bool <span class="cov8" title="1">{
        return len(s.Languages) &gt; 1
}</span>

func (s *SiteInfo) IsServer() bool <span class="cov0" title="0">{
        return s.owner.running
}</span>

type siteRefLinker struct {
        s *Site

        errorLogger *log.Logger
        notFoundURL string
}

func newSiteRefLinker(cfg config.Provider, s *Site) (siteRefLinker, error) <span class="cov8" title="1">{
        logger := s.Log.Error()

        notFoundURL := cfg.GetString("refLinksNotFoundURL")
        errLevel := cfg.GetString("refLinksErrorLevel")
        if strings.EqualFold(errLevel, "warning") </span><span class="cov0" title="0">{
                logger = s.Log.Warn()
        }</span>
        <span class="cov8" title="1">return siteRefLinker{s: s, errorLogger: logger, notFoundURL: notFoundURL}, nil</span>
}

func (s siteRefLinker) logNotFound(ref, what string, p page.Page, position text.Position) <span class="cov0" title="0">{
        if position.IsValid() </span><span class="cov0" title="0">{
                s.errorLogger.Printf("[%s] REF_NOT_FOUND: Ref %q: %s: %s", s.s.Lang(), ref, position.String(), what)
        }</span> else<span class="cov0" title="0"> if p == nil </span><span class="cov0" title="0">{
                s.errorLogger.Printf("[%s] REF_NOT_FOUND: Ref %q: %s", s.s.Lang(), ref, what)
        }</span> else<span class="cov0" title="0"> {
                s.errorLogger.Printf("[%s] REF_NOT_FOUND: Ref %q from page %q: %s", s.s.Lang(), ref, p.Pathc(), what)
        }</span>
}

func (s *siteRefLinker) refLink(ref string, source interface{}, relative bool, outputFormat string) (string, error) <span class="cov8" title="1">{
        p, err := unwrapPage(source)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">var refURL *url.URL

        ref = filepath.ToSlash(ref)

        refURL, err = url.Parse(ref)

        if err != nil </span><span class="cov0" title="0">{
                return s.notFoundURL, err
        }</span>

        <span class="cov8" title="1">var target page.Page
        var link string

        if refURL.Path != "" </span><span class="cov8" title="1">{
                var err error
                target, err = s.s.getPageRef(p, refURL.Path)
                var pos text.Position
                if err != nil || target == nil </span><span class="cov0" title="0">{
                        if p, ok := source.(text.Positioner); ok </span><span class="cov0" title="0">{
                                pos = p.Position()
                        }</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        s.logNotFound(refURL.Path, err.Error(), p, pos)
                        return s.notFoundURL, nil
                }</span>

                <span class="cov8" title="1">if target == nil </span><span class="cov0" title="0">{
                        s.logNotFound(refURL.Path, "page not found", p, pos)
                        return s.notFoundURL, nil
                }</span>

                <span class="cov8" title="1">var permalinker Permalinker = target

                if outputFormat != "" </span><span class="cov0" title="0">{
                        o := target.OutputFormats().Get(outputFormat)

                        if o == nil </span><span class="cov0" title="0">{
                                s.logNotFound(refURL.Path, fmt.Sprintf("output format %q", outputFormat), p, pos)
                                return s.notFoundURL, nil
                        }</span>
                        <span class="cov0" title="0">permalinker = o</span>
                }

                <span class="cov8" title="1">if relative </span><span class="cov8" title="1">{
                        link = permalinker.RelPermalink()
                }</span> else<span class="cov8" title="1"> {
                        link = permalinker.Permalink()
                }</span>
        }

        <span class="cov8" title="1">if refURL.Fragment != "" </span><span class="cov8" title="1">{
                _ = target
                link = link + "#" + refURL.Fragment

                if pctx, ok := target.(pageContext); ok </span><span class="cov8" title="1">{
                        if refURL.Path != "" </span><span class="cov8" title="1">{
                                if di, ok := pctx.getContentConverter().(converter.DocumentInfo); ok </span><span class="cov8" title="1">{
                                        link = link + di.AnchorSuffix()
                                }</span>
                        }
                } else<span class="cov8" title="1"> if pctx, ok := p.(pageContext); ok </span><span class="cov8" title="1">{
                        if di, ok := pctx.getContentConverter().(converter.DocumentInfo); ok </span><span class="cov0" title="0">{
                                link = link + di.AnchorSuffix()
                        }</span>
                }

        }

        <span class="cov8" title="1">return link, nil</span>
}

func (s *Site) running() bool <span class="cov8" title="1">{
        return s.h != nil &amp;&amp; s.h.running
}</span>

func (s *Site) multilingual() *Multilingual <span class="cov8" title="1">{
        return s.h.multilingual
}</span>

type whatChanged struct {
        source bool
        files  map[string]bool
}

// RegisterMediaTypes will register the Site's media types in the mime
// package, so it will behave correctly with Hugo's built-in server.
func (s *Site) RegisterMediaTypes() <span class="cov0" title="0">{
        for _, mt := range s.mediaTypesConfig </span><span class="cov0" title="0">{
                for _, suffix := range mt.Suffixes() </span><span class="cov0" title="0">{
                        _ = mime.AddExtensionType(mt.Delimiter+suffix, mt.Type()+"; charset=utf-8")
                }</span>
        }
}

func (s *Site) filterFileEvents(events []fsnotify.Event) []fsnotify.Event <span class="cov8" title="1">{
        var filtered []fsnotify.Event
        seen := make(map[fsnotify.Event]bool)

        for _, ev := range events </span><span class="cov8" title="1">{
                // Avoid processing the same event twice.
                if seen[ev] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">seen[ev] = true

                if s.SourceSpec.IgnoreFile(ev.Name) </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Throw away any directories
                <span class="cov8" title="1">isRegular, err := s.SourceSpec.IsRegularSourceFile(ev.Name)
                if err != nil &amp;&amp; os.IsNotExist(err) &amp;&amp; (ev.Op&amp;fsnotify.Remove == fsnotify.Remove || ev.Op&amp;fsnotify.Rename == fsnotify.Rename) </span><span class="cov8" title="1">{
                        // Force keep of event
                        isRegular = true
                }</span>
                <span class="cov8" title="1">if !isRegular </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">if runtime.GOOS == "darwin" </span><span class="cov0" title="0">{ // When a file system is HFS+, its filepath is in NFD form.
                        ev.Name = norm.NFC.String(ev.Name)
                }</span>

                <span class="cov8" title="1">filtered = append(filtered, ev)</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

func (s *Site) translateFileEvents(events []fsnotify.Event) []fsnotify.Event <span class="cov8" title="1">{
        var filtered []fsnotify.Event

        eventMap := make(map[string][]fsnotify.Event)

        // We often get a Remove etc. followed by a Create, a Create followed by a Write.
        // Remove the superfluous events to mage the update logic simpler.
        for _, ev := range events </span><span class="cov8" title="1">{
                eventMap[ev.Name] = append(eventMap[ev.Name], ev)
        }</span>

        <span class="cov8" title="1">for _, ev := range events </span><span class="cov8" title="1">{
                mapped := eventMap[ev.Name]

                // Keep one
                found := false
                var kept fsnotify.Event
                for i, ev2 := range mapped </span><span class="cov8" title="1">{
                        if i == 0 </span><span class="cov8" title="1">{
                                kept = ev2
                        }</span>

                        <span class="cov8" title="1">if ev2.Op&amp;fsnotify.Write == fsnotify.Write </span><span class="cov8" title="1">{
                                kept = ev2
                                found = true
                        }</span>

                        <span class="cov8" title="1">if !found &amp;&amp; ev2.Op&amp;fsnotify.Create == fsnotify.Create </span><span class="cov8" title="1">{
                                kept = ev2
                        }</span>
                }

                <span class="cov8" title="1">filtered = append(filtered, kept)</span>
        }

        <span class="cov8" title="1">return filtered</span>
}

var (
        // These are only used for cache busting, so false positives are fine.
        // We also deliberately do not match for file suffixes to also catch
        // directory names.
        // TODO(bep) consider this when completing the relevant PR rewrite on this.
        cssFileRe   = regexp.MustCompile("(css|sass|scss)")
        cssConfigRe = regexp.MustCompile(`(postcss|tailwind)\.config\.js`)
        jsFileRe    = regexp.MustCompile("(js|ts|jsx|tsx)")
)

// reBuild partially rebuilds a site given the filesystem events.
// It returns whatever the content source was changed.
// TODO(bep) clean up/rewrite this method.
func (s *Site) processPartial(config *BuildCfg, init func(config *BuildCfg) error, events []fsnotify.Event) error <span class="cov8" title="1">{
        events = s.filterFileEvents(events)
        events = s.translateFileEvents(events)

        changeIdentities := make(identity.Identities)

        s.Log.Debugf("Rebuild for events %q", events)

        h := s.h

        // First we need to determine what changed

        var (
                sourceChanged       = []fsnotify.Event{}
                sourceReallyChanged = []fsnotify.Event{}
                contentFilesChanged []string

                tmplChanged bool
                tmplAdded   bool
                dataChanged bool
                i18nChanged bool

                sourceFilesChanged = make(map[string]bool)

                // prevent spamming the log on changes
                logger = helpers.NewDistinctErrorLogger()
        )

        var cachePartitions []string
        // Special case
        // TODO(bep) I have a ongoing branch where I have redone the cache. Consider this there.
        var (
                evictCSSRe *regexp.Regexp
                evictJSRe  *regexp.Regexp
        )

        for _, ev := range events </span><span class="cov8" title="1">{
                if assetsFilename, _ := s.BaseFs.Assets.MakePathRelative(ev.Name); assetsFilename != "" </span><span class="cov8" title="1">{
                        cachePartitions = append(cachePartitions, resources.ResourceKeyPartitions(assetsFilename)...)
                        if evictCSSRe == nil </span><span class="cov8" title="1">{
                                if cssFileRe.MatchString(assetsFilename) || cssConfigRe.MatchString(assetsFilename) </span><span class="cov0" title="0">{
                                        evictCSSRe = cssFileRe
                                }</span>
                        }
                        <span class="cov8" title="1">if evictJSRe == nil &amp;&amp; jsFileRe.MatchString(assetsFilename) </span><span class="cov8" title="1">{
                                evictJSRe = jsFileRe
                        }</span>
                }

                <span class="cov8" title="1">id, found := s.eventToIdentity(ev)
                if found </span><span class="cov8" title="1">{
                        changeIdentities[id] = id

                        switch id.Type </span>{
                        case files.ComponentFolderContent:<span class="cov8" title="1">
                                logger.Println("Source changed", ev)
                                sourceChanged = append(sourceChanged, ev)</span>
                        case files.ComponentFolderLayouts:<span class="cov8" title="1">
                                tmplChanged = true
                                if !s.Tmpl().HasTemplate(id.Path) </span><span class="cov8" title="1">{
                                        tmplAdded = true
                                }</span>
                                <span class="cov8" title="1">if tmplAdded </span><span class="cov8" title="1">{
                                        logger.Println("Template added", ev)
                                }</span> else<span class="cov8" title="1"> {
                                        logger.Println("Template changed", ev)
                                }</span>

                        case files.ComponentFolderData:<span class="cov8" title="1">
                                logger.Println("Data changed", ev)
                                dataChanged = true</span>
                        case files.ComponentFolderI18n:<span class="cov8" title="1">
                                logger.Println("i18n changed", ev)
                                i18nChanged = true</span>

                        }
                }
        }

        <span class="cov8" title="1">changed := &amp;whatChanged{
                source: len(sourceChanged) &gt; 0,
                files:  sourceFilesChanged,
        }

        config.whatChanged = changed

        if err := init(config); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // These in memory resource caches will be rebuilt on demand.
        <span class="cov8" title="1">for _, s := range s.h.Sites </span><span class="cov8" title="1">{
                s.ResourceSpec.ResourceCache.DeletePartitions(cachePartitions...)
                if evictCSSRe != nil </span><span class="cov0" title="0">{
                        s.ResourceSpec.ResourceCache.DeleteMatches(evictCSSRe)
                }</span>
                <span class="cov8" title="1">if evictJSRe != nil </span><span class="cov8" title="1">{
                        s.ResourceSpec.ResourceCache.DeleteMatches(evictJSRe)
                }</span>
        }

        <span class="cov8" title="1">if tmplChanged || i18nChanged </span><span class="cov8" title="1">{
                sites := s.h.Sites
                first := sites[0]

                s.h.init.Reset()

                // TOD(bep) globals clean
                if err := first.Deps.LoadResources(); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">for i := 1; i &lt; len(sites); i++ </span><span class="cov8" title="1">{
                        site := sites[i]
                        var err error
                        depsCfg := deps.DepsCfg{
                                Language:      site.language,
                                MediaTypes:    site.mediaTypesConfig,
                                OutputFormats: site.outputFormatsConfig,
                        }
                        site.Deps, err = first.Deps.ForLanguage(depsCfg, func(d *deps.Deps) error </span><span class="cov8" title="1">{
                                d.Site = site.Info
                                return nil
                        }</span>)
                        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">if dataChanged </span><span class="cov8" title="1">{
                s.h.init.data.Reset()
        }</span>

        <span class="cov8" title="1">for _, ev := range sourceChanged </span><span class="cov8" title="1">{
                removed := false

                if ev.Op&amp;fsnotify.Remove == fsnotify.Remove </span><span class="cov8" title="1">{
                        removed = true
                }</span>

                // Some editors (Vim) sometimes issue only a Rename operation when writing an existing file
                // Sometimes a rename operation means that file has been renamed other times it means
                // it's been updated
                <span class="cov8" title="1">if ev.Op&amp;fsnotify.Rename == fsnotify.Rename </span><span class="cov8" title="1">{
                        // If the file is still on disk, it's only been updated, if it's not, it's been moved
                        if ex, err := afero.Exists(s.Fs.Source, ev.Name); !ex || err != nil </span><span class="cov8" title="1">{
                                removed = true
                        }</span>
                }

                <span class="cov8" title="1">if removed &amp;&amp; files.IsContentFile(ev.Name) </span><span class="cov8" title="1">{
                        h.removePageByFilename(ev.Name)
                }</span>

                <span class="cov8" title="1">sourceReallyChanged = append(sourceReallyChanged, ev)
                sourceFilesChanged[ev.Name] = true</span>
        }

        <span class="cov8" title="1">if config.ErrRecovery || tmplAdded || dataChanged </span><span class="cov8" title="1">{
                h.resetPageState()
        }</span> else<span class="cov8" title="1"> {
                h.resetPageStateFromEvents(changeIdentities)
        }</span>

        <span class="cov8" title="1">if len(sourceReallyChanged) &gt; 0 || len(contentFilesChanged) &gt; 0 </span><span class="cov8" title="1">{
                var filenamesChanged []string
                for _, e := range sourceReallyChanged </span><span class="cov8" title="1">{
                        filenamesChanged = append(filenamesChanged, e.Name)
                }</span>
                <span class="cov8" title="1">if len(contentFilesChanged) &gt; 0 </span><span class="cov0" title="0">{
                        filenamesChanged = append(filenamesChanged, contentFilesChanged...)
                }</span>

                <span class="cov8" title="1">filenamesChanged = helpers.UniqueStringsReuse(filenamesChanged)

                if err := s.readAndProcessContent(*config, filenamesChanged...); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }

        <span class="cov8" title="1">return nil</span>
}

func (s *Site) process(config BuildCfg) (err error) <span class="cov8" title="1">{
        if err = s.initialize(); err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, "initialize")
                return
        }</span>
        <span class="cov8" title="1">if err = s.readAndProcessContent(config); err != nil </span><span class="cov0" title="0">{
                err = errors.Wrap(err, "readAndProcessContent")
                return
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (s *Site) render(ctx *siteRenderContext) (err error) <span class="cov8" title="1">{
        if err := page.Clear(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if ctx.outIdx == 0 </span><span class="cov8" title="1">{
                // Note that even if disableAliases is set, the aliases themselves are
                // preserved on page. The motivation with this is to be able to generate
                // 301 redirects in a .htacess file and similar using a custom output format.
                if !s.Cfg.GetBool("disableAliases") </span><span class="cov8" title="1">{
                        // Aliases must be rendered before pages.
                        // Some sites, Hugo docs included, have faulty alias definitions that point
                        // to itself or another real page. These will be overwritten in the next
                        // step.
                        if err = s.renderAliases(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }
        }

        <span class="cov8" title="1">if err = s.renderPages(ctx); err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if ctx.outIdx == 0 </span><span class="cov8" title="1">{
                if err = s.renderSitemap(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">if ctx.multihost </span><span class="cov8" title="1">{
                        if err = s.renderRobotsTXT(); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

                <span class="cov8" title="1">if err = s.render404(); err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">if !ctx.renderSingletonPages() </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if err = s.renderMainLanguageRedirect(); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

func (s *Site) Initialise() (err error) <span class="cov0" title="0">{
        return s.initialize()
}</span>

func (s *Site) initialize() (err error) <span class="cov8" title="1">{
        return s.initializeSiteInfo()
}</span>

// HomeAbsURL is a convenience method giving the absolute URL to the home page.
func (s *SiteInfo) HomeAbsURL() string <span class="cov8" title="1">{
        base := ""
        if s.IsMultiLingual() </span><span class="cov8" title="1">{
                base = s.Language().Lang
        }</span>
        <span class="cov8" title="1">return s.owner.AbsURL(base, false)</span>
}

// SitemapAbsURL is a convenience method giving the absolute URL to the sitemap.
func (s *SiteInfo) SitemapAbsURL() string <span class="cov8" title="1">{
        p := s.HomeAbsURL()
        if !strings.HasSuffix(p, "/") </span><span class="cov8" title="1">{
                p += "/"
        }</span>
        <span class="cov8" title="1">p += s.s.siteCfg.sitemap.Filename
        return p</span>
}

func (s *Site) initializeSiteInfo() error <span class="cov8" title="1">{
        var (
                lang      = s.language
                languages langs.Languages
        )

        if s.h != nil &amp;&amp; s.h.multilingual != nil </span><span class="cov8" title="1">{
                languages = s.h.multilingual.Languages
        }</span>

        <span class="cov8" title="1">permalinks := s.Cfg.GetStringMapString("permalinks")

        defaultContentInSubDir := s.Cfg.GetBool("defaultContentLanguageInSubdir")
        defaultContentLanguage := s.Cfg.GetString("defaultContentLanguage")

        languagePrefix := ""
        if s.multilingualEnabled() &amp;&amp; (defaultContentInSubDir || lang.Lang != defaultContentLanguage) </span><span class="cov8" title="1">{
                languagePrefix = "/" + lang.Lang
        }</span>

        <span class="cov8" title="1">uglyURLs := func(p page.Page) bool </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">v := s.Cfg.Get("uglyURLs")
        if v != nil </span><span class="cov8" title="1">{
                switch vv := v.(type) </span>{
                case bool:<span class="cov8" title="1">
                        uglyURLs = func(p page.Page) bool </span><span class="cov8" title="1">{
                                return vv
                        }</span>
                case string:<span class="cov0" title="0">
                        // Is what be get from CLI (--uglyURLs)
                        vvv := cast.ToBool(vv)
                        uglyURLs = func(p page.Page) bool </span><span class="cov0" title="0">{
                                return vvv
                        }</span>
                default:<span class="cov8" title="1">
                        m := maps.ToStringMapBool(v)
                        uglyURLs = func(p page.Page) bool </span><span class="cov8" title="1">{
                                return m[p.Section()]
                        }</span>
                }
        }

        // Assemble dependencies to be used in hugo.Deps.
        // TODO(bep) another reminder: We need to clean up this Site vs HugoSites construct.
        <span class="cov8" title="1">var deps []*hugo.Dependency
        var depFromMod func(m modules.Module) *hugo.Dependency
        depFromMod = func(m modules.Module) *hugo.Dependency </span><span class="cov8" title="1">{
                dep := &amp;hugo.Dependency{
                        Path:    m.Path(),
                        Version: m.Version(),
                        Time:    m.Time(),
                        Vendor:  m.Vendor(),
                }

                // These are pointers, but this all came from JSON so there's no recursive navigation,
                // so just create new values.
                if m.Replace() != nil </span><span class="cov0" title="0">{
                        dep.Replace = depFromMod(m.Replace())
                }</span>
                <span class="cov8" title="1">if m.Owner() != nil </span><span class="cov8" title="1">{
                        dep.Owner = depFromMod(m.Owner())
                }</span>
                <span class="cov8" title="1">return dep</span>
        }
        <span class="cov8" title="1">for _, m := range s.Paths.AllModules </span><span class="cov8" title="1">{
                deps = append(deps, depFromMod(m))
        }</span>

        <span class="cov8" title="1">s.Info = &amp;SiteInfo{
                title:                          lang.GetString("title"),
                Author:                         lang.GetStringMap("author"),
                Social:                         lang.GetStringMapString("social"),
                LanguageCode:                   lang.GetString("languageCode"),
                Copyright:                      lang.GetString("copyright"),
                language:                       lang,
                LanguagePrefix:                 languagePrefix,
                Languages:                      languages,
                defaultContentLanguageInSubdir: defaultContentInSubDir,
                sectionPagesMenu:               lang.GetString("sectionPagesMenu"),
                BuildDrafts:                    s.Cfg.GetBool("buildDrafts"),
                canonifyURLs:                   s.Cfg.GetBool("canonifyURLs"),
                relativeURLs:                   s.Cfg.GetBool("relativeURLs"),
                uglyURLs:                       uglyURLs,
                permalinks:                     permalinks,
                owner:                          s.h,
                s:                              s,
                hugoInfo:                       hugo.NewInfo(s.Cfg.GetString("environment"), deps),
        }

        rssOutputFormat, found := s.outputFormats[page.KindHome].GetByName(output.RSSFormat.Name)

        if found </span><span class="cov8" title="1">{
                s.Info.RSSLink = s.permalink(rssOutputFormat.BaseFilename())
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *Site) eventToIdentity(e fsnotify.Event) (identity.PathIdentity, bool) <span class="cov8" title="1">{
        for _, fs := range s.BaseFs.SourceFilesystems.FileSystems() </span><span class="cov8" title="1">{
                if p := fs.Path(e.Name); p != "" </span><span class="cov8" title="1">{
                        return identity.NewPathIdentity(fs.Name, filepath.ToSlash(p)), true
                }</span>
        }
        <span class="cov8" title="1">return identity.PathIdentity{}, false</span>
}

func (s *Site) readAndProcessContent(buildConfig BuildCfg, filenames ...string) error <span class="cov8" title="1">{
        sourceSpec := source.NewSourceSpec(s.PathSpec, buildConfig.ContentInclusionFilter, s.BaseFs.Content.Fs)

        proc := newPagesProcessor(s.h, sourceSpec)

        c := newPagesCollector(sourceSpec, s.h.getContentMaps(), s.Log, s.h.ContentChanges, proc, filenames...)

        if err := c.Collect(); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func (s *Site) getMenusFromConfig() navigation.Menus <span class="cov8" title="1">{
        ret := navigation.Menus{}

        if menus := s.language.GetStringMap("menus"); menus != nil </span><span class="cov8" title="1">{
                for name, menu := range menus </span><span class="cov8" title="1">{
                        m, err := cast.ToSliceE(menu)
                        if err != nil </span><span class="cov0" title="0">{
                                s.Log.Errorf("unable to process menus in site config\n")
                                s.Log.Errorln(err)
                        }</span> else<span class="cov8" title="1"> {
                                handleErr := func(err error) </span><span class="cov8" title="1">{
                                        if err == nil </span><span class="cov8" title="1">{
                                                return
                                        }</span>
                                        <span class="cov0" title="0">s.Log.Errorf("unable to process menus in site config\n")
                                        s.Log.Errorln(err)</span>
                                }

                                <span class="cov8" title="1">for _, entry := range m </span><span class="cov8" title="1">{
                                        s.Log.Debugf("found menu: %q, in site config\n", name)

                                        menuEntry := navigation.MenuEntry{Menu: name}
                                        ime, err := maps.ToStringMapE(entry)
                                        handleErr(err)

                                        err = menuEntry.MarshallMap(ime)
                                        handleErr(err)

                                        // TODO(bep) clean up all of this
                                        menuEntry.ConfiguredURL = s.Info.createNodeMenuEntryURL(menuEntry.ConfiguredURL)

                                        if ret[name] == nil </span><span class="cov8" title="1">{
                                                ret[name] = navigation.Menu{}
                                        }</span>
                                        <span class="cov8" title="1">ret[name] = ret[name].Add(&amp;menuEntry)</span>
                                }
                        }
                }
                <span class="cov8" title="1">return ret</span>
        }
        <span class="cov0" title="0">return ret</span>
}

func (s *SiteInfo) createNodeMenuEntryURL(in string) string <span class="cov8" title="1">{
        if !strings.HasPrefix(in, "/") </span><span class="cov8" title="1">{
                return in
        }</span>
        // make it match the nodes
        <span class="cov8" title="1">menuEntryURL := in
        menuEntryURL = helpers.SanitizeURLKeepTrailingSlash(s.s.PathSpec.URLize(menuEntryURL))
        if !s.canonifyURLs </span><span class="cov8" title="1">{
                menuEntryURL = paths.AddContextRoot(s.s.PathSpec.BaseURL.String(), menuEntryURL)
        }</span>
        <span class="cov8" title="1">return menuEntryURL</span>
}

func (s *Site) assembleMenus() <span class="cov8" title="1">{
        s.menus = make(navigation.Menus)

        type twoD struct {
                MenuName, EntryName string
        }
        flat := map[twoD]*navigation.MenuEntry{}
        children := map[twoD]navigation.Menu{}

        // add menu entries from config to flat hash
        menuConfig := s.getMenusFromConfig()
        for name, menu := range menuConfig </span><span class="cov8" title="1">{
                for _, me := range menu </span><span class="cov8" title="1">{
                        if types.IsNil(me.Page) &amp;&amp; me.PageRef != "" </span><span class="cov8" title="1">{
                                // Try to resolve the page.
                                me.Page, _ = s.getPageNew(nil, me.PageRef)
                        }</span>
                        <span class="cov8" title="1">flat[twoD{name, me.KeyName()}] = me</span>
                }
        }

        <span class="cov8" title="1">sectionPagesMenu := s.Info.sectionPagesMenu

        if sectionPagesMenu != "" </span><span class="cov8" title="1">{
                s.pageMap.sections.Walk(func(s string, v interface{}) bool </span><span class="cov8" title="1">{
                        p := v.(*contentNode).p
                        if p.IsHome() </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        // From Hugo 0.22 we have nested sections, but until we get a
                        // feel of how that would work in this setting, let us keep
                        // this menu for the top level only.
                        <span class="cov8" title="1">id := p.Section()
                        if _, ok := flat[twoD{sectionPagesMenu, id}]; ok </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov8" title="1">me := navigation.MenuEntry{
                                Identifier: id,
                                Name:       p.LinkTitle(),
                                Weight:     p.Weight(),
                                Page:       p,
                        }
                        flat[twoD{sectionPagesMenu, me.KeyName()}] = &amp;me

                        return false</span>
                })
        }

        // Add menu entries provided by pages
        <span class="cov8" title="1">s.pageMap.pageTrees.WalkRenderable(func(ss string, n *contentNode) bool </span><span class="cov8" title="1">{
                p := n.p

                for name, me := range p.pageMenus.menus() </span><span class="cov8" title="1">{
                        if _, ok := flat[twoD{name, me.KeyName()}]; ok </span><span class="cov0" title="0">{
                                err := p.wrapError(errors.Errorf("duplicate menu entry with identifier %q in menu %q", me.KeyName(), name))
                                s.Log.Warnln(err)
                                continue</span>
                        }
                        <span class="cov8" title="1">flat[twoD{name, me.KeyName()}] = me</span>
                }

                <span class="cov8" title="1">return false</span>
        })

        // Create Children Menus First
        <span class="cov8" title="1">for _, e := range flat </span><span class="cov8" title="1">{
                if e.Parent != "" </span><span class="cov8" title="1">{
                        children[twoD{e.Menu, e.Parent}] = children[twoD{e.Menu, e.Parent}].Add(e)
                }</span>
        }

        // Placing Children in Parents (in flat)
        <span class="cov8" title="1">for p, childmenu := range children </span><span class="cov8" title="1">{
                _, ok := flat[twoD{p.MenuName, p.EntryName}]
                if !ok </span><span class="cov0" title="0">{
                        // if parent does not exist, create one without a URL
                        flat[twoD{p.MenuName, p.EntryName}] = &amp;navigation.MenuEntry{Name: p.EntryName}
                }</span>
                <span class="cov8" title="1">flat[twoD{p.MenuName, p.EntryName}].Children = childmenu</span>
        }

        // Assembling Top Level of Tree
        <span class="cov8" title="1">for menu, e := range flat </span><span class="cov8" title="1">{
                if e.Parent == "" </span><span class="cov8" title="1">{
                        _, ok := s.menus[menu.MenuName]
                        if !ok </span><span class="cov8" title="1">{
                                s.menus[menu.MenuName] = navigation.Menu{}
                        }</span>
                        <span class="cov8" title="1">s.menus[menu.MenuName] = s.menus[menu.MenuName].Add(e)</span>
                }
        }
}

// get any language code to prefix the target file path with.
func (s *Site) getLanguageTargetPathLang(alwaysInSubDir bool) string <span class="cov8" title="1">{
        if s.h.IsMultihost() </span><span class="cov8" title="1">{
                return s.Language().Lang
        }</span>

        <span class="cov8" title="1">return s.getLanguagePermalinkLang(alwaysInSubDir)</span>
}

// get any lanaguagecode to prefix the relative permalink with.
func (s *Site) getLanguagePermalinkLang(alwaysInSubDir bool) string <span class="cov8" title="1">{
        if !s.Info.IsMultiLingual() || s.h.IsMultihost() </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if alwaysInSubDir </span><span class="cov8" title="1">{
                return s.Language().Lang
        }</span>

        <span class="cov8" title="1">isDefault := s.Language().Lang == s.multilingual().DefaultLang.Lang

        if !isDefault || s.Info.defaultContentLanguageInSubdir </span><span class="cov8" title="1">{
                return s.Language().Lang
        }</span>

        <span class="cov8" title="1">return ""</span>
}

func (s *Site) getTaxonomyKey(key string) string <span class="cov8" title="1">{
        if s.PathSpec.DisablePathToLower </span><span class="cov8" title="1">{
                return s.PathSpec.MakePath(key)
        }</span>
        <span class="cov8" title="1">return strings.ToLower(s.PathSpec.MakePath(key))</span>
}

// Prepare site for a new full build.
func (s *Site) resetBuildState(sourceChanged bool) <span class="cov8" title="1">{
        s.relatedDocsHandler = s.relatedDocsHandler.Clone()
        s.init.Reset()

        if sourceChanged </span><span class="cov8" title="1">{
                s.pageMap.contentMap.pageReverseIndex.Reset()
                s.PageCollections = newPageCollections(s.pageMap)
                s.pageMap.withEveryBundlePage(func(p *pageState) bool </span><span class="cov8" title="1">{
                        p.pagePages = &amp;pagePages{}
                        if p.bucket != nil </span><span class="cov8" title="1">{
                                p.bucket.pagesMapBucketPages = &amp;pagesMapBucketPages{}
                        }</span>
                        <span class="cov8" title="1">p.parent = nil
                        p.Scratcher = maps.NewScratcher()
                        return false</span>
                })
        } else<span class="cov8" title="1"> {
                s.pageMap.withEveryBundlePage(func(p *pageState) bool </span><span class="cov8" title="1">{
                        p.Scratcher = maps.NewScratcher()
                        return false
                }</span>)
        }
}

func (s *Site) errorCollator(results &lt;-chan error, errs chan&lt;- error) <span class="cov8" title="1">{
        var errors []error
        for e := range results </span><span class="cov8" title="1">{
                errors = append(errors, e)
        }</span>

        <span class="cov8" title="1">errs &lt;- s.h.pickOneAndLogTheRest(errors)

        close(errs)</span>
}

// GetPage looks up a page of a given type for the given ref.
// In Hugo &lt;= 0.44 you had to add Page Kind (section, home) etc. as the first
// argument and then either a unix styled path (with or without a leading slash))
// or path elements separated.
// When we now remove the Kind from this API, we need to make the transition as painless
// as possible for existing sites. Most sites will use {{ .Site.GetPage "section" "my/section" }},
// i.e. 2 arguments, so we test for that.
func (s *SiteInfo) GetPage(ref ...string) (page.Page, error) <span class="cov8" title="1">{
        p, err := s.s.getPageOldVersion(ref...)

        if p == nil </span><span class="cov8" title="1">{
                // The nil struct has meaning in some situations, mostly to avoid breaking
                // existing sites doing $nilpage.IsDescendant($p), which will always return
                // false.
                p = page.NilPage
        }</span>

        <span class="cov8" title="1">return p, err</span>
}

func (s *SiteInfo) GetPageWithTemplateInfo(info tpl.Info, ref ...string) (page.Page, error) <span class="cov8" title="1">{
        p, err := s.GetPage(ref...)
        if p != nil </span><span class="cov8" title="1">{
                // Track pages referenced by templates/shortcodes
                // when in server mode.
                if im, ok := info.(identity.Manager); ok </span><span class="cov8" title="1">{
                        im.Add(p)
                }</span>
        }
        <span class="cov8" title="1">return p, err</span>
}

func (s *Site) permalink(link string) string <span class="cov8" title="1">{
        return s.PathSpec.PermalinkForBaseURL(link, s.PathSpec.BaseURL.String())
}</span>

func (s *Site) absURLPath(targetPath string) string <span class="cov8" title="1">{
        var path string
        if s.Info.relativeURLs </span><span class="cov8" title="1">{
                path = helpers.GetDottedRelativePath(targetPath)
        }</span> else<span class="cov8" title="1"> {
                url := s.PathSpec.BaseURL.String()
                if !strings.HasSuffix(url, "/") </span><span class="cov8" title="1">{
                        url += "/"
                }</span>
                <span class="cov8" title="1">path = url</span>
        }

        <span class="cov8" title="1">return path</span>
}

func (s *Site) lookupLayouts(layouts ...string) tpl.Template <span class="cov8" title="1">{
        for _, l := range layouts </span><span class="cov8" title="1">{
                if templ, found := s.Tmpl().Lookup(l); found </span><span class="cov8" title="1">{
                        return templ
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (s *Site) renderAndWriteXML(statCounter *uint64, name string, targetPath string, d interface{}, templ tpl.Template) error <span class="cov8" title="1">{
        s.Log.Debugf("Render XML for %q to %q", name, targetPath)
        renderBuffer := bp.GetBuffer()
        defer bp.PutBuffer(renderBuffer)

        if err := s.renderForTemplate(name, "", d, renderBuffer, templ); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">pd := publisher.Descriptor{
                Src:         renderBuffer,
                TargetPath:  targetPath,
                StatCounter: statCounter,
                // For the minification part of XML,
                // we currently only use the MIME type.
                OutputFormat: output.RSSFormat,
                AbsURLPath:   s.absURLPath(targetPath),
        }

        return s.publisher.Publish(pd)</span>
}

func (s *Site) renderAndWritePage(statCounter *uint64, name string, targetPath string, p *pageState, templ tpl.Template) error <span class="cov8" title="1">{
        s.Log.Debugf("Render %s to %q", name, targetPath)
        s.h.IncrPageRender()
        renderBuffer := bp.GetBuffer()
        defer bp.PutBuffer(renderBuffer)

        of := p.outputFormat()

        if err := s.renderForTemplate(p.Kind(), of.Name, p, renderBuffer, templ); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>

        <span class="cov8" title="1">if renderBuffer.Len() == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">isHTML := of.IsHTML
        isRSS := of.Name == "RSS"

        pd := publisher.Descriptor{
                Src:          renderBuffer,
                TargetPath:   targetPath,
                StatCounter:  statCounter,
                OutputFormat: p.outputFormat(),
        }

        if isRSS </span><span class="cov8" title="1">{
                // Always canonify URLs in RSS
                pd.AbsURLPath = s.absURLPath(targetPath)
        }</span> else<span class="cov8" title="1"> if isHTML </span><span class="cov8" title="1">{
                if s.Info.relativeURLs || s.Info.canonifyURLs </span><span class="cov8" title="1">{
                        pd.AbsURLPath = s.absURLPath(targetPath)
                }</span>

                <span class="cov8" title="1">if s.running() &amp;&amp; s.Cfg.GetBool("watch") &amp;&amp; !s.Cfg.GetBool("disableLiveReload") </span><span class="cov0" title="0">{
                        pd.LiveReloadBaseURL = s.PathSpec.BaseURL.URL()
                        if s.Cfg.GetInt("liveReloadPort") != -1 </span><span class="cov0" title="0">{
                                pd.LiveReloadBaseURL.Host = fmt.Sprintf("%s:%d", pd.LiveReloadBaseURL.Hostname(), s.Cfg.GetInt("liveReloadPort"))
                        }</span>
                }

                // For performance reasons we only inject the Hugo generator tag on the home page.
                <span class="cov8" title="1">if p.IsHome() </span><span class="cov8" title="1">{
                        pd.AddHugoGeneratorTag = !s.Cfg.GetBool("disableHugoGeneratorInject")
                }</span>

        }

        <span class="cov8" title="1">return s.publisher.Publish(pd)</span>
}

var infoOnMissingLayout = map[string]bool{
        // The 404 layout is very much optional in Hugo, but we do look for it.
        "404": true,
}

// hookRenderer is the canonical implementation of all hooks.ITEMRenderer,
// where ITEM is the thing being hooked.
type hookRenderer struct {
        templateHandler tpl.TemplateHandler
        identity.SearchProvider
        templ tpl.Template
}

func (hr hookRenderer) RenderLink(w io.Writer, ctx hooks.LinkContext) error <span class="cov8" title="1">{
        return hr.templateHandler.Execute(hr.templ, w, ctx)
}</span>

func (hr hookRenderer) RenderHeading(w io.Writer, ctx hooks.HeadingContext) error <span class="cov8" title="1">{
        return hr.templateHandler.Execute(hr.templ, w, ctx)
}</span>

func (s *Site) renderForTemplate(name, outputFormat string, d interface{}, w io.Writer, templ tpl.Template) (err error) <span class="cov8" title="1">{
        if templ == nil </span><span class="cov0" title="0">{
                s.logMissingLayout(name, "", "", outputFormat)
                return nil
        }</span>

        <span class="cov8" title="1">if err = s.Tmpl().Execute(templ, w, d); err != nil </span><span class="cov8" title="1">{
                return _errors.Wrapf(err, "render of %q failed", name)
        }</span>
        <span class="cov8" title="1">return</span>
}

func (s *Site) lookupTemplate(layouts ...string) (tpl.Template, bool) <span class="cov8" title="1">{
        for _, l := range layouts </span><span class="cov8" title="1">{
                if templ, found := s.Tmpl().Lookup(l); found </span><span class="cov8" title="1">{
                        return templ, true
                }</span>
        }

        <span class="cov0" title="0">return nil, false</span>
}

func (s *Site) publish(statCounter *uint64, path string, r io.Reader) (err error) <span class="cov8" title="1">{
        s.PathSpec.ProcessingStats.Incr(statCounter)

        return helpers.WriteToDisk(filepath.Clean(path), r, s.BaseFs.PublishFs)
}</span>

func (s *Site) kindFromFileInfoOrSections(fi *fileInfo, sections []string) string <span class="cov8" title="1">{
        if fi.TranslationBaseName() == "_index" </span><span class="cov8" title="1">{
                if fi.Dir() == "" </span><span class="cov0" title="0">{
                        return page.KindHome
                }</span>

                <span class="cov8" title="1">return s.kindFromSections(sections)</span>

        }

        <span class="cov8" title="1">return page.KindPage</span>
}

func (s *Site) kindFromSections(sections []string) string <span class="cov8" title="1">{
        if len(sections) == 0 </span><span class="cov8" title="1">{
                return page.KindHome
        }</span>

        <span class="cov8" title="1">return s.kindFromSectionPath(path.Join(sections...))</span>
}

func (s *Site) kindFromSectionPath(sectionPath string) string <span class="cov8" title="1">{
        for _, plural := range s.siteCfg.taxonomiesConfig </span><span class="cov8" title="1">{
                if plural == sectionPath </span><span class="cov8" title="1">{
                        return page.KindTaxonomy
                }</span>

                <span class="cov8" title="1">if strings.HasPrefix(sectionPath, plural) </span><span class="cov8" title="1">{
                        return page.KindTerm
                }</span>

        }

        <span class="cov8" title="1">return page.KindSection</span>
}

func (s *Site) newPage(
        n *contentNode,
        parentbBucket *pagesMapBucket,
        kind, title string,
        sections ...string) *pageState <span class="cov8" title="1">{
        m := map[string]interface{}{}
        if title != "" </span><span class="cov8" title="1">{
                m["title"] = title
        }</span>

        <span class="cov8" title="1">p, err := newPageFromMeta(
                n,
                parentbBucket,
                m,
                &amp;pageMeta{
                        s:        s,
                        kind:     kind,
                        sections: sections,
                })
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov8" title="1">return p</span>
}

func (s *Site) shouldBuild(p page.Page) bool <span class="cov8" title="1">{
        return shouldBuild(s.BuildFuture, s.BuildExpired,
                s.BuildDrafts, p.Draft(), p.PublishDate(), p.ExpiryDate())
}</span>

func shouldBuild(buildFuture bool, buildExpired bool, buildDrafts bool, Draft bool,
        publishDate time.Time, expiryDate time.Time) bool <span class="cov8" title="1">{
        if !(buildDrafts || !Draft) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if !buildFuture &amp;&amp; !publishDate.IsZero() &amp;&amp; publishDate.After(time.Now()) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if !buildExpired &amp;&amp; !expiryDate.IsZero() &amp;&amp; expiryDate.Before(time.Now()) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file141" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "strings"

        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/spf13/cast"
)

func createDefaultOutputFormats(allFormats output.Formats) map[string]output.Formats <span class="cov8" title="1">{
        rssOut, rssFound := allFormats.GetByName(output.RSSFormat.Name)
        htmlOut, _ := allFormats.GetByName(output.HTMLFormat.Name)
        robotsOut, _ := allFormats.GetByName(output.RobotsTxtFormat.Name)
        sitemapOut, _ := allFormats.GetByName(output.SitemapFormat.Name)

        defaultListTypes := output.Formats{htmlOut}
        if rssFound </span><span class="cov8" title="1">{
                defaultListTypes = append(defaultListTypes, rssOut)
        }</span>

        <span class="cov8" title="1">m := map[string]output.Formats{
                page.KindPage:     {htmlOut},
                page.KindHome:     defaultListTypes,
                page.KindSection:  defaultListTypes,
                page.KindTerm:     defaultListTypes,
                page.KindTaxonomy: defaultListTypes,
                // Below are for consistency. They are currently not used during rendering.
                kindSitemap:   {sitemapOut},
                kindRobotsTXT: {robotsOut},
                kind404:       {htmlOut},
        }

        // May be disabled
        if rssFound </span><span class="cov8" title="1">{
                m[kindRSS] = output.Formats{rssOut}
        }</span>

        <span class="cov8" title="1">return m</span>
}

func createSiteOutputFormats(allFormats output.Formats, outputs map[string]interface{}, rssDisabled bool) (map[string]output.Formats, error) <span class="cov8" title="1">{
        defaultOutputFormats := createDefaultOutputFormats(allFormats)

        if outputs == nil </span><span class="cov8" title="1">{
                return defaultOutputFormats, nil
        }</span>

        <span class="cov8" title="1">outFormats := make(map[string]output.Formats)

        if len(outputs) == 0 </span><span class="cov0" title="0">{
                return outFormats, nil
        }</span>

        <span class="cov8" title="1">seen := make(map[string]bool)

        for k, v := range outputs </span><span class="cov8" title="1">{
                k = getKind(k)
                if k == "" </span><span class="cov0" title="0">{
                        // Invalid kind
                        continue</span>
                }
                <span class="cov8" title="1">var formats output.Formats
                vals := cast.ToStringSlice(v)
                for _, format := range vals </span><span class="cov8" title="1">{
                        f, found := allFormats.GetByName(format)
                        if !found </span><span class="cov8" title="1">{
                                if rssDisabled &amp;&amp; strings.EqualFold(format, "RSS") </span><span class="cov8" title="1">{
                                        // This is legacy behaviour. We used to have both
                                        // a RSS page kind and output format.
                                        continue</span>
                                }
                                <span class="cov8" title="1">return nil, fmt.Errorf("failed to resolve output format %q from site config", format)</span>
                        }
                        <span class="cov8" title="1">formats = append(formats, f)</span>
                }

                // This effectively prevents empty outputs entries for a given Kind.
                // We need at least one.
                <span class="cov8" title="1">if len(formats) &gt; 0 </span><span class="cov8" title="1">{
                        seen[k] = true
                        outFormats[k] = formats
                }</span>
        }

        // Add defaults for the entries not provided by the user.
        <span class="cov8" title="1">for k, v := range defaultOutputFormats </span><span class="cov8" title="1">{
                if !seen[k] </span><span class="cov8" title="1">{
                        outFormats[k] = v
                }</span>
        }

        <span class="cov8" title="1">return outFormats, nil</span>
}
</pre>
		
		<pre class="file" id="file142" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "path"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/tpl"

        "github.com/gohugoio/hugo/config"

        "github.com/gohugoio/hugo/output"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/page/pagemeta"
)

type siteRenderContext struct {
        cfg *BuildCfg

        // Zero based index for all output formats combined.
        sitesOutIdx int

        // Zero based index of the output formats configured within a Site.
        // Note that these outputs are sorted.
        outIdx int

        multihost bool
}

// Whether to render 404.html, robotsTXT.txt which usually is rendered
// once only in the site root.
func (s siteRenderContext) renderSingletonPages() bool <span class="cov8" title="1">{
        if s.multihost </span><span class="cov8" title="1">{
                // 1 per site
                return s.outIdx == 0
        }</span>

        // 1 for all sites
        <span class="cov8" title="1">return s.sitesOutIdx == 0</span>
}

// renderPages renders pages each corresponding to a markdown file.
// TODO(bep np doc
func (s *Site) renderPages(ctx *siteRenderContext) error <span class="cov8" title="1">{
        numWorkers := config.GetNumWorkerMultiplier()

        results := make(chan error)
        pages := make(chan *pageState, numWorkers) // buffered for performance
        errs := make(chan error)

        go s.errorCollator(results, errs)

        wg := &amp;sync.WaitGroup{}

        for i := 0; i &lt; numWorkers; i++ </span><span class="cov8" title="1">{
                wg.Add(1)
                go pageRenderer(ctx, s, pages, results, wg)
        }</span>

        <span class="cov8" title="1">cfg := ctx.cfg

        s.pageMap.pageTrees.Walk(func(ss string, n *contentNode) bool </span><span class="cov8" title="1">{
                if cfg.shouldRender(n.p) </span><span class="cov8" title="1">{
                        select </span>{
                        case &lt;-s.h.Done():<span class="cov8" title="1">
                                return true</span>
                        default:<span class="cov8" title="1">
                                pages &lt;- n.p</span>
                        }
                }
                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">close(pages)

        wg.Wait()

        close(results)

        err := &lt;-errs
        if err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "failed to render pages")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func pageRenderer(
        ctx *siteRenderContext,
        s *Site,
        pages &lt;-chan *pageState,
        results chan&lt;- error,
        wg *sync.WaitGroup) <span class="cov8" title="1">{
        defer wg.Done()

        for p := range pages </span><span class="cov8" title="1">{
                if p.m.buildConfig.PublishResources </span><span class="cov8" title="1">{
                        if err := p.renderResources(); err != nil </span><span class="cov0" title="0">{
                                s.SendError(p.errorf(err, "failed to render page resources"))
                                continue</span>
                        }
                }

                <span class="cov8" title="1">if !p.render </span><span class="cov8" title="1">{
                        // Nothing more to do for this page.
                        continue</span>
                }

                <span class="cov8" title="1">templ, found, err := p.resolveTemplate()
                if err != nil </span><span class="cov8" title="1">{
                        s.SendError(p.errorf(err, "failed to resolve template"))
                        continue</span>
                }

                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        s.logMissingLayout("", p.Layout(), p.Kind(), p.f.Name)
                        continue</span>
                }

                <span class="cov8" title="1">targetPath := p.targetPaths().TargetFilename

                if err := s.renderAndWritePage(&amp;s.PathSpec.ProcessingStats.Pages, "page "+p.Title(), targetPath, p, templ); err != nil </span><span class="cov8" title="1">{
                        results &lt;- err
                }</span>

                <span class="cov8" title="1">if p.paginator != nil &amp;&amp; p.paginator.current != nil </span><span class="cov8" title="1">{
                        if err := s.renderPaginator(p, templ); err != nil </span><span class="cov0" title="0">{
                                results &lt;- err
                        }</span>
                }
        }
}

func (s *Site) logMissingLayout(name, layout, kind, outputFormat string) <span class="cov8" title="1">{
        log := s.Log.Warn()
        if name != "" &amp;&amp; infoOnMissingLayout[name] </span><span class="cov0" title="0">{
                log = s.Log.Info()
        }</span>

        <span class="cov8" title="1">errMsg := "You should create a template file which matches Hugo Layouts Lookup Rules for this combination."
        var args []interface{}
        msg := "found no layout file for"
        if outputFormat != "" </span><span class="cov8" title="1">{
                msg += " %q"
                args = append(args, outputFormat)
        }</span>

        <span class="cov8" title="1">if layout != "" </span><span class="cov0" title="0">{
                msg += " for layout %q"
                args = append(args, layout)
        }</span>

        <span class="cov8" title="1">if kind != "" </span><span class="cov8" title="1">{
                msg += " for kind %q"
                args = append(args, kind)
        }</span>

        <span class="cov8" title="1">if name != "" </span><span class="cov0" title="0">{
                msg += " for %q"
                args = append(args, name)
        }</span>

        <span class="cov8" title="1">msg += ": " + errMsg

        log.Printf(msg, args...)</span>
}

// renderPaginator must be run after the owning Page has been rendered.
func (s *Site) renderPaginator(p *pageState, templ tpl.Template) error <span class="cov8" title="1">{
        paginatePath := s.Cfg.GetString("paginatePath")

        d := p.targetPathDescriptor
        f := p.s.rc.Format
        d.Type = f

        if p.paginator.current == nil || p.paginator.current != p.paginator.current.First() </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("invalid paginator state for %q", p.pathOrTitle()))</span>
        }

        <span class="cov8" title="1">if f.IsHTML </span><span class="cov8" title="1">{
                // Write alias for page 1
                d.Addends = fmt.Sprintf("/%s/%d", paginatePath, 1)
                targetPaths := page.CreateTargetPaths(d)

                if err := s.writeDestAlias(targetPaths.TargetFilename, p.Permalink(), f, nil); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        // Render pages for the rest
        <span class="cov8" title="1">for current := p.paginator.current.Next(); current != nil; current = current.Next() </span><span class="cov8" title="1">{

                p.paginator.current = current
                d.Addends = fmt.Sprintf("/%s/%d", paginatePath, current.PageNumber())
                targetPaths := page.CreateTargetPaths(d)

                if err := s.renderAndWritePage(
                        &amp;s.PathSpec.ProcessingStats.PaginatorPages,
                        p.Title(),
                        targetPaths.TargetFilename, p, templ); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

        }

        <span class="cov8" title="1">return nil</span>
}

func (s *Site) render404() error <span class="cov8" title="1">{
        p, err := newPageStandalone(&amp;pageMeta{
                s:    s,
                kind: kind404,
                urlPaths: pagemeta.URLPath{
                        URL: "404.html",
                },
        },
                output.HTMLFormat,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !p.render </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">var d output.LayoutDescriptor
        d.Kind = kind404

        templ, found, err := s.Tmpl().LookupLayout(d, output.HTMLFormat)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">targetPath := p.targetPaths().TargetFilename

        if targetPath == "" </span><span class="cov0" title="0">{
                return errors.New("failed to create targetPath for 404 page")
        }</span>

        <span class="cov8" title="1">return s.renderAndWritePage(&amp;s.PathSpec.ProcessingStats.Pages, "404 page", targetPath, p, templ)</span>
}

func (s *Site) renderSitemap() error <span class="cov8" title="1">{
        p, err := newPageStandalone(&amp;pageMeta{
                s:    s,
                kind: kindSitemap,
                urlPaths: pagemeta.URLPath{
                        URL: s.siteCfg.sitemap.Filename,
                },
        },
                output.HTMLFormat,
        )
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !p.render </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">targetPath := p.targetPaths().TargetFilename

        if targetPath == "" </span><span class="cov0" title="0">{
                return errors.New("failed to create targetPath for sitemap")
        }</span>

        <span class="cov8" title="1">templ := s.lookupLayouts("sitemap.xml", "_default/sitemap.xml", "_internal/_default/sitemap.xml")

        return s.renderAndWriteXML(&amp;s.PathSpec.ProcessingStats.Sitemaps, "sitemap", targetPath, p, templ)</span>
}

func (s *Site) renderRobotsTXT() error <span class="cov8" title="1">{
        if !s.Cfg.GetBool("enableRobotsTXT") </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">p, err := newPageStandalone(&amp;pageMeta{
                s:    s,
                kind: kindRobotsTXT,
                urlPaths: pagemeta.URLPath{
                        URL: "robots.txt",
                },
        },
                output.RobotsTxtFormat)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if !p.render </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">templ := s.lookupLayouts("robots.txt", "_default/robots.txt", "_internal/_default/robots.txt")

        return s.renderAndWritePage(&amp;s.PathSpec.ProcessingStats.Pages, "Robots Txt", p.targetPaths().TargetFilename, p, templ)</span>
}

// renderAliases renders shell pages that simply have a redirect in the header.
func (s *Site) renderAliases() error <span class="cov8" title="1">{
        var err error
        s.pageMap.pageTrees.WalkLinkable(func(ss string, n *contentNode) bool </span><span class="cov8" title="1">{
                p := n.p
                if len(p.Aliases()) == 0 </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">pathSeen := make(map[string]bool)

                for _, of := range p.OutputFormats() </span><span class="cov8" title="1">{
                        if !of.Format.IsHTML </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">f := of.Format

                        if pathSeen[f.Path] </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">pathSeen[f.Path] = true

                        plink := of.Permalink()

                        for _, a := range p.Aliases() </span><span class="cov8" title="1">{
                                isRelative := !strings.HasPrefix(a, "/")

                                if isRelative </span><span class="cov8" title="1">{
                                        // Make alias relative, where "." will be on the
                                        // same directory level as the current page.
                                        basePath := path.Join(p.targetPaths().SubResourceBaseLink, "..")
                                        a = path.Join(basePath, a)

                                }</span> else<span class="cov8" title="1"> {
                                        // Make sure AMP and similar doesn't clash with regular aliases.
                                        a = path.Join(f.Path, a)
                                }</span>

                                <span class="cov8" title="1">if s.UglyURLs &amp;&amp; !strings.HasSuffix(a, ".html") </span><span class="cov8" title="1">{
                                        a += ".html"
                                }</span>

                                <span class="cov8" title="1">lang := p.Language().Lang

                                if s.h.multihost &amp;&amp; !strings.HasPrefix(a, "/"+lang) </span><span class="cov8" title="1">{
                                        // These need to be in its language root.
                                        a = path.Join(lang, a)
                                }</span>

                                <span class="cov8" title="1">err = s.writeDestAlias(a, plink, f, p)
                                if err != nil </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                }
                <span class="cov8" title="1">return false</span>
        })

        <span class="cov8" title="1">return err</span>
}

// renderMainLanguageRedirect creates a redirect to the main language home,
// depending on if it lives in sub folder (e.g. /en) or not.
func (s *Site) renderMainLanguageRedirect() error <span class="cov8" title="1">{
        if !s.h.multilingual.enabled() || s.h.IsMultihost() </span><span class="cov8" title="1">{
                // No need for a redirect
                return nil
        }</span>

        <span class="cov8" title="1">html, found := s.outputFormatsConfig.GetByName("HTML")
        if found </span><span class="cov8" title="1">{
                mainLang := s.h.multilingual.DefaultLang
                if s.Info.defaultContentLanguageInSubdir </span><span class="cov8" title="1">{
                        mainLangURL := s.PathSpec.AbsURL(mainLang.Lang+"/", false)
                        s.Log.Debugf("Write redirect to main language %s: %s", mainLang, mainLangURL)
                        if err := s.publishDestAlias(true, "/", mainLangURL, html, nil); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                } else<span class="cov8" title="1"> {
                        mainLangURL := s.PathSpec.AbsURL("", false)
                        s.Log.Debugf("Write redirect to main language %s: %s", mainLang, mainLangURL)
                        if err := s.publishDestAlias(true, mainLang.Lang, mainLangURL, html, nil); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file143" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/gohugoio/hugo/resources/page"
)

// Sections returns the top level sections.
func (s *SiteInfo) Sections() page.Pages <span class="cov8" title="1">{
        home, err := s.Home()
        if err == nil </span><span class="cov8" title="1">{
                return home.Sections()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Home is a shortcut to the home page, equivalent to .Site.GetPage "home".
func (s *SiteInfo) Home() (page.Page, error) <span class="cov8" title="1">{
        return s.s.home, nil
}</span>
</pre>
		
		<pre class="file" id="file144" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "fmt"
        "sort"

        "github.com/gohugoio/hugo/compare"

        "github.com/gohugoio/hugo/resources/page"
)

// The TaxonomyList is a list of all taxonomies and their values
// e.g. List['tags'] =&gt; TagTaxonomy (from above)
type TaxonomyList map[string]Taxonomy

func (tl TaxonomyList) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("TaxonomyList(%d)", len(tl))
}</span>

// A Taxonomy is a map of keywords to a list of pages.
// For example
//    TagTaxonomy['technology'] = page.WeightedPages
//    TagTaxonomy['go']  =  page.WeightedPages
type Taxonomy map[string]page.WeightedPages

// OrderedTaxonomy is another representation of an Taxonomy using an array rather than a map.
// Important because you can't order a map.
type OrderedTaxonomy []OrderedTaxonomyEntry

// OrderedTaxonomyEntry is similar to an element of a Taxonomy, but with the key embedded (as name)
// e.g:  {Name: Technology, page.WeightedPages: TaxonomyPages}
type OrderedTaxonomyEntry struct {
        Name string
        page.WeightedPages
}

// Get the weighted pages for the given key.
func (i Taxonomy) Get(key string) page.WeightedPages <span class="cov8" title="1">{
        return i[key]
}</span>

// Count the weighted pages for the given key.
func (i Taxonomy) Count(key string) int <span class="cov0" title="0">{ return len(i[key]) }</span>

func (i Taxonomy) add(key string, w page.WeightedPage) <span class="cov8" title="1">{
        i[key] = append(i[key], w)
}</span>

// TaxonomyArray returns an ordered taxonomy with a non defined order.
func (i Taxonomy) TaxonomyArray() OrderedTaxonomy <span class="cov8" title="1">{
        ies := make([]OrderedTaxonomyEntry, len(i))
        count := 0
        for k, v := range i </span><span class="cov8" title="1">{
                ies[count] = OrderedTaxonomyEntry{Name: k, WeightedPages: v}
                count++
        }</span>
        <span class="cov8" title="1">return ies</span>
}

// Alphabetical returns an ordered taxonomy sorted by key name.
func (i Taxonomy) Alphabetical() OrderedTaxonomy <span class="cov8" title="1">{
        name := func(i1, i2 *OrderedTaxonomyEntry) bool </span><span class="cov8" title="1">{
                return compare.LessStrings(i1.Name, i2.Name)
        }</span>

        <span class="cov8" title="1">ia := i.TaxonomyArray()
        oiBy(name).Sort(ia)
        return ia</span>
}

// ByCount returns an ordered taxonomy sorted by # of pages per key.
// If taxonomies have the same # of pages, sort them alphabetical
func (i Taxonomy) ByCount() OrderedTaxonomy <span class="cov8" title="1">{
        count := func(i1, i2 *OrderedTaxonomyEntry) bool </span><span class="cov8" title="1">{
                li1 := len(i1.WeightedPages)
                li2 := len(i2.WeightedPages)

                if li1 == li2 </span><span class="cov8" title="1">{
                        return compare.LessStrings(i1.Name, i2.Name)
                }</span>
                <span class="cov0" title="0">return li1 &gt; li2</span>
        }

        <span class="cov8" title="1">ia := i.TaxonomyArray()
        oiBy(count).Sort(ia)
        return ia</span>
}

// Pages returns the Pages for this taxonomy.
func (ie OrderedTaxonomyEntry) Pages() page.Pages <span class="cov0" title="0">{
        return ie.WeightedPages.Pages()
}</span>

// Count returns the count the pages in this taxonomy.
func (ie OrderedTaxonomyEntry) Count() int <span class="cov8" title="1">{
        return len(ie.WeightedPages)
}</span>

// Term returns the name given to this taxonomy.
func (ie OrderedTaxonomyEntry) Term() string <span class="cov0" title="0">{
        return ie.Name
}</span>

// Reverse reverses the order of the entries in this taxonomy.
func (t OrderedTaxonomy) Reverse() OrderedTaxonomy <span class="cov0" title="0">{
        for i, j := 0, len(t)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                t[i], t[j] = t[j], t[i]
        }</span>

        <span class="cov0" title="0">return t</span>
}

// A type to implement the sort interface for TaxonomyEntries.
type orderedTaxonomySorter struct {
        taxonomy OrderedTaxonomy
        by       oiBy
}

// Closure used in the Sort.Less method.
type oiBy func(i1, i2 *OrderedTaxonomyEntry) bool

func (by oiBy) Sort(taxonomy OrderedTaxonomy) <span class="cov8" title="1">{
        ps := &amp;orderedTaxonomySorter{
                taxonomy: taxonomy,
                by:       by, // The Sort method's receiver is the function (closure) that defines the sort order.
        }
        sort.Stable(ps)
}</span>

// Len is part of sort.Interface.
func (s *orderedTaxonomySorter) Len() int <span class="cov8" title="1">{
        return len(s.taxonomy)
}</span>

// Swap is part of sort.Interface.
func (s *orderedTaxonomySorter) Swap(i, j int) <span class="cov8" title="1">{
        s.taxonomy[i], s.taxonomy[j] = s.taxonomy[j], s.taxonomy[i]
}</span>

// Less is part of sort.Interface. It is implemented by calling the "by" closure in the sorter.
func (s *orderedTaxonomySorter) Less(i, j int) bool <span class="cov8" title="1">{
        return s.by(&amp;s.taxonomy[i], &amp;s.taxonomy[j])
}</span>
</pre>
		
		<pre class="file" id="file145" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package hugolib

import (
        "github.com/gohugoio/hugo/resources/page"
)

func pagesToTranslationsMap(sites []*Site) map[string]page.Pages <span class="cov8" title="1">{
        out := make(map[string]page.Pages)

        for _, s := range sites </span><span class="cov8" title="1">{
                s.pageMap.pageTrees.Walk(func(ss string, n *contentNode) bool </span><span class="cov8" title="1">{
                        p := n.p
                        // TranslationKey is implemented for all page types.
                        base := p.TranslationKey()

                        pageTranslations, found := out[base]
                        if !found </span><span class="cov8" title="1">{
                                pageTranslations = make(page.Pages, 0)
                        }</span>

                        <span class="cov8" title="1">pageTranslations = append(pageTranslations, p)
                        out[base] = pageTranslations

                        return false</span>
                })
        }

        <span class="cov8" title="1">return out</span>
}

func assignTranslationsToPages(allTranslations map[string]page.Pages, sites []*Site) <span class="cov8" title="1">{
        for _, s := range sites </span><span class="cov8" title="1">{
                s.pageMap.pageTrees.Walk(func(ss string, n *contentNode) bool </span><span class="cov8" title="1">{
                        p := n.p
                        base := p.TranslationKey()
                        translations, found := allTranslations[base]
                        if !found </span><span class="cov0" title="0">{
                                return false
                        }</span>
                        <span class="cov8" title="1">p.setTranslations(translations)
                        return false</span>
                })
        }
}
</pre>
		
		<pre class="file" id="file146" style="display: none">package identity

import (
        "path/filepath"
        "strings"
        "sync"
        "sync/atomic"
)

// NewIdentityManager creates a new Manager starting at id.
func NewManager(id Provider) Manager <span class="cov8" title="1">{
        return &amp;identityManager{
                Provider: id,
                ids:      Identities{id.GetIdentity(): id},
        }
}</span>

// NewPathIdentity creates a new Identity with the two identifiers
// type and path.
func NewPathIdentity(typ, pat string) PathIdentity <span class="cov0" title="0">{
        pat = strings.ToLower(strings.TrimPrefix(filepath.ToSlash(pat), "/"))
        return PathIdentity{Type: typ, Path: pat}
}</span>

// Identities stores identity providers.
type Identities map[Identity]Provider

func (ids Identities) search(depth int, id Identity) Provider <span class="cov8" title="1">{
        if v, found := ids[id.GetIdentity()]; found </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">depth++

        // There may be infinite recursion in templates.
        if depth &gt; 100 </span><span class="cov0" title="0">{
                // Bail out.
                return nil
        }</span>

        <span class="cov8" title="1">for _, v := range ids </span><span class="cov8" title="1">{
                switch t := v.(type) </span>{
                case IdentitiesProvider:<span class="cov0" title="0">
                        if nested := t.GetIdentities().search(depth, id); nested != nil </span><span class="cov0" title="0">{
                                return nested
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

// IdentitiesProvider provides all Identities.
type IdentitiesProvider interface {
        GetIdentities() Identities
}

// Identity represents an thing that can provide an identify. This can be
// any Go type, but the Identity returned by GetIdentify must be hashable.
type Identity interface {
        Provider
        Name() string
}

// Manager manages identities, and is itself a Provider of Identity.
type Manager interface {
        SearchProvider
        Add(ids ...Provider)
        Reset()
}

// SearchProvider provides access to the chained set of identities.
type SearchProvider interface {
        Provider
        IdentitiesProvider
        Search(id Identity) Provider
}

// A PathIdentity is a common identity identified by a type and a path, e.g. "layouts" and "_default/single.html".
type PathIdentity struct {
        Type string
        Path string
}

// GetIdentity returns itself.
func (id PathIdentity) GetIdentity() Identity <span class="cov0" title="0">{
        return id
}</span>

// Name returns the Path.
func (id PathIdentity) Name() string <span class="cov0" title="0">{
        return id.Path
}</span>

// A KeyValueIdentity a general purpose identity.
type KeyValueIdentity struct {
        Key   string
        Value string
}

// GetIdentity returns itself.
func (id KeyValueIdentity) GetIdentity() Identity <span class="cov0" title="0">{
        return id
}</span>

// Name returns the Key.
func (id KeyValueIdentity) Name() string <span class="cov0" title="0">{
        return id.Key
}</span>

// Provider provides the hashable Identity.
type Provider interface {
        GetIdentity() Identity
}

type identityManager struct {
        sync.Mutex
        Provider
        ids Identities
}

func (im *identityManager) Add(ids ...Provider) <span class="cov0" title="0">{
        im.Lock()
        for _, id := range ids </span><span class="cov0" title="0">{
                im.ids[id.GetIdentity()] = id
        }</span>
        <span class="cov0" title="0">im.Unlock()</span>
}

func (im *identityManager) Reset() <span class="cov0" title="0">{
        im.Lock()
        id := im.GetIdentity()
        im.ids = Identities{id.GetIdentity(): id}
        im.Unlock()
}</span>

// TODO(bep) these identities are currently only read on server reloads
// so there should be no concurrency issues, but that may change.
func (im *identityManager) GetIdentities() Identities <span class="cov0" title="0">{
        im.Lock()
        defer im.Unlock()
        return im.ids
}</span>

func (im *identityManager) Search(id Identity) Provider <span class="cov8" title="1">{
        im.Lock()
        defer im.Unlock()
        return im.ids.search(0, id.GetIdentity())
}</span>

// Incrementer increments and returns the value.
// Typically used for IDs.
type Incrementer interface {
        Incr() int
}

// IncrementByOne implements Incrementer adding 1 every time Incr is called.
type IncrementByOne struct {
        counter uint64
}

func (c *IncrementByOne) Incr() int <span class="cov0" title="0">{
        return int(atomic.AddUint64(&amp;c.counter, uint64(1)))
}</span>
</pre>
		
		<pre class="file" id="file147" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package langs

import (
        "fmt"
        "path/filepath"
        "sort"
        "strings"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/spf13/cast"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/config"
)

type LanguagesConfig struct {
        Languages                      Languages
        Multihost                      bool
        DefaultContentLanguageInSubdir bool
}

func LoadLanguageSettings(cfg config.Provider, oldLangs Languages) (c LanguagesConfig, err error) <span class="cov0" title="0">{
        defaultLang := strings.ToLower(cfg.GetString("defaultContentLanguage"))
        if defaultLang == "" </span><span class="cov0" title="0">{
                defaultLang = "en"
                cfg.Set("defaultContentLanguage", defaultLang)
        }</span>

        <span class="cov0" title="0">var languages map[string]interface{}

        languagesFromConfig := cfg.GetParams("languages")
        disableLanguages := cfg.GetStringSlice("disableLanguages")

        if len(disableLanguages) == 0 </span><span class="cov0" title="0">{
                languages = languagesFromConfig
        }</span> else<span class="cov0" title="0"> {
                languages = make(maps.Params)
                for k, v := range languagesFromConfig </span><span class="cov0" title="0">{
                        for _, disabled := range disableLanguages </span><span class="cov0" title="0">{
                                if disabled == defaultLang </span><span class="cov0" title="0">{
                                        return c, fmt.Errorf("cannot disable default language %q", defaultLang)
                                }</span>

                                <span class="cov0" title="0">if strings.EqualFold(k, disabled) </span><span class="cov0" title="0">{
                                        v.(maps.Params)["disabled"] = true
                                        break</span>
                                }
                        }
                        <span class="cov0" title="0">languages[k] = v</span>
                }
        }

        <span class="cov0" title="0">var languages2 Languages

        if len(languages) == 0 </span><span class="cov0" title="0">{
                languages2 = append(languages2, NewDefaultLanguage(cfg))
        }</span> else<span class="cov0" title="0"> {
                languages2, err = toSortedLanguages(cfg, languages)
                if err != nil </span><span class="cov0" title="0">{
                        return c, errors.Wrap(err, "Failed to parse multilingual config")
                }</span>
        }

        <span class="cov0" title="0">if oldLangs != nil </span><span class="cov0" title="0">{
                // When in multihost mode, the languages are mapped to a server, so
                // some structural language changes will need a restart of the dev server.
                // The validation below isn't complete, but should cover the most
                // important cases.
                var invalid bool
                if languages2.IsMultihost() != oldLangs.IsMultihost() </span><span class="cov0" title="0">{
                        invalid = true
                }</span> else<span class="cov0" title="0"> {
                        if languages2.IsMultihost() &amp;&amp; len(languages2) != len(oldLangs) </span><span class="cov0" title="0">{
                                invalid = true
                        }</span>
                }

                <span class="cov0" title="0">if invalid </span><span class="cov0" title="0">{
                        return c, errors.New("language change needing a server restart detected")
                }</span>

                <span class="cov0" title="0">if languages2.IsMultihost() </span><span class="cov0" title="0">{
                        // We need to transfer any server baseURL to the new language
                        for i, ol := range oldLangs </span><span class="cov0" title="0">{
                                nl := languages2[i]
                                nl.Set("baseURL", ol.GetString("baseURL"))
                        }</span>
                }
        }

        // The defaultContentLanguage is something the user has to decide, but it needs
        // to match a language in the language definition list.
        <span class="cov0" title="0">langExists := false
        for _, lang := range languages2 </span><span class="cov0" title="0">{
                if lang.Lang == defaultLang </span><span class="cov0" title="0">{
                        langExists = true
                        break</span>
                }
        }

        <span class="cov0" title="0">if !langExists </span><span class="cov0" title="0">{
                return c, fmt.Errorf("site config value %q for defaultContentLanguage does not match any language definition", defaultLang)
        }</span>

        <span class="cov0" title="0">c.Languages = languages2
        c.Multihost = languages2.IsMultihost()
        c.DefaultContentLanguageInSubdir = c.Multihost

        sortedDefaultFirst := make(Languages, len(c.Languages))
        for i, v := range c.Languages </span><span class="cov0" title="0">{
                sortedDefaultFirst[i] = v
        }</span>
        <span class="cov0" title="0">sort.Slice(sortedDefaultFirst, func(i, j int) bool </span><span class="cov0" title="0">{
                li, lj := sortedDefaultFirst[i], sortedDefaultFirst[j]
                if li.Lang == defaultLang </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">if lj.Lang == defaultLang </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">return i &lt; j</span>
        })

        <span class="cov0" title="0">cfg.Set("languagesSorted", c.Languages)
        cfg.Set("languagesSortedDefaultFirst", sortedDefaultFirst)
        cfg.Set("multilingual", len(languages2) &gt; 1)

        multihost := c.Multihost

        if multihost </span><span class="cov0" title="0">{
                cfg.Set("defaultContentLanguageInSubdir", true)
                cfg.Set("multihost", true)
        }</span>

        <span class="cov0" title="0">if multihost </span><span class="cov0" title="0">{
                // The baseURL may be provided at the language level. If that is true,
                // then every language must have a baseURL. In this case we always render
                // to a language sub folder, which is then stripped from all the Permalink URLs etc.
                for _, l := range languages2 </span><span class="cov0" title="0">{
                        burl := l.GetLocal("baseURL")
                        if burl == nil </span><span class="cov0" title="0">{
                                return c, errors.New("baseURL must be set on all or none of the languages")
                        }</span>
                }
        }

        <span class="cov0" title="0">for _, language := range c.Languages </span><span class="cov0" title="0">{
                if language.initErr != nil </span><span class="cov0" title="0">{
                        return c, language.initErr
                }</span>
        }

        <span class="cov0" title="0">return c, nil</span>
}

func toSortedLanguages(cfg config.Provider, l map[string]interface{}) (Languages, error) <span class="cov0" title="0">{
        languages := make(Languages, len(l))
        i := 0

        for lang, langConf := range l </span><span class="cov0" title="0">{
                langsMap, err := maps.ToStringMapE(langConf)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("Language config is not a map: %T", langConf)
                }</span>

                <span class="cov0" title="0">language := NewLanguage(lang, cfg)

                for loki, v := range langsMap </span><span class="cov0" title="0">{
                        switch loki </span>{
                        case "title":<span class="cov0" title="0">
                                language.Title = cast.ToString(v)</span>
                        case "languagename":<span class="cov0" title="0">
                                language.LanguageName = cast.ToString(v)</span>
                        case "languagedirection":<span class="cov0" title="0">
                                language.LanguageDirection = cast.ToString(v)</span>
                        case "weight":<span class="cov0" title="0">
                                language.Weight = cast.ToInt(v)</span>
                        case "contentdir":<span class="cov0" title="0">
                                language.ContentDir = filepath.Clean(cast.ToString(v))</span>
                        case "disabled":<span class="cov0" title="0">
                                language.Disabled = cast.ToBool(v)</span>
                        case "params":<span class="cov0" title="0">
                                m := maps.ToStringMap(v)
                                // Needed for case insensitive fetching of params values
                                maps.PrepareParams(m)
                                for k, vv := range m </span><span class="cov0" title="0">{
                                        language.SetParam(k, vv)
                                }</span>
                        case "timezone":<span class="cov0" title="0">
                                if err := language.loadLocation(cast.ToString(v)); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                        }

                        // Put all into the Params map
                        <span class="cov0" title="0">language.SetParam(loki, v)

                        // Also set it in the configuration map (for baseURL etc.)
                        language.Set(loki, v)</span>
                }

                <span class="cov0" title="0">languages[i] = language
                i++</span>
        }

        <span class="cov0" title="0">sort.Sort(languages)

        return languages, nil</span>
}
</pre>
		
		<pre class="file" id="file148" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package i18n

import (
        "fmt"
        "reflect"
        "strings"

        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/common/hreflect"
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/go-i18n/v2/i18n"
)

type translateFunc func(translationID string, templateData interface{}) string

var i18nWarningLogger = helpers.NewDistinctErrorLogger()

// Translator handles i18n translations.
type Translator struct {
        translateFuncs map[string]translateFunc
        cfg            config.Provider
        logger         loggers.Logger
}

// NewTranslator creates a new Translator for the given language bundle and configuration.
func NewTranslator(b *i18n.Bundle, cfg config.Provider, logger loggers.Logger) Translator <span class="cov8" title="1">{
        t := Translator{cfg: cfg, logger: logger, translateFuncs: make(map[string]translateFunc)}
        t.initFuncs(b)
        return t
}</span>

// Func gets the translate func for the given language, or for the default
// configured language if not found.
func (t Translator) Func(lang string) translateFunc <span class="cov8" title="1">{
        if f, ok := t.translateFuncs[lang]; ok </span><span class="cov8" title="1">{
                return f
        }</span>
        <span class="cov8" title="1">t.logger.Infof("Translation func for language %v not found, use default.", lang)
        if f, ok := t.translateFuncs[t.cfg.GetString("defaultContentLanguage")]; ok </span><span class="cov8" title="1">{
                return f
        }</span>

        <span class="cov0" title="0">t.logger.Infoln("i18n not initialized; if you need string translations, check that you have a bundle in /i18n that matches the site language or the default language.")
        return func(translationID string, args interface{}) string </span><span class="cov0" title="0">{
                return ""
        }</span>
}

func (t Translator) initFuncs(bndl *i18n.Bundle) <span class="cov8" title="1">{
        enableMissingTranslationPlaceholders := t.cfg.GetBool("enableMissingTranslationPlaceholders")
        for _, lang := range bndl.LanguageTags() </span><span class="cov8" title="1">{
                currentLang := lang
                currentLangStr := currentLang.String()
                // This may be pt-BR; make it case insensitive.
                currentLangKey := strings.ToLower(strings.TrimPrefix(currentLangStr, artificialLangTagPrefix))
                localizer := i18n.NewLocalizer(bndl, currentLangStr)
                t.translateFuncs[currentLangKey] = func(translationID string, templateData interface{}) string </span><span class="cov8" title="1">{
                        pluralCount := getPluralCount(templateData)

                        if templateData != nil </span><span class="cov8" title="1">{
                                tp := reflect.TypeOf(templateData)
                                if hreflect.IsInt(tp.Kind()) </span><span class="cov8" title="1">{
                                        // This was how go-i18n worked in v1,
                                        // and we keep it like this to avoid breaking
                                        // lots of sites in the wild.
                                        templateData = intCount(cast.ToInt(templateData))
                                }</span>
                        }

                        <span class="cov8" title="1">translated, translatedLang, err := localizer.LocalizeWithTag(&amp;i18n.LocalizeConfig{
                                MessageID:    translationID,
                                TemplateData: templateData,
                                PluralCount:  pluralCount,
                        })

                        sameLang := currentLang == translatedLang

                        if err == nil &amp;&amp; sameLang </span><span class="cov8" title="1">{
                                return translated
                        }</span>

                        <span class="cov8" title="1">if err != nil &amp;&amp; sameLang &amp;&amp; translated != "" </span><span class="cov8" title="1">{
                                // See #8492
                                // TODO(bep) this needs to be improved/fixed upstream,
                                // but currently we get an error even if the fallback to
                                // "other" succeeds.
                                if fmt.Sprintf("%T", err) == "i18n.pluralFormNotFoundError" </span><span class="cov8" title="1">{
                                        return translated
                                }</span>
                        }

                        <span class="cov8" title="1">if _, ok := err.(*i18n.MessageNotFoundErr); !ok </span><span class="cov0" title="0">{
                                t.logger.Warnf("Failed to get translated string for language %q and ID %q: %s", currentLangStr, translationID, err)
                        }</span>

                        <span class="cov8" title="1">if t.cfg.GetBool("logI18nWarnings") </span><span class="cov0" title="0">{
                                i18nWarningLogger.Printf("i18n|MISSING_TRANSLATION|%s|%s", currentLangStr, translationID)
                        }</span>

                        <span class="cov8" title="1">if enableMissingTranslationPlaceholders </span><span class="cov8" title="1">{
                                return "[i18n] " + translationID
                        }</span>

                        <span class="cov8" title="1">return translated</span>
                }
        }
}

// intCount wraps the Count method.
type intCount int

func (c intCount) Count() int <span class="cov8" title="1">{
        return int(c)
}</span>

const countFieldName = "Count"

// getPluralCount gets the plural count as a string (floats) or an integer.
// If v is nil, nil is returned.
func getPluralCount(v interface{}) interface{} <span class="cov8" title="1">{
        if v == nil </span><span class="cov8" title="1">{
                // i18n called without any argument, make sure it does not
                // get any plural count.
                return nil
        }</span>

        <span class="cov8" title="1">switch v := v.(type) </span>{
        case map[string]interface{}:<span class="cov8" title="1">
                for k, vv := range v </span><span class="cov8" title="1">{
                        if strings.EqualFold(k, countFieldName) </span><span class="cov8" title="1">{
                                return toPluralCountValue(vv)
                        }</span>
                }
        default:<span class="cov8" title="1">
                vv := reflect.Indirect(reflect.ValueOf(v))
                if vv.Kind() == reflect.Interface &amp;&amp; !vv.IsNil() </span><span class="cov0" title="0">{
                        vv = vv.Elem()
                }</span>
                <span class="cov8" title="1">tp := vv.Type()

                if tp.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                        f := vv.FieldByName(countFieldName)
                        if f.IsValid() </span><span class="cov8" title="1">{
                                return toPluralCountValue(f.Interface())
                        }</span>
                        <span class="cov8" title="1">m := vv.MethodByName(countFieldName)
                        if m.IsValid() &amp;&amp; m.Type().NumIn() == 0 &amp;&amp; m.Type().NumOut() == 1 </span><span class="cov8" title="1">{
                                c := m.Call(nil)
                                return toPluralCountValue(c[0].Interface())
                        }</span>
                }
        }

        <span class="cov8" title="1">return toPluralCountValue(v)</span>

}

// go-i18n expects floats to be represented by string.
func toPluralCountValue(in interface{}) interface{} <span class="cov8" title="1">{
        k := reflect.TypeOf(in).Kind()
        switch </span>{
        case hreflect.IsFloat(k):<span class="cov8" title="1">
                f := cast.ToString(in)
                if !strings.Contains(f, ".") </span><span class="cov8" title="1">{
                        f += ".0"
                }</span>
                <span class="cov8" title="1">return f</span>
        case k == reflect.String:<span class="cov8" title="1">
                if _, err := cast.ToFloat64E(in); err == nil </span><span class="cov8" title="1">{
                        return in
                }</span>
                // A non-numeric value.
                <span class="cov8" title="1">return nil</span>
        default:<span class="cov8" title="1">
                if i, err := cast.ToIntE(in); err == nil </span><span class="cov8" title="1">{
                        return i
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file149" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package i18n

import (
        "encoding/json"
        "strings"

        "github.com/gohugoio/hugo/common/paths"

        "github.com/gohugoio/hugo/common/herrors"
        "golang.org/x/text/language"
        yaml "gopkg.in/yaml.v2"

        "github.com/gohugoio/go-i18n/v2/i18n"
        "github.com/gohugoio/hugo/helpers"
        toml "github.com/pelletier/go-toml/v2"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/source"
        _errors "github.com/pkg/errors"
)

// TranslationProvider provides translation handling, i.e. loading
// of bundles etc.
type TranslationProvider struct {
        t Translator
}

// NewTranslationProvider creates a new translation provider.
func NewTranslationProvider() *TranslationProvider <span class="cov8" title="1">{
        return &amp;TranslationProvider{}
}</span>

// Update updates the i18n func in the provided Deps.
func (tp *TranslationProvider) Update(d *deps.Deps) error <span class="cov8" title="1">{
        spec := source.NewSourceSpec(d.PathSpec, nil, nil)

        bundle := i18n.NewBundle(language.English)
        bundle.RegisterUnmarshalFunc("toml", toml.Unmarshal)
        bundle.RegisterUnmarshalFunc("yaml", yaml.Unmarshal)
        bundle.RegisterUnmarshalFunc("yml", yaml.Unmarshal)
        bundle.RegisterUnmarshalFunc("json", json.Unmarshal)

        // The source dirs are ordered so the most important comes first. Since this is a
        // last key win situation, we have to reverse the iteration order.
        dirs := d.BaseFs.I18n.Dirs
        for i := len(dirs) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                dir := dirs[i]
                src := spec.NewFilesystemFromFileMetaInfo(dir)
                files, err := src.Files()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">for _, file := range files </span><span class="cov8" title="1">{
                        if err := addTranslationFile(bundle, file); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">tp.t = NewTranslator(bundle, d.Cfg, d.Log)

        d.Translate = tp.t.Func(d.Language.Lang)

        return nil</span>
}

const artificialLangTagPrefix = "art-x-"

func addTranslationFile(bundle *i18n.Bundle, r source.File) error <span class="cov8" title="1">{
        f, err := r.FileInfo().Meta().Open()
        if err != nil </span><span class="cov0" title="0">{
                return _errors.Wrapf(err, "failed to open translations file %q:", r.LogicalName())
        }</span>

        <span class="cov8" title="1">b := helpers.ReaderToBytes(f)
        f.Close()

        name := r.LogicalName()
        lang := paths.Filename(name)
        tag := language.Make(lang)
        if tag == language.Und </span><span class="cov8" title="1">{
                try := artificialLangTagPrefix + lang
                _, err = language.Parse(try)
                if err != nil </span><span class="cov0" title="0">{
                        return _errors.Errorf("%q %s.", try, err)
                }</span>
                <span class="cov8" title="1">name = artificialLangTagPrefix + name</span>
        }

        <span class="cov8" title="1">_, err = bundle.ParseMessageFileBytes(b, name)
        if err != nil </span><span class="cov8" title="1">{
                if strings.Contains(err.Error(), "no plural rule") </span><span class="cov8" title="1">{
                        // https://github.com/gohugoio/hugo/issues/7798
                        name = artificialLangTagPrefix + name
                        _, err = bundle.ParseMessageFileBytes(b, name)
                        if err == nil </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                }
                <span class="cov0" title="0">return errWithFileContext(_errors.Wrapf(err, "failed to load translations"), r)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Clone sets the language func for the new language.
func (tp *TranslationProvider) Clone(d *deps.Deps) error <span class="cov0" title="0">{
        d.Translate = tp.t.Func(d.Language.Lang)

        return nil
}</span>

func errWithFileContext(inerr error, r source.File) error <span class="cov0" title="0">{
        fim, ok := r.FileInfo().(hugofs.FileMetaInfo)
        if !ok </span><span class="cov0" title="0">{
                return inerr
        }</span>

        <span class="cov0" title="0">meta := fim.Meta()
        realFilename := meta.Filename
        f, err := meta.Open()
        if err != nil </span><span class="cov0" title="0">{
                return inerr
        }</span>
        <span class="cov0" title="0">defer f.Close()

        err, _ = herrors.WithFileContext(
                inerr,
                realFilename,
                f,
                herrors.SimpleLineMatcher)

        return err</span>
}
</pre>
		
		<pre class="file" id="file150" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package langs

import (
        "sort"
        "strings"
        "sync"
        "time"

        "github.com/pkg/errors"

        translators "github.com/gohugoio/localescompressed"
        "github.com/gohugoio/locales"
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/config"
)

// These are the settings that should only be looked up in the global Viper
// config and not per language.
// This list may not be complete, but contains only settings that we know
// will be looked up in both.
// This isn't perfect, but it is ultimately the user who shoots him/herself in
// the foot.
// See the pathSpec.
var globalOnlySettings = map[string]bool{
        strings.ToLower("defaultContentLanguageInSubdir"): true,
        strings.ToLower("defaultContentLanguage"):         true,
        strings.ToLower("multilingual"):                   true,
        strings.ToLower("assetDir"):                       true,
        strings.ToLower("resourceDir"):                    true,
        strings.ToLower("build"):                          true,
}

// Language manages specific-language configuration.
type Language struct {
        Lang              string
        LanguageName      string
        LanguageDirection string
        Title             string
        Weight            int

        Disabled bool

        // If set per language, this tells Hugo that all content files without any
        // language indicator (e.g. my-page.en.md) is in this language.
        // This is usually a path relative to the working dir, but it can be an
        // absolute directory reference. It is what we get.
        ContentDir string

        // Global config.
        Cfg config.Provider

        // Language specific config.
        LocalCfg config.Provider

        // Composite config.
        config.Provider

        // These are params declared in the [params] section of the language merged with the
        // site's params, the most specific (language) wins on duplicate keys.
        params    map[string]interface{}
        paramsMu  sync.Mutex
        paramsSet bool

        // Used for date formatting etc. We don't want these exported to the
        // templates.
        // TODO(bep) do the same for some of the others.
        translator locales.Translator

        location *time.Location

        // Error during initialization. Will fail the buld.
        initErr error
}

func (l *Language) String() string <span class="cov0" title="0">{
        return l.Lang
}</span>

// NewLanguage creates a new language.
func NewLanguage(lang string, cfg config.Provider) *Language <span class="cov8" title="1">{
        // Note that language specific params will be overridden later.
        // We should improve that, but we need to make a copy:
        params := make(map[string]interface{})
        for k, v := range cfg.GetStringMap("params") </span><span class="cov0" title="0">{
                params[k] = v
        }</span>
        <span class="cov8" title="1">maps.PrepareParams(params)

        localCfg := config.New()
        compositeConfig := config.NewCompositeConfig(cfg, localCfg)
        translator := translators.GetTranslator(lang)
        if translator == nil </span><span class="cov0" title="0">{
                translator = translators.GetTranslator(cfg.GetString("defaultContentLanguage"))
                if translator == nil </span><span class="cov0" title="0">{
                        translator = translators.GetTranslator("en")
                }</span>
        }

        <span class="cov8" title="1">l := &amp;Language{
                Lang:       lang,
                ContentDir: cfg.GetString("contentDir"),
                Cfg:        cfg, LocalCfg: localCfg,
                Provider:   compositeConfig,
                params:     params,
                translator: translator,
        }

        if err := l.loadLocation(cfg.GetString("timeZone")); err != nil </span><span class="cov0" title="0">{
                l.initErr = err
        }</span>

        <span class="cov8" title="1">return l</span>
}

// NewDefaultLanguage creates the default language for a config.Provider.
// If not otherwise specified the default is "en".
func NewDefaultLanguage(cfg config.Provider) *Language <span class="cov8" title="1">{
        defaultLang := cfg.GetString("defaultContentLanguage")

        if defaultLang == "" </span><span class="cov8" title="1">{
                defaultLang = "en"
        }</span>

        <span class="cov8" title="1">return NewLanguage(defaultLang, cfg)</span>
}

// Languages is a sortable list of languages.
type Languages []*Language

// NewLanguages creates a sorted list of languages.
// NOTE: function is currently unused.
func NewLanguages(l ...*Language) Languages <span class="cov0" title="0">{
        languages := make(Languages, len(l))
        for i := 0; i &lt; len(l); i++ </span><span class="cov0" title="0">{
                languages[i] = l[i]
        }</span>
        <span class="cov0" title="0">sort.Sort(languages)
        return languages</span>
}

func (l Languages) Len() int <span class="cov0" title="0">{ return len(l) }</span>
func (l Languages) Less(i, j int) bool <span class="cov0" title="0">{
        wi, wj := l[i].Weight, l[j].Weight

        if wi == wj </span><span class="cov0" title="0">{
                return l[i].Lang &lt; l[j].Lang
        }</span>

        <span class="cov0" title="0">return wj == 0 || wi &lt; wj</span>
}

func (l Languages) Swap(i, j int) <span class="cov0" title="0">{ l[i], l[j] = l[j], l[i] }</span>

// Params returns language-specific params merged with the global params.
func (l *Language) Params() maps.Params <span class="cov8" title="1">{
        // TODO(bep) this construct should not be needed. Create the
        // language params in one go.
        l.paramsMu.Lock()
        defer l.paramsMu.Unlock()
        if !l.paramsSet </span><span class="cov8" title="1">{
                maps.PrepareParams(l.params)
                l.paramsSet = true
        }</span>
        <span class="cov8" title="1">return l.params</span>
}

func (l Languages) AsSet() map[string]bool <span class="cov0" title="0">{
        m := make(map[string]bool)
        for _, lang := range l </span><span class="cov0" title="0">{
                m[lang.Lang] = true
        }</span>

        <span class="cov0" title="0">return m</span>
}

func (l Languages) AsOrdinalSet() map[string]int <span class="cov0" title="0">{
        m := make(map[string]int)
        for i, lang := range l </span><span class="cov0" title="0">{
                m[lang.Lang] = i
        }</span>

        <span class="cov0" title="0">return m</span>
}

// IsMultihost returns whether there are more than one language and at least one of
// the languages has baseURL specificed on the language level.
func (l Languages) IsMultihost() bool <span class="cov0" title="0">{
        if len(l) &lt;= 1 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, lang := range l </span><span class="cov0" title="0">{
                if lang.GetLocal("baseURL") != nil </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// SetParam sets a param with the given key and value.
// SetParam is case-insensitive.
func (l *Language) SetParam(k string, v interface{}) <span class="cov8" title="1">{
        l.paramsMu.Lock()
        defer l.paramsMu.Unlock()
        if l.paramsSet </span><span class="cov0" title="0">{
                panic("params cannot be changed once set")</span>
        }
        <span class="cov8" title="1">l.params[k] = v</span>
}

// GetLocal gets a configuration value set on language level. It will
// not fall back to any global value.
// It will return nil if a value with the given key cannot be found.
func (l *Language) GetLocal(key string) interface{} <span class="cov0" title="0">{
        if l == nil </span><span class="cov0" title="0">{
                panic("language not set")</span>
        }
        <span class="cov0" title="0">key = strings.ToLower(key)
        if !globalOnlySettings[key] </span><span class="cov0" title="0">{
                return l.LocalCfg.Get(key)
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (l *Language) Set(k string, v interface{}) <span class="cov8" title="1">{
        k = strings.ToLower(k)
        if globalOnlySettings[k] </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">l.Provider.Set(k, v)</span>
}

// Merge is currently not supported for Language.
func (l *Language) Merge(key string, value interface{}) <span class="cov0" title="0">{
        panic("Not supported")</span>
}

// IsSet checks whether the key is set in the language or the related config store.
func (l *Language) IsSet(key string) bool <span class="cov0" title="0">{
        key = strings.ToLower(key)
        if !globalOnlySettings[key] </span><span class="cov0" title="0">{
                return l.Provider.IsSet(key)
        }</span>
        <span class="cov0" title="0">return l.Cfg.IsSet(key)</span>
}

// Internal access to unexported Language fields.
// This construct is to prevent them from leaking to the templates.

func GetTranslator(l *Language) locales.Translator <span class="cov0" title="0">{
        return l.translator
}</span>

func GetLocation(l *Language) *time.Location <span class="cov0" title="0">{
        return l.location
}</span>

func (l *Language) loadLocation(tzStr string) error <span class="cov8" title="1">{
        location, err := time.LoadLocation(tzStr)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "invalid timeZone for language %q", l.Lang)
        }</span>
        <span class="cov8" title="1">l.location = location

        return nil</span>
}
</pre>
		
		<pre class="file" id="file151" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lazy

import (
        "context"
        "sync"
        "sync/atomic"
        "time"

        "github.com/pkg/errors"
)

// New creates a new empty Init.
func New() *Init <span class="cov8" title="1">{
        return &amp;Init{}
}</span>

// Init holds a graph of lazily initialized dependencies.
type Init struct {
        // Used in tests
        initCount uint64

        mu sync.Mutex

        prev     *Init
        children []*Init

        init onceMore
        out  interface{}
        err  error
        f    func() (interface{}, error)
}

// Add adds a func as a new child dependency.
func (ini *Init) Add(initFn func() (interface{}, error)) *Init <span class="cov8" title="1">{
        if ini == nil </span><span class="cov0" title="0">{
                ini = New()
        }</span>
        <span class="cov8" title="1">return ini.add(false, initFn)</span>
}

// InitCount gets the number of this this Init has been initialized.
func (ini *Init) InitCount() int <span class="cov0" title="0">{
        i := atomic.LoadUint64(&amp;ini.initCount)
        return int(i)
}</span>

// AddWithTimeout is same as Add, but with a timeout that aborts initialization.
func (ini *Init) AddWithTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) *Init <span class="cov8" title="1">{
        return ini.Add(func() (interface{}, error) </span><span class="cov8" title="1">{
                return ini.withTimeout(timeout, f)
        }</span>)
}

// Branch creates a new dependency branch based on an existing and adds
// the given dependency as a child.
func (ini *Init) Branch(initFn func() (interface{}, error)) *Init <span class="cov8" title="1">{
        if ini == nil </span><span class="cov0" title="0">{
                ini = New()
        }</span>
        <span class="cov8" title="1">return ini.add(true, initFn)</span>
}

// BranchdWithTimeout is same as Branch, but with a timeout.
func (ini *Init) BranchWithTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) *Init <span class="cov0" title="0">{
        return ini.Branch(func() (interface{}, error) </span><span class="cov0" title="0">{
                return ini.withTimeout(timeout, f)
        }</span>)
}

// Do initializes the entire dependency graph.
func (ini *Init) Do() (interface{}, error) <span class="cov8" title="1">{
        if ini == nil </span><span class="cov0" title="0">{
                panic("init is nil")</span>
        }

        <span class="cov8" title="1">ini.init.Do(func() </span><span class="cov8" title="1">{
                atomic.AddUint64(&amp;ini.initCount, 1)
                prev := ini.prev
                if prev != nil </span><span class="cov8" title="1">{
                        // A branch. Initialize the ancestors.
                        if prev.shouldInitialize() </span><span class="cov8" title="1">{
                                _, err := prev.Do()
                                if err != nil </span><span class="cov0" title="0">{
                                        ini.err = err
                                        return
                                }</span>
                        } else<span class="cov8" title="1"> if prev.inProgress() </span><span class="cov0" title="0">{
                                // Concurrent initialization. The following init func
                                // may depend on earlier state, so wait.
                                prev.wait()
                        }</span>
                }

                <span class="cov8" title="1">if ini.f != nil </span><span class="cov8" title="1">{
                        ini.out, ini.err = ini.f()
                }</span>

                <span class="cov8" title="1">for _, child := range ini.children </span><span class="cov8" title="1">{
                        if child.shouldInitialize() </span><span class="cov8" title="1">{
                                _, err := child.Do()
                                if err != nil </span><span class="cov8" title="1">{
                                        ini.err = err
                                        return
                                }</span>
                        }
                }
        })

        <span class="cov8" title="1">ini.wait()

        return ini.out, ini.err</span>
}

// TODO(bep) investigate if we can use sync.Cond for this.
func (ini *Init) wait() <span class="cov8" title="1">{
        var counter time.Duration
        for !ini.init.Done() </span><span class="cov0" title="0">{
                counter += 10
                if counter &gt; 600000000 </span><span class="cov0" title="0">{
                        panic("BUG: timed out in lazy init")</span>
                }
                <span class="cov0" title="0">time.Sleep(counter * time.Microsecond)</span>
        }
}

func (ini *Init) inProgress() bool <span class="cov8" title="1">{
        return ini != nil &amp;&amp; ini.init.InProgress()
}</span>

func (ini *Init) shouldInitialize() bool <span class="cov8" title="1">{
        return !(ini == nil || ini.init.Done() || ini.init.InProgress())
}</span>

// Reset resets the current and all its dependencies.
func (ini *Init) Reset() <span class="cov8" title="1">{
        mu := ini.init.ResetWithLock()
        ini.err = nil
        defer mu.Unlock()
        for _, d := range ini.children </span><span class="cov8" title="1">{
                d.Reset()
        }</span>
}

func (ini *Init) add(branch bool, initFn func() (interface{}, error)) *Init <span class="cov8" title="1">{
        ini.mu.Lock()
        defer ini.mu.Unlock()

        if branch </span><span class="cov8" title="1">{
                return &amp;Init{
                        f:    initFn,
                        prev: ini,
                }
        }</span>

        <span class="cov8" title="1">ini.checkDone()
        ini.children = append(ini.children, &amp;Init{
                f: initFn,
        })

        return ini</span>
}

func (ini *Init) checkDone() <span class="cov8" title="1">{
        if ini.init.Done() </span><span class="cov0" title="0">{
                panic("init cannot be added to after it has run")</span>
        }
}

func (ini *Init) withTimeout(timeout time.Duration, f func(ctx context.Context) (interface{}, error)) (interface{}, error) <span class="cov8" title="1">{
        ctx, cancel := context.WithTimeout(context.Background(), timeout)
        defer cancel()
        c := make(chan verr, 1)

        go func() </span><span class="cov8" title="1">{
                v, err := f(ctx)
                select </span>{
                case &lt;-ctx.Done():<span class="cov8" title="1">
                        return</span>
                default:<span class="cov8" title="1">
                        c &lt;- verr{v: v, err: err}</span>
                }
        }()

        <span class="cov8" title="1">select </span>{
        case &lt;-ctx.Done():<span class="cov8" title="1">
                return nil, errors.New("timed out initializing value. You may have a circular loop in a shortcode, or your site may have resources that take longer to build than the `timeout` limit in your Hugo config file.")</span>
        case ve := &lt;-c:<span class="cov8" title="1">
                return ve.v, ve.err</span>
        }
}

type verr struct {
        v   interface{}
        err error
}
</pre>
		
		<pre class="file" id="file152" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lazy

import (
        "sync"
        "sync/atomic"
)

// onceMore is similar to sync.Once.
//
// Additional features are:
// * it can be reset, so the action can be repeated if needed
// * it has methods to check if it's done or in progress
//
type onceMore struct {
        mu   sync.Mutex
        lock uint32
        done uint32
}

func (t *onceMore) Do(f func()) <span class="cov8" title="1">{
        if atomic.LoadUint32(&amp;t.done) == 1 </span><span class="cov8" title="1">{
                return
        }</span>

        // f may call this Do and we would get a deadlock.
        <span class="cov8" title="1">locked := atomic.CompareAndSwapUint32(&amp;t.lock, 0, 1)
        if !locked </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">defer atomic.StoreUint32(&amp;t.lock, 0)

        t.mu.Lock()
        defer t.mu.Unlock()

        // Double check
        if t.done == 1 </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">defer atomic.StoreUint32(&amp;t.done, 1)
        f()</span>
}

func (t *onceMore) InProgress() bool <span class="cov8" title="1">{
        return atomic.LoadUint32(&amp;t.lock) == 1
}</span>

func (t *onceMore) Done() bool <span class="cov8" title="1">{
        return atomic.LoadUint32(&amp;t.done) == 1
}</span>

func (t *onceMore) ResetWithLock() *sync.Mutex <span class="cov8" title="1">{
        t.mu.Lock()
        defer atomic.StoreUint32(&amp;t.done, 0)
        return &amp;t.mu
}</span>
</pre>
		
		<pre class="file" id="file153" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package asciidocext converts AsciiDoc to HTML using Asciidoctor
// external binary. The `asciidoc` module is reserved for a future golang
// implementation.
package asciidocext

import (
        "bytes"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/hexec"
        "github.com/gohugoio/hugo/htesting"

        "github.com/gohugoio/hugo/identity"
        "github.com/gohugoio/hugo/markup/asciidocext/asciidocext_config"
        "github.com/gohugoio/hugo/markup/converter"
        "github.com/gohugoio/hugo/markup/internal"
        "github.com/gohugoio/hugo/markup/tableofcontents"
        "golang.org/x/net/html"
)

/* ToDo: RelPermalink patch for svg posts not working*/
type pageSubset interface {
        RelPermalink() string
}

// Provider is the package entry point.
var Provider converter.ProviderProvider = provider{}

type provider struct{}

func (p provider) New(cfg converter.ProviderConfig) (converter.Provider, error) <span class="cov8" title="1">{
        return converter.NewProvider("asciidocext", func(ctx converter.DocumentContext) (converter.Converter, error) </span><span class="cov8" title="1">{
                return &amp;asciidocConverter{
                        ctx: ctx,
                        cfg: cfg,
                }, nil
        }</span>), nil
}

type asciidocResult struct {
        converter.Result
        toc tableofcontents.Root
}

func (r asciidocResult) TableOfContents() tableofcontents.Root <span class="cov0" title="0">{
        return r.toc
}</span>

type asciidocConverter struct {
        ctx converter.DocumentContext
        cfg converter.ProviderConfig
}

func (a *asciidocConverter) Convert(ctx converter.RenderContext) (converter.Result, error) <span class="cov0" title="0">{
        b, err := a.getAsciidocContent(ctx.Src, a.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">content, toc, err := a.extractTOC(b)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return asciidocResult{
                Result: converter.Bytes(content),
                toc:    toc,
        }, nil</span>
}

func (a *asciidocConverter) Supports(_ identity.Identity) bool <span class="cov0" title="0">{
        return false
}</span>

// getAsciidocContent calls asciidoctor as an external helper
// to convert AsciiDoc content to HTML.
func (a *asciidocConverter) getAsciidocContent(src []byte, ctx converter.DocumentContext) ([]byte, error) <span class="cov0" title="0">{
        if !hasAsciiDoc() </span><span class="cov0" title="0">{
                a.cfg.Logger.Errorln("asciidoctor not found in $PATH: Please install.\n",
                        "                 Leaving AsciiDoc content unrendered.")
                return src, nil
        }</span>

        <span class="cov0" title="0">args := a.parseArgs(ctx)
        args = append(args, "-")

        a.cfg.Logger.Infoln("Rendering", ctx.DocumentName, " using asciidoctor args", args, "...")

        return internal.ExternallyRenderContent(a.cfg, ctx, src, asciiDocBinaryName, args)</span>
}

func (a *asciidocConverter) parseArgs(ctx converter.DocumentContext) []string <span class="cov8" title="1">{
        cfg := a.cfg.MarkupConfig.AsciidocExt
        args := []string{}

        args = a.appendArg(args, "-b", cfg.Backend, asciidocext_config.CliDefault.Backend, asciidocext_config.AllowedBackend)

        for _, extension := range cfg.Extensions </span><span class="cov8" title="1">{
                if strings.LastIndexAny(extension, `\/.`) &gt; -1 </span><span class="cov8" title="1">{
                        a.cfg.Logger.Errorln("Unsupported asciidoctor extension was passed in. Extension `" + extension + "` ignored. Only installed asciidoctor extensions are allowed.")
                        continue</span>
                }
                <span class="cov8" title="1">args = append(args, "-r", extension)</span>
        }

        <span class="cov8" title="1">for attributeKey, attributeValue := range cfg.Attributes </span><span class="cov8" title="1">{
                if asciidocext_config.DisallowedAttributes[attributeKey] </span><span class="cov8" title="1">{
                        a.cfg.Logger.Errorln("Unsupported asciidoctor attribute was passed in. Attribute `" + attributeKey + "` ignored.")
                        continue</span>
                }

                <span class="cov8" title="1">args = append(args, "-a", attributeKey+"="+attributeValue)</span>
        }

        <span class="cov8" title="1">if cfg.WorkingFolderCurrent </span><span class="cov8" title="1">{
                contentDir := filepath.Dir(ctx.Filename)
                sourceDir := a.cfg.Cfg.GetString("source")
                destinationDir := a.cfg.Cfg.GetString("destination")

                if destinationDir == "" </span><span class="cov8" title="1">{
                        a.cfg.Logger.Errorln("markup.asciidocext.workingFolderCurrent requires hugo command option --destination to be set")
                }</span>
                <span class="cov8" title="1">if !filepath.IsAbs(destinationDir) &amp;&amp; sourceDir != "" </span><span class="cov0" title="0">{
                        destinationDir = filepath.Join(sourceDir, destinationDir)
                }</span>

                <span class="cov8" title="1">var outDir string
                var err error

                file := filepath.Base(ctx.Filename)
                if a.cfg.Cfg.GetBool("uglyUrls") || file == "_index.adoc" || file == "index.adoc" </span><span class="cov8" title="1">{
                        outDir, err = filepath.Abs(filepath.Dir(filepath.Join(destinationDir, ctx.DocumentName)))
                }</span> else<span class="cov8" title="1"> {
                        postDir := ""
                        page, ok := ctx.Document.(pageSubset)
                        if ok </span><span class="cov0" title="0">{
                                postDir = filepath.Base(page.RelPermalink())
                        }</span> else<span class="cov8" title="1"> {
                                a.cfg.Logger.Errorln("unable to cast interface to pageSubset")
                        }</span>

                        <span class="cov8" title="1">outDir, err = filepath.Abs(filepath.Join(destinationDir, filepath.Dir(ctx.DocumentName), postDir))</span>
                }

                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        a.cfg.Logger.Errorln("asciidoctor outDir: ", err)
                }</span>

                <span class="cov8" title="1">args = append(args, "--base-dir", contentDir, "-a", "outdir="+outDir)</span>
        }

        <span class="cov8" title="1">if cfg.NoHeaderOrFooter </span><span class="cov8" title="1">{
                args = append(args, "--no-header-footer")
        }</span> else<span class="cov8" title="1"> {
                a.cfg.Logger.Warnln("asciidoctor parameter NoHeaderOrFooter is expected for correct html rendering")
        }</span>

        <span class="cov8" title="1">if cfg.SectionNumbers </span><span class="cov8" title="1">{
                args = append(args, "--section-numbers")
        }</span>

        <span class="cov8" title="1">if cfg.Verbose </span><span class="cov8" title="1">{
                args = append(args, "--verbose")
        }</span>

        <span class="cov8" title="1">if cfg.Trace </span><span class="cov0" title="0">{
                args = append(args, "--trace")
        }</span>

        <span class="cov8" title="1">args = a.appendArg(args, "--failure-level", cfg.FailureLevel, asciidocext_config.CliDefault.FailureLevel, asciidocext_config.AllowedFailureLevel)

        args = a.appendArg(args, "--safe-mode", cfg.SafeMode, asciidocext_config.CliDefault.SafeMode, asciidocext_config.AllowedSafeMode)

        return args</span>
}

func (a *asciidocConverter) appendArg(args []string, option, value, defaultValue string, allowedValues map[string]bool) []string <span class="cov8" title="1">{
        if value != defaultValue </span><span class="cov8" title="1">{
                if allowedValues[value] </span><span class="cov8" title="1">{
                        args = append(args, option, value)
                }</span> else<span class="cov8" title="1"> {
                        a.cfg.Logger.Errorln("Unsupported asciidoctor value `" + value + "` for option " + option + " was passed in and will be ignored.")
                }</span>
        }
        <span class="cov8" title="1">return args</span>
}

const asciiDocBinaryName = "asciidoctor"

func hasAsciiDoc() bool <span class="cov8" title="1">{
        return hexec.InPath(asciiDocBinaryName)
}</span>

// extractTOC extracts the toc from the given src html.
// It returns the html without the TOC, and the TOC data
func (a *asciidocConverter) extractTOC(src []byte) ([]byte, tableofcontents.Root, error) <span class="cov0" title="0">{
        var buf bytes.Buffer
        buf.Write(src)
        node, err := html.Parse(&amp;buf)
        if err != nil </span><span class="cov0" title="0">{
                return nil, tableofcontents.Root{}, err
        }</span>
        <span class="cov0" title="0">var (
                f       func(*html.Node) bool
                toc     tableofcontents.Root
                toVisit []*html.Node
        )
        f = func(n *html.Node) bool </span><span class="cov0" title="0">{
                if n.Type == html.ElementNode &amp;&amp; n.Data == "div" &amp;&amp; attr(n, "id") == "toc" </span><span class="cov0" title="0">{
                        toc = parseTOC(n)
                        if !a.cfg.MarkupConfig.AsciidocExt.PreserveTOC </span><span class="cov0" title="0">{
                                n.Parent.RemoveChild(n)
                        }</span>
                        <span class="cov0" title="0">return true</span>
                }
                <span class="cov0" title="0">if n.FirstChild != nil </span><span class="cov0" title="0">{
                        toVisit = append(toVisit, n.FirstChild)
                }</span>
                <span class="cov0" title="0">if n.NextSibling != nil &amp;&amp; f(n.NextSibling) </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">for len(toVisit) &gt; 0 </span><span class="cov0" title="0">{
                        nv := toVisit[0]
                        toVisit = toVisit[1:]
                        if f(nv) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov0" title="0">return false</span>
        }
        <span class="cov0" title="0">f(node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, tableofcontents.Root{}, err
        }</span>
        <span class="cov0" title="0">buf.Reset()
        err = html.Render(&amp;buf, node)
        if err != nil </span><span class="cov0" title="0">{
                return nil, tableofcontents.Root{}, err
        }</span>
        // ltrim &lt;html&gt;&lt;head&gt;&lt;/head&gt;&lt;body&gt; and rtrim &lt;/body&gt;&lt;/html&gt; which are added by html.Render
        <span class="cov0" title="0">res := buf.Bytes()[25:]
        res = res[:len(res)-14]
        return res, toc, nil</span>
}

// parseTOC returns a TOC root from the given toc Node
func parseTOC(doc *html.Node) tableofcontents.Root <span class="cov0" title="0">{
        var (
                toc tableofcontents.Root
                f   func(*html.Node, int, int)
        )
        f = func(n *html.Node, row, level int) </span><span class="cov0" title="0">{
                if n.Type == html.ElementNode </span><span class="cov0" title="0">{
                        switch n.Data </span>{
                        case "ul":<span class="cov0" title="0">
                                if level == 0 </span><span class="cov0" title="0">{
                                        row++
                                }</span>
                                <span class="cov0" title="0">level++
                                f(n.FirstChild, row, level)</span>
                        case "li":<span class="cov0" title="0">
                                for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov0" title="0">{
                                        if c.Type != html.ElementNode || c.Data != "a" </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        <span class="cov0" title="0">href := attr(c, "href")[1:]
                                        toc.AddAt(tableofcontents.Heading{
                                                Text: nodeContent(c),
                                                ID:   href,
                                        }, row, level)</span>
                                }
                                <span class="cov0" title="0">f(n.FirstChild, row, level)</span>
                        }
                }
                <span class="cov0" title="0">if n.NextSibling != nil </span><span class="cov0" title="0">{
                        f(n.NextSibling, row, level)
                }</span>
        }
        <span class="cov0" title="0">f(doc.FirstChild, -1, 0)
        return toc</span>
}

func attr(node *html.Node, key string) string <span class="cov0" title="0">{
        for _, a := range node.Attr </span><span class="cov0" title="0">{
                if a.Key == key </span><span class="cov0" title="0">{
                        return a.Val
                }</span>
        }
        <span class="cov0" title="0">return ""</span>
}

func nodeContent(node *html.Node) string <span class="cov0" title="0">{
        var buf bytes.Buffer
        for c := node.FirstChild; c != nil; c = c.NextSibling </span><span class="cov0" title="0">{
                html.Render(&amp;buf, c)
        }</span>
        <span class="cov0" title="0">return buf.String()</span>
}

// Supports returns whether Asciidoctor is installed on this computer.
func Supports() bool <span class="cov8" title="1">{
        hasBin := hasAsciiDoc()
        if htesting.SupportsAll() </span><span class="cov0" title="0">{
                if !hasBin </span><span class="cov0" title="0">{
                        panic("asciidoctor not installed")</span>
                }
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov8" title="1">return hasBin</span>
}
</pre>
		
		<pre class="file" id="file154" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package blackfriday converts Markdown to HTML using Blackfriday v1.
package blackfriday

import (
        "unicode"

        "github.com/gohugoio/hugo/identity"
        "github.com/gohugoio/hugo/markup/blackfriday/blackfriday_config"
        "github.com/gohugoio/hugo/markup/converter"
        "github.com/russross/blackfriday"
)

// Provider is the package entry point.
var Provider converter.ProviderProvider = provider{}

type provider struct {
}

func (p provider) New(cfg converter.ProviderConfig) (converter.Provider, error) <span class="cov8" title="1">{
        defaultExtensions := getMarkdownExtensions(cfg.MarkupConfig.BlackFriday)

        return converter.NewProvider("blackfriday", func(ctx converter.DocumentContext) (converter.Converter, error) </span><span class="cov8" title="1">{
                b := cfg.MarkupConfig.BlackFriday
                extensions := defaultExtensions

                if ctx.ConfigOverrides != nil </span><span class="cov8" title="1">{
                        var err error
                        b, err = blackfriday_config.UpdateConfig(b, ctx.ConfigOverrides)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">extensions = getMarkdownExtensions(b)</span>
                }

                <span class="cov8" title="1">return &amp;blackfridayConverter{
                        ctx:        ctx,
                        bf:         b,
                        extensions: extensions,
                        cfg:        cfg,
                }, nil</span>
        }), nil
}

type blackfridayConverter struct {
        ctx        converter.DocumentContext
        bf         blackfriday_config.Config
        extensions int
        cfg        converter.ProviderConfig
}

func (c *blackfridayConverter) SanitizeAnchorName(s string) string <span class="cov0" title="0">{
        return SanitizedAnchorName(s)
}</span>

// SanitizedAnchorName is how Blackfriday sanitizes anchor names.
// Implementation borrowed from https://github.com/russross/blackfriday/blob/a477dd1646916742841ed20379f941cfa6c5bb6f/block.go#L1464
func SanitizedAnchorName(text string) string <span class="cov8" title="1">{
        var anchorName []rune
        futureDash := false
        for _, r := range text </span><span class="cov8" title="1">{
                switch </span>{
                case unicode.IsLetter(r) || unicode.IsNumber(r):<span class="cov8" title="1">
                        if futureDash &amp;&amp; len(anchorName) &gt; 0 </span><span class="cov8" title="1">{
                                anchorName = append(anchorName, '-')
                        }</span>
                        <span class="cov8" title="1">futureDash = false
                        anchorName = append(anchorName, unicode.ToLower(r))</span>
                default:<span class="cov8" title="1">
                        futureDash = true</span>
                }
        }
        <span class="cov8" title="1">return string(anchorName)</span>
}

func (c *blackfridayConverter) AnchorSuffix() string <span class="cov0" title="0">{
        if c.bf.PlainIDAnchors </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">return ":" + c.ctx.DocumentID</span>
}

func (c *blackfridayConverter) Convert(ctx converter.RenderContext) (converter.Result, error) <span class="cov8" title="1">{
        r := c.getHTMLRenderer(ctx.RenderTOC)

        return converter.Bytes(blackfriday.Markdown(ctx.Src, r, c.extensions)), nil
}</span>

func (c *blackfridayConverter) Supports(feature identity.Identity) bool <span class="cov0" title="0">{
        return false
}</span>

func (c *blackfridayConverter) getHTMLRenderer(renderTOC bool) blackfriday.Renderer <span class="cov8" title="1">{
        flags := getFlags(renderTOC, c.bf)

        documentID := c.ctx.DocumentID

        renderParameters := blackfriday.HtmlRendererParameters{
                FootnoteAnchorPrefix:       c.bf.FootnoteAnchorPrefix,
                FootnoteReturnLinkContents: c.bf.FootnoteReturnLinkContents,
        }

        if documentID != "" &amp;&amp; !c.bf.PlainIDAnchors </span><span class="cov8" title="1">{
                renderParameters.FootnoteAnchorPrefix = documentID + ":" + renderParameters.FootnoteAnchorPrefix
                renderParameters.HeaderIDSuffix = ":" + documentID
        }</span>

        <span class="cov8" title="1">return &amp;hugoHTMLRenderer{
                c:        c,
                Renderer: blackfriday.HtmlRendererWithParameters(flags, "", "", renderParameters),
        }</span>
}

func getFlags(renderTOC bool, cfg blackfriday_config.Config) int <span class="cov8" title="1">{
        var flags int

        if renderTOC </span><span class="cov0" title="0">{
                flags = blackfriday.HTML_TOC
        }</span>

        <span class="cov8" title="1">flags |= blackfriday.HTML_USE_XHTML
        flags |= blackfriday.HTML_FOOTNOTE_RETURN_LINKS

        if cfg.Smartypants </span><span class="cov8" title="1">{
                flags |= blackfriday.HTML_USE_SMARTYPANTS
        }</span>

        <span class="cov8" title="1">if cfg.SmartypantsQuotesNBSP </span><span class="cov8" title="1">{
                flags |= blackfriday.HTML_SMARTYPANTS_QUOTES_NBSP
        }</span>

        <span class="cov8" title="1">if cfg.AngledQuotes </span><span class="cov8" title="1">{
                flags |= blackfriday.HTML_SMARTYPANTS_ANGLED_QUOTES
        }</span>

        <span class="cov8" title="1">if cfg.Fractions </span><span class="cov8" title="1">{
                flags |= blackfriday.HTML_SMARTYPANTS_FRACTIONS
        }</span>

        <span class="cov8" title="1">if cfg.HrefTargetBlank </span><span class="cov8" title="1">{
                flags |= blackfriday.HTML_HREF_TARGET_BLANK
        }</span>

        <span class="cov8" title="1">if cfg.NofollowLinks </span><span class="cov8" title="1">{
                flags |= blackfriday.HTML_NOFOLLOW_LINKS
        }</span>

        <span class="cov8" title="1">if cfg.NoreferrerLinks </span><span class="cov8" title="1">{
                flags |= blackfriday.HTML_NOREFERRER_LINKS
        }</span>

        <span class="cov8" title="1">if cfg.SmartDashes </span><span class="cov8" title="1">{
                flags |= blackfriday.HTML_SMARTYPANTS_DASHES
        }</span>

        <span class="cov8" title="1">if cfg.LatexDashes </span><span class="cov8" title="1">{
                flags |= blackfriday.HTML_SMARTYPANTS_LATEX_DASHES
        }</span>

        <span class="cov8" title="1">if cfg.SkipHTML </span><span class="cov0" title="0">{
                flags |= blackfriday.HTML_SKIP_HTML
        }</span>

        <span class="cov8" title="1">return flags</span>
}

func getMarkdownExtensions(cfg blackfriday_config.Config) int <span class="cov8" title="1">{
        // Default Blackfriday common extensions
        commonExtensions := 0 |
                blackfriday.EXTENSION_NO_INTRA_EMPHASIS |
                blackfriday.EXTENSION_TABLES |
                blackfriday.EXTENSION_FENCED_CODE |
                blackfriday.EXTENSION_AUTOLINK |
                blackfriday.EXTENSION_STRIKETHROUGH |
                blackfriday.EXTENSION_SPACE_HEADERS |
                blackfriday.EXTENSION_HEADER_IDS |
                blackfriday.EXTENSION_BACKSLASH_LINE_BREAK |
                blackfriday.EXTENSION_DEFINITION_LISTS

        // Extra Blackfriday extensions that Hugo enables by default
        flags := commonExtensions |
                blackfriday.EXTENSION_AUTO_HEADER_IDS |
                blackfriday.EXTENSION_FOOTNOTES

        for _, extension := range cfg.Extensions </span><span class="cov8" title="1">{
                if flag, ok := blackfridayExtensionMap[extension]; ok </span><span class="cov8" title="1">{
                        flags |= flag
                }</span>
        }
        <span class="cov8" title="1">for _, extension := range cfg.ExtensionsMask </span><span class="cov8" title="1">{
                if flag, ok := blackfridayExtensionMap[extension]; ok </span><span class="cov8" title="1">{
                        flags &amp;= ^flag
                }</span>
        }
        <span class="cov8" title="1">return flags</span>
}

var blackfridayExtensionMap = map[string]int{
        "noIntraEmphasis":        blackfriday.EXTENSION_NO_INTRA_EMPHASIS,
        "tables":                 blackfriday.EXTENSION_TABLES,
        "fencedCode":             blackfriday.EXTENSION_FENCED_CODE,
        "autolink":               blackfriday.EXTENSION_AUTOLINK,
        "strikethrough":          blackfriday.EXTENSION_STRIKETHROUGH,
        "laxHtmlBlocks":          blackfriday.EXTENSION_LAX_HTML_BLOCKS,
        "spaceHeaders":           blackfriday.EXTENSION_SPACE_HEADERS,
        "hardLineBreak":          blackfriday.EXTENSION_HARD_LINE_BREAK,
        "tabSizeEight":           blackfriday.EXTENSION_TAB_SIZE_EIGHT,
        "footnotes":              blackfriday.EXTENSION_FOOTNOTES,
        "noEmptyLineBeforeBlock": blackfriday.EXTENSION_NO_EMPTY_LINE_BEFORE_BLOCK,
        "headerIds":              blackfriday.EXTENSION_HEADER_IDS,
        "titleblock":             blackfriday.EXTENSION_TITLEBLOCK,
        "autoHeaderIds":          blackfriday.EXTENSION_AUTO_HEADER_IDS,
        "backslashLineBreak":     blackfriday.EXTENSION_BACKSLASH_LINE_BREAK,
        "definitionLists":        blackfriday.EXTENSION_DEFINITION_LISTS,
        "joinLines":              blackfriday.EXTENSION_JOIN_LINES,
}

var (
        _ converter.DocumentInfo        = (*blackfridayConverter)(nil)
        _ converter.AnchorNameSanitizer = (*blackfridayConverter)(nil)
)
</pre>
		
		<pre class="file" id="file155" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package blackfriday

import (
        "bytes"
        "strings"

        "github.com/russross/blackfriday"
)

// hugoHTMLRenderer wraps a blackfriday.Renderer, typically a blackfriday.Html
// adding some custom behaviour.
type hugoHTMLRenderer struct {
        c *blackfridayConverter
        blackfriday.Renderer
}

// BlockCode renders a given text as a block of code.
// Chroma is used if it is setup to handle code fences.
func (r *hugoHTMLRenderer) BlockCode(out *bytes.Buffer, text []byte, lang string) <span class="cov0" title="0">{
        if r.c.cfg.MarkupConfig.Highlight.CodeFences </span><span class="cov0" title="0">{
                str := strings.Trim(string(text), "\n\r")
                highlighted, _ := r.c.cfg.Highlight(str, lang, "")
                out.WriteString(highlighted)
        }</span> else<span class="cov0" title="0"> {
                r.Renderer.BlockCode(out, text, lang)
        }</span>
}

// ListItem adds task list support to the Blackfriday renderer.
func (r *hugoHTMLRenderer) ListItem(out *bytes.Buffer, text []byte, flags int) <span class="cov0" title="0">{
        if !r.c.bf.TaskLists </span><span class="cov0" title="0">{
                r.Renderer.ListItem(out, text, flags)
                return
        }</span>

        <span class="cov0" title="0">switch </span>{
        case bytes.HasPrefix(text, []byte("[ ] ")):<span class="cov0" title="0">
                text = append([]byte(`&lt;label&gt;&lt;input type="checkbox" disabled class="task-list-item"&gt;`), text[3:]...)
                text = append(text, []byte(`&lt;/label&gt;`)...)</span>

        case bytes.HasPrefix(text, []byte("[x] ")) || bytes.HasPrefix(text, []byte("[X] ")):<span class="cov0" title="0">
                text = append([]byte(`&lt;label&gt;&lt;input type="checkbox" checked disabled class="task-list-item"&gt;`), text[3:]...)
                text = append(text, []byte(`&lt;/label&gt;`)...)</span>
        }

        <span class="cov0" title="0">r.Renderer.ListItem(out, text, flags)</span>
}

// List adds task list support to the Blackfriday renderer.
func (r *hugoHTMLRenderer) List(out *bytes.Buffer, text func() bool, flags int) <span class="cov0" title="0">{
        if !r.c.bf.TaskLists </span><span class="cov0" title="0">{
                r.Renderer.List(out, text, flags)
                return
        }</span>
        <span class="cov0" title="0">marker := out.Len()
        r.Renderer.List(out, text, flags)
        if out.Len() &gt; marker </span><span class="cov0" title="0">{
                list := out.Bytes()[marker:]
                if bytes.Contains(list, []byte("task-list-item")) </span><span class="cov0" title="0">{
                        // Find the index of the first &gt;, it might be 3 or 4 depending on whether
                        // there is a new line at the start, but this is safer than just hardcoding it.
                        closingBracketIndex := bytes.Index(list, []byte("&gt;"))
                        // Rewrite the buffer from the marker
                        out.Truncate(marker)
                        // Safely assuming closingBracketIndex won't be -1 since there is a list
                        // May be either dl, ul or ol
                        list := append(list[:closingBracketIndex], append([]byte(` class="task-list"`), list[closingBracketIndex:]...)...)
                        out.Write(list)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file156" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package goldmark

import (
        "bytes"
        "strconv"
        "unicode"
        "unicode/utf8"

        "github.com/gohugoio/hugo/markup/blackfriday"

        "github.com/gohugoio/hugo/markup/goldmark/goldmark_config"

        "github.com/gohugoio/hugo/common/text"

        "github.com/yuin/goldmark/ast"
        "github.com/yuin/goldmark/parser"
        "github.com/yuin/goldmark/util"

        bp "github.com/gohugoio/hugo/bufferpool"
)

func sanitizeAnchorNameString(s string, idType string) string <span class="cov8" title="1">{
        return string(sanitizeAnchorName([]byte(s), idType))
}</span>

func sanitizeAnchorName(b []byte, idType string) []byte <span class="cov8" title="1">{
        return sanitizeAnchorNameWithHook(b, idType, nil)
}</span>

func sanitizeAnchorNameWithHook(b []byte, idType string, hook func(buf *bytes.Buffer)) []byte <span class="cov8" title="1">{
        buf := bp.GetBuffer()

        if idType == goldmark_config.AutoHeadingIDTypeBlackfriday </span><span class="cov8" title="1">{
                // TODO(bep) make it more efficient.
                buf.WriteString(blackfriday.SanitizedAnchorName(string(b)))
        }</span> else<span class="cov8" title="1"> {
                asciiOnly := idType == goldmark_config.AutoHeadingIDTypeGitHubAscii

                if asciiOnly </span><span class="cov8" title="1">{
                        // Normalize it to preserve accents if possible.
                        b = text.RemoveAccents(b)
                }</span>

                <span class="cov8" title="1">b = bytes.TrimSpace(b)

                for len(b) &gt; 0 </span><span class="cov8" title="1">{
                        r, size := utf8.DecodeRune(b)
                        switch </span>{
                        case asciiOnly &amp;&amp; size != 1:<span class="cov8" title="1"></span>
                        case r == '-' || r == ' ':<span class="cov8" title="1">
                                buf.WriteRune('-')</span>
                        case isAlphaNumeric(r):<span class="cov8" title="1">
                                buf.WriteRune(unicode.ToLower(r))</span>
                        default:<span class="cov8" title="1"></span>
                        }

                        <span class="cov8" title="1">b = b[size:]</span>
                }
        }

        <span class="cov8" title="1">if hook != nil </span><span class="cov8" title="1">{
                hook(buf)
        }</span>

        <span class="cov8" title="1">result := make([]byte, buf.Len())
        copy(result, buf.Bytes())

        bp.PutBuffer(buf)

        return result</span>
}

func isAlphaNumeric(r rune) bool <span class="cov8" title="1">{
        return r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r)
}</span>

var _ parser.IDs = (*idFactory)(nil)

type idFactory struct {
        idType string
        vals   map[string]struct{}
}

func newIDFactory(idType string) *idFactory <span class="cov8" title="1">{
        return &amp;idFactory{
                vals:   make(map[string]struct{}),
                idType: idType,
        }
}</span>

func (ids *idFactory) Generate(value []byte, kind ast.NodeKind) []byte <span class="cov8" title="1">{
        return sanitizeAnchorNameWithHook(value, ids.idType, func(buf *bytes.Buffer) </span><span class="cov8" title="1">{
                if buf.Len() == 0 </span><span class="cov0" title="0">{
                        if kind == ast.KindHeading </span><span class="cov0" title="0">{
                                buf.WriteString("heading")
                        }</span> else<span class="cov0" title="0"> {
                                buf.WriteString("id")
                        }</span>
                }

                <span class="cov8" title="1">if _, found := ids.vals[util.BytesToReadOnlyString(buf.Bytes())]; found </span><span class="cov8" title="1">{
                        // Append a hypen and a number, starting with 1.
                        buf.WriteRune('-')
                        pos := buf.Len()
                        for i := 1; ; i++ </span><span class="cov8" title="1">{
                                buf.WriteString(strconv.Itoa(i))
                                if _, found := ids.vals[util.BytesToReadOnlyString(buf.Bytes())]; !found </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov8" title="1">buf.Truncate(pos)</span>
                        }
                }

                <span class="cov8" title="1">ids.vals[buf.String()] = struct{}{}</span>
        })
}

func (ids *idFactory) Put(value []byte) <span class="cov8" title="1">{
        ids.vals[util.BytesToReadOnlyString(value)] = struct{}{}
}</span>
</pre>
		
		<pre class="file" id="file157" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package goldmark converts Markdown to HTML using Goldmark.
package goldmark

import (
        "bytes"
        "fmt"
        "math/bits"
        "path/filepath"
        "runtime/debug"

        "github.com/gohugoio/hugo/markup/goldmark/internal/extensions/attributes"
        "github.com/yuin/goldmark/ast"

        "github.com/gohugoio/hugo/identity"

        "github.com/pkg/errors"

        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/markup/converter"
        "github.com/gohugoio/hugo/markup/highlight"
        "github.com/gohugoio/hugo/markup/tableofcontents"
        "github.com/yuin/goldmark"
        hl "github.com/yuin/goldmark-highlighting"
        "github.com/yuin/goldmark/extension"
        "github.com/yuin/goldmark/parser"
        "github.com/yuin/goldmark/renderer"
        "github.com/yuin/goldmark/renderer/html"
        "github.com/yuin/goldmark/text"
        "github.com/yuin/goldmark/util"
)

// Provider is the package entry point.
var Provider converter.ProviderProvider = provide{}

type provide struct {
}

func (p provide) New(cfg converter.ProviderConfig) (converter.Provider, error) <span class="cov8" title="1">{
        md := newMarkdown(cfg)

        return converter.NewProvider("goldmark", func(ctx converter.DocumentContext) (converter.Converter, error) </span><span class="cov8" title="1">{
                return &amp;goldmarkConverter{
                        ctx: ctx,
                        cfg: cfg,
                        md:  md,
                        sanitizeAnchorName: func(s string) string </span><span class="cov0" title="0">{
                                return sanitizeAnchorNameString(s, cfg.MarkupConfig.Goldmark.Parser.AutoHeadingIDType)
                        }</span>,
                }, nil
        }), nil
}

var _ converter.AnchorNameSanitizer = (*goldmarkConverter)(nil)

type goldmarkConverter struct {
        md  goldmark.Markdown
        ctx converter.DocumentContext
        cfg converter.ProviderConfig

        sanitizeAnchorName func(s string) string
}

func (c *goldmarkConverter) SanitizeAnchorName(s string) string <span class="cov0" title="0">{
        return c.sanitizeAnchorName(s)
}</span>

func newMarkdown(pcfg converter.ProviderConfig) goldmark.Markdown <span class="cov8" title="1">{
        mcfg := pcfg.MarkupConfig
        cfg := pcfg.MarkupConfig.Goldmark
        var rendererOptions []renderer.Option

        if cfg.Renderer.HardWraps </span><span class="cov0" title="0">{
                rendererOptions = append(rendererOptions, html.WithHardWraps())
        }</span>

        <span class="cov8" title="1">if cfg.Renderer.XHTML </span><span class="cov0" title="0">{
                rendererOptions = append(rendererOptions, html.WithXHTML())
        }</span>

        <span class="cov8" title="1">if cfg.Renderer.Unsafe </span><span class="cov8" title="1">{
                rendererOptions = append(rendererOptions, html.WithUnsafe())
        }</span>

        <span class="cov8" title="1">var (
                extensions = []goldmark.Extender{
                        newLinks(),
                        newTocExtension(rendererOptions),
                }
                parserOptions []parser.Option
        )

        if mcfg.Highlight.CodeFences </span><span class="cov8" title="1">{
                extensions = append(extensions, newHighlighting(mcfg.Highlight))
        }</span>

        <span class="cov8" title="1">if cfg.Extensions.Table </span><span class="cov8" title="1">{
                extensions = append(extensions, extension.Table)
        }</span>

        <span class="cov8" title="1">if cfg.Extensions.Strikethrough </span><span class="cov8" title="1">{
                extensions = append(extensions, extension.Strikethrough)
        }</span>

        <span class="cov8" title="1">if cfg.Extensions.Linkify </span><span class="cov8" title="1">{
                extensions = append(extensions, extension.Linkify)
        }</span>

        <span class="cov8" title="1">if cfg.Extensions.TaskList </span><span class="cov8" title="1">{
                extensions = append(extensions, extension.TaskList)
        }</span>

        <span class="cov8" title="1">if cfg.Extensions.Typographer </span><span class="cov8" title="1">{
                extensions = append(extensions, extension.Typographer)
        }</span>

        <span class="cov8" title="1">if cfg.Extensions.DefinitionList </span><span class="cov8" title="1">{
                extensions = append(extensions, extension.DefinitionList)
        }</span>

        <span class="cov8" title="1">if cfg.Extensions.Footnote </span><span class="cov8" title="1">{
                extensions = append(extensions, extension.Footnote)
        }</span>

        <span class="cov8" title="1">if cfg.Parser.AutoHeadingID </span><span class="cov8" title="1">{
                parserOptions = append(parserOptions, parser.WithAutoHeadingID())
        }</span>

        <span class="cov8" title="1">if cfg.Parser.Attribute.Title </span><span class="cov8" title="1">{
                parserOptions = append(parserOptions, parser.WithAttribute())
        }</span>

        <span class="cov8" title="1">if cfg.Parser.Attribute.Block </span><span class="cov8" title="1">{
                extensions = append(extensions, attributes.New())
        }</span>

        <span class="cov8" title="1">md := goldmark.New(
                goldmark.WithExtensions(
                        extensions...,
                ),
                goldmark.WithParserOptions(
                        parserOptions...,
                ),
                goldmark.WithRendererOptions(
                        rendererOptions...,
                ),
        )

        return md</span>
}

var _ identity.IdentitiesProvider = (*converterResult)(nil)

type converterResult struct {
        converter.Result
        toc tableofcontents.Root
        ids identity.Identities
}

func (c converterResult) TableOfContents() tableofcontents.Root <span class="cov8" title="1">{
        return c.toc
}</span>

func (c converterResult) GetIdentities() identity.Identities <span class="cov8" title="1">{
        return c.ids
}</span>

type bufWriter struct {
        *bytes.Buffer
}

const maxInt = 1&lt;&lt;(bits.UintSize-1) - 1

func (b *bufWriter) Available() int <span class="cov0" title="0">{
        return maxInt
}</span>

func (b *bufWriter) Buffered() int <span class="cov0" title="0">{
        return b.Len()
}</span>

func (b *bufWriter) Flush() error <span class="cov8" title="1">{
        return nil
}</span>

type renderContext struct {
        *bufWriter
        pos int
        renderContextData
}

type renderContextData interface {
        RenderContext() converter.RenderContext
        DocumentContext() converter.DocumentContext
        AddIdentity(id identity.Provider)
}

type renderContextDataHolder struct {
        rctx converter.RenderContext
        dctx converter.DocumentContext
        ids  identity.Manager
}

func (ctx *renderContextDataHolder) RenderContext() converter.RenderContext <span class="cov8" title="1">{
        return ctx.rctx
}</span>

func (ctx *renderContextDataHolder) DocumentContext() converter.DocumentContext <span class="cov0" title="0">{
        return ctx.dctx
}</span>

func (ctx *renderContextDataHolder) AddIdentity(id identity.Provider) <span class="cov0" title="0">{
        ctx.ids.Add(id)
}</span>

var converterIdentity = identity.KeyValueIdentity{Key: "goldmark", Value: "converter"}

func (c *goldmarkConverter) Convert(ctx converter.RenderContext) (result converter.Result, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        dir := afero.GetTempDir(hugofs.Os, "hugo_bugs")
                        name := fmt.Sprintf("goldmark_%s.txt", c.ctx.DocumentID)
                        filename := filepath.Join(dir, name)
                        afero.WriteFile(hugofs.Os, filename, ctx.Src, 07555)
                        fmt.Print(string(debug.Stack()))
                        err = errors.Errorf("[BUG] goldmark: %s: create an issue on GitHub attaching the file in: %s", r, filename)
                }</span>
        }()

        <span class="cov8" title="1">buf := &amp;bufWriter{Buffer: &amp;bytes.Buffer{}}
        result = buf
        pctx := c.newParserContext(ctx)
        reader := text.NewReader(ctx.Src)

        doc := c.md.Parser().Parse(
                reader,
                parser.WithContext(pctx),
        )

        rcx := &amp;renderContextDataHolder{
                rctx: ctx,
                dctx: c.ctx,
                ids:  identity.NewManager(converterIdentity),
        }

        w := &amp;renderContext{
                bufWriter:         buf,
                renderContextData: rcx,
        }

        if err := c.md.Renderer().Render(w, ctx.Src, doc); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return converterResult{
                Result: buf,
                ids:    rcx.ids.GetIdentities(),
                toc:    pctx.TableOfContents(),
        }, nil</span>
}

var featureSet = map[identity.Identity]bool{
        converter.FeatureRenderHooks: true,
}

func (c *goldmarkConverter) Supports(feature identity.Identity) bool <span class="cov8" title="1">{
        return featureSet[feature.GetIdentity()]
}</span>

func (c *goldmarkConverter) newParserContext(rctx converter.RenderContext) *parserContext <span class="cov8" title="1">{
        ctx := parser.NewContext(parser.WithIDs(newIDFactory(c.cfg.MarkupConfig.Goldmark.Parser.AutoHeadingIDType)))
        ctx.Set(tocEnableKey, rctx.RenderTOC)
        return &amp;parserContext{
                Context: ctx,
        }
}</span>

type parserContext struct {
        parser.Context
}

func (p *parserContext) TableOfContents() tableofcontents.Root <span class="cov8" title="1">{
        if v := p.Get(tocResultKey); v != nil </span><span class="cov8" title="1">{
                return v.(tableofcontents.Root)
        }</span>
        <span class="cov8" title="1">return tableofcontents.Root{}</span>
}

func newHighlighting(cfg highlight.Config) goldmark.Extender <span class="cov8" title="1">{
        return hl.NewHighlighting(
                hl.WithStyle(cfg.Style),
                hl.WithGuessLanguage(cfg.GuessSyntax),
                hl.WithCodeBlockOptions(highlight.GetCodeBlockOptions()),
                hl.WithFormatOptions(
                        cfg.ToHTMLOptions()...,
                ),

                hl.WithWrapperRenderer(func(w util.BufWriter, ctx hl.CodeBlockContext, entering bool) </span><span class="cov8" title="1">{
                        var language string
                        if l, hasLang := ctx.Language(); hasLang </span><span class="cov8" title="1">{
                                language = string(l)
                        }</span>

                        <span class="cov8" title="1">if ctx.Highlighted() </span><span class="cov8" title="1">{
                                if entering </span><span class="cov8" title="1">{
                                        writeDivStart(w, ctx)
                                }</span> else<span class="cov8" title="1"> {
                                        writeDivEnd(w)
                                }</span>
                        } else<span class="cov8" title="1"> {
                                if entering </span><span class="cov8" title="1">{
                                        highlight.WritePreStart(w, language, "")
                                }</span> else<span class="cov8" title="1"> {
                                        highlight.WritePreEnd(w)
                                }</span>
                        }
                }),
        )
}

func writeDivStart(w util.BufWriter, ctx hl.CodeBlockContext) <span class="cov8" title="1">{
        w.WriteString(`&lt;div class="highlight`)

        var attributes []ast.Attribute
        if ctx.Attributes() != nil </span><span class="cov8" title="1">{
                attributes = ctx.Attributes().All()
        }</span>

        <span class="cov8" title="1">if attributes != nil </span><span class="cov8" title="1">{
                class, found := ctx.Attributes().GetString("class")
                if found </span><span class="cov8" title="1">{
                        w.WriteString(" ")
                        w.Write(util.EscapeHTML(class.([]byte)))

                }</span>
                <span class="cov8" title="1">_, _ = w.WriteString("\"")
                renderAttributes(w, true, attributes...)</span>
        } else<span class="cov8" title="1"> {
                _, _ = w.WriteString("\"")
        }</span>

        <span class="cov8" title="1">w.WriteString("&gt;")</span>
}

func writeDivEnd(w util.BufWriter) <span class="cov8" title="1">{
        w.WriteString("&lt;/div&gt;")
}</span>
</pre>
		
		<pre class="file" id="file158" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package goldmark

import (
        "bytes"
        "strings"
        "sync"

        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/markup/converter/hooks"

        "github.com/yuin/goldmark"
        "github.com/yuin/goldmark/ast"
        "github.com/yuin/goldmark/renderer"
        "github.com/yuin/goldmark/renderer/html"
        "github.com/yuin/goldmark/util"
)

var _ renderer.SetOptioner = (*hookedRenderer)(nil)

func newLinkRenderer() renderer.NodeRenderer <span class="cov8" title="1">{
        r := &amp;hookedRenderer{
                Config: html.Config{
                        Writer: html.DefaultWriter,
                },
        }
        return r
}</span>

func newLinks() goldmark.Extender <span class="cov8" title="1">{
        return &amp;links{}
}</span>

type attributesHolder struct {
        // What we get from Goldmark.
        astAttributes []ast.Attribute

        // What we send to the the render hooks.
        attributesInit sync.Once
        attributes     map[string]string
}

func (a *attributesHolder) Attributes() map[string]string <span class="cov0" title="0">{
        a.attributesInit.Do(func() </span><span class="cov0" title="0">{
                a.attributes = make(map[string]string)
                for _, attr := range a.astAttributes </span><span class="cov0" title="0">{
                        a.attributes[string(attr.Name)] = string(util.EscapeHTML(attr.Value.([]byte)))
                }</span>
        })
        <span class="cov0" title="0">return a.attributes</span>
}

type linkContext struct {
        page        interface{}
        destination string
        title       string
        text        string
        plainText   string
}

func (ctx linkContext) Destination() string <span class="cov0" title="0">{
        return ctx.destination
}</span>

func (ctx linkContext) Resolved() bool <span class="cov0" title="0">{
        return false
}</span>

func (ctx linkContext) Page() interface{} <span class="cov0" title="0">{
        return ctx.page
}</span>

func (ctx linkContext) Text() string <span class="cov0" title="0">{
        return ctx.text
}</span>

func (ctx linkContext) PlainText() string <span class="cov0" title="0">{
        return ctx.plainText
}</span>

func (ctx linkContext) Title() string <span class="cov0" title="0">{
        return ctx.title
}</span>

type headingContext struct {
        page      interface{}
        level     int
        anchor    string
        text      string
        plainText string
        *attributesHolder
}

func (ctx headingContext) Page() interface{} <span class="cov0" title="0">{
        return ctx.page
}</span>

func (ctx headingContext) Level() int <span class="cov0" title="0">{
        return ctx.level
}</span>

func (ctx headingContext) Anchor() string <span class="cov0" title="0">{
        return ctx.anchor
}</span>

func (ctx headingContext) Text() string <span class="cov0" title="0">{
        return ctx.text
}</span>

func (ctx headingContext) PlainText() string <span class="cov0" title="0">{
        return ctx.plainText
}</span>

type hookedRenderer struct {
        html.Config
}

func (r *hookedRenderer) SetOption(name renderer.OptionName, value interface{}) <span class="cov8" title="1">{
        r.Config.SetOption(name, value)
}</span>

// RegisterFuncs implements NodeRenderer.RegisterFuncs.
func (r *hookedRenderer) RegisterFuncs(reg renderer.NodeRendererFuncRegisterer) <span class="cov8" title="1">{
        reg.Register(ast.KindLink, r.renderLink)
        reg.Register(ast.KindAutoLink, r.renderAutoLink)
        reg.Register(ast.KindImage, r.renderImage)
        reg.Register(ast.KindHeading, r.renderHeading)
}</span>

func (r *hookedRenderer) renderAttributesForNode(w util.BufWriter, node ast.Node) <span class="cov8" title="1">{
        renderAttributes(w, false, node.Attributes()...)
}</span>

var (

        // Attributes with special meaning that does not make sense to render in HTML.
        attributeExcludes = map[string]bool{
                "hl_lines":    true,
                "hl_style":    true,
                "linenos":     true,
                "linenostart": true,
        }
)

func renderAttributes(w util.BufWriter, skipClass bool, attributes ...ast.Attribute) <span class="cov8" title="1">{
        for _, attr := range attributes </span><span class="cov8" title="1">{
                if skipClass &amp;&amp; bytes.Equal(attr.Name, []byte("class")) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">a := strings.ToLower(string(attr.Name))
                if attributeExcludes[a] || strings.HasPrefix(a, "on") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">_, _ = w.WriteString(" ")
                _, _ = w.Write(attr.Name)
                _, _ = w.WriteString(`="`)

                switch v := attr.Value.(type) </span>{
                case []byte:<span class="cov8" title="1">
                        _, _ = w.Write(util.EscapeHTML(v))</span>
                default:<span class="cov0" title="0">
                        w.WriteString(cast.ToString(v))</span>
                }

                <span class="cov8" title="1">_ = w.WriteByte('"')</span>
        }
}

func (r *hookedRenderer) renderImage(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) <span class="cov0" title="0">{
        n := node.(*ast.Image)
        var h hooks.Renderers

        ctx, ok := w.(*renderContext)
        if ok </span><span class="cov0" title="0">{
                h = ctx.RenderContext().RenderHooks
                ok = h.ImageRenderer != nil
        }</span>

        <span class="cov0" title="0">if !ok </span><span class="cov0" title="0">{
                return r.renderImageDefault(w, source, node, entering)
        }</span>

        <span class="cov0" title="0">if entering </span><span class="cov0" title="0">{
                // Store the current pos so we can capture the rendered text.
                ctx.pos = ctx.Buffer.Len()
                return ast.WalkContinue, nil
        }</span>

        <span class="cov0" title="0">text := ctx.Buffer.Bytes()[ctx.pos:]
        ctx.Buffer.Truncate(ctx.pos)

        err := h.ImageRenderer.RenderLink(
                w,
                linkContext{
                        page:        ctx.DocumentContext().Document,
                        destination: string(n.Destination),
                        title:       string(n.Title),
                        text:        string(text),
                        plainText:   string(n.Text(source)),
                },
        )

        ctx.AddIdentity(h.ImageRenderer)

        return ast.WalkContinue, err</span>
}

// Fall back to the default Goldmark render funcs. Method below borrowed from:
// https://github.com/yuin/goldmark/blob/b611cd333a492416b56aa8d94b04a67bf0096ab2/renderer/html/html.go#L404
func (r *hookedRenderer) renderImageDefault(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) <span class="cov0" title="0">{
        if !entering </span><span class="cov0" title="0">{
                return ast.WalkContinue, nil
        }</span>
        <span class="cov0" title="0">n := node.(*ast.Image)
        _, _ = w.WriteString("&lt;img src=\"")
        if r.Unsafe || !html.IsDangerousURL(n.Destination) </span><span class="cov0" title="0">{
                _, _ = w.Write(util.EscapeHTML(util.URLEscape(n.Destination, true)))
        }</span>
        <span class="cov0" title="0">_, _ = w.WriteString(`" alt="`)
        _, _ = w.Write(n.Text(source))
        _ = w.WriteByte('"')
        if n.Title != nil </span><span class="cov0" title="0">{
                _, _ = w.WriteString(` title="`)
                r.Writer.Write(w, n.Title)
                _ = w.WriteByte('"')
        }</span>
        <span class="cov0" title="0">if r.XHTML </span><span class="cov0" title="0">{
                _, _ = w.WriteString(" /&gt;")
        }</span> else<span class="cov0" title="0"> {
                _, _ = w.WriteString("&gt;")
        }</span>
        <span class="cov0" title="0">return ast.WalkSkipChildren, nil</span>
}

func (r *hookedRenderer) renderLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) <span class="cov8" title="1">{
        n := node.(*ast.Link)
        var h hooks.Renderers

        ctx, ok := w.(*renderContext)
        if ok </span><span class="cov8" title="1">{
                h = ctx.RenderContext().RenderHooks
                ok = h.LinkRenderer != nil
        }</span>

        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return r.renderLinkDefault(w, source, node, entering)
        }</span>

        <span class="cov0" title="0">if entering </span><span class="cov0" title="0">{
                // Store the current pos so we can capture the rendered text.
                ctx.pos = ctx.Buffer.Len()
                return ast.WalkContinue, nil
        }</span>

        <span class="cov0" title="0">text := ctx.Buffer.Bytes()[ctx.pos:]
        ctx.Buffer.Truncate(ctx.pos)

        err := h.LinkRenderer.RenderLink(
                w,
                linkContext{
                        page:        ctx.DocumentContext().Document,
                        destination: string(n.Destination),
                        title:       string(n.Title),
                        text:        string(text),
                        plainText:   string(n.Text(source)),
                },
        )

        // TODO(bep) I have a working branch that fixes these rather confusing identity types,
        // but for now it's important that it's not .GetIdentity() that's added here,
        // to make sure we search the entire chain on changes.
        ctx.AddIdentity(h.LinkRenderer)

        return ast.WalkContinue, err</span>
}

// Fall back to the default Goldmark render funcs. Method below borrowed from:
// https://github.com/yuin/goldmark/blob/b611cd333a492416b56aa8d94b04a67bf0096ab2/renderer/html/html.go#L404
func (r *hookedRenderer) renderLinkDefault(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) <span class="cov8" title="1">{
        n := node.(*ast.Link)
        if entering </span><span class="cov8" title="1">{
                _, _ = w.WriteString("&lt;a href=\"")
                if r.Unsafe || !html.IsDangerousURL(n.Destination) </span><span class="cov8" title="1">{
                        _, _ = w.Write(util.EscapeHTML(util.URLEscape(n.Destination, true)))
                }</span>
                <span class="cov8" title="1">_ = w.WriteByte('"')
                if n.Title != nil </span><span class="cov8" title="1">{
                        _, _ = w.WriteString(` title="`)
                        r.Writer.Write(w, n.Title)
                        _ = w.WriteByte('"')
                }</span>
                <span class="cov8" title="1">_ = w.WriteByte('&gt;')</span>
        } else<span class="cov8" title="1"> {
                _, _ = w.WriteString("&lt;/a&gt;")
        }</span>
        <span class="cov8" title="1">return ast.WalkContinue, nil</span>
}

func (r *hookedRenderer) renderAutoLink(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) <span class="cov8" title="1">{
        if !entering </span><span class="cov8" title="1">{
                return ast.WalkContinue, nil
        }</span>

        <span class="cov8" title="1">n := node.(*ast.AutoLink)
        var h hooks.Renderers

        ctx, ok := w.(*renderContext)
        if ok </span><span class="cov8" title="1">{
                h = ctx.RenderContext().RenderHooks
                ok = h.LinkRenderer != nil
        }</span>

        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return r.renderAutoLinkDefault(w, source, node, entering)
        }</span>

        <span class="cov0" title="0">url := string(n.URL(source))
        label := string(n.Label(source))
        if n.AutoLinkType == ast.AutoLinkEmail &amp;&amp; !strings.HasPrefix(strings.ToLower(url), "mailto:") </span><span class="cov0" title="0">{
                url = "mailto:" + url
        }</span>

        <span class="cov0" title="0">err := h.LinkRenderer.RenderLink(
                w,
                linkContext{
                        page:        ctx.DocumentContext().Document,
                        destination: url,
                        text:        label,
                        plainText:   label,
                },
        )

        // TODO(bep) I have a working branch that fixes these rather confusing identity types,
        // but for now it's important that it's not .GetIdentity() that's added here,
        // to make sure we search the entire chain on changes.
        ctx.AddIdentity(h.LinkRenderer)

        return ast.WalkContinue, err</span>
}

// Fall back to the default Goldmark render funcs. Method below borrowed from:
// https://github.com/yuin/goldmark/blob/5588d92a56fe1642791cf4aa8e9eae8227cfeecd/renderer/html/html.go#L439
func (r *hookedRenderer) renderAutoLinkDefault(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) <span class="cov8" title="1">{
        n := node.(*ast.AutoLink)
        if !entering </span><span class="cov0" title="0">{
                return ast.WalkContinue, nil
        }</span>
        <span class="cov8" title="1">_, _ = w.WriteString(`&lt;a href="`)
        url := n.URL(source)
        label := n.Label(source)
        if n.AutoLinkType == ast.AutoLinkEmail &amp;&amp; !bytes.HasPrefix(bytes.ToLower(url), []byte("mailto:")) </span><span class="cov8" title="1">{
                _, _ = w.WriteString("mailto:")
        }</span>
        <span class="cov8" title="1">_, _ = w.Write(util.EscapeHTML(util.URLEscape(url, false)))
        if n.Attributes() != nil </span><span class="cov0" title="0">{
                _ = w.WriteByte('"')
                html.RenderAttributes(w, n, html.LinkAttributeFilter)
                _ = w.WriteByte('&gt;')
        }</span> else<span class="cov8" title="1"> {
                _, _ = w.WriteString(`"&gt;`)
        }</span>
        <span class="cov8" title="1">_, _ = w.Write(util.EscapeHTML(label))
        _, _ = w.WriteString(`&lt;/a&gt;`)
        return ast.WalkContinue, nil</span>
}

func (r *hookedRenderer) renderHeading(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) <span class="cov8" title="1">{
        n := node.(*ast.Heading)
        var h hooks.Renderers

        ctx, ok := w.(*renderContext)
        if ok </span><span class="cov8" title="1">{
                h = ctx.RenderContext().RenderHooks
                ok = h.HeadingRenderer != nil
        }</span>

        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                return r.renderHeadingDefault(w, source, node, entering)
        }</span>

        <span class="cov0" title="0">if entering </span><span class="cov0" title="0">{
                // Store the current pos so we can capture the rendered text.
                ctx.pos = ctx.Buffer.Len()
                return ast.WalkContinue, nil
        }</span>

        <span class="cov0" title="0">text := ctx.Buffer.Bytes()[ctx.pos:]
        ctx.Buffer.Truncate(ctx.pos)
        // All ast.Heading nodes are guaranteed to have an attribute called "id"
        // that is an array of bytes that encode a valid string.
        anchori, _ := n.AttributeString("id")
        anchor := anchori.([]byte)

        err := h.HeadingRenderer.RenderHeading(
                w,
                headingContext{
                        page:             ctx.DocumentContext().Document,
                        level:            n.Level,
                        anchor:           string(anchor),
                        text:             string(text),
                        plainText:        string(n.Text(source)),
                        attributesHolder: &amp;attributesHolder{astAttributes: n.Attributes()},
                },
        )

        ctx.AddIdentity(h.HeadingRenderer)

        return ast.WalkContinue, err</span>
}

func (r *hookedRenderer) renderHeadingDefault(w util.BufWriter, source []byte, node ast.Node, entering bool) (ast.WalkStatus, error) <span class="cov8" title="1">{
        n := node.(*ast.Heading)
        if entering </span><span class="cov8" title="1">{
                _, _ = w.WriteString("&lt;h")
                _ = w.WriteByte("0123456"[n.Level])
                if n.Attributes() != nil </span><span class="cov8" title="1">{
                        r.renderAttributesForNode(w, node)
                }</span>
                <span class="cov8" title="1">_ = w.WriteByte('&gt;')</span>
        } else<span class="cov8" title="1"> {
                _, _ = w.WriteString("&lt;/h")
                _ = w.WriteByte("0123456"[n.Level])
                _, _ = w.WriteString("&gt;\n")
        }</span>
        <span class="cov8" title="1">return ast.WalkContinue, nil</span>
}

type links struct {
}

// Extend implements goldmark.Extender.
func (e *links) Extend(m goldmark.Markdown) <span class="cov8" title="1">{
        m.Renderer().AddOptions(renderer.WithNodeRenderers(
                util.Prioritized(newLinkRenderer(), 100),
        ))
}</span>
</pre>
		
		<pre class="file" id="file159" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package goldmark

import (
        "bytes"

        "github.com/gohugoio/hugo/markup/tableofcontents"

        "github.com/yuin/goldmark"
        "github.com/yuin/goldmark/ast"
        "github.com/yuin/goldmark/parser"
        "github.com/yuin/goldmark/renderer"
        "github.com/yuin/goldmark/text"
        "github.com/yuin/goldmark/util"
)

var (
        tocResultKey = parser.NewContextKey()
        tocEnableKey = parser.NewContextKey()
)

type tocTransformer struct {
        r renderer.Renderer
}

func (t *tocTransformer) Transform(n *ast.Document, reader text.Reader, pc parser.Context) <span class="cov8" title="1">{
        if b, ok := pc.Get(tocEnableKey).(bool); !ok || !b </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">var (
                toc         tableofcontents.Root
                tocHeading  tableofcontents.Heading
                level       int
                row         = -1
                inHeading   bool
                headingText bytes.Buffer
        )

        ast.Walk(n, func(n ast.Node, entering bool) (ast.WalkStatus, error) </span><span class="cov8" title="1">{
                s := ast.WalkStatus(ast.WalkContinue)
                if n.Kind() == ast.KindHeading </span><span class="cov8" title="1">{
                        if inHeading &amp;&amp; !entering </span><span class="cov8" title="1">{
                                tocHeading.Text = headingText.String()
                                headingText.Reset()
                                toc.AddAt(tocHeading, row, level-1)
                                tocHeading = tableofcontents.Heading{}
                                inHeading = false
                                return s, nil
                        }</span>

                        <span class="cov8" title="1">inHeading = true</span>
                }

                <span class="cov8" title="1">if !(inHeading &amp;&amp; entering) </span><span class="cov8" title="1">{
                        return s, nil
                }</span>

                <span class="cov8" title="1">switch n.Kind() </span>{
                case ast.KindHeading:<span class="cov8" title="1">
                        heading := n.(*ast.Heading)
                        level = heading.Level

                        if level == 1 || row == -1 </span><span class="cov8" title="1">{
                                row++
                        }</span>

                        <span class="cov8" title="1">id, found := heading.AttributeString("id")
                        if found </span><span class="cov8" title="1">{
                                tocHeading.ID = string(id.([]byte))
                        }</span>
                case
                        ast.KindCodeSpan,
                        ast.KindLink,
                        ast.KindImage,
                        ast.KindEmphasis:<span class="cov8" title="1">
                        err := t.r.Render(&amp;headingText, reader.Source(), n)
                        if err != nil </span><span class="cov0" title="0">{
                                return s, err
                        }</span>

                        <span class="cov8" title="1">return ast.WalkSkipChildren, nil</span>
                case
                        ast.KindAutoLink,
                        ast.KindRawHTML,
                        ast.KindText,
                        ast.KindString:<span class="cov8" title="1">
                        err := t.r.Render(&amp;headingText, reader.Source(), n)
                        if err != nil </span><span class="cov0" title="0">{
                                return s, err
                        }</span>
                }

                <span class="cov8" title="1">return s, nil</span>
        })

        <span class="cov8" title="1">pc.Set(tocResultKey, toc)</span>
}

type tocExtension struct {
        options []renderer.Option
}

func newTocExtension(options []renderer.Option) goldmark.Extender <span class="cov8" title="1">{
        return &amp;tocExtension{
                options: options,
        }
}</span>

func (e *tocExtension) Extend(m goldmark.Markdown) <span class="cov8" title="1">{
        r := goldmark.DefaultRenderer()
        r.AddOptions(e.options...)
        m.Parser().AddOptions(parser.WithASTTransformers(util.Prioritized(&amp;tocTransformer{
                r: r,
        }, 10)))
}</span>
</pre>
		
		<pre class="file" id="file160" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package highlight provides code highlighting.
package highlight

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/alecthomas/chroma/formatters/html"

        "github.com/gohugoio/hugo/config"

        "github.com/mitchellh/mapstructure"
)

var DefaultConfig = Config{
        // The highlighter style to use.
        // See https://xyproto.github.io/splash/docs/all.html
        Style:              "monokai",
        LineNoStart:        1,
        CodeFences:         true,
        NoClasses:          true,
        LineNumbersInTable: true,
        TabWidth:           4,
}

//
type Config struct {
        Style string

        CodeFences bool

        // Use inline CSS styles.
        NoClasses bool

        // When set, line numbers will be printed.
        LineNos            bool
        LineNumbersInTable bool

        // When set, add links to line numbers
        AnchorLineNos bool
        LineAnchors   string

        // Start the line numbers from this value (default is 1).
        LineNoStart int

        // A space separated list of line numbers, e.g. “3-8 10-20”.
        Hl_Lines string

        // TabWidth sets the number of characters for a tab. Defaults to 4.
        TabWidth int

        GuessSyntax bool
}

func (cfg Config) ToHTMLOptions() []html.Option <span class="cov8" title="1">{
        var lineAnchors string
        if cfg.LineAnchors != "" </span><span class="cov8" title="1">{
                lineAnchors = cfg.LineAnchors + "-"
        }</span>
        <span class="cov8" title="1">options := []html.Option{
                html.TabWidth(cfg.TabWidth),
                html.WithLineNumbers(cfg.LineNos),
                html.BaseLineNumber(cfg.LineNoStart),
                html.LineNumbersInTable(cfg.LineNumbersInTable),
                html.WithClasses(!cfg.NoClasses),
                html.LinkableLineNumbers(cfg.AnchorLineNos, lineAnchors),
        }

        if cfg.Hl_Lines != "" </span><span class="cov8" title="1">{
                ranges, err := hlLinesToRanges(cfg.LineNoStart, cfg.Hl_Lines)
                if err == nil </span><span class="cov8" title="1">{
                        options = append(options, html.HighlightLines(ranges))
                }</span>
        }

        <span class="cov8" title="1">return options</span>
}

func applyOptionsFromString(opts string, cfg *Config) error <span class="cov8" title="1">{
        optsm, err := parseOptions(opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return mapstructure.WeakDecode(optsm, cfg)</span>
}

// ApplyLegacyConfig applies legacy config from back when we had
// Pygments.
func ApplyLegacyConfig(cfg config.Provider, conf *Config) error <span class="cov8" title="1">{
        if conf.Style == DefaultConfig.Style </span><span class="cov8" title="1">{
                if s := cfg.GetString("pygmentsStyle"); s != "" </span><span class="cov8" title="1">{
                        conf.Style = s
                }</span>
        }

        <span class="cov8" title="1">if conf.NoClasses == DefaultConfig.NoClasses &amp;&amp; cfg.IsSet("pygmentsUseClasses") </span><span class="cov8" title="1">{
                conf.NoClasses = !cfg.GetBool("pygmentsUseClasses")
        }</span>

        <span class="cov8" title="1">if conf.CodeFences == DefaultConfig.CodeFences &amp;&amp; cfg.IsSet("pygmentsCodeFences") </span><span class="cov8" title="1">{
                conf.CodeFences = cfg.GetBool("pygmentsCodeFences")
        }</span>

        <span class="cov8" title="1">if conf.GuessSyntax == DefaultConfig.GuessSyntax &amp;&amp; cfg.IsSet("pygmentsCodefencesGuessSyntax") </span><span class="cov0" title="0">{
                conf.GuessSyntax = cfg.GetBool("pygmentsCodefencesGuessSyntax")
        }</span>

        <span class="cov8" title="1">if cfg.IsSet("pygmentsOptions") </span><span class="cov8" title="1">{
                if err := applyOptionsFromString(cfg.GetString("pygmentsOptions"), conf); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func parseOptions(in string) (map[string]interface{}, error) <span class="cov8" title="1">{
        in = strings.Trim(in, " ")
        opts := make(map[string]interface{})

        if in == "" </span><span class="cov0" title="0">{
                return opts, nil
        }</span>

        <span class="cov8" title="1">for _, v := range strings.Split(in, ",") </span><span class="cov8" title="1">{
                keyVal := strings.Split(v, "=")
                key := strings.ToLower(strings.Trim(keyVal[0], " "))
                if len(keyVal) != 2 </span><span class="cov0" title="0">{
                        return opts, fmt.Errorf("invalid Highlight option: %s", key)
                }</span>
                <span class="cov8" title="1">if key == "linenos" </span><span class="cov8" title="1">{
                        opts[key] = keyVal[1] != "false"
                        if keyVal[1] == "table" || keyVal[1] == "inline" </span><span class="cov8" title="1">{
                                opts["lineNumbersInTable"] = keyVal[1] == "table"
                        }</span>
                } else<span class="cov8" title="1"> {
                        opts[key] = keyVal[1]
                }</span>
        }

        <span class="cov8" title="1">return opts, nil</span>
}

// startLine compensates for https://github.com/alecthomas/chroma/issues/30
func hlLinesToRanges(startLine int, s string) ([][2]int, error) <span class="cov8" title="1">{
        var ranges [][2]int
        s = strings.TrimSpace(s)

        if s == "" </span><span class="cov0" title="0">{
                return ranges, nil
        }</span>

        // Variants:
        // 1 2 3 4
        // 1-2 3-4
        // 1-2 3
        // 1 3-4
        // 1    3-4
        <span class="cov8" title="1">fields := strings.Split(s, " ")
        for _, field := range fields </span><span class="cov8" title="1">{
                field = strings.TrimSpace(field)
                if field == "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">numbers := strings.Split(field, "-")
                var r [2]int
                first, err := strconv.Atoi(numbers[0])
                if err != nil </span><span class="cov0" title="0">{
                        return ranges, err
                }</span>
                <span class="cov8" title="1">first = first + startLine - 1
                r[0] = first
                if len(numbers) &gt; 1 </span><span class="cov8" title="1">{
                        second, err := strconv.Atoi(numbers[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return ranges, err
                        }</span>
                        <span class="cov8" title="1">second = second + startLine - 1
                        r[1] = second</span>
                } else<span class="cov8" title="1"> {
                        r[1] = first
                }</span>

                <span class="cov8" title="1">ranges = append(ranges, r)</span>
        }
        <span class="cov8" title="1">return ranges, nil</span>
}
</pre>
		
		<pre class="file" id="file161" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package highlight

import (
        "fmt"
        gohtml "html"
        "io"
        "strings"

        "github.com/alecthomas/chroma"
        "github.com/alecthomas/chroma/formatters/html"
        "github.com/alecthomas/chroma/lexers"
        "github.com/alecthomas/chroma/styles"
        hl "github.com/yuin/goldmark-highlighting"
)

func New(cfg Config) Highlighter <span class="cov8" title="1">{
        return Highlighter{
                cfg: cfg,
        }
}</span>

type Highlighter struct {
        cfg Config
}

func (h Highlighter) Highlight(code, lang, optsStr string) (string, error) <span class="cov8" title="1">{
        if optsStr == "" </span><span class="cov8" title="1">{
                return highlight(code, lang, h.cfg)
        }</span>

        <span class="cov8" title="1">cfg := h.cfg
        if err := applyOptionsFromString(optsStr, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return highlight(code, lang, cfg)</span>
}

func highlight(code, lang string, cfg Config) (string, error) <span class="cov8" title="1">{
        w := &amp;strings.Builder{}
        var lexer chroma.Lexer
        if lang != "" </span><span class="cov8" title="1">{
                lexer = lexers.Get(lang)
        }</span>

        <span class="cov8" title="1">if lexer == nil &amp;&amp; cfg.GuessSyntax </span><span class="cov8" title="1">{
                lexer = lexers.Analyse(code)
                if lexer == nil </span><span class="cov8" title="1">{
                        lexer = lexers.Fallback
                }</span>
                <span class="cov8" title="1">lang = strings.ToLower(lexer.Config().Name)</span>
        }

        <span class="cov8" title="1">if lexer == nil </span><span class="cov8" title="1">{
                wrapper := getPreWrapper(lang)
                fmt.Fprint(w, wrapper.Start(true, ""))
                fmt.Fprint(w, gohtml.EscapeString(code))
                fmt.Fprint(w, wrapper.End(true))
                return w.String(), nil
        }</span>

        <span class="cov8" title="1">style := styles.Get(cfg.Style)
        if style == nil </span><span class="cov0" title="0">{
                style = styles.Fallback
        }</span>
        <span class="cov8" title="1">lexer = chroma.Coalesce(lexer)

        iterator, err := lexer.Tokenise(nil, code)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">options := cfg.ToHTMLOptions()
        options = append(options, getHtmlPreWrapper(lang))

        formatter := html.New(options...)

        fmt.Fprint(w, `&lt;div class="highlight"&gt;`)
        if err := formatter.Format(w, style, iterator); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">fmt.Fprint(w, `&lt;/div&gt;`)

        return w.String(), nil</span>
}

func GetCodeBlockOptions() func(ctx hl.CodeBlockContext) []html.Option <span class="cov0" title="0">{
        return func(ctx hl.CodeBlockContext) []html.Option </span><span class="cov0" title="0">{
                var language string
                if l, ok := ctx.Language(); ok </span><span class="cov0" title="0">{
                        language = string(l)
                }</span>
                <span class="cov0" title="0">return []html.Option{
                        getHtmlPreWrapper(language),
                }</span>
        }
}

func getPreWrapper(language string) preWrapper <span class="cov8" title="1">{
        return preWrapper{language: language}
}</span>

func getHtmlPreWrapper(language string) html.Option <span class="cov8" title="1">{
        return html.WithPreWrapper(getPreWrapper(language))
}</span>

type preWrapper struct {
        language string
}

func (p preWrapper) Start(code bool, styleAttr string) string <span class="cov8" title="1">{
        var language string
        if code </span><span class="cov8" title="1">{
                language = p.language
        }</span>
        <span class="cov8" title="1">w := &amp;strings.Builder{}
        WritePreStart(w, language, styleAttr)
        return w.String()</span>
}

func WritePreStart(w io.Writer, language, styleAttr string) <span class="cov8" title="1">{
        fmt.Fprintf(w, `&lt;pre tabindex="0"%s&gt;`, styleAttr)
        fmt.Fprint(w, "&lt;code")
        if language != "" </span><span class="cov8" title="1">{
                fmt.Fprint(w, ` class="language-`+language+`"`)
                fmt.Fprint(w, ` data-lang="`+language+`"`)
        }</span>
        <span class="cov8" title="1">fmt.Fprint(w, "&gt;")</span>
}

const preEnd = "&lt;/code&gt;&lt;/pre&gt;"

func (p preWrapper) End(code bool) string <span class="cov8" title="1">{
        return preEnd
}</span>

func WritePreEnd(w io.Writer) <span class="cov0" title="0">{
        fmt.Fprint(w, preEnd)
}</span>
</pre>
		
		<pre class="file" id="file162" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package markup

import (
        "strings"

        "github.com/gohugoio/hugo/markup/highlight"

        "github.com/gohugoio/hugo/markup/markup_config"

        "github.com/gohugoio/hugo/markup/goldmark"

        "github.com/gohugoio/hugo/markup/org"

        "github.com/gohugoio/hugo/markup/asciidocext"
        "github.com/gohugoio/hugo/markup/blackfriday"
        "github.com/gohugoio/hugo/markup/converter"
        "github.com/gohugoio/hugo/markup/pandoc"
        "github.com/gohugoio/hugo/markup/rst"
)

func NewConverterProvider(cfg converter.ProviderConfig) (ConverterProvider, error) <span class="cov8" title="1">{
        converters := make(map[string]converter.Provider)

        markupConfig, err := markup_config.Decode(cfg.Cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if cfg.Highlight == nil </span><span class="cov8" title="1">{
                h := highlight.New(markupConfig.Highlight)
                cfg.Highlight = func(code, lang, optsStr string) (string, error) </span><span class="cov0" title="0">{
                        return h.Highlight(code, lang, optsStr)
                }</span>
        }

        <span class="cov8" title="1">cfg.MarkupConfig = markupConfig

        add := func(p converter.ProviderProvider, aliases ...string) error </span><span class="cov8" title="1">{
                c, err := p.New(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">name := c.Name()

                aliases = append(aliases, name)

                if strings.EqualFold(name, cfg.MarkupConfig.DefaultMarkdownHandler) </span><span class="cov8" title="1">{
                        aliases = append(aliases, "markdown")
                }</span>

                <span class="cov8" title="1">addConverter(converters, c, aliases...)
                return nil</span>
        }

        <span class="cov8" title="1">if err := add(goldmark.Provider); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := add(blackfriday.Provider); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := add(asciidocext.Provider, "ad", "adoc"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := add(rst.Provider); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := add(pandoc.Provider, "pdc"); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if err := add(org.Provider); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;converterRegistry{
                config:     cfg,
                converters: converters,
        }, nil</span>
}

type ConverterProvider interface {
        Get(name string) converter.Provider
        // Default() converter.Provider
        GetMarkupConfig() markup_config.Config
        Highlight(code, lang, optsStr string) (string, error)
}

type converterRegistry struct {
        // Maps name (md, markdown, blackfriday etc.) to a converter provider.
        // Note that this is also used for aliasing, so the same converter
        // may be registered multiple times.
        // All names are lower case.
        converters map[string]converter.Provider

        config converter.ProviderConfig
}

func (r *converterRegistry) Get(name string) converter.Provider <span class="cov8" title="1">{
        return r.converters[strings.ToLower(name)]
}</span>

func (r *converterRegistry) Highlight(code, lang, optsStr string) (string, error) <span class="cov0" title="0">{
        return r.config.Highlight(code, lang, optsStr)
}</span>

func (r *converterRegistry) GetMarkupConfig() markup_config.Config <span class="cov8" title="1">{
        return r.config.MarkupConfig
}</span>

func addConverter(m map[string]converter.Provider, c converter.Provider, aliases ...string) <span class="cov8" title="1">{
        for _, alias := range aliases </span><span class="cov8" title="1">{
                m[alias] = c
        }</span>
}
</pre>
		
		<pre class="file" id="file163" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package markup_config

import (
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/docshelper"
        "github.com/gohugoio/hugo/markup/asciidocext/asciidocext_config"
        "github.com/gohugoio/hugo/markup/blackfriday/blackfriday_config"
        "github.com/gohugoio/hugo/markup/goldmark/goldmark_config"
        "github.com/gohugoio/hugo/markup/highlight"
        "github.com/gohugoio/hugo/markup/tableofcontents"
        "github.com/gohugoio/hugo/parser"
        "github.com/mitchellh/mapstructure"
)

type Config struct {
        // Default markdown handler for md/markdown extensions.
        // Default is "goldmark".
        // Before Hugo 0.60 this was "blackfriday".
        DefaultMarkdownHandler string

        Highlight       highlight.Config
        TableOfContents tableofcontents.Config

        // Content renderers
        Goldmark    goldmark_config.Config
        BlackFriday blackfriday_config.Config

        AsciidocExt asciidocext_config.Config
}

func Decode(cfg config.Provider) (conf Config, err error) <span class="cov8" title="1">{
        conf = Default

        m := cfg.GetStringMap("markup")
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">normalizeConfig(m)

        err = mapstructure.WeakDecode(m, &amp;conf)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if err = applyLegacyConfig(cfg, &amp;conf); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if err = highlight.ApplyLegacyConfig(cfg, &amp;conf.Highlight); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

func normalizeConfig(m map[string]interface{}) <span class="cov8" title="1">{
        v, err := maps.GetNestedParam("goldmark.parser", ".", m)
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">vm := maps.ToStringMap(v)
        // Changed from a bool in 0.81.0
        if vv, found := vm["attribute"]; found </span><span class="cov8" title="1">{
                if vvb, ok := vv.(bool); ok </span><span class="cov8" title="1">{
                        vm["attribute"] = goldmark_config.ParserAttribute{
                                Title: vvb,
                        }
                }</span>
        }
}

func applyLegacyConfig(cfg config.Provider, conf *Config) error <span class="cov8" title="1">{
        if bm := cfg.GetStringMap("blackfriday"); bm != nil </span><span class="cov8" title="1">{
                // Legacy top level blackfriday config.
                err := mapstructure.WeakDecode(bm, &amp;conf.BlackFriday)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">if conf.BlackFriday.FootnoteAnchorPrefix == "" </span><span class="cov8" title="1">{
                conf.BlackFriday.FootnoteAnchorPrefix = cfg.GetString("footnoteAnchorPrefix")
        }</span>

        <span class="cov8" title="1">if conf.BlackFriday.FootnoteReturnLinkContents == "" </span><span class="cov8" title="1">{
                conf.BlackFriday.FootnoteReturnLinkContents = cfg.GetString("footnoteReturnLinkContents")
        }</span>

        <span class="cov8" title="1">return nil</span>
}

var Default = Config{
        DefaultMarkdownHandler: "goldmark",

        TableOfContents: tableofcontents.DefaultConfig,
        Highlight:       highlight.DefaultConfig,

        Goldmark:    goldmark_config.Default,
        BlackFriday: blackfriday_config.Default,

        AsciidocExt: asciidocext_config.Default,
}

func init() <span class="cov8" title="1">{
        docsProvider := func() docshelper.DocProvider </span><span class="cov0" title="0">{
                return docshelper.DocProvider{"config": map[string]interface{}{"markup": parser.LowerCaseCamelJSONMarshaller{Value: Default}}}
        }</span>
        <span class="cov8" title="1">docshelper.AddDocProviderFunc(docsProvider)</span>
}
</pre>
		
		<pre class="file" id="file164" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package org converts Emacs Org-Mode to HTML.
package org

import (
        "bytes"

        "github.com/gohugoio/hugo/identity"

        "github.com/gohugoio/hugo/markup/converter"
        "github.com/niklasfasching/go-org/org"
        "github.com/spf13/afero"
)

// Provider is the package entry point.
var Provider converter.ProviderProvider = provide{}

type provide struct {
}

func (p provide) New(cfg converter.ProviderConfig) (converter.Provider, error) <span class="cov8" title="1">{
        return converter.NewProvider("org", func(ctx converter.DocumentContext) (converter.Converter, error) </span><span class="cov8" title="1">{
                return &amp;orgConverter{
                        ctx: ctx,
                        cfg: cfg,
                }, nil
        }</span>), nil
}

type orgConverter struct {
        ctx converter.DocumentContext
        cfg converter.ProviderConfig
}

func (c *orgConverter) Convert(ctx converter.RenderContext) (converter.Result, error) <span class="cov8" title="1">{
        logger := c.cfg.Logger
        config := org.New()
        config.Log = logger.Warn()
        config.ReadFile = func(filename string) ([]byte, error) </span><span class="cov0" title="0">{
                return afero.ReadFile(c.cfg.ContentFs, filename)
        }</span>
        <span class="cov8" title="1">writer := org.NewHTMLWriter()
        writer.HighlightCodeBlock = func(source, lang string, inline bool) string </span><span class="cov0" title="0">{
                highlightedSource, err := c.cfg.Highlight(source, lang, "")
                if err != nil </span><span class="cov0" title="0">{
                        logger.Errorf("Could not highlight source as lang %s. Using raw source.", lang)
                        return source
                }</span>
                <span class="cov0" title="0">return highlightedSource</span>
        }

        <span class="cov8" title="1">html, err := config.Parse(bytes.NewReader(ctx.Src), c.ctx.DocumentName).Write(writer)
        if err != nil </span><span class="cov0" title="0">{
                logger.Errorf("Could not render org: %s. Using unrendered content.", err)
                return converter.Bytes(ctx.Src), nil
        }</span>
        <span class="cov8" title="1">return converter.Bytes([]byte(html)), nil</span>
}

func (c *orgConverter) Supports(feature identity.Identity) bool <span class="cov0" title="0">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file165" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package pandoc converts content to HTML using Pandoc as an external helper.
package pandoc

import (
        "github.com/gohugoio/hugo/common/hexec"
        "github.com/gohugoio/hugo/htesting"
        "github.com/gohugoio/hugo/identity"
        "github.com/gohugoio/hugo/markup/internal"

        "github.com/gohugoio/hugo/markup/converter"
)

// Provider is the package entry point.
var Provider converter.ProviderProvider = provider{}

type provider struct {
}

func (p provider) New(cfg converter.ProviderConfig) (converter.Provider, error) <span class="cov0" title="0">{
        return converter.NewProvider("pandoc", func(ctx converter.DocumentContext) (converter.Converter, error) </span><span class="cov0" title="0">{
                return &amp;pandocConverter{
                        ctx: ctx,
                        cfg: cfg,
                }, nil
        }</span>), nil
}

type pandocConverter struct {
        ctx converter.DocumentContext
        cfg converter.ProviderConfig
}

func (c *pandocConverter) Convert(ctx converter.RenderContext) (converter.Result, error) <span class="cov0" title="0">{
        b, err := c.getPandocContent(ctx.Src, c.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return converter.Bytes(b), nil</span>
}

func (c *pandocConverter) Supports(feature identity.Identity) bool <span class="cov0" title="0">{
        return false
}</span>

// getPandocContent calls pandoc as an external helper to convert pandoc markdown to HTML.
func (c *pandocConverter) getPandocContent(src []byte, ctx converter.DocumentContext) ([]byte, error) <span class="cov0" title="0">{
        logger := c.cfg.Logger
        binaryName := getPandocBinaryName()
        if binaryName == "" </span><span class="cov0" title="0">{
                logger.Println("pandoc not found in $PATH: Please install.\n",
                        "                 Leaving pandoc content unrendered.")
                return src, nil
        }</span>
        <span class="cov0" title="0">args := []string{"--mathjax"}
        return internal.ExternallyRenderContent(c.cfg, ctx, src, binaryName, args)</span>
}

const pandocBinary = "pandoc"

func getPandocBinaryName() string <span class="cov8" title="1">{
        if hexec.InPath(pandocBinary) </span><span class="cov0" title="0">{
                return pandocBinary
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// Supports returns whether Pandoc is installed on this computer.
func Supports() bool <span class="cov8" title="1">{
        hasBin := getPandocBinaryName() != ""
        if htesting.SupportsAll() </span><span class="cov0" title="0">{
                if !hasBin </span><span class="cov0" title="0">{
                        panic("pandoc not installed")</span>
                }
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov8" title="1">return hasBin</span>
}
</pre>
		
		<pre class="file" id="file166" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package rst converts content to HTML using the RST external helper.
package rst

import (
        "bytes"
        "runtime"

        "github.com/gohugoio/hugo/common/hexec"
        "github.com/gohugoio/hugo/htesting"

        "github.com/gohugoio/hugo/identity"
        "github.com/gohugoio/hugo/markup/internal"

        "github.com/gohugoio/hugo/markup/converter"
)

// Provider is the package entry point.
var Provider converter.ProviderProvider = provider{}

type provider struct {
}

func (p provider) New(cfg converter.ProviderConfig) (converter.Provider, error) <span class="cov0" title="0">{
        return converter.NewProvider("rst", func(ctx converter.DocumentContext) (converter.Converter, error) </span><span class="cov0" title="0">{
                return &amp;rstConverter{
                        ctx: ctx,
                        cfg: cfg,
                }, nil
        }</span>), nil
}

type rstConverter struct {
        ctx converter.DocumentContext
        cfg converter.ProviderConfig
}

func (c *rstConverter) Convert(ctx converter.RenderContext) (converter.Result, error) <span class="cov0" title="0">{
        b, err := c.getRstContent(ctx.Src, c.ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return converter.Bytes(b), nil</span>
}

func (c *rstConverter) Supports(feature identity.Identity) bool <span class="cov0" title="0">{
        return false
}</span>

// getRstContent calls the Python script rst2html as an external helper
// to convert reStructuredText content to HTML.
func (c *rstConverter) getRstContent(src []byte, ctx converter.DocumentContext) ([]byte, error) <span class="cov0" title="0">{
        logger := c.cfg.Logger
        binaryName, binaryPath := getRstBinaryNameAndPath()

        if binaryName == "" </span><span class="cov0" title="0">{
                logger.Println("rst2html / rst2html.py not found in $PATH: Please install.\n",
                        "                 Leaving reStructuredText content unrendered.")
                return src, nil
        }</span>

        <span class="cov0" title="0">logger.Infoln("Rendering", ctx.DocumentName, "with", binaryName, "...")

        var result []byte
        var err error

        // certain *nix based OSs wrap executables in scripted launchers
        // invoking binaries on these OSs via python interpreter causes SyntaxError
        // invoke directly so that shebangs work as expected
        // handle Windows manually because it doesn't do shebangs
        if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                pythonBinary, _ := internal.GetPythonBinaryAndExecPath()
                args := []string{binaryPath, "--leave-comments", "--initial-header-level=2"}
                result, err = internal.ExternallyRenderContent(c.cfg, ctx, src, pythonBinary, args)
        }</span> else<span class="cov0" title="0"> {
                args := []string{"--leave-comments", "--initial-header-level=2"}
                result, err = internal.ExternallyRenderContent(c.cfg, ctx, src, binaryName, args)
        }</span>

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // TODO(bep) check if rst2html has a body only option.
        <span class="cov0" title="0">bodyStart := bytes.Index(result, []byte("&lt;body&gt;\n"))
        if bodyStart &lt; 0 </span><span class="cov0" title="0">{
                bodyStart = -7 // compensate for length
        }</span>

        <span class="cov0" title="0">bodyEnd := bytes.Index(result, []byte("\n&lt;/body&gt;"))
        if bodyEnd &lt; 0 || bodyEnd &gt;= len(result) </span><span class="cov0" title="0">{
                bodyEnd = len(result) - 1
                if bodyEnd &lt; 0 </span><span class="cov0" title="0">{
                        bodyEnd = 0
                }</span>
        }

        <span class="cov0" title="0">return result[bodyStart+7 : bodyEnd], err</span>
}

var rst2Binaries = []string{"rst2html", "rst2html.py"}

func getRstBinaryNameAndPath() (string, string) <span class="cov8" title="1">{
        for _, candidate := range rst2Binaries </span><span class="cov8" title="1">{
                if pth := hexec.LookPath(candidate); pth != "" </span><span class="cov0" title="0">{
                        return candidate, pth
                }</span>
        }
        <span class="cov8" title="1">return "", ""</span>
}

// Supports returns whether rst is (or should be) installed on this computer.
func Supports() bool <span class="cov8" title="1">{
        name, _ := getRstBinaryNameAndPath()
        hasBin := name != ""
        if htesting.SupportsAll() </span><span class="cov0" title="0">{
                if !hasBin </span><span class="cov0" title="0">{
                        panic("rst not installed")</span>
                }
                <span class="cov0" title="0">return true</span>
        }
        <span class="cov8" title="1">return hasBin</span>
}
</pre>
		
		<pre class="file" id="file167" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tableofcontents

import (
        "strings"
)

// Headings holds the top level headings.
type Headings []Heading

// Heading holds the data about a heading and its children.
type Heading struct {
        ID   string
        Text string

        Headings Headings
}

// IsZero is true when no ID or Text is set.
func (h Heading) IsZero() bool <span class="cov8" title="1">{
        return h.ID == "" &amp;&amp; h.Text == ""
}</span>

// Root implements AddAt, which can be used to build the
// data structure for the ToC.
type Root struct {
        Headings Headings
}

// AddAt adds the heading into the given location.
func (toc *Root) AddAt(h Heading, row, level int) <span class="cov8" title="1">{
        for i := len(toc.Headings); i &lt;= row; i++ </span><span class="cov8" title="1">{
                toc.Headings = append(toc.Headings, Heading{})
        }</span>

        <span class="cov8" title="1">if level == 0 </span><span class="cov8" title="1">{
                toc.Headings[row] = h
                return
        }</span>

        <span class="cov8" title="1">heading := &amp;toc.Headings[row]

        for i := 1; i &lt; level; i++ </span><span class="cov8" title="1">{
                if len(heading.Headings) == 0 </span><span class="cov8" title="1">{
                        heading.Headings = append(heading.Headings, Heading{})
                }</span>
                <span class="cov8" title="1">heading = &amp;heading.Headings[len(heading.Headings)-1]</span>
        }
        <span class="cov8" title="1">heading.Headings = append(heading.Headings, h)</span>
}

// ToHTML renders the ToC as HTML.
func (toc Root) ToHTML(startLevel, stopLevel int, ordered bool) string <span class="cov8" title="1">{
        b := &amp;tocBuilder{
                s:          strings.Builder{},
                h:          toc.Headings,
                startLevel: startLevel,
                stopLevel:  stopLevel,
                ordered:    ordered,
        }
        b.Build()
        return b.s.String()
}</span>

type tocBuilder struct {
        s strings.Builder
        h Headings

        startLevel int
        stopLevel  int
        ordered    bool
}

func (b *tocBuilder) Build() <span class="cov8" title="1">{
        b.writeNav(b.h)
}</span>

func (b *tocBuilder) writeNav(h Headings) <span class="cov8" title="1">{
        b.s.WriteString("&lt;nav id=\"TableOfContents\"&gt;")
        b.writeHeadings(1, 0, b.h)
        b.s.WriteString("&lt;/nav&gt;")
}</span>

func (b *tocBuilder) writeHeadings(level, indent int, h Headings) <span class="cov8" title="1">{
        if level &lt; b.startLevel </span><span class="cov8" title="1">{
                for _, h := range h </span><span class="cov8" title="1">{
                        b.writeHeadings(level+1, indent, h.Headings)
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">if b.stopLevel != -1 &amp;&amp; level &gt; b.stopLevel </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">hasChildren := len(h) &gt; 0

        if hasChildren </span><span class="cov8" title="1">{
                b.s.WriteString("\n")
                b.indent(indent + 1)
                if b.ordered </span><span class="cov8" title="1">{
                        b.s.WriteString("&lt;ol&gt;\n")
                }</span> else<span class="cov8" title="1"> {
                        b.s.WriteString("&lt;ul&gt;\n")
                }</span>
        }

        <span class="cov8" title="1">for _, h := range h </span><span class="cov8" title="1">{
                b.writeHeading(level+1, indent+2, h)
        }</span>

        <span class="cov8" title="1">if hasChildren </span><span class="cov8" title="1">{
                b.indent(indent + 1)
                if b.ordered </span><span class="cov8" title="1">{
                        b.s.WriteString("&lt;/ol&gt;")
                }</span> else<span class="cov8" title="1"> {
                        b.s.WriteString("&lt;/ul&gt;")
                }</span>
                <span class="cov8" title="1">b.s.WriteString("\n")
                b.indent(indent)</span>
        }
}

func (b *tocBuilder) writeHeading(level, indent int, h Heading) <span class="cov8" title="1">{
        b.indent(indent)
        b.s.WriteString("&lt;li&gt;")
        if !h.IsZero() </span><span class="cov8" title="1">{
                b.s.WriteString("&lt;a href=\"#" + h.ID + "\"&gt;" + h.Text + "&lt;/a&gt;")
        }</span>
        <span class="cov8" title="1">b.writeHeadings(level, indent, h.Headings)
        b.s.WriteString("&lt;/li&gt;\n")</span>
}

func (b *tocBuilder) indent(n int) <span class="cov8" title="1">{
        for i := 0; i &lt; n; i++ </span><span class="cov8" title="1">{
                b.s.WriteString("  ")
        }</span>
}

// DefaultConfig is the default ToC configuration.
var DefaultConfig = Config{
        StartLevel: 2,
        EndLevel:   3,
        Ordered:    false,
}

type Config struct {
        // Heading start level to include in the table of contents, starting
        // at h1 (inclusive).
        StartLevel int

        // Heading end level, inclusive, to include in the table of contents.
        // Default is 3, a value of -1 will include everything.
        EndLevel int

        // Whether to produce a ordered list or not.
        Ordered bool
}
</pre>
		
		<pre class="file" id="file168" style="display: none">package media

import (
        "github.com/gohugoio/hugo/docshelper"
)

// This is is just some helpers used to create some JSON used in the Hugo docs.
func init() <span class="cov8" title="1">{
        docsProvider := func() docshelper.DocProvider </span><span class="cov0" title="0">{
                return docshelper.DocProvider{"media": map[string]interface{}{"types": DefaultTypes}}
        }</span>
        <span class="cov8" title="1">docshelper.AddDocProviderFunc(docsProvider)</span>
}
</pre>
		
		<pre class="file" id="file169" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package media

import (
        "encoding/json"
        "errors"
        "fmt"
        "net/http"
        "sort"
        "strings"

        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/mitchellh/mapstructure"
)

var zero Type

const (
        defaultDelimiter = "."
)

// Type (also known as MIME type and content type) is a two-part identifier for
// file formats and format contents transmitted on the Internet.
// For Hugo's use case, we use the top-level type name / subtype name + suffix.
// One example would be application/svg+xml
// If suffix is not provided, the sub type will be used.
// See // https://en.wikipedia.org/wiki/Media_type
type Type struct {
        MainType  string `json:"mainType"`  // i.e. text
        SubType   string `json:"subType"`   // i.e. html
        Delimiter string `json:"delimiter"` // e.g. "."

        // FirstSuffix holds the first suffix defined for this Type.
        FirstSuffix SuffixInfo `json:"firstSuffix"`

        // This is the optional suffix after the "+" in the MIME type,
        //  e.g. "xml" in "application/rss+xml".
        mimeSuffix string

        // E.g. "jpg,jpeg"
        // Stored as a string to make Type comparable.
        suffixesCSV string
}

// SuffixInfo holds information about a Type's suffix.
type SuffixInfo struct {
        Suffix     string `json:"suffix"`
        FullSuffix string `json:"fullSuffix"`
}

// FromContent resolve the Type primarily using http.DetectContentType.
// If http.DetectContentType resolves to application/octet-stream, a zero Type is returned.
// If http.DetectContentType  resolves to text/plain or application/xml, we try to get more specific using types and ext.
func FromContent(types Types, extensionHints []string, content []byte) Type <span class="cov8" title="1">{
        t := strings.Split(http.DetectContentType(content), ";")[0]
        if t == "application/octet-stream" </span><span class="cov0" title="0">{
                return zero
        }</span>

        <span class="cov8" title="1">var found bool
        m, found := types.GetByType(t)
        if !found </span><span class="cov8" title="1">{
                if t == "text/xml" </span><span class="cov8" title="1">{
                        // This is how it's configured in Hugo by default.
                        m, found = types.GetByType("application/xml")
                }</span>
        }

        <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                return zero
        }</span>

        <span class="cov8" title="1">var mm Type

        for _, extension := range extensionHints </span><span class="cov8" title="1">{
                extension = strings.TrimPrefix(extension, ".")
                mm, _, found = types.GetFirstBySuffix(extension)
                if found </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if found </span><span class="cov8" title="1">{
                if m == mm </span><span class="cov8" title="1">{
                        return m
                }</span>

                <span class="cov8" title="1">if m.IsText() &amp;&amp; mm.IsText() </span><span class="cov8" title="1">{
                        // http.DetectContentType isn't brilliant when it comes to common text formats, so we need to do better.
                        // For now we say that if it's detected to be a text format and the extension/content type in header reports
                        // it to be a text format, then we use that.
                        return mm
                }</span>

                // E.g. an image with a *.js extension.
                <span class="cov8" title="1">return zero</span>
        }

        <span class="cov0" title="0">return m</span>
}

// FromStringAndExt creates a Type from a MIME string and a given extension.
func FromStringAndExt(t, ext string) (Type, error) <span class="cov8" title="1">{
        tp, err := fromString(t)
        if err != nil </span><span class="cov0" title="0">{
                return tp, err
        }</span>
        <span class="cov8" title="1">tp.suffixesCSV = strings.TrimPrefix(ext, ".")
        tp.Delimiter = defaultDelimiter
        tp.init()
        return tp, nil</span>
}

// FromString creates a new Type given a type string on the form MainType/SubType and
// an optional suffix, e.g. "text/html" or "text/html+html".
func fromString(t string) (Type, error) <span class="cov8" title="1">{
        t = strings.ToLower(t)
        parts := strings.Split(t, "/")
        if len(parts) != 2 </span><span class="cov8" title="1">{
                return Type{}, fmt.Errorf("cannot parse %q as a media type", t)
        }</span>
        <span class="cov8" title="1">mainType := parts[0]
        subParts := strings.Split(parts[1], "+")

        subType := strings.Split(subParts[0], ";")[0]

        var suffix string

        if len(subParts) &gt; 1 </span><span class="cov8" title="1">{
                suffix = subParts[1]
        }</span>

        <span class="cov8" title="1">return Type{MainType: mainType, SubType: subType, mimeSuffix: suffix}, nil</span>
}

// Type returns a string representing the main- and sub-type of a media type, e.g. "text/css".
// A suffix identifier will be appended after a "+" if set, e.g. "image/svg+xml".
// Hugo will register a set of default media types.
// These can be overridden by the user in the configuration,
// by defining a media type with the same Type.
func (m Type) Type() string <span class="cov8" title="1">{
        // Examples are
        // image/svg+xml
        // text/css
        if m.mimeSuffix != "" </span><span class="cov8" title="1">{
                return m.MainType + "/" + m.SubType + "+" + m.mimeSuffix
        }</span>
        <span class="cov8" title="1">return m.MainType + "/" + m.SubType</span>
}

func (m Type) String() string <span class="cov8" title="1">{
        return m.Type()
}</span>

// Suffixes returns all valid file suffixes for this type.
func (m Type) Suffixes() []string <span class="cov8" title="1">{
        if m.suffixesCSV == "" </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return strings.Split(m.suffixesCSV, ",")</span>
}

// IsText returns whether this Type is a text format.
// Note that this may currently return false negatives.
// TODO(bep) improve
func (m Type) IsText() bool <span class="cov8" title="1">{
        if m.MainType == "text" </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">switch m.SubType </span>{
        case "javascript", "json", "rss", "xml", "svg", TOMLType.SubType, YAMLType.SubType:<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

func (m *Type) init() <span class="cov8" title="1">{
        m.FirstSuffix.FullSuffix = ""
        m.FirstSuffix.Suffix = ""
        if suffixes := m.Suffixes(); suffixes != nil </span><span class="cov8" title="1">{
                m.FirstSuffix.Suffix = suffixes[0]
                m.FirstSuffix.FullSuffix = m.Delimiter + m.FirstSuffix.Suffix
        }</span>
}

// WithDelimiterAndSuffixes is used in tests.
func WithDelimiterAndSuffixes(t Type, delimiter, suffixesCSV string) Type <span class="cov0" title="0">{
        t.Delimiter = delimiter
        t.suffixesCSV = suffixesCSV
        t.init()
        return t
}</span>

func newMediaType(main, sub string, suffixes []string) Type <span class="cov8" title="1">{
        t := Type{MainType: main, SubType: sub, suffixesCSV: strings.Join(suffixes, ","), Delimiter: defaultDelimiter}
        t.init()
        return t
}</span>

func newMediaTypeWithMimeSuffix(main, sub, mimeSuffix string, suffixes []string) Type <span class="cov8" title="1">{
        mt := newMediaType(main, sub, suffixes)
        mt.mimeSuffix = mimeSuffix
        mt.init()
        return mt
}</span>

// Definitions from https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/MIME_types etc.
// Note that from Hugo 0.44 we only set Suffix if it is part of the MIME type.
var (
        CalendarType   = newMediaType("text", "calendar", []string{"ics"})
        CSSType        = newMediaType("text", "css", []string{"css"})
        SCSSType       = newMediaType("text", "x-scss", []string{"scss"})
        SASSType       = newMediaType("text", "x-sass", []string{"sass"})
        CSVType        = newMediaType("text", "csv", []string{"csv"})
        HTMLType       = newMediaType("text", "html", []string{"html"})
        JavascriptType = newMediaType("application", "javascript", []string{"js", "jsm", "mjs"})
        TypeScriptType = newMediaType("application", "typescript", []string{"ts"})
        TSXType        = newMediaType("text", "tsx", []string{"tsx"})
        JSXType        = newMediaType("text", "jsx", []string{"jsx"})

        JSONType           = newMediaType("application", "json", []string{"json"})
        WebAppManifestType = newMediaTypeWithMimeSuffix("application", "manifest", "json", []string{"webmanifest"})
        RSSType            = newMediaTypeWithMimeSuffix("application", "rss", "xml", []string{"xml", "rss"})
        XMLType            = newMediaType("application", "xml", []string{"xml"})
        SVGType            = newMediaTypeWithMimeSuffix("image", "svg", "xml", []string{"svg"})
        TextType           = newMediaType("text", "plain", []string{"txt"})
        TOMLType           = newMediaType("application", "toml", []string{"toml"})
        YAMLType           = newMediaType("application", "yaml", []string{"yaml", "yml"})

        // Common image types
        PNGType  = newMediaType("image", "png", []string{"png"})
        JPEGType = newMediaType("image", "jpeg", []string{"jpg", "jpeg", "jpe", "jif", "jfif"})
        GIFType  = newMediaType("image", "gif", []string{"gif"})
        TIFFType = newMediaType("image", "tiff", []string{"tif", "tiff"})
        BMPType  = newMediaType("image", "bmp", []string{"bmp"})
        WEBPType = newMediaType("image", "webp", []string{"webp"})

        // Common font types
        TrueTypeFontType = newMediaType("font", "ttf", []string{"ttf"})
        OpenTypeFontType = newMediaType("font", "otf", []string{"otf"})

        // Common document types
        PDFType = newMediaType("application", "pdf", []string{"pdf"})

        // Common video types
        AVIType  = newMediaType("video", "x-msvideo", []string{"avi"})
        MPEGType = newMediaType("video", "mpeg", []string{"mpg", "mpeg"})
        MP4Type  = newMediaType("video", "mp4", []string{"mp4"})
        OGGType  = newMediaType("video", "ogg", []string{"ogv"})
        WEBMType = newMediaType("video", "webm", []string{"webm"})
        GPPType  = newMediaType("video", "3gpp", []string{"3gpp", "3gp"})

        OctetType = newMediaType("application", "octet-stream", nil)
)

// DefaultTypes is the default media types supported by Hugo.
var DefaultTypes = Types{
        CalendarType,
        CSSType,
        CSVType,
        SCSSType,
        SASSType,
        HTMLType,
        JavascriptType,
        TypeScriptType,
        TSXType,
        JSXType,
        JSONType,
        WebAppManifestType,
        RSSType,
        XMLType,
        SVGType,
        TextType,
        OctetType,
        YAMLType,
        TOMLType,
        PNGType,
        GIFType,
        BMPType,
        JPEGType,
        WEBPType,
        AVIType,
        MPEGType,
        MP4Type,
        OGGType,
        WEBMType,
        GPPType,
        OpenTypeFontType,
        TrueTypeFontType,
        PDFType,
}

func init() <span class="cov8" title="1">{
        sort.Sort(DefaultTypes)

        // Sanity check.
        seen := make(map[Type]bool)
        for _, t := range DefaultTypes </span><span class="cov8" title="1">{
                if seen[t] </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("MediaType %s duplicated in list", t))</span>
                }
                <span class="cov8" title="1">seen[t] = true</span>
        }
}

// Types is a slice of media types.
type Types []Type

func (t Types) Len() int           <span class="cov8" title="1">{ return len(t) }</span>
func (t Types) Swap(i, j int)      <span class="cov8" title="1">{ t[i], t[j] = t[j], t[i] }</span>
func (t Types) Less(i, j int) bool <span class="cov8" title="1">{ return t[i].Type() &lt; t[j].Type() }</span>

// GetByType returns a media type for tp.
func (t Types) GetByType(tp string) (Type, bool) <span class="cov8" title="1">{
        for _, tt := range t </span><span class="cov8" title="1">{
                if strings.EqualFold(tt.Type(), tp) </span><span class="cov8" title="1">{
                        return tt, true
                }</span>
        }

        <span class="cov8" title="1">if !strings.Contains(tp, "+") </span><span class="cov8" title="1">{
                // Try with the main and sub type
                parts := strings.Split(tp, "/")
                if len(parts) == 2 </span><span class="cov8" title="1">{
                        return t.GetByMainSubType(parts[0], parts[1])
                }</span>
        }

        <span class="cov0" title="0">return Type{}, false</span>
}

// BySuffix will return all media types matching a suffix.
func (t Types) BySuffix(suffix string) []Type <span class="cov8" title="1">{
        suffix = strings.ToLower(suffix)
        var types []Type
        for _, tt := range t </span><span class="cov8" title="1">{
                if tt.hasSuffix(suffix) </span><span class="cov8" title="1">{
                        types = append(types, tt)
                }</span>
        }
        <span class="cov8" title="1">return types</span>
}

// GetFirstBySuffix will return the first type matching the given suffix.
func (t Types) GetFirstBySuffix(suffix string) (Type, SuffixInfo, bool) <span class="cov8" title="1">{
        suffix = strings.ToLower(suffix)
        for _, tt := range t </span><span class="cov8" title="1">{
                if tt.hasSuffix(suffix) </span><span class="cov8" title="1">{
                        return tt, SuffixInfo{
                                FullSuffix: tt.Delimiter + suffix,
                                Suffix:     suffix,
                        }, true
                }</span>
        }
        <span class="cov8" title="1">return Type{}, SuffixInfo{}, false</span>
}

// GetBySuffix gets a media type given as suffix, e.g. "html".
// It will return false if no format could be found, or if the suffix given
// is ambiguous.
// The lookup is case insensitive.
func (t Types) GetBySuffix(suffix string) (tp Type, si SuffixInfo, found bool) <span class="cov8" title="1">{
        suffix = strings.ToLower(suffix)
        for _, tt := range t </span><span class="cov8" title="1">{
                if tt.hasSuffix(suffix) </span><span class="cov8" title="1">{
                        if found </span><span class="cov0" title="0">{
                                // ambiguous
                                found = false
                                return
                        }</span>
                        <span class="cov8" title="1">tp = tt
                        si = SuffixInfo{
                                FullSuffix: tt.Delimiter + suffix,
                                Suffix:     suffix,
                        }
                        found = true</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func (m Type) hasSuffix(suffix string) bool <span class="cov8" title="1">{
        return strings.Contains(","+m.suffixesCSV+",", ","+suffix+",")
}</span>

// GetByMainSubType gets a media type given a main and a sub type e.g. "text" and "plain".
// It will return false if no format could be found, or if the combination given
// is ambiguous.
// The lookup is case insensitive.
func (t Types) GetByMainSubType(mainType, subType string) (tp Type, found bool) <span class="cov8" title="1">{
        for _, tt := range t </span><span class="cov8" title="1">{
                if strings.EqualFold(mainType, tt.MainType) &amp;&amp; strings.EqualFold(subType, tt.SubType) </span><span class="cov8" title="1">{
                        if found </span><span class="cov0" title="0">{
                                // ambiguous
                                found = false
                                return
                        }</span>

                        <span class="cov8" title="1">tp = tt
                        found = true</span>
                }
        }
        <span class="cov8" title="1">return</span>
}

func suffixIsRemoved() error <span class="cov0" title="0">{
        return errors.New(`MediaType.Suffix is removed. Before Hugo 0.44 this was used both to set a custom file suffix and as way
to augment the mediatype definition (what you see after the "+", e.g. "image/svg+xml").

This had its limitations. For one, it was only possible with one file extension per MIME type.

Now you can specify multiple file suffixes using "suffixes", but you need to specify the full MIME type
identifier:

[mediaTypes]
[mediaTypes."image/svg+xml"]
suffixes = ["svg", "abc" ]

In most cases, it will be enough to just change:

[mediaTypes]
[mediaTypes."my/custom-mediatype"]
suffix = "txt"

To:

[mediaTypes]
[mediaTypes."my/custom-mediatype"]
suffixes = ["txt"]

Note that you can still get the Media Type's suffix from a template: {{ $mediaType.Suffix }}. But this will now map to the MIME type filename.
`)
}</span>

// DecodeTypes takes a list of media type configurations and merges those,
// in the order given, with the Hugo defaults as the last resort.
func DecodeTypes(mms ...map[string]interface{}) (Types, error) <span class="cov8" title="1">{
        var m Types

        // Maps type string to Type. Type string is the full application/svg+xml.
        mmm := make(map[string]Type)
        for _, dt := range DefaultTypes </span><span class="cov8" title="1">{
                mmm[dt.Type()] = dt
        }</span>

        <span class="cov8" title="1">for _, mm := range mms </span><span class="cov8" title="1">{
                for k, v := range mm </span><span class="cov8" title="1">{
                        var mediaType Type

                        mediaType, found := mmm[k]
                        if !found </span><span class="cov8" title="1">{
                                var err error
                                mediaType, err = fromString(k)
                                if err != nil </span><span class="cov0" title="0">{
                                        return m, err
                                }</span>
                        }

                        <span class="cov8" title="1">if err := mapstructure.WeakDecode(v, &amp;mediaType); err != nil </span><span class="cov0" title="0">{
                                return m, err
                        }</span>

                        <span class="cov8" title="1">vm := maps.ToStringMap(v)
                        maps.PrepareParams(vm)
                        _, delimiterSet := vm["delimiter"]
                        _, suffixSet := vm["suffix"]

                        if suffixSet </span><span class="cov0" title="0">{
                                return Types{}, suffixIsRemoved()
                        }</span>

                        <span class="cov8" title="1">if suffixes, found := vm["suffixes"]; found </span><span class="cov8" title="1">{
                                mediaType.suffixesCSV = strings.TrimSpace(strings.ToLower(strings.Join(cast.ToStringSlice(suffixes), ",")))
                        }</span>

                        // The user may set the delimiter as an empty string.
                        <span class="cov8" title="1">if !delimiterSet &amp;&amp; mediaType.suffixesCSV != "" </span><span class="cov8" title="1">{
                                mediaType.Delimiter = defaultDelimiter
                        }</span>

                        <span class="cov8" title="1">mediaType.init()

                        mmm[k] = mediaType</span>

                }
        }

        <span class="cov8" title="1">for _, v := range mmm </span><span class="cov8" title="1">{
                m = append(m, v)
        }</span>
        <span class="cov8" title="1">sort.Sort(m)

        return m, nil</span>
}

// IsZero reports whether this Type represents a zero value.
func (m Type) IsZero() bool <span class="cov0" title="0">{
        return m.SubType == ""
}</span>

// MarshalJSON returns the JSON encoding of m.
func (m Type) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        type Alias Type
        return json.Marshal(&amp;struct {
                Alias
                Type     string   `json:"type"`
                String   string   `json:"string"`
                Suffixes []string `json:"suffixes"`
        }{
                Alias:    (Alias)(m),
                Type:     m.Type(),
                String:   m.String(),
                Suffixes: strings.Split(m.suffixesCSV, ","),
        })
}</span>
</pre>
		
		<pre class="file" id="file170" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package metrics provides simple metrics tracking features.
package metrics

import (
        "fmt"
        "io"
        "math"
        "reflect"
        "sort"
        "strconv"
        "strings"
        "sync"
        "time"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/common/types"

        "github.com/gohugoio/hugo/compare"
)

// The Provider interface defines an interface for measuring metrics.
type Provider interface {
        // MeasureSince adds a measurement for key to the metric store.
        // Used with defer and time.Now().
        MeasureSince(key string, start time.Time)

        // WriteMetrics will write a summary of the metrics to w.
        WriteMetrics(w io.Writer)

        // TrackValue tracks the value for diff calculations etc.
        TrackValue(key string, value interface{})

        // Reset clears the metric store.
        Reset()
}

type diff struct {
        baseline interface{}
        count    int
        simSum   int
}

var counter = 0

func (d *diff) add(v interface{}) *diff <span class="cov0" title="0">{
        if types.IsNil(d.baseline) </span><span class="cov0" title="0">{
                d.baseline = v
                d.count = 1
                d.simSum = 100 // If we get only one it is very cache friendly.
                return d
        }</span>
        <span class="cov0" title="0">adder := howSimilar(v, d.baseline)
        d.simSum += adder
        d.count++

        return d</span>
}

// Store provides storage for a set of metrics.
type Store struct {
        calculateHints bool
        metrics        map[string][]time.Duration
        mu             sync.Mutex
        diffs          map[string]*diff
        diffmu         sync.Mutex
}

// NewProvider returns a new instance of a metric store.
func NewProvider(calculateHints bool) Provider <span class="cov0" title="0">{
        return &amp;Store{
                calculateHints: calculateHints,
                metrics:        make(map[string][]time.Duration),
                diffs:          make(map[string]*diff),
        }
}</span>

// Reset clears the metrics store.
func (s *Store) Reset() <span class="cov0" title="0">{
        s.mu.Lock()
        s.metrics = make(map[string][]time.Duration)
        s.mu.Unlock()
        s.diffmu.Lock()
        s.diffs = make(map[string]*diff)
        s.diffmu.Unlock()
}</span>

// TrackValue tracks the value for diff calculations etc.
func (s *Store) TrackValue(key string, value interface{}) <span class="cov0" title="0">{
        if !s.calculateHints </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov0" title="0">s.diffmu.Lock()
        var (
                d     *diff
                found bool
        )

        d, found = s.diffs[key]

        if !found </span><span class="cov0" title="0">{
                d = &amp;diff{}
                s.diffs[key] = d
        }</span>

        <span class="cov0" title="0">d.add(value)

        s.diffmu.Unlock()</span>
}

// MeasureSince adds a measurement for key to the metric store.
func (s *Store) MeasureSince(key string, start time.Time) <span class="cov0" title="0">{
        s.mu.Lock()
        s.metrics[key] = append(s.metrics[key], time.Since(start))
        s.mu.Unlock()
}</span>

// WriteMetrics writes a summary of the metrics to w.
func (s *Store) WriteMetrics(w io.Writer) <span class="cov0" title="0">{
        s.mu.Lock()

        results := make([]result, len(s.metrics))

        var i int
        for k, v := range s.metrics </span><span class="cov0" title="0">{
                var sum time.Duration
                var max time.Duration

                diff, found := s.diffs[k]

                cacheFactor := 0
                if found </span><span class="cov0" title="0">{
                        cacheFactor = int(math.Floor(float64(diff.simSum) / float64(diff.count)))
                }</span>

                <span class="cov0" title="0">for _, d := range v </span><span class="cov0" title="0">{
                        sum += d
                        if d &gt; max </span><span class="cov0" title="0">{
                                max = d
                        }</span>
                }

                <span class="cov0" title="0">avg := time.Duration(int(sum) / len(v))

                results[i] = result{key: k, count: len(v), max: max, sum: sum, avg: avg, cacheFactor: cacheFactor}
                i++</span>
        }

        <span class="cov0" title="0">s.mu.Unlock()

        if s.calculateHints </span><span class="cov0" title="0">{
                fmt.Fprintf(w, "  %9s  %13s  %12s  %12s  %5s  %s\n", "cache", "cumulative", "average", "maximum", "", "")
                fmt.Fprintf(w, "  %9s  %13s  %12s  %12s  %5s  %s\n", "potential", "duration", "duration", "duration", "count", "template")
                fmt.Fprintf(w, "  %9s  %13s  %12s  %12s  %5s  %s\n", "-----", "----------", "--------", "--------", "-----", "--------")
        }</span> else<span class="cov0" title="0"> {
                fmt.Fprintf(w, "  %13s  %12s  %12s  %5s  %s\n", "cumulative", "average", "maximum", "", "")
                fmt.Fprintf(w, "  %13s  %12s  %12s  %5s  %s\n", "duration", "duration", "duration", "count", "template")
                fmt.Fprintf(w, "  %13s  %12s  %12s  %5s  %s\n", "----------", "--------", "--------", "-----", "--------")

        }</span>

        <span class="cov0" title="0">sort.Sort(bySum(results))
        for _, v := range results </span><span class="cov0" title="0">{
                if s.calculateHints </span><span class="cov0" title="0">{
                        fmt.Fprintf(w, "  %9d %13s  %12s  %12s  %5d  %s\n", v.cacheFactor, v.sum, v.avg, v.max, v.count, v.key)
                }</span> else<span class="cov0" title="0"> {
                        fmt.Fprintf(w, "  %13s  %12s  %12s  %5d  %s\n", v.sum, v.avg, v.max, v.count, v.key)
                }</span>
        }
}

// A result represents the calculated results for a given metric.
type result struct {
        key         string
        count       int
        cacheFactor int
        sum         time.Duration
        max         time.Duration
        avg         time.Duration
}

type bySum []result

func (b bySum) Len() int           <span class="cov0" title="0">{ return len(b) }</span>
func (b bySum) Swap(i, j int)      <span class="cov0" title="0">{ b[i], b[j] = b[j], b[i] }</span>
func (b bySum) Less(i, j int) bool <span class="cov0" title="0">{ return b[i].sum &gt; b[j].sum }</span>

// howSimilar is a naive diff implementation that returns
// a number between 0-100 indicating how similar a and b are.
func howSimilar(a, b interface{}) int <span class="cov8" title="1">{
        t1, t2 := reflect.TypeOf(a), reflect.TypeOf(b)
        if t1 != t2 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">if t1.Comparable() &amp;&amp; t2.Comparable() </span><span class="cov8" title="1">{
                if a == b </span><span class="cov8" title="1">{
                        return 100
                }</span>
        }

        <span class="cov8" title="1">as, ok1 := types.TypeToString(a)
        bs, ok2 := types.TypeToString(b)

        if ok1 &amp;&amp; ok2 </span><span class="cov8" title="1">{
                return howSimilarStrings(as, bs)
        }</span>

        <span class="cov8" title="1">if ok1 != ok2 </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">e1, ok1 := a.(compare.Eqer)
        e2, ok2 := b.(compare.Eqer)
        if ok1 &amp;&amp; ok2 &amp;&amp; e1.Eq(e2) </span><span class="cov0" title="0">{
                return 100
        }</span>

        <span class="cov8" title="1">pe1, pok1 := a.(compare.ProbablyEqer)
        pe2, pok2 := b.(compare.ProbablyEqer)
        if pok1 &amp;&amp; pok2 &amp;&amp; pe1.ProbablyEq(pe2) </span><span class="cov8" title="1">{
                return 90
        }</span>

        <span class="cov8" title="1">h1, h2 := helpers.HashString(a), helpers.HashString(b)
        if h1 == h2 </span><span class="cov8" title="1">{
                return 100
        }</span>
        <span class="cov8" title="1">return 0</span>
}

// howSimilar is a naive diff implementation that returns
// a number between 0-100 indicating how similar a and b are.
// 100 is when all words in a also exists in b.
func howSimilarStrings(a, b string) int <span class="cov8" title="1">{
        if a == b </span><span class="cov0" title="0">{
                return 100
        }</span>

        // Give some weight to the word positions.
        <span class="cov8" title="1">const partitionSize = 4

        af, bf := strings.Fields(a), strings.Fields(b)
        if len(bf) &gt; len(af) </span><span class="cov8" title="1">{
                af, bf = bf, af
        }</span>

        <span class="cov8" title="1">m1 := make(map[string]bool)
        for i, x := range bf </span><span class="cov8" title="1">{
                partition := partition(i, partitionSize)
                key := x + "/" + strconv.Itoa(partition)
                m1[key] = true
        }</span>

        <span class="cov8" title="1">common := 0
        for i, x := range af </span><span class="cov8" title="1">{
                partition := partition(i, partitionSize)
                key := x + "/" + strconv.Itoa(partition)
                if m1[key] </span><span class="cov8" title="1">{
                        common++
                }</span>
        }

        <span class="cov8" title="1">return int(math.Floor((float64(common) / float64(len(af)) * 100)))</span>
}

func partition(d, scale int) int <span class="cov8" title="1">{
        return int(math.Floor((float64(d) / float64(scale)))) * scale
}</span>
</pre>
		
		<pre class="file" id="file171" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package minifiers

import (
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/docshelper"
        "github.com/gohugoio/hugo/parser"
        "github.com/spf13/cast"

        "github.com/mitchellh/mapstructure"
        "github.com/tdewolff/minify/v2/css"
        "github.com/tdewolff/minify/v2/html"
        "github.com/tdewolff/minify/v2/js"
        "github.com/tdewolff/minify/v2/json"
        "github.com/tdewolff/minify/v2/svg"
        "github.com/tdewolff/minify/v2/xml"
)

var defaultTdewolffConfig = tdewolffConfig{
        HTML: html.Minifier{
                KeepDocumentTags:        true,
                KeepConditionalComments: true,
                KeepEndTags:             true,
                KeepDefaultAttrVals:     true,
                KeepWhitespace:          true,
        },
        CSS: css.Minifier{
                Precision: 0,
                KeepCSS2:  true,
        },
        JS:   js.Minifier{},
        JSON: json.Minifier{},
        SVG: svg.Minifier{
                Precision: 0,
        },
        XML: xml.Minifier{
                KeepWhitespace: false,
        },
}

type tdewolffConfig struct {
        HTML html.Minifier
        CSS  css.Minifier
        JS   js.Minifier
        JSON json.Minifier
        SVG  svg.Minifier
        XML  xml.Minifier
}

type minifyConfig struct {
        // Whether to minify the published output (the HTML written to /public).
        MinifyOutput bool

        DisableHTML bool
        DisableCSS  bool
        DisableJS   bool
        DisableJSON bool
        DisableSVG  bool
        DisableXML  bool

        Tdewolff tdewolffConfig
}

var defaultConfig = minifyConfig{
        Tdewolff: defaultTdewolffConfig,
}

func decodeConfig(cfg config.Provider) (conf minifyConfig, err error) <span class="cov8" title="1">{
        conf = defaultConfig

        // May be set by CLI.
        conf.MinifyOutput = cfg.GetBool("minifyOutput")

        v := cfg.Get("minify")
        if v == nil </span><span class="cov8" title="1">{
                return
        }</span>

        // Legacy.
        <span class="cov8" title="1">if b, ok := v.(bool); ok </span><span class="cov8" title="1">{
                conf.MinifyOutput = b
                return
        }</span>

        <span class="cov8" title="1">m := maps.ToStringMap(v)

        // Handle upstream renames.
        if td, found := m["tdewolff"]; found </span><span class="cov8" title="1">{
                tdm := maps.ToStringMap(td)
                for _, key := range []string{"css", "svg"} </span><span class="cov8" title="1">{
                        if v, found := tdm[key]; found </span><span class="cov8" title="1">{
                                vm := maps.ToStringMap(v)
                                if vv, found := vm["decimal"]; found </span><span class="cov8" title="1">{
                                        vvi := cast.ToInt(vv)
                                        if vvi &gt; 0 </span><span class="cov8" title="1">{
                                                vm["precision"] = vvi
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">err = mapstructure.WeakDecode(m, &amp;conf)

        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">return</span>
}

func init() <span class="cov8" title="1">{
        docsProvider := func() docshelper.DocProvider </span><span class="cov0" title="0">{
                return docshelper.DocProvider{"config": map[string]interface{}{"minify": parser.LowerCaseCamelJSONMarshaller{Value: defaultConfig}}}
        }</span>
        <span class="cov8" title="1">docshelper.AddDocProviderFunc(docsProvider)</span>
}
</pre>
		
		<pre class="file" id="file172" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package minifiers contains minifiers mapped to MIME types. This package is used
// in both the resource transformation, i.e. resources.Minify, and in the publishing
// chain.
package minifiers

import (
        "io"
        "regexp"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/transform"

        "github.com/gohugoio/hugo/media"
        "github.com/tdewolff/minify/v2"
)

// Client wraps a minifier.
type Client struct {
        // Whether output minification is enabled (HTML in /public)
        MinifyOutput bool

        m *minify.M
}

// Transformer returns a func that can be used in the transformer publishing chain.
// TODO(bep) minify config etc
func (m Client) Transformer(mediatype media.Type) transform.Transformer <span class="cov0" title="0">{
        _, params, min := m.m.Match(mediatype.Type())
        if min == nil </span><span class="cov0" title="0">{
                // No minifier for this MIME type
                return nil
        }</span>

        <span class="cov0" title="0">return func(ft transform.FromTo) error </span><span class="cov0" title="0">{
                // Note that the source io.Reader will already be buffered, but it implements
                // the Bytes() method, which is recognized by the Minify library.
                return min.Minify(m.m, ft.To(), ft.From(), params)
        }</span>
}

// Minify tries to minify the src into dst given a MIME type.
func (m Client) Minify(mediatype media.Type, dst io.Writer, src io.Reader) error <span class="cov8" title="1">{
        return m.m.Minify(mediatype.Type(), dst, src)
}</span>

// noopMinifier implements minify.Minifier [1], but doesn't minify content. This means
// that we can avoid missing minifiers for any MIME types in our minify.M, which
// causes minify to return errors, while still allowing minification to be
// disabled for specific types.
//
// [1]: https://pkg.go.dev/github.com/tdewolff/minify#Minifier
type noopMinifier struct{}

// Minify copies r into w without transformation.
func (m noopMinifier) Minify(_ *minify.M, w io.Writer, r io.Reader, _ map[string]string) error <span class="cov8" title="1">{
        _, err := io.Copy(w, r)
        return err
}</span>

// New creates a new Client with the provided MIME types as the mapping foundation.
// The HTML minifier is also registered for additional HTML types (AMP etc.) in the
// provided list of output formats.
func New(mediaTypes media.Types, outputFormats output.Formats, cfg config.Provider) (Client, error) <span class="cov8" title="1">{
        conf, err := decodeConfig(cfg)

        m := minify.New()
        if err != nil </span><span class="cov0" title="0">{
                return Client{}, err
        }</span>

        // We use the Type definition of the media types defined in the site if found.
        <span class="cov8" title="1">addMinifier(m, mediaTypes, "css", getMinifier(conf, "css"))

        addMinifier(m, mediaTypes, "js", getMinifier(conf, "js"))
        m.AddRegexp(regexp.MustCompile("^(application|text)/(x-)?(java|ecma)script$"), getMinifier(conf, "js"))

        addMinifier(m, mediaTypes, "json", getMinifier(conf, "json"))
        m.AddRegexp(regexp.MustCompile(`^(application|text)/(x-|(ld|manifest)\+)?json$`), getMinifier(conf, "json"))

        addMinifier(m, mediaTypes, "svg", getMinifier(conf, "svg"))

        addMinifier(m, mediaTypes, "xml", getMinifier(conf, "xml"))

        // HTML
        addMinifier(m, mediaTypes, "html", getMinifier(conf, "html"))
        for _, of := range outputFormats </span><span class="cov8" title="1">{
                if of.IsHTML </span><span class="cov8" title="1">{
                        m.Add(of.MediaType.Type(), getMinifier(conf, "html"))
                }</span>
        }

        <span class="cov8" title="1">return Client{m: m, MinifyOutput: conf.MinifyOutput}, nil</span>
}

// getMinifier returns the appropriate minify.MinifierFunc for the MIME
// type suffix s, given the config c.
func getMinifier(c minifyConfig, s string) minify.Minifier <span class="cov8" title="1">{
        switch </span>{
        case s == "css" &amp;&amp; !c.DisableCSS:<span class="cov8" title="1">
                return &amp;c.Tdewolff.CSS</span>
        case s == "js" &amp;&amp; !c.DisableJS:<span class="cov8" title="1">
                return &amp;c.Tdewolff.JS</span>
        case s == "json" &amp;&amp; !c.DisableJSON:<span class="cov8" title="1">
                return &amp;c.Tdewolff.JSON</span>
        case s == "svg" &amp;&amp; !c.DisableSVG:<span class="cov8" title="1">
                return &amp;c.Tdewolff.SVG</span>
        case s == "xml" &amp;&amp; !c.DisableXML:<span class="cov8" title="1">
                return &amp;c.Tdewolff.XML</span>
        case s == "html" &amp;&amp; !c.DisableHTML:<span class="cov8" title="1">
                return &amp;c.Tdewolff.HTML</span>
        default:<span class="cov8" title="1">
                return noopMinifier{}</span>
        }
}

func addMinifier(m *minify.M, mt media.Types, suffix string, min minify.Minifier) <span class="cov8" title="1">{
        types := mt.BySuffix(suffix)
        for _, t := range types </span><span class="cov8" title="1">{
                m.Add(t.Type(), min)
        }</span>
}
</pre>
		
		<pre class="file" id="file173" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package modules

import (
        "bufio"
        "bytes"
        "context"
        "encoding/json"
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "os/exec"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/gohugoio/hugo/common/collections"
        "github.com/gohugoio/hugo/common/hexec"

        hglob "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/gobwas/glob"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/gohugoio/hugo/config"

        "github.com/rogpeppe/go-internal/module"

        "github.com/gohugoio/hugo/common/hugio"

        "github.com/pkg/errors"
        "github.com/spf13/afero"
)

var fileSeparator = string(os.PathSeparator)

const (
        goBinaryStatusOK goBinaryStatus = iota
        goBinaryStatusNotFound
        goBinaryStatusTooOld
)

// The "vendor" dir is reserved for Go Modules.
const vendord = "_vendor"

const (
        goModFilename = "go.mod"
        goSumFilename = "go.sum"
)

// NewClient creates a new Client that can be used to manage the Hugo Components
// in a given workingDir.
// The Client will resolve the dependencies recursively, but needs the top
// level imports to start out.
func NewClient(cfg ClientConfig) *Client <span class="cov8" title="1">{
        fs := cfg.Fs
        n := filepath.Join(cfg.WorkingDir, goModFilename)
        goModEnabled, _ := afero.Exists(fs, n)
        var goModFilename string
        if goModEnabled </span><span class="cov0" title="0">{
                goModFilename = n
        }</span>

        <span class="cov8" title="1">var env []string
        mcfg := cfg.ModuleConfig

        config.SetEnvVars(&amp;env,
                "PWD", cfg.WorkingDir,
                "GO111MODULE", "on",
                "GOPROXY", mcfg.Proxy,
                "GOPRIVATE", mcfg.Private,
                "GONOPROXY", mcfg.NoProxy,
                "GOPATH", cfg.CacheDir,
                // GOCACHE was introduced in Go 1.15. This matches the location derived from GOPATH above.
                "GOCACHE", filepath.Join(cfg.CacheDir, "pkg", "mod"),
        )

        logger := cfg.Logger
        if logger == nil </span><span class="cov8" title="1">{
                logger = loggers.NewWarningLogger()
        }</span>

        <span class="cov8" title="1">var noVendor glob.Glob
        if cfg.ModuleConfig.NoVendor != "" </span><span class="cov8" title="1">{
                noVendor, _ = hglob.GetGlob(hglob.NormalizePath(cfg.ModuleConfig.NoVendor))
        }</span>

        <span class="cov8" title="1">return &amp;Client{
                fs:                fs,
                ccfg:              cfg,
                logger:            logger,
                noVendor:          noVendor,
                moduleConfig:      mcfg,
                environ:           env,
                GoModulesFilename: goModFilename,
        }</span>
}

// Client contains most of the API provided by this package.
type Client struct {
        fs     afero.Fs
        logger loggers.Logger

        noVendor glob.Glob

        ccfg ClientConfig

        // The top level module config
        moduleConfig Config

        // Environment variables used in "go get" etc.
        environ []string

        // Set when Go modules are initialized in the current repo, that is:
        // a go.mod file exists.
        GoModulesFilename string

        // Set if we get a exec.ErrNotFound when running Go, which is most likely
        // due to being run on a system without Go installed. We record it here
        // so we can give an instructional error at the end if module/theme
        // resolution fails.
        goBinaryStatus goBinaryStatus
}

// Graph writes a module dependenchy graph to the given writer.
func (c *Client) Graph(w io.Writer) error <span class="cov8" title="1">{
        mc, coll := c.collect(true)
        if coll.err != nil </span><span class="cov0" title="0">{
                return coll.err
        }</span>
        <span class="cov8" title="1">for _, module := range mc.AllModules </span><span class="cov8" title="1">{
                if module.Owner() == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">prefix := ""
                if module.Disabled() </span><span class="cov0" title="0">{
                        prefix = "DISABLED "
                }</span>
                <span class="cov8" title="1">dep := pathVersion(module.Owner()) + " " + pathVersion(module)
                if replace := module.Replace(); replace != nil </span><span class="cov0" title="0">{
                        if replace.Version() != "" </span><span class="cov0" title="0">{
                                dep += " =&gt; " + pathVersion(replace)
                        }</span> else<span class="cov0" title="0"> {
                                // Local dir.
                                dep += " =&gt; " + replace.Dir()
                        }</span>
                }
                <span class="cov8" title="1">fmt.Fprintln(w, prefix+dep)</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Tidy can be used to remove unused dependencies from go.mod and go.sum.
func (c *Client) Tidy() error <span class="cov8" title="1">{
        tc, coll := c.collect(false)
        if coll.err != nil </span><span class="cov0" title="0">{
                return coll.err
        }</span>

        <span class="cov8" title="1">if coll.skipTidy </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">return c.tidy(tc.AllModules, false)</span>
}

// Vendor writes all the module dependencies to a _vendor folder.
//
// Unlike Go, we support it for any level.
//
// We, by default, use the /_vendor folder first, if found. To disable,
// run with
//    hugo --ignoreVendorPaths=".*"
//
// Given a module tree, Hugo will pick the first module for a given path,
// meaning that if the top-level module is vendored, that will be the full
// set of dependencies.
func (c *Client) Vendor() error <span class="cov8" title="1">{
        vendorDir := filepath.Join(c.ccfg.WorkingDir, vendord)
        if err := c.rmVendorDir(vendorDir); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := c.fs.MkdirAll(vendorDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Write the modules list to modules.txt.
        //
        // On the form:
        //
        // # github.com/alecthomas/chroma v0.6.3
        //
        // This is how "go mod vendor" does it. Go also lists
        // the packages below it, but that is currently not applicable to us.
        //
        <span class="cov8" title="1">var modulesContent bytes.Buffer

        tc, coll := c.collect(true)
        if coll.err != nil </span><span class="cov0" title="0">{
                return coll.err
        }</span>

        <span class="cov8" title="1">for _, t := range tc.AllModules </span><span class="cov8" title="1">{
                if t.Owner() == nil </span><span class="cov8" title="1">{
                        // This is the project.
                        continue</span>
                }

                <span class="cov8" title="1">if !c.shouldVendor(t.Path()) </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if !t.IsGoMod() &amp;&amp; !t.Vendor() </span><span class="cov0" title="0">{
                        // We currently do not vendor components living in the
                        // theme directory, see https://github.com/gohugoio/hugo/issues/5993
                        continue</span>
                }

                // See https://github.com/gohugoio/hugo/issues/8239
                // This is an error situation. We need something to vendor.
                <span class="cov8" title="1">if t.Mounts() == nil </span><span class="cov0" title="0">{
                        return errors.Errorf("cannot vendor module %q, need at least one mount", t.Path())
                }</span>

                <span class="cov8" title="1">fmt.Fprintln(&amp;modulesContent, "# "+t.Path()+" "+t.Version())

                dir := t.Dir()

                for _, mount := range t.Mounts() </span><span class="cov8" title="1">{
                        sourceFilename := filepath.Join(dir, mount.Source)
                        targetFilename := filepath.Join(vendorDir, t.Path(), mount.Source)
                        fi, err := c.fs.Stat(sourceFilename)
                        if err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to vendor module")
                        }</span>

                        <span class="cov8" title="1">if fi.IsDir() </span><span class="cov8" title="1">{
                                if err := hugio.CopyDir(c.fs, sourceFilename, targetFilename, nil); err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "failed to copy module to vendor dir")
                                }</span>
                        } else<span class="cov0" title="0"> {
                                targetDir := filepath.Dir(targetFilename)

                                if err := c.fs.MkdirAll(targetDir, 0755); err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "failed to make target dir")
                                }</span>

                                <span class="cov0" title="0">if err := hugio.CopyFile(c.fs, sourceFilename, targetFilename); err != nil </span><span class="cov0" title="0">{
                                        return errors.Wrap(err, "failed to copy module file to vendor")
                                }</span>
                        }
                }

                // Include the resource cache if present.
                <span class="cov8" title="1">resourcesDir := filepath.Join(dir, files.FolderResources)
                _, err := c.fs.Stat(resourcesDir)
                if err == nil </span><span class="cov0" title="0">{
                        if err := hugio.CopyDir(c.fs, resourcesDir, filepath.Join(vendorDir, t.Path(), files.FolderResources), nil); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "failed to copy resources to vendor dir")
                        }</span>
                }

                // Also include any theme.toml or config.* files in the root.
                <span class="cov8" title="1">configFiles, _ := afero.Glob(c.fs, filepath.Join(dir, "config.*"))
                configFiles = append(configFiles, filepath.Join(dir, "theme.toml"))
                for _, configFile := range configFiles </span><span class="cov8" title="1">{
                        if err := hugio.CopyFile(c.fs, configFile, filepath.Join(vendorDir, t.Path(), filepath.Base(configFile))); err != nil </span><span class="cov8" title="1">{
                                if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if modulesContent.Len() &gt; 0 </span><span class="cov8" title="1">{
                if err := afero.WriteFile(c.fs, filepath.Join(vendorDir, vendorModulesFilename), modulesContent.Bytes(), 0666); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// Get runs "go get" with the supplied arguments.
func (c *Client) Get(args ...string) error <span class="cov8" title="1">{
        if len(args) == 0 || (len(args) == 1 &amp;&amp; args[0] == "-u") </span><span class="cov0" title="0">{
                update := len(args) != 0

                // We need to be explicit about the modules to get.
                for _, m := range c.moduleConfig.Imports </span><span class="cov0" title="0">{
                        if !isProbablyModule(m.Path) </span><span class="cov0" title="0">{
                                // Skip themes/components stored below /themes etc.
                                // There may be false positives in the above, but those
                                // should be rare, and they will fail below with an
                                // "cannot find module providing ..." message.
                                continue</span>
                        }
                        <span class="cov0" title="0">var args []string
                        if update </span><span class="cov0" title="0">{
                                args = append(args, "-u")
                        }</span>
                        <span class="cov0" title="0">args = append(args, m.Path)
                        if err := c.get(args...); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">return c.get(args...)</span>
}

func (c *Client) get(args ...string) error <span class="cov8" title="1">{
        var hasD bool
        for _, arg := range args </span><span class="cov8" title="1">{
                if arg == "-d" </span><span class="cov0" title="0">{
                        hasD = true
                        break</span>
                }
        }
        <span class="cov8" title="1">if !hasD </span><span class="cov8" title="1">{
                // go get without the -d flag does not make sense to us, as
                // it will try to build and install go packages.
                args = append([]string{"-d"}, args...)
        }</span>
        <span class="cov8" title="1">if err := c.runGo(context.Background(), c.logger.Out(), append([]string{"get"}, args...)...); err != nil </span><span class="cov0" title="0">{
                errors.Wrapf(err, "failed to get %q", args)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Init initializes this as a Go Module with the given path.
// If path is empty, Go will try to guess.
// If this succeeds, this project will be marked as Go Module.
func (c *Client) Init(path string) error <span class="cov8" title="1">{
        err := c.runGo(context.Background(), c.logger.Out(), "mod", "init", path)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to init modules")
        }</span>

        <span class="cov8" title="1">c.GoModulesFilename = filepath.Join(c.ccfg.WorkingDir, goModFilename)

        return nil</span>
}

var verifyErrorDirRe = regexp.MustCompile(`dir has been modified \((.*?)\)`)

// Verify checks that the dependencies of the current module,
// which are stored in a local downloaded source cache, have not been
// modified since being downloaded.
func (c *Client) Verify(clean bool) error <span class="cov0" title="0">{
        // TODO(bep) add path to mod clean
        err := c.runVerify()
        if err != nil </span><span class="cov0" title="0">{
                if clean </span><span class="cov0" title="0">{
                        m := verifyErrorDirRe.FindAllStringSubmatch(err.Error(), -1)
                        if m != nil </span><span class="cov0" title="0">{
                                for i := 0; i &lt; len(m); i++ </span><span class="cov0" title="0">{
                                        c, err := hugofs.MakeReadableAndRemoveAllModulePkgDir(c.fs, m[i][1])
                                        if err != nil </span><span class="cov0" title="0">{
                                                return err
                                        }</span>
                                        <span class="cov0" title="0">fmt.Println("Cleaned", c)</span>
                                }
                        }
                        // Try to verify it again.
                        <span class="cov0" title="0">err = c.runVerify()</span>
                }
        }
        <span class="cov0" title="0">return err</span>
}

func (c *Client) Clean(pattern string) error <span class="cov0" title="0">{
        mods, err := c.listGoMods()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var g glob.Glob

        if pattern != "" </span><span class="cov0" title="0">{
                var err error
                g, err = hglob.GetGlob(pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">for _, m := range mods </span><span class="cov0" title="0">{
                if m.Replace != nil || m.Main </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">if g != nil &amp;&amp; !g.Match(m.Path) </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">_, err = hugofs.MakeReadableAndRemoveAllModulePkgDir(c.fs, m.Dir)
                if err == nil </span><span class="cov0" title="0">{
                        c.logger.Printf("hugo: cleaned module cache for %q", m.Path)
                }</span>
        }
        <span class="cov0" title="0">return err</span>
}

func (c *Client) runVerify() error <span class="cov0" title="0">{
        return c.runGo(context.Background(), ioutil.Discard, "mod", "verify")
}</span>

func isProbablyModule(path string) bool <span class="cov8" title="1">{
        return module.CheckPath(path) == nil
}</span>

func (c *Client) listGoMods() (goModules, error) <span class="cov8" title="1">{
        if c.GoModulesFilename == "" || !c.moduleConfig.hasModuleImport() </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">downloadModules := func(modules ...string) error </span><span class="cov8" title="1">{
                args := []string{"mod", "download"}
                args = append(args, modules...)
                out := ioutil.Discard
                err := c.runGo(context.Background(), out, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to download modules")
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">if err := downloadModules(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">listAndDecodeModules := func(handle func(m *goModule) error, modules ...string) error </span><span class="cov8" title="1">{
                b := &amp;bytes.Buffer{}
                args := []string{"list", "-m", "-json"}
                if len(modules) &gt; 0 </span><span class="cov8" title="1">{
                        args = append(args, modules...)
                }</span> else<span class="cov8" title="1"> {
                        args = append(args, "all")
                }</span>
                <span class="cov8" title="1">err := c.runGo(context.Background(), b, args...)
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "failed to list modules")
                }</span>

                <span class="cov8" title="1">dec := json.NewDecoder(b)
                for </span><span class="cov8" title="1">{
                        m := &amp;goModule{}
                        if err := dec.Decode(m); err != nil </span><span class="cov8" title="1">{
                                if err == io.EOF </span><span class="cov8" title="1">{
                                        break</span>
                                }
                                <span class="cov0" title="0">return errors.Wrap(err, "failed to decode modules list")</span>
                        }

                        <span class="cov8" title="1">if err := handle(m); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">var modules goModules
        err := listAndDecodeModules(func(m *goModule) error </span><span class="cov8" title="1">{
                modules = append(modules, m)
                return nil
        }</span>)
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // From Go 1.17, go lazy loads transitive dependencies.
        // That does not work for us.
        // So, download these modules and update the Dir in the modules list.
        <span class="cov8" title="1">var modulesToDownload []string
        for _, m := range modules </span><span class="cov8" title="1">{
                if m.Dir == "" </span><span class="cov8" title="1">{
                        modulesToDownload = append(modulesToDownload, fmt.Sprintf("%s@%s", m.Path, m.Version))
                }</span>
        }

        <span class="cov8" title="1">if len(modulesToDownload) &gt; 0 </span><span class="cov8" title="1">{
                if err := downloadModules(modulesToDownload...); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">err := listAndDecodeModules(func(m *goModule) error </span><span class="cov8" title="1">{
                        if mm := modules.GetByPath(m.Path); mm != nil </span><span class="cov8" title="1">{
                                mm.Dir = m.Dir
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }, modulesToDownload...)
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return modules, err</span>
}

func (c *Client) rewriteGoMod(name string, isGoMod map[string]bool) error <span class="cov0" title="0">{
        data, err := c.rewriteGoModRewrite(name, isGoMod)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">if data != nil </span><span class="cov0" title="0">{
                if err := afero.WriteFile(c.fs, filepath.Join(c.ccfg.WorkingDir, name), data, 0666); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) rewriteGoModRewrite(name string, isGoMod map[string]bool) ([]byte, error) <span class="cov0" title="0">{
        if name == goModFilename &amp;&amp; c.GoModulesFilename == "" </span><span class="cov0" title="0">{
                // Already checked.
                return nil, nil
        }</span>

        <span class="cov0" title="0">modlineSplitter := getModlineSplitter(name == goModFilename)

        b := &amp;bytes.Buffer{}
        f, err := c.fs.Open(filepath.Join(c.ccfg.WorkingDir, name))
        if err != nil </span><span class="cov0" title="0">{
                if os.IsNotExist(err) </span><span class="cov0" title="0">{
                        // It's been deleted.
                        return nil, nil
                }</span>
                <span class="cov0" title="0">return nil, err</span>
        }
        <span class="cov0" title="0">defer f.Close()

        scanner := bufio.NewScanner(f)
        var dirty bool

        for scanner.Scan() </span><span class="cov0" title="0">{
                line := scanner.Text()
                var doWrite bool

                if parts := modlineSplitter(line); parts != nil </span><span class="cov0" title="0">{
                        modname, modver := parts[0], parts[1]
                        modver = strings.TrimSuffix(modver, "/"+goModFilename)
                        modnameVer := modname + " " + modver
                        doWrite = isGoMod[modnameVer]
                }</span> else<span class="cov0" title="0"> {
                        doWrite = true
                }</span>

                <span class="cov0" title="0">if doWrite </span><span class="cov0" title="0">{
                        fmt.Fprintln(b, line)
                }</span> else<span class="cov0" title="0"> {
                        dirty = true
                }</span>
        }

        <span class="cov0" title="0">if !dirty </span><span class="cov0" title="0">{
                // Nothing changed
                return nil, nil
        }</span>

        <span class="cov0" title="0">return b.Bytes(), nil</span>
}

func (c *Client) rmVendorDir(vendorDir string) error <span class="cov8" title="1">{
        modulestxt := filepath.Join(vendorDir, vendorModulesFilename)

        if _, err := c.fs.Stat(vendorDir); err != nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov0" title="0">_, err := c.fs.Stat(modulestxt)
        if err != nil </span><span class="cov0" title="0">{
                // If we have a _vendor dir without modules.txt it sounds like
                // a _vendor dir created by others.
                return errors.New("found _vendor dir without modules.txt, skip delete")
        }</span>

        <span class="cov0" title="0">return c.fs.RemoveAll(vendorDir)</span>
}

func (c *Client) runGo(
        ctx context.Context,
        stdout io.Writer,
        args ...string) error <span class="cov8" title="1">{
        if c.goBinaryStatus != 0 </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">stderr := new(bytes.Buffer)

        argsv := collections.StringSliceToInterfaceSlice(args)
        argsv = append(argsv, hexec.WithEnviron(c.environ))
        argsv = append(argsv, hexec.WithStderr(io.MultiWriter(stderr, os.Stderr)))
        argsv = append(argsv, hexec.WithStdout(stdout))
        argsv = append(argsv, hexec.WithDir(c.ccfg.WorkingDir))
        argsv = append(argsv, hexec.WithContext(ctx))

        cmd, err := c.ccfg.Exec.New("go", argsv...)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                if ee, ok := err.(*exec.Error); ok &amp;&amp; ee.Err == exec.ErrNotFound </span><span class="cov0" title="0">{
                        c.goBinaryStatus = goBinaryStatusNotFound
                        return nil
                }</span>

                <span class="cov0" title="0">if strings.Contains(stderr.String(), "invalid version: unknown revision") </span><span class="cov0" title="0">{
                        // See https://github.com/gohugoio/hugo/issues/6825
                        c.logger.Println(`An unknown revision most likely means that someone has deleted the remote ref (e.g. with a force push to GitHub).
To resolve this, you need to manually edit your go.mod file and replace the version for the module in question with a valid ref.

The easiest is to just enter a valid branch name there, e.g. master, which would be what you put in place of 'v0.5.1' in the example below.

require github.com/gohugoio/hugo-mod-jslibs/instantpage v0.5.1

If you then run 'hugo mod graph' it should resolve itself to the most recent version (or commit if no semver versions are available).`)
                }</span>

                <span class="cov0" title="0">_, ok := err.(*exec.ExitError)
                if !ok </span><span class="cov0" title="0">{
                        return errors.Errorf("failed to execute 'go %v': %s %T", args, err, err)
                }</span>

                // Too old Go version
                <span class="cov0" title="0">if strings.Contains(stderr.String(), "flag provided but not defined") </span><span class="cov0" title="0">{
                        c.goBinaryStatus = goBinaryStatusTooOld
                        return nil
                }</span>

                <span class="cov0" title="0">return errors.Errorf("go command failed: %s", stderr)</span>

        }

        <span class="cov8" title="1">return nil</span>
}

func (c *Client) tidy(mods Modules, goModOnly bool) error <span class="cov0" title="0">{
        isGoMod := make(map[string]bool)
        for _, m := range mods </span><span class="cov0" title="0">{
                if m.Owner() == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if m.IsGoMod() </span><span class="cov0" title="0">{
                        // Matching the format in go.mod
                        pathVer := m.Path() + " " + m.Version()
                        isGoMod[pathVer] = true
                }</span>
        }

        <span class="cov0" title="0">if err := c.rewriteGoMod(goModFilename, isGoMod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if goModOnly </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">if err := c.rewriteGoMod(goSumFilename, isGoMod); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (c *Client) shouldVendor(path string) bool <span class="cov8" title="1">{
        return c.noVendor == nil || !c.noVendor.Match(path)
}</span>

func (c *Client) createThemeDirname(modulePath string, isProjectMod bool) (string, error) <span class="cov8" title="1">{
        invalid := errors.Errorf("invalid module path %q; must be relative to themesDir when defined outside of the project", modulePath)

        modulePath = filepath.Clean(modulePath)
        if filepath.IsAbs(modulePath) </span><span class="cov8" title="1">{
                if isProjectMod </span><span class="cov8" title="1">{
                        return modulePath, nil
                }</span>
                <span class="cov8" title="1">return "", invalid</span>
        }

        <span class="cov8" title="1">moduleDir := filepath.Join(c.ccfg.ThemesDir, modulePath)
        if !isProjectMod &amp;&amp; !strings.HasPrefix(moduleDir, c.ccfg.ThemesDir) </span><span class="cov8" title="1">{
                return "", invalid
        }</span>
        <span class="cov8" title="1">return moduleDir, nil</span>
}

// ClientConfig configures the module Client.
type ClientConfig struct {
        Fs     afero.Fs
        Logger loggers.Logger

        // If set, it will be run before we do any duplicate checks for modules
        // etc.
        HookBeforeFinalize func(m *ModulesConfig) error

        // Ignore any _vendor directory for module paths matching the given pattern.
        // This can be nil.
        IgnoreVendor glob.Glob

        // Absolute path to the project dir.
        WorkingDir string

        // Absolute path to the project's themes dir.
        ThemesDir string

        // Eg. "production"
        Environment string

        Exec *hexec.Exec

        CacheDir     string // Module cache
        ModuleConfig Config
}

func (c ClientConfig) shouldIgnoreVendor(path string) bool <span class="cov8" title="1">{
        return c.IgnoreVendor != nil &amp;&amp; c.IgnoreVendor.Match(path)
}</span>

type goBinaryStatus int

type goModule struct {
        Path     string         // module path
        Version  string         // module version
        Versions []string       // available module versions (with -versions)
        Replace  *goModule      // replaced by this module
        Time     *time.Time     // time version was created
        Update   *goModule      // available update, if any (with -u)
        Main     bool           // is this the main module?
        Indirect bool           // is this module only an indirect dependency of main module?
        Dir      string         // directory holding files for this module, if any
        GoMod    string         // path to go.mod file for this module, if any
        Error    *goModuleError // error loading module
}

type goModuleError struct {
        Err string // the error itself
}

type goModules []*goModule

func (modules goModules) GetByPath(p string) *goModule <span class="cov8" title="1">{
        if modules == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">for _, m := range modules </span><span class="cov8" title="1">{
                if strings.EqualFold(p, m.Path) </span><span class="cov8" title="1">{
                        return m
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (modules goModules) GetMain() *goModule <span class="cov8" title="1">{
        for _, m := range modules </span><span class="cov8" title="1">{
                if m.Main </span><span class="cov8" title="1">{
                        return m
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func getModlineSplitter(isGoMod bool) func(line string) []string <span class="cov8" title="1">{
        if isGoMod </span><span class="cov8" title="1">{
                return func(line string) []string </span><span class="cov8" title="1">{
                        if strings.HasPrefix(line, "require (") </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">if !strings.HasPrefix(line, "require") &amp;&amp; !strings.HasPrefix(line, "\t") </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">line = strings.TrimPrefix(line, "require")
                        line = strings.TrimSpace(line)
                        line = strings.TrimSuffix(line, "// indirect")

                        return strings.Fields(line)</span>
                }
        }

        <span class="cov8" title="1">return func(line string) []string </span><span class="cov8" title="1">{
                return strings.Fields(line)
        }</span>
}

func pathVersion(m Module) string <span class="cov8" title="1">{
        versionStr := m.Version()
        if m.Vendor() </span><span class="cov8" title="1">{
                versionStr += "+vendor"
        }</span>
        <span class="cov8" title="1">if versionStr == "" </span><span class="cov8" title="1">{
                return m.Path()
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("%s@%s", m.Path(), versionStr)</span>
}
</pre>
		
		<pre class="file" id="file174" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package modules

import (
        "bufio"
        "fmt"
        "os"
        "path/filepath"
        "regexp"
        "strings"
        "time"

        "github.com/bep/debounce"
        "github.com/gohugoio/hugo/common/loggers"

        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/parser/metadecoders"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/rogpeppe/go-internal/module"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/config"
        "github.com/spf13/afero"
)

var ErrNotExist = errors.New("module does not exist")

const vendorModulesFilename = "modules.txt"

// IsNotExist returns whether an error means that a module could not be found.
func IsNotExist(err error) bool <span class="cov0" title="0">{
        return errors.Cause(err) == ErrNotExist
}</span>

// CreateProjectModule creates modules from the given config.
// This is used in tests only.
func CreateProjectModule(cfg config.Provider) (Module, error) <span class="cov0" title="0">{
        workingDir := cfg.GetString("workingDir")
        var modConfig Config

        mod := createProjectModule(nil, workingDir, modConfig)
        if err := ApplyProjectConfigDefaults(cfg, mod); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return mod, nil</span>
}

func (h *Client) Collect() (ModulesConfig, error) <span class="cov8" title="1">{
        mc, coll := h.collect(true)
        if coll.err != nil </span><span class="cov0" title="0">{
                return mc, coll.err
        }</span>

        <span class="cov8" title="1">if err := (&amp;mc).setActiveMods(h.logger); err != nil </span><span class="cov0" title="0">{
                return mc, err
        }</span>

        <span class="cov8" title="1">if h.ccfg.HookBeforeFinalize != nil </span><span class="cov0" title="0">{
                if err := h.ccfg.HookBeforeFinalize(&amp;mc); err != nil </span><span class="cov0" title="0">{
                        return mc, err
                }</span>
        }

        <span class="cov8" title="1">if err := (&amp;mc).finalize(h.logger); err != nil </span><span class="cov0" title="0">{
                return mc, err
        }</span>

        <span class="cov8" title="1">return mc, nil</span>
}

func (h *Client) collect(tidy bool) (ModulesConfig, *collector) <span class="cov8" title="1">{
        c := &amp;collector{
                Client: h,
        }

        c.collect()
        if c.err != nil </span><span class="cov0" title="0">{
                return ModulesConfig{}, c
        }</span>

        // https://github.com/gohugoio/hugo/issues/6115
        /*if !c.skipTidy &amp;&amp; tidy {
                if err := h.tidy(c.modules, true); err != nil {
                        c.err = err
                        return ModulesConfig{}, c
                }
        }*/

        <span class="cov8" title="1">return ModulesConfig{
                AllModules:        c.modules,
                GoModulesFilename: c.GoModulesFilename,
        }, c</span>
}

type ModulesConfig struct {
        // All modules, including any disabled.
        AllModules Modules

        // All active modules.
        ActiveModules Modules

        // Set if this is a Go modules enabled project.
        GoModulesFilename string
}

func (m *ModulesConfig) setActiveMods(logger loggers.Logger) error <span class="cov8" title="1">{
        var activeMods Modules
        for _, mod := range m.AllModules </span><span class="cov8" title="1">{
                if !mod.Config().HugoVersion.IsValid() </span><span class="cov0" title="0">{
                        logger.Warnf(`Module %q is not compatible with this Hugo version; run "hugo mod graph" for more information.`, mod.Path())
                }</span>
                <span class="cov8" title="1">if !mod.Disabled() </span><span class="cov8" title="1">{
                        activeMods = append(activeMods, mod)
                }</span>
        }

        <span class="cov8" title="1">m.ActiveModules = activeMods

        return nil</span>
}

func (m *ModulesConfig) finalize(logger loggers.Logger) error <span class="cov8" title="1">{
        for _, mod := range m.AllModules </span><span class="cov8" title="1">{
                m := mod.(*moduleAdapter)
                m.mounts = filterUnwantedMounts(m.mounts)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func filterUnwantedMounts(mounts []Mount) []Mount <span class="cov8" title="1">{
        // Remove duplicates
        seen := make(map[string]bool)
        tmp := mounts[:0]
        for _, m := range mounts </span><span class="cov8" title="1">{
                if !seen[m.key()] </span><span class="cov8" title="1">{
                        tmp = append(tmp, m)
                }</span>
                <span class="cov8" title="1">seen[m.key()] = true</span>
        }
        <span class="cov8" title="1">return tmp</span>
}

type collected struct {
        // Pick the first and prevent circular loops.
        seen map[string]bool

        // Maps module path to a _vendor dir. These values are fetched from
        // _vendor/modules.txt, and the first (top-most) will win.
        vendored map[string]vendoredModule

        // Set if a Go modules enabled project.
        gomods goModules

        // Ordered list of collected modules, including Go Modules and theme
        // components stored below /themes.
        modules Modules
}

// Collects and creates a module tree.
type collector struct {
        *Client

        // Store away any non-fatal error and return at the end.
        err error

        // Set to disable any Tidy operation in the end.
        skipTidy bool

        *collected
}

func (c *collector) initModules() error <span class="cov8" title="1">{
        c.collected = &amp;collected{
                seen:     make(map[string]bool),
                vendored: make(map[string]vendoredModule),
                gomods:   goModules{},
        }

        // If both these are true, we don't even need Go installed to build.
        if c.ccfg.IgnoreVendor == nil &amp;&amp; c.isVendored(c.ccfg.WorkingDir) </span><span class="cov8" title="1">{
                return nil
        }</span>

        // We may fail later if we don't find the mods.
        <span class="cov8" title="1">return c.loadModules()</span>
}

func (c *collector) isSeen(path string) bool <span class="cov8" title="1">{
        key := pathKey(path)
        if c.seen[key] </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">c.seen[key] = true
        return false</span>
}

func (c *collector) getVendoredDir(path string) (vendoredModule, bool) <span class="cov8" title="1">{
        v, found := c.vendored[path]
        return v, found
}</span>

func (c *collector) add(owner *moduleAdapter, moduleImport Import, disabled bool) (*moduleAdapter, error) <span class="cov8" title="1">{
        var (
                mod       *goModule
                moduleDir string
                version   string
                vendored  bool
        )

        modulePath := moduleImport.Path
        var realOwner Module = owner

        if !c.ccfg.shouldIgnoreVendor(modulePath) </span><span class="cov8" title="1">{
                if err := c.collectModulesTXT(owner); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                // Try _vendor first.
                <span class="cov8" title="1">var vm vendoredModule
                vm, vendored = c.getVendoredDir(modulePath)
                if vendored </span><span class="cov8" title="1">{
                        moduleDir = vm.Dir
                        realOwner = vm.Owner
                        version = vm.Version

                        if owner.projectMod </span><span class="cov8" title="1">{
                                // We want to keep the go.mod intact with the versions and all.
                                c.skipTidy = true
                        }</span>

                }
        }

        <span class="cov8" title="1">if moduleDir == "" </span><span class="cov8" title="1">{
                var versionQuery string
                mod = c.gomods.GetByPath(modulePath)
                if mod != nil </span><span class="cov8" title="1">{
                        moduleDir = mod.Dir
                        versionQuery = mod.Version
                }</span>

                <span class="cov8" title="1">if moduleDir == "" </span><span class="cov8" title="1">{
                        if c.GoModulesFilename != "" &amp;&amp; isProbablyModule(modulePath) </span><span class="cov8" title="1">{
                                // Try to "go get" it and reload the module configuration.
                                if versionQuery == "" </span><span class="cov8" title="1">{
                                        // See https://golang.org/ref/mod#version-queries
                                        // This will select the latest release-version (not beta etc.).
                                        versionQuery = "upgrade"
                                }</span>
                                <span class="cov8" title="1">if err := c.Get(fmt.Sprintf("%s@%s", modulePath, versionQuery)); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>
                                <span class="cov8" title="1">if err := c.loadModules(); err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">mod = c.gomods.GetByPath(modulePath)
                                if mod != nil </span><span class="cov8" title="1">{
                                        moduleDir = mod.Dir
                                }</span>
                        }

                        // Fall back to project/themes/&lt;mymodule&gt;
                        <span class="cov8" title="1">if moduleDir == "" </span><span class="cov0" title="0">{
                                var err error
                                moduleDir, err = c.createThemeDirname(modulePath, owner.projectMod || moduleImport.pathProjectReplaced)
                                if err != nil </span><span class="cov0" title="0">{
                                        c.err = err
                                        return nil, nil
                                }</span>
                                <span class="cov0" title="0">if found, _ := afero.Exists(c.fs, moduleDir); !found </span><span class="cov0" title="0">{
                                        c.err = c.wrapModuleNotFound(errors.Errorf(`module %q not found; either add it as a Hugo Module or store it in %q.`, modulePath, c.ccfg.ThemesDir))
                                        return nil, nil
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">if found, _ := afero.Exists(c.fs, moduleDir); !found </span><span class="cov0" title="0">{
                c.err = c.wrapModuleNotFound(errors.Errorf("%q not found", moduleDir))
                return nil, nil
        }</span>

        <span class="cov8" title="1">if !strings.HasSuffix(moduleDir, fileSeparator) </span><span class="cov8" title="1">{
                moduleDir += fileSeparator
        }</span>

        <span class="cov8" title="1">ma := &amp;moduleAdapter{
                dir:      moduleDir,
                vendor:   vendored,
                disabled: disabled,
                gomod:    mod,
                version:  version,
                // This may be the owner of the _vendor dir
                owner: realOwner,
        }

        if mod == nil </span><span class="cov8" title="1">{
                ma.path = modulePath
        }</span>

        <span class="cov8" title="1">if !moduleImport.IgnoreConfig </span><span class="cov8" title="1">{
                if err := c.applyThemeConfig(ma); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">if err := c.applyMounts(moduleImport, ma); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">c.modules = append(c.modules, ma)
        return ma, nil</span>
}

func (c *collector) addAndRecurse(owner *moduleAdapter, disabled bool) error <span class="cov8" title="1">{
        moduleConfig := owner.Config()
        if owner.projectMod </span><span class="cov8" title="1">{
                if err := c.applyMounts(Import{}, owner); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">for _, moduleImport := range moduleConfig.Imports </span><span class="cov8" title="1">{
                disabled := disabled || moduleImport.Disable

                if !c.isSeen(moduleImport.Path) </span><span class="cov8" title="1">{
                        tc, err := c.add(owner, moduleImport, disabled)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">if tc == nil || moduleImport.IgnoreImports </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if err := c.addAndRecurse(tc, disabled); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }
        <span class="cov8" title="1">return nil</span>
}

func (c *collector) applyMounts(moduleImport Import, mod *moduleAdapter) error <span class="cov8" title="1">{
        if moduleImport.NoMounts </span><span class="cov0" title="0">{
                mod.mounts = nil
                return nil
        }</span>

        <span class="cov8" title="1">mounts := moduleImport.Mounts

        modConfig := mod.Config()

        if len(mounts) == 0 </span><span class="cov8" title="1">{
                // Mounts not defined by the import.
                mounts = modConfig.Mounts
        }</span>

        <span class="cov8" title="1">if !mod.projectMod &amp;&amp; len(mounts) == 0 </span><span class="cov8" title="1">{
                // Create default mount points for every component folder that
                // exists in the module.
                for _, componentFolder := range files.ComponentFolders </span><span class="cov8" title="1">{
                        sourceDir := filepath.Join(mod.Dir(), componentFolder)
                        _, err := c.fs.Stat(sourceDir)
                        if err == nil </span><span class="cov8" title="1">{
                                mounts = append(mounts, Mount{
                                        Source: componentFolder,
                                        Target: componentFolder,
                                })
                        }</span>
                }
        }

        <span class="cov8" title="1">var err error
        mounts, err = c.normalizeMounts(mod, mounts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">mounts, err = c.mountCommonJSConfig(mod, mounts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">mod.mounts = mounts
        return nil</span>
}

func (c *collector) applyThemeConfig(tc *moduleAdapter) error <span class="cov8" title="1">{
        var (
                configFilename string
                themeCfg       map[string]interface{}
                hasConfigFile  bool
                err            error
        )

        // Viper supports more, but this is the sub-set supported by Hugo.
        for _, configFormats := range config.ValidConfigFileExtensions </span><span class="cov8" title="1">{
                configFilename = filepath.Join(tc.Dir(), "config."+configFormats)
                hasConfigFile, _ = afero.Exists(c.fs, configFilename)
                if hasConfigFile </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        // The old theme information file.
        <span class="cov8" title="1">themeTOML := filepath.Join(tc.Dir(), "theme.toml")

        hasThemeTOML, _ := afero.Exists(c.fs, themeTOML)
        if hasThemeTOML </span><span class="cov0" title="0">{
                data, err := afero.ReadFile(c.fs, themeTOML)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">themeCfg, err = metadecoders.Default.UnmarshalToMap(data, metadecoders.TOML)
                if err != nil </span><span class="cov0" title="0">{
                        c.logger.Warnf("Failed to read module config for %q in %q: %s", tc.Path(), themeTOML, err)
                }</span> else<span class="cov0" title="0"> {
                        maps.PrepareParams(themeCfg)
                }</span>
        }

        <span class="cov8" title="1">if hasConfigFile </span><span class="cov8" title="1">{
                if configFilename != "" </span><span class="cov8" title="1">{
                        var err error
                        tc.cfg, err = config.FromFile(c.fs, configFilename)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }

                <span class="cov8" title="1">tc.configFilenames = append(tc.configFilenames, configFilename)</span>

        }

        // Also check for a config dir, which we overlay on top of the file configuration.
        <span class="cov8" title="1">configDir := filepath.Join(tc.Dir(), "config")
        dcfg, dirnames, err := config.LoadConfigFromDir(c.fs, configDir, c.ccfg.Environment)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if len(dirnames) &gt; 0 </span><span class="cov0" title="0">{
                tc.configFilenames = append(tc.configFilenames, dirnames...)

                if hasConfigFile </span><span class="cov0" title="0">{
                        // Set will overwrite existing keys.
                        tc.cfg.Set("", dcfg.Get(""))
                }</span> else<span class="cov0" title="0"> {
                        tc.cfg = dcfg
                }</span>
        }

        <span class="cov8" title="1">config, err := decodeConfig(tc.cfg, c.moduleConfig.replacementsMap)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">const oldVersionKey = "min_version"

        if hasThemeTOML </span><span class="cov0" title="0">{

                // Merge old with new
                if minVersion, found := themeCfg[oldVersionKey]; found </span><span class="cov0" title="0">{
                        if config.HugoVersion.Min == "" </span><span class="cov0" title="0">{
                                config.HugoVersion.Min = hugo.VersionString(cast.ToString(minVersion))
                        }</span>
                }

                <span class="cov0" title="0">if config.Params == nil </span><span class="cov0" title="0">{
                        config.Params = make(map[string]interface{})
                }</span>

                <span class="cov0" title="0">for k, v := range themeCfg </span><span class="cov0" title="0">{
                        if k == oldVersionKey </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">config.Params[k] = v</span>
                }

        }

        <span class="cov8" title="1">tc.config = config

        return nil</span>
}

func (c *collector) collect() <span class="cov8" title="1">{
        defer c.logger.PrintTimerIfDelayed(time.Now(), "hugo: collected modules")
        d := debounce.New(2 * time.Second)
        d(func() </span><span class="cov8" title="1">{
                c.logger.Println("hugo: downloading modules …")
        }</span>)
        <span class="cov8" title="1">defer d(func() </span>{<span class="cov8" title="1">}</span>)

        <span class="cov8" title="1">if err := c.initModules(); err != nil </span><span class="cov0" title="0">{
                c.err = err
                return
        }</span>

        <span class="cov8" title="1">projectMod := createProjectModule(c.gomods.GetMain(), c.ccfg.WorkingDir, c.moduleConfig)

        if err := c.addAndRecurse(projectMod, false); err != nil </span><span class="cov0" title="0">{
                c.err = err
                return
        }</span>

        // Add the project mod on top.
        <span class="cov8" title="1">c.modules = append(Modules{projectMod}, c.modules...)</span>
}

func (c *collector) isVendored(dir string) bool <span class="cov8" title="1">{
        _, err := c.fs.Stat(filepath.Join(dir, vendord, vendorModulesFilename))
        return err == nil
}</span>

func (c *collector) collectModulesTXT(owner Module) error <span class="cov8" title="1">{
        vendorDir := filepath.Join(owner.Dir(), vendord)
        filename := filepath.Join(vendorDir, vendorModulesFilename)

        f, err := c.fs.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                if os.IsNotExist(err) </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">defer f.Close()

        scanner := bufio.NewScanner(f)

        for scanner.Scan() </span><span class="cov8" title="1">{
                // # github.com/alecthomas/chroma v0.6.3
                line := scanner.Text()
                line = strings.Trim(line, "# ")
                line = strings.TrimSpace(line)
                parts := strings.Fields(line)
                if len(parts) != 2 </span><span class="cov0" title="0">{
                        return errors.Errorf("invalid modules list: %q", filename)
                }</span>
                <span class="cov8" title="1">path := parts[0]

                shouldAdd := c.Client.moduleConfig.VendorClosest

                if !shouldAdd </span><span class="cov8" title="1">{
                        if _, found := c.vendored[path]; !found </span><span class="cov8" title="1">{
                                shouldAdd = true
                        }</span>
                }

                <span class="cov8" title="1">if shouldAdd </span><span class="cov8" title="1">{
                        c.vendored[path] = vendoredModule{
                                Owner:   owner,
                                Dir:     filepath.Join(vendorDir, path),
                                Version: parts[1],
                        }
                }</span>

        }
        <span class="cov8" title="1">return nil</span>
}

func (c *collector) loadModules() error <span class="cov8" title="1">{
        modules, err := c.listGoMods()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">c.gomods = modules
        return nil</span>
}

// Matches postcss.config.js etc.
var commonJSConfigs = regexp.MustCompile(`(babel|postcss|tailwind)\.config\.js`)

func (c *collector) mountCommonJSConfig(owner *moduleAdapter, mounts []Mount) ([]Mount, error) <span class="cov8" title="1">{
        for _, m := range mounts </span><span class="cov8" title="1">{
                if strings.HasPrefix(m.Target, files.JsConfigFolderMountPrefix) </span><span class="cov0" title="0">{
                        // This follows the convention of the other component types (assets, content, etc.),
                        // if one or more is specified by the user, we skip the defaults.
                        // These mounts were added to Hugo in 0.75.
                        return mounts, nil
                }</span>
        }

        // Mount the common JS config files.
        <span class="cov8" title="1">fis, err := afero.ReadDir(c.fs, owner.Dir())
        if err != nil </span><span class="cov0" title="0">{
                return mounts, err
        }</span>

        <span class="cov8" title="1">for _, fi := range fis </span><span class="cov8" title="1">{
                n := fi.Name()

                should := n == files.FilenamePackageHugoJSON || n == files.FilenamePackageJSON
                should = should || commonJSConfigs.MatchString(n)

                if should </span><span class="cov0" title="0">{
                        mounts = append(mounts, Mount{
                                Source: n,
                                Target: filepath.Join(files.ComponentFolderAssets, files.FolderJSConfig, n),
                        })
                }</span>

        }

        <span class="cov8" title="1">return mounts, nil</span>
}

func (c *collector) normalizeMounts(owner *moduleAdapter, mounts []Mount) ([]Mount, error) <span class="cov8" title="1">{
        var out []Mount
        dir := owner.Dir()

        for _, mnt := range mounts </span><span class="cov8" title="1">{
                errMsg := fmt.Sprintf("invalid module config for %q", owner.Path())

                if mnt.Source == "" || mnt.Target == "" </span><span class="cov0" title="0">{
                        return nil, errors.New(errMsg + ": both source and target must be set")
                }</span>

                <span class="cov8" title="1">mnt.Source = filepath.Clean(mnt.Source)
                mnt.Target = filepath.Clean(mnt.Target)
                var sourceDir string

                if owner.projectMod &amp;&amp; filepath.IsAbs(mnt.Source) </span><span class="cov0" title="0">{
                        // Abs paths in the main project is allowed.
                        sourceDir = mnt.Source
                }</span> else<span class="cov8" title="1"> {
                        sourceDir = filepath.Join(dir, mnt.Source)
                }</span>

                // Verify that Source exists
                <span class="cov8" title="1">_, err := c.fs.Stat(sourceDir)
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }

                // Verify that target points to one of the predefined component dirs
                <span class="cov8" title="1">targetBase := mnt.Target
                idxPathSep := strings.Index(mnt.Target, string(os.PathSeparator))
                if idxPathSep != -1 </span><span class="cov0" title="0">{
                        targetBase = mnt.Target[0:idxPathSep]
                }</span>
                <span class="cov8" title="1">if !files.IsComponentFolder(targetBase) </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("%s: mount target must be one of: %v", errMsg, files.ComponentFolders)
                }</span>

                <span class="cov8" title="1">out = append(out, mnt)</span>
        }

        <span class="cov8" title="1">return out, nil</span>
}

func (c *collector) wrapModuleNotFound(err error) error <span class="cov0" title="0">{
        err = errors.Wrap(ErrNotExist, err.Error())
        if c.GoModulesFilename == "" </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">baseMsg := "we found a go.mod file in your project, but"

        switch c.goBinaryStatus </span>{
        case goBinaryStatusNotFound:<span class="cov0" title="0">
                return errors.Wrap(err, baseMsg+" you need to install Go to use it. See https://golang.org/dl/.")</span>
        case goBinaryStatusTooOld:<span class="cov0" title="0">
                return errors.Wrap(err, baseMsg+" you need to a newer version of Go to use it. See https://golang.org/dl/.")</span>
        }

        <span class="cov0" title="0">return err</span>
}

type vendoredModule struct {
        Owner   Module
        Dir     string
        Version string
}

func createProjectModule(gomod *goModule, workingDir string, conf Config) *moduleAdapter <span class="cov8" title="1">{
        // Create a pseudo module for the main project.
        var path string
        if gomod == nil </span><span class="cov8" title="1">{
                path = "project"
        }</span>

        <span class="cov8" title="1">return &amp;moduleAdapter{
                path:       path,
                dir:        workingDir,
                gomod:      gomod,
                projectMod: true,
                config:     conf,
        }</span>
}

// In the first iteration of Hugo Modules, we do not support multiple
// major versions running at the same time, so we pick the first (upper most).
// We will investigate namespaces in future versions.
// TODO(bep) add a warning when the above happens.
func pathKey(p string) string <span class="cov8" title="1">{
        prefix, _, _ := module.SplitPathVersion(p)

        return strings.ToLower(prefix)
}</span>
</pre>
		
		<pre class="file" id="file175" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package modules

import (
        "fmt"
        "path/filepath"
        "strings"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/hugo"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/hugofs/files"
        "github.com/gohugoio/hugo/langs"
        "github.com/mitchellh/mapstructure"
)

var DefaultModuleConfig = Config{

        // Default to direct, which means "git clone" and similar. We
        // will investigate proxy settings in more depth later.
        // See https://github.com/golang/go/issues/26334
        Proxy: "direct",

        // Comma separated glob list matching paths that should not use the
        // proxy configured above.
        NoProxy: "none",

        // Comma separated glob list matching paths that should be
        // treated as private.
        Private: "*.*",

        // A list of replacement directives mapping a module path to a directory
        // or a theme component in the themes folder.
        // Note that this will turn the component into a traditional theme component
        // that does not partake in vendoring etc.
        // The syntax is the similar to the replacement directives used in go.mod, e.g:
        //    github.com/mod1 -&gt; ../mod1,github.com/mod2 -&gt; ../mod2
        Replacements: nil,
}

// ApplyProjectConfigDefaults applies default/missing module configuration for
// the main project.
func ApplyProjectConfigDefaults(cfg config.Provider, mod Module) error <span class="cov0" title="0">{
        moda := mod.(*moduleAdapter)

        // Map legacy directory config into the new module.
        languages := cfg.Get("languagesSortedDefaultFirst").(langs.Languages)
        isMultiHost := languages.IsMultihost()

        // To bridge between old and new configuration format we need
        // a way to make sure all of the core components are configured on
        // the basic level.
        componentsConfigured := make(map[string]bool)
        for _, mnt := range moda.mounts </span><span class="cov0" title="0">{
                if !strings.HasPrefix(mnt.Target, files.JsConfigFolderMountPrefix) </span><span class="cov0" title="0">{
                        componentsConfigured[mnt.Component()] = true
                }</span>
        }

        <span class="cov0" title="0">type dirKeyComponent struct {
                key          string
                component    string
                multilingual bool
        }

        dirKeys := []dirKeyComponent{
                {"contentDir", files.ComponentFolderContent, true},
                {"dataDir", files.ComponentFolderData, false},
                {"layoutDir", files.ComponentFolderLayouts, false},
                {"i18nDir", files.ComponentFolderI18n, false},
                {"archetypeDir", files.ComponentFolderArchetypes, false},
                {"assetDir", files.ComponentFolderAssets, false},
                {"", files.ComponentFolderStatic, isMultiHost},
        }

        createMountsFor := func(d dirKeyComponent, cfg config.Provider) []Mount </span><span class="cov0" title="0">{
                var lang string
                if language, ok := cfg.(*langs.Language); ok </span><span class="cov0" title="0">{
                        lang = language.Lang
                }</span>

                // Static mounts are a little special.
                <span class="cov0" title="0">if d.component == files.ComponentFolderStatic </span><span class="cov0" title="0">{
                        var mounts []Mount
                        staticDirs := getStaticDirs(cfg)
                        if len(staticDirs) &gt; 0 </span><span class="cov0" title="0">{
                                componentsConfigured[d.component] = true
                        }</span>

                        <span class="cov0" title="0">for _, dir := range staticDirs </span><span class="cov0" title="0">{
                                mounts = append(mounts, Mount{Lang: lang, Source: dir, Target: d.component})
                        }</span>

                        <span class="cov0" title="0">return mounts</span>

                }

                <span class="cov0" title="0">if cfg.IsSet(d.key) </span><span class="cov0" title="0">{
                        source := cfg.GetString(d.key)
                        componentsConfigured[d.component] = true

                        return []Mount{{
                                // No lang set for layouts etc.
                                Source: source,
                                Target: d.component,
                        }}
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov0" title="0">createMounts := func(d dirKeyComponent) []Mount </span><span class="cov0" title="0">{
                var mounts []Mount
                if d.multilingual </span><span class="cov0" title="0">{
                        if d.component == files.ComponentFolderContent </span><span class="cov0" title="0">{
                                seen := make(map[string]bool)
                                hasContentDir := false
                                for _, language := range languages </span><span class="cov0" title="0">{
                                        if language.ContentDir != "" </span><span class="cov0" title="0">{
                                                hasContentDir = true
                                                break</span>
                                        }
                                }

                                <span class="cov0" title="0">if hasContentDir </span><span class="cov0" title="0">{
                                        for _, language := range languages </span><span class="cov0" title="0">{
                                                contentDir := language.ContentDir
                                                if contentDir == "" </span><span class="cov0" title="0">{
                                                        contentDir = files.ComponentFolderContent
                                                }</span>
                                                <span class="cov0" title="0">if contentDir == "" || seen[contentDir] </span><span class="cov0" title="0">{
                                                        continue</span>
                                                }
                                                <span class="cov0" title="0">seen[contentDir] = true
                                                mounts = append(mounts, Mount{Lang: language.Lang, Source: contentDir, Target: d.component})</span>
                                        }
                                }

                                <span class="cov0" title="0">componentsConfigured[d.component] = len(seen) &gt; 0</span>

                        } else<span class="cov0" title="0"> {
                                for _, language := range languages </span><span class="cov0" title="0">{
                                        mounts = append(mounts, createMountsFor(d, language)...)
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        mounts = append(mounts, createMountsFor(d, cfg)...)
                }</span>

                <span class="cov0" title="0">return mounts</span>
        }

        <span class="cov0" title="0">var mounts []Mount
        for _, dirKey := range dirKeys </span><span class="cov0" title="0">{
                if componentsConfigured[dirKey.component] </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">mounts = append(mounts, createMounts(dirKey)...)</span>

        }

        // Add default configuration
        <span class="cov0" title="0">for _, dirKey := range dirKeys </span><span class="cov0" title="0">{
                if componentsConfigured[dirKey.component] </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">mounts = append(mounts, Mount{Source: dirKey.component, Target: dirKey.component})</span>
        }

        // Prepend the mounts from configuration.
        <span class="cov0" title="0">mounts = append(moda.mounts, mounts...)

        moda.mounts = mounts

        return nil</span>
}

// DecodeConfig creates a modules Config from a given Hugo configuration.
func DecodeConfig(cfg config.Provider) (Config, error) <span class="cov8" title="1">{
        return decodeConfig(cfg, nil)
}</span>

func decodeConfig(cfg config.Provider, pathReplacements map[string]string) (Config, error) <span class="cov8" title="1">{
        c := DefaultModuleConfig
        c.replacementsMap = pathReplacements

        if cfg == nil </span><span class="cov0" title="0">{
                return c, nil
        }</span>

        <span class="cov8" title="1">themeSet := cfg.IsSet("theme")
        moduleSet := cfg.IsSet("module")

        if moduleSet </span><span class="cov8" title="1">{
                m := cfg.GetStringMap("module")
                if err := mapstructure.WeakDecode(m, &amp;c); err != nil </span><span class="cov0" title="0">{
                        return c, err
                }</span>

                <span class="cov8" title="1">if c.replacementsMap == nil </span><span class="cov8" title="1">{

                        if len(c.Replacements) == 1 </span><span class="cov8" title="1">{
                                c.Replacements = strings.Split(c.Replacements[0], ",")
                        }</span>

                        <span class="cov8" title="1">for i, repl := range c.Replacements </span><span class="cov8" title="1">{
                                c.Replacements[i] = strings.TrimSpace(repl)
                        }</span>

                        <span class="cov8" title="1">c.replacementsMap = make(map[string]string)
                        for _, repl := range c.Replacements </span><span class="cov8" title="1">{
                                parts := strings.Split(repl, "-&gt;")
                                if len(parts) != 2 </span><span class="cov0" title="0">{
                                        return c, errors.Errorf(`invalid module.replacements: %q; configure replacement pairs on the form "oldpath-&gt;newpath" `, repl)
                                }</span>

                                <span class="cov8" title="1">c.replacementsMap[strings.TrimSpace(parts[0])] = strings.TrimSpace(parts[1])</span>
                        }
                }

                <span class="cov8" title="1">if c.replacementsMap != nil &amp;&amp; c.Imports != nil </span><span class="cov8" title="1">{
                        for i, imp := range c.Imports </span><span class="cov8" title="1">{
                                if newImp, found := c.replacementsMap[imp.Path]; found </span><span class="cov8" title="1">{
                                        imp.Path = newImp
                                        imp.pathProjectReplaced = true
                                        c.Imports[i] = imp
                                }</span>
                        }
                }

                <span class="cov8" title="1">for i, mnt := range c.Mounts </span><span class="cov8" title="1">{
                        mnt.Source = filepath.Clean(mnt.Source)
                        mnt.Target = filepath.Clean(mnt.Target)
                        c.Mounts[i] = mnt
                }</span>

        }

        <span class="cov8" title="1">if themeSet </span><span class="cov8" title="1">{
                imports := config.GetStringSlicePreserveString(cfg, "theme")
                for _, imp := range imports </span><span class="cov8" title="1">{
                        c.Imports = append(c.Imports, Import{
                                Path: imp,
                        })
                }</span>

        }

        <span class="cov8" title="1">return c, nil</span>
}

// Config holds a module config.
type Config struct {
        Mounts  []Mount
        Imports []Import

        // Meta info about this module (license information etc.).
        Params map[string]interface{}

        // Will be validated against the running Hugo version.
        HugoVersion HugoVersion

        // A optional Glob pattern matching module paths to skip when vendoring, e.g.
        // "github.com/**".
        NoVendor string

        // When enabled, we will pick the vendored module closest to the module
        // using it.
        // The default behaviour is to pick the first.
        // Note that there can still be only one dependency of a given module path,
        // so once it is in use it cannot be redefined.
        VendorClosest bool

        Replacements    []string
        replacementsMap map[string]string

        // Configures GOPROXY.
        Proxy string
        // Configures GONOPROXY.
        NoProxy string
        // Configures GOPRIVATE.
        Private string
}

// hasModuleImport reports whether the project config have one or more
// modules imports, e.g. github.com/bep/myshortcodes.
func (c Config) hasModuleImport() bool <span class="cov8" title="1">{
        for _, imp := range c.Imports </span><span class="cov8" title="1">{
                if isProbablyModule(imp.Path) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

// HugoVersion holds Hugo binary version requirements for a module.
type HugoVersion struct {
        // The minimum Hugo version that this module works with.
        Min hugo.VersionString

        // The maximum Hugo version that this module works with.
        Max hugo.VersionString

        // Set if the extended version is needed.
        Extended bool
}

func (v HugoVersion) String() string <span class="cov0" title="0">{
        extended := ""
        if v.Extended </span><span class="cov0" title="0">{
                extended = " extended"
        }</span>

        <span class="cov0" title="0">if v.Min != "" &amp;&amp; v.Max != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("%s/%s%s", v.Min, v.Max, extended)
        }</span>

        <span class="cov0" title="0">if v.Min != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Min %s%s", v.Min, extended)
        }</span>

        <span class="cov0" title="0">if v.Max != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("Max %s%s", v.Max, extended)
        }</span>

        <span class="cov0" title="0">return extended</span>
}

// IsValid reports whether this version is valid compared to the running
// Hugo binary.
func (v HugoVersion) IsValid() bool <span class="cov8" title="1">{
        current := hugo.CurrentVersion.Version()
        if v.Extended &amp;&amp; !hugo.IsExtended </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">isValid := true

        if v.Min != "" &amp;&amp; current.Compare(v.Min) &gt; 0 </span><span class="cov0" title="0">{
                isValid = false
        }</span>

        <span class="cov8" title="1">if v.Max != "" &amp;&amp; current.Compare(v.Max) &lt; 0 </span><span class="cov8" title="1">{
                isValid = false
        }</span>

        <span class="cov8" title="1">return isValid</span>
}

type Import struct {
        Path                string // Module path
        pathProjectReplaced bool   // Set when Path is replaced in project config.
        IgnoreConfig        bool   // Ignore any config in config.toml (will still follow imports).
        IgnoreImports       bool   // Do not follow any configured imports.
        NoMounts            bool   // Do not mount any folder in this import.
        NoVendor            bool   // Never vendor this import (only allowed in main project).
        Disable             bool   // Turn off this module.
        Mounts              []Mount
}

type Mount struct {
        Source string // relative path in source repo, e.g. "scss"
        Target string // relative target path, e.g. "assets/bootstrap/scss"

        Lang string // any language code associated with this mount.

        // Include only files matching the given Glob patterns (string or slice).
        IncludeFiles interface{}

        // Exclude all files matching the given Glob patterns (string or slice).
        ExcludeFiles interface{}
}

// Used as key to remove duplicates.
func (m Mount) key() string <span class="cov8" title="1">{
        return strings.Join([]string{m.Lang, m.Source, m.Target}, "/")
}</span>

func (m Mount) Component() string <span class="cov0" title="0">{
        return strings.Split(m.Target, fileSeparator)[0]
}</span>

func (m Mount) ComponentAndName() (string, string) <span class="cov0" title="0">{
        k := strings.Index(m.Target, fileSeparator)
        if k == -1 </span><span class="cov0" title="0">{
                return m.Target, ""
        }</span>
        <span class="cov0" title="0">return m.Target[:k], m.Target[k+1:]</span>
}

func getStaticDirs(cfg config.Provider) []string <span class="cov0" title="0">{
        var staticDirs []string
        for i := -1; i &lt;= 10; i++ </span><span class="cov0" title="0">{
                staticDirs = append(staticDirs, getStringOrStringSlice(cfg, "staticDir", i)...)
        }</span>
        <span class="cov0" title="0">return staticDirs</span>
}

func getStringOrStringSlice(cfg config.Provider, key string, id int) []string <span class="cov0" title="0">{
        if id &gt;= 0 </span><span class="cov0" title="0">{
                key = fmt.Sprintf("%s%d", key, id)
        }</span>

        <span class="cov0" title="0">return config.GetStringSlicePreserveString(cfg, key)</span>
}
</pre>
		
		<pre class="file" id="file176" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package modules provides a client that can be used to manage Hugo Components,
// what's referred to as Hugo Modules. Hugo Modules is built on top of Go Modules,
// but also supports vendoring and components stored directly in the themes dir.
package modules

import (
        "time"

        "github.com/gohugoio/hugo/config"
)

var _ Module = (*moduleAdapter)(nil)

type Module interface {

        // Optional config read from the configFilename above.
        Cfg() config.Provider

        // The decoded module config and mounts.
        Config() Config

        // Optional configuration filenames (e.g. "/themes/mytheme/config.json").
        // This will be added to the special configuration watch list when in
        // server mode.
        ConfigFilenames() []string

        // Directory holding files for this module.
        Dir() string

        // This module is disabled.
        Disabled() bool

        // Returns whether this is a Go Module.
        IsGoMod() bool

        // Any directory remappings.
        Mounts() []Mount

        // In the dependency tree, this is the first module that defines this module
        // as a dependency.
        Owner() Module

        // Returns the path to this module.
        // This will either be the module path, e.g. "github.com/gohugoio/myshortcodes",
        // or the path below your /theme folder, e.g. "mytheme".
        Path() string

        // Replaced by this module.
        Replace() Module

        // Returns whether Dir points below the _vendor dir.
        Vendor() bool

        // The module version.
        Version() string

        // Time version was created.
        Time() time.Time

        // Whether this module's dir is a watch candidate.
        Watch() bool
}

type Modules []Module

type moduleAdapter struct {
        path       string
        dir        string
        version    string
        vendor     bool
        disabled   bool
        projectMod bool
        owner      Module

        mounts []Mount

        configFilenames []string
        cfg             config.Provider
        config          Config

        // Set if a Go module.
        gomod *goModule
}

func (m *moduleAdapter) Cfg() config.Provider <span class="cov0" title="0">{
        return m.cfg
}</span>

func (m *moduleAdapter) Config() Config <span class="cov8" title="1">{
        return m.config
}</span>

func (m *moduleAdapter) ConfigFilenames() []string <span class="cov0" title="0">{
        return m.configFilenames
}</span>

func (m *moduleAdapter) Dir() string <span class="cov8" title="1">{
        // This may point to the _vendor dir.
        if !m.IsGoMod() || m.dir != "" </span><span class="cov8" title="1">{
                return m.dir
        }</span>
        <span class="cov0" title="0">return m.gomod.Dir</span>
}

func (m *moduleAdapter) Disabled() bool <span class="cov8" title="1">{
        return m.disabled
}</span>

func (m *moduleAdapter) IsGoMod() bool <span class="cov8" title="1">{
        return m.gomod != nil
}</span>

func (m *moduleAdapter) Mounts() []Mount <span class="cov8" title="1">{
        return m.mounts
}</span>

func (m *moduleAdapter) Owner() Module <span class="cov8" title="1">{
        return m.owner
}</span>

func (m *moduleAdapter) Path() string <span class="cov8" title="1">{
        if !m.IsGoMod() || m.path != "" </span><span class="cov8" title="1">{
                return m.path
        }</span>
        <span class="cov8" title="1">return m.gomod.Path</span>
}

func (m *moduleAdapter) Replace() Module <span class="cov8" title="1">{
        if m.IsGoMod() &amp;&amp; !m.Vendor() &amp;&amp; m.gomod.Replace != nil </span><span class="cov0" title="0">{
                return &amp;moduleAdapter{
                        gomod: m.gomod.Replace,
                        owner: m.owner,
                }
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (m *moduleAdapter) Vendor() bool <span class="cov8" title="1">{
        return m.vendor
}</span>

func (m *moduleAdapter) Version() string <span class="cov8" title="1">{
        if !m.IsGoMod() || m.version != "" </span><span class="cov8" title="1">{
                return m.version
        }</span>
        <span class="cov8" title="1">return m.gomod.Version</span>
}

func (m *moduleAdapter) Time() time.Time <span class="cov0" title="0">{
        if !m.IsGoMod() || m.gomod.Time == nil </span><span class="cov0" title="0">{
                return time.Time{}
        }</span>

        <span class="cov0" title="0">return *m.gomod.Time</span>

}

func (m *moduleAdapter) Watch() bool <span class="cov0" title="0">{
        if m.Owner() == nil </span><span class="cov0" title="0">{
                // Main project
                return true
        }</span>

        <span class="cov0" title="0">if !m.IsGoMod() </span><span class="cov0" title="0">{
                // Module inside /themes
                return true
        }</span>

        <span class="cov0" title="0">if m.Replace() != nil </span><span class="cov0" title="0">{
                // Version is not set when replaced by a local folder.
                return m.Replace().Version() == ""
        }</span>

        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file177" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package npm

import (
        "bytes"
        "encoding/json"
        "fmt"
        "io"
        "strings"

        "github.com/gohugoio/hugo/common/hugio"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/hugofs"
        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/helpers"
)

const (
        dependenciesKey    = "dependencies"
        devDependenciesKey = "devDependencies"

        packageJSONName = "package.json"

        packageJSONTemplate = `{
  "name": "%s",
  "version": "%s"
}`
)

func Pack(fs afero.Fs, fis []hugofs.FileMetaInfo) error <span class="cov0" title="0">{
        var b *packageBuilder

        // Have a package.hugo.json?
        fi, err := fs.Stat(files.FilenamePackageHugoJSON)
        if err != nil </span><span class="cov0" title="0">{
                // Have a package.json?
                fi, err = fs.Stat(packageJSONName)
                if err == nil </span><span class="cov0" title="0">{
                        // Preserve the original in package.hugo.json.
                        if err = hugio.CopyFile(fs, packageJSONName, files.FilenamePackageHugoJSON); err != nil </span><span class="cov0" title="0">{
                                return errors.Wrap(err, "npm pack: failed to copy package file")
                        }</span>
                } else<span class="cov0" title="0"> {
                        // Create one.
                        name := "project"
                        // Use the Hugo site's folder name as the default name.
                        // The owner can change it later.
                        rfi, err := fs.Stat("")
                        if err == nil </span><span class="cov0" title="0">{
                                name = rfi.Name()
                        }</span>
                        <span class="cov0" title="0">packageJSONContent := fmt.Sprintf(packageJSONTemplate, name, "0.1.0")
                        if err = afero.WriteFile(fs, files.FilenamePackageHugoJSON, []byte(packageJSONContent), 0666); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov0" title="0">fi, err = fs.Stat(files.FilenamePackageHugoJSON)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov0" title="0">meta := fi.(hugofs.FileMetaInfo).Meta()
        masterFilename := meta.Filename
        f, err := meta.Open()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "npm pack: failed to open package file")
        }</span>
        <span class="cov0" title="0">b = newPackageBuilder(meta.Module, f)
        f.Close()

        for _, fi := range fis </span><span class="cov0" title="0">{
                if fi.IsDir() </span><span class="cov0" title="0">{
                        // We only care about the files in the root.
                        continue</span>
                }

                <span class="cov0" title="0">if fi.Name() != files.FilenamePackageHugoJSON </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">meta := fi.(hugofs.FileMetaInfo).Meta()

                if meta.Filename == masterFilename </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">f, err := meta.Open()
                if err != nil </span><span class="cov0" title="0">{
                        return errors.Wrap(err, "npm pack: failed to open package file")
                }</span>
                <span class="cov0" title="0">b.Add(meta.Module, f)
                f.Close()</span>
        }

        <span class="cov0" title="0">if b.Err() != nil </span><span class="cov0" title="0">{
                return errors.Wrap(b.Err(), "npm pack: failed to build")
        }</span>

        // Replace the dependencies in the original template with the merged set.
        <span class="cov0" title="0">b.originalPackageJSON[dependenciesKey] = b.dependencies
        b.originalPackageJSON[devDependenciesKey] = b.devDependencies
        var commentsm map[string]interface{}
        comments, found := b.originalPackageJSON["comments"]
        if found </span><span class="cov0" title="0">{
                commentsm = maps.ToStringMap(comments)
        }</span> else<span class="cov0" title="0"> {
                commentsm = make(map[string]interface{})
        }</span>
        <span class="cov0" title="0">commentsm[dependenciesKey] = b.dependenciesComments
        commentsm[devDependenciesKey] = b.devDependenciesComments
        b.originalPackageJSON["comments"] = commentsm

        // Write it out to the project package.json
        packageJSONData := new(bytes.Buffer)
        encoder := json.NewEncoder(packageJSONData)
        encoder.SetEscapeHTML(false)
        encoder.SetIndent("", strings.Repeat(" ", 2))
        if err := encoder.Encode(b.originalPackageJSON); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "npm pack: failed to marshal JSON")
        }</span>

        <span class="cov0" title="0">if err := afero.WriteFile(fs, packageJSONName, packageJSONData.Bytes(), 0666); err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "npm pack: failed to write package.json")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func newPackageBuilder(source string, first io.Reader) *packageBuilder <span class="cov8" title="1">{
        b := &amp;packageBuilder{
                devDependencies:         make(map[string]interface{}),
                devDependenciesComments: make(map[string]interface{}),
                dependencies:            make(map[string]interface{}),
                dependenciesComments:    make(map[string]interface{}),
        }

        m := b.unmarshal(first)
        if b.err != nil </span><span class="cov0" title="0">{
                return b
        }</span>

        <span class="cov8" title="1">b.addm(source, m)
        b.originalPackageJSON = m

        return b</span>
}

type packageBuilder struct {
        err error

        // The original package.hugo.json.
        originalPackageJSON map[string]interface{}

        devDependencies         map[string]interface{}
        devDependenciesComments map[string]interface{}
        dependencies            map[string]interface{}
        dependenciesComments    map[string]interface{}
}

func (b *packageBuilder) Add(source string, r io.Reader) *packageBuilder <span class="cov8" title="1">{
        if b.err != nil </span><span class="cov0" title="0">{
                return b
        }</span>

        <span class="cov8" title="1">m := b.unmarshal(r)
        if b.err != nil </span><span class="cov0" title="0">{
                return b
        }</span>

        <span class="cov8" title="1">b.addm(source, m)

        return b</span>
}

func (b *packageBuilder) addm(source string, m map[string]interface{}) <span class="cov8" title="1">{
        if source == "" </span><span class="cov8" title="1">{
                source = "project"
        }</span>

        // The version selection is currently very simple.
        // We may consider minimal version selection or something
        // after testing this out.
        //
        // But for now, the first version string for a given dependency wins.
        // These packages will be added by order of import (project, module1, module2...),
        // so that should at least give the project control over the situation.
        <span class="cov8" title="1">if devDeps, found := m[devDependenciesKey]; found </span><span class="cov8" title="1">{
                mm := maps.ToStringMapString(devDeps)
                for k, v := range mm </span><span class="cov8" title="1">{
                        if _, added := b.devDependencies[k]; !added </span><span class="cov8" title="1">{
                                b.devDependencies[k] = v
                                b.devDependenciesComments[k] = source
                        }</span>
                }
        }

        <span class="cov8" title="1">if deps, found := m[dependenciesKey]; found </span><span class="cov8" title="1">{
                mm := maps.ToStringMapString(deps)
                for k, v := range mm </span><span class="cov8" title="1">{
                        if _, added := b.dependencies[k]; !added </span><span class="cov8" title="1">{
                                b.dependencies[k] = v
                                b.dependenciesComments[k] = source
                        }</span>
                }
        }
}

func (b *packageBuilder) unmarshal(r io.Reader) map[string]interface{} <span class="cov8" title="1">{
        m := make(map[string]interface{})
        err := json.Unmarshal(helpers.ReaderToBytes(r), &amp;m)
        if err != nil </span><span class="cov0" title="0">{
                b.err = err
        }</span>
        <span class="cov8" title="1">return m</span>
}

func (b *packageBuilder) Err() error <span class="cov8" title="1">{
        return b.err
}</span>
</pre>
		
		<pre class="file" id="file178" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package navigation

import (
        "fmt"
        "html/template"
        "sort"
        "strings"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/compare"

        "github.com/spf13/cast"
)

var smc = newMenuCache()

// MenuEntry represents a menu item defined in either Page front matter
// or in the site config.
type MenuEntry struct {
        ConfiguredURL string // The URL value from front matter / config.
        Page          Page
        PageRef       string // The path to the page, only relevant for site config.
        Name          string
        Menu          string
        Identifier    string
        title         string
        Pre           template.HTML
        Post          template.HTML
        Weight        int
        Parent        string
        Children      Menu
        Params        maps.Params
}

func (m *MenuEntry) URL() string <span class="cov0" title="0">{

        // Check page first.
        // In Hugo 0.86.0 we added `pageRef`,
        // a way to connect menu items in site config to pages.
        // This means that you now can have both a Page
        // and a configured URL.
        // Having the configured URL as a fallback if the Page isn't found
        // is obviously more useful, especially in multilingual sites.
        if !types.IsNil(m.Page) </span><span class="cov0" title="0">{
                return m.Page.RelPermalink()
        }</span>

        <span class="cov0" title="0">return m.ConfiguredURL</span>
}

// A narrow version of page.Page.
type Page interface {
        LinkTitle() string
        RelPermalink() string
        Path() string
        Section() string
        Weight() int
        IsPage() bool
        IsSection() bool
        IsAncestor(other interface{}) (bool, error)
        Params() maps.Params
}

// Menu is a collection of menu entries.
type Menu []*MenuEntry

// Menus is a dictionary of menus.
type Menus map[string]Menu

// PageMenus is a dictionary of menus defined in the Pages.
type PageMenus map[string]*MenuEntry

// HasChildren returns whether this menu item has any children.
func (m *MenuEntry) HasChildren() bool <span class="cov0" title="0">{
        return m.Children != nil
}</span>

// KeyName returns the key used to identify this menu entry.
func (m *MenuEntry) KeyName() string <span class="cov0" title="0">{
        if m.Identifier != "" </span><span class="cov0" title="0">{
                return m.Identifier
        }</span>
        <span class="cov0" title="0">return m.Name</span>
}

func (m *MenuEntry) hopefullyUniqueID() string <span class="cov0" title="0">{
        if m.Identifier != "" </span><span class="cov0" title="0">{
                return m.Identifier
        }</span> else<span class="cov0" title="0"> if m.URL() != "" </span><span class="cov0" title="0">{
                return m.URL()
        }</span> else<span class="cov0" title="0"> {
                return m.Name
        }</span>
}

// IsEqual returns whether the two menu entries represents the same menu entry.
func (m *MenuEntry) IsEqual(inme *MenuEntry) bool <span class="cov0" title="0">{
        return m.hopefullyUniqueID() == inme.hopefullyUniqueID() &amp;&amp; m.Parent == inme.Parent
}</span>

// IsSameResource returns whether the two menu entries points to the same
// resource (URL).
func (m *MenuEntry) IsSameResource(inme *MenuEntry) bool <span class="cov0" title="0">{
        if m.isSamePage(inme.Page) </span><span class="cov0" title="0">{
                return m.Page == inme.Page
        }</span>
        <span class="cov0" title="0">murl, inmeurl := m.URL(), inme.URL()
        return murl != "" &amp;&amp; inmeurl != "" &amp;&amp; murl == inmeurl</span>
}

func (m *MenuEntry) isSamePage(p Page) bool <span class="cov0" title="0">{
        if !types.IsNil(m.Page) &amp;&amp; !types.IsNil(p) </span><span class="cov0" title="0">{
                return m.Page == p
        }</span>
        <span class="cov0" title="0">return false</span>
}

func (m *MenuEntry) MarshallMap(ime map[string]interface{}) error <span class="cov0" title="0">{
        var err error
        for k, v := range ime </span><span class="cov0" title="0">{
                loki := strings.ToLower(k)
                switch loki </span>{
                case "url":<span class="cov0" title="0">
                        m.ConfiguredURL = cast.ToString(v)</span>
                case "pageref":<span class="cov0" title="0">
                        m.PageRef = cast.ToString(v)</span>
                case "weight":<span class="cov0" title="0">
                        m.Weight = cast.ToInt(v)</span>
                case "name":<span class="cov0" title="0">
                        m.Name = cast.ToString(v)</span>
                case "title":<span class="cov0" title="0">
                        m.title = cast.ToString(v)</span>
                case "pre":<span class="cov0" title="0">
                        m.Pre = template.HTML(cast.ToString(v))</span>
                case "post":<span class="cov0" title="0">
                        m.Post = template.HTML(cast.ToString(v))</span>
                case "identifier":<span class="cov0" title="0">
                        m.Identifier = cast.ToString(v)</span>
                case "parent":<span class="cov0" title="0">
                        m.Parent = cast.ToString(v)</span>
                case "params":<span class="cov0" title="0">
                        var ok bool
                        m.Params, ok = maps.ToParamsAndPrepare(v)
                        if !ok </span><span class="cov0" title="0">{
                                err = fmt.Errorf("cannot convert %T to Params", v)
                        }</span>
                }
        }

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to marshal menu entry %q", m.KeyName())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (m Menu) Add(me *MenuEntry) Menu <span class="cov0" title="0">{
        m = append(m, me)
        // TODO(bep)
        m.Sort()
        return m
}</span>

/*
 * Implementation of a custom sorter for Menu
 */

// A type to implement the sort interface for Menu
type menuSorter struct {
        menu Menu
        by   menuEntryBy
}

// Closure used in the Sort.Less method.
type menuEntryBy func(m1, m2 *MenuEntry) bool

func (by menuEntryBy) Sort(menu Menu) <span class="cov0" title="0">{
        ms := &amp;menuSorter{
                menu: menu,
                by:   by, // The Sort method's receiver is the function (closure) that defines the sort order.
        }
        sort.Stable(ms)
}</span>

var defaultMenuEntrySort = func(m1, m2 *MenuEntry) bool <span class="cov0" title="0">{
        if m1.Weight == m2.Weight </span><span class="cov0" title="0">{
                c := compare.Strings(m1.Name, m2.Name)
                if c == 0 </span><span class="cov0" title="0">{
                        return m1.Identifier &lt; m2.Identifier
                }</span>
                <span class="cov0" title="0">return c &lt; 0</span>
        }

        <span class="cov0" title="0">if m2.Weight == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov0" title="0">if m1.Weight == 0 </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">return m1.Weight &lt; m2.Weight</span>
}

func (ms *menuSorter) Len() int      <span class="cov0" title="0">{ return len(ms.menu) }</span>
func (ms *menuSorter) Swap(i, j int) <span class="cov0" title="0">{ ms.menu[i], ms.menu[j] = ms.menu[j], ms.menu[i] }</span>

// Less is part of sort.Interface. It is implemented by calling the "by" closure in the sorter.
func (ms *menuSorter) Less(i, j int) bool <span class="cov0" title="0">{ return ms.by(ms.menu[i], ms.menu[j]) }</span>

// Sort sorts the menu by weight, name and then by identifier.
func (m Menu) Sort() Menu <span class="cov0" title="0">{
        menuEntryBy(defaultMenuEntrySort).Sort(m)
        return m
}</span>

// Limit limits the returned menu to n entries.
func (m Menu) Limit(n int) Menu <span class="cov0" title="0">{
        if len(m) &gt; n </span><span class="cov0" title="0">{
                return m[0:n]
        }</span>
        <span class="cov0" title="0">return m</span>
}

// ByWeight sorts the menu by the weight defined in the menu configuration.
func (m Menu) ByWeight() Menu <span class="cov0" title="0">{
        const key = "menuSort.ByWeight"
        menus, _ := smc.get(key, menuEntryBy(defaultMenuEntrySort).Sort, m)

        return menus
}</span>

// ByName sorts the menu by the name defined in the menu configuration.
func (m Menu) ByName() Menu <span class="cov0" title="0">{
        const key = "menuSort.ByName"
        title := func(m1, m2 *MenuEntry) bool </span><span class="cov0" title="0">{
                return compare.LessStrings(m1.Name, m2.Name)
        }</span>

        <span class="cov0" title="0">menus, _ := smc.get(key, menuEntryBy(title).Sort, m)

        return menus</span>
}

// Reverse reverses the order of the menu entries.
func (m Menu) Reverse() Menu <span class="cov0" title="0">{
        const key = "menuSort.Reverse"
        reverseFunc := func(menu Menu) </span><span class="cov0" title="0">{
                for i, j := 0, len(menu)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov0" title="0">{
                        menu[i], menu[j] = menu[j], menu[i]
                }</span>
        }
        <span class="cov0" title="0">menus, _ := smc.get(key, reverseFunc, m)

        return menus</span>
}

func (m Menu) Clone() Menu <span class="cov0" title="0">{
        return append(Menu(nil), m...)
}</span>

func (m *MenuEntry) Title() string <span class="cov0" title="0">{
        if m.title != "" </span><span class="cov0" title="0">{
                return m.title
        }</span>

        <span class="cov0" title="0">if m.Page != nil </span><span class="cov0" title="0">{
                return m.Page.LinkTitle()
        }</span>

        <span class="cov0" title="0">return ""</span>
}
</pre>
		
		<pre class="file" id="file179" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
package navigation

import (
        "sync"
)

type menuCacheEntry struct {
        in  []Menu
        out Menu
}

func (entry menuCacheEntry) matches(menuList []Menu) bool <span class="cov8" title="1">{
        if len(entry.in) != len(menuList) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, m := range menuList </span><span class="cov8" title="1">{
                if !menuEqual(m, entry.in[i]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func newMenuCache() *menuCache <span class="cov8" title="1">{
        return &amp;menuCache{m: make(map[string][]menuCacheEntry)}
}</span>

func (c *menuCache) clear() <span class="cov0" title="0">{
        c.Lock()
        defer c.Unlock()
        c.m = make(map[string][]menuCacheEntry)
}</span>

type menuCache struct {
        sync.RWMutex
        m map[string][]menuCacheEntry
}

func menuEqual(m1, m2 Menu) bool <span class="cov8" title="1">{
        if m1 == nil &amp;&amp; m2 == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if m1 == nil || m2 == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if len(m1) != len(m2) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if len(m1) == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(m1); i++ </span><span class="cov8" title="1">{
                if m1[i] != m2[i] </span><span class="cov0" title="0">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (c *menuCache) get(key string, apply func(m Menu), menuLists ...Menu) (Menu, bool) <span class="cov8" title="1">{
        return c.getP(key, func(m *Menu) </span><span class="cov8" title="1">{
                if apply != nil </span><span class="cov8" title="1">{
                        apply(*m)
                }</span>
        }, menuLists...)
}

func (c *menuCache) getP(key string, apply func(m *Menu), menuLists ...Menu) (Menu, bool) <span class="cov8" title="1">{
        c.Lock()
        defer c.Unlock()

        if cached, ok := c.m[key]; ok </span><span class="cov8" title="1">{
                for _, entry := range cached </span><span class="cov8" title="1">{
                        if entry.matches(menuLists) </span><span class="cov8" title="1">{
                                return entry.out, true
                        }</span>
                }
        }

        <span class="cov8" title="1">m := menuLists[0]
        menuCopy := append(Menu(nil), m...)

        if apply != nil </span><span class="cov8" title="1">{
                apply(&amp;menuCopy)
        }</span>

        <span class="cov8" title="1">entry := menuCacheEntry{in: menuLists, out: menuCopy}
        if v, ok := c.m[key]; ok </span><span class="cov8" title="1">{
                c.m[key] = append(v, entry)
        }</span> else<span class="cov8" title="1"> {
                c.m[key] = []menuCacheEntry{entry}
        }</span>

        <span class="cov8" title="1">return menuCopy, false</span>
}
</pre>
		
		<pre class="file" id="file180" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package navigation

import (
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/common/types"

        "github.com/pkg/errors"
        "github.com/spf13/cast"
)

type PageMenusProvider interface {
        PageMenusGetter
        MenuQueryProvider
}

type PageMenusGetter interface {
        Menus() PageMenus
}

type MenusGetter interface {
        Menus() Menus
}

type MenuQueryProvider interface {
        HasMenuCurrent(menuID string, me *MenuEntry) bool
        IsMenuCurrent(menuID string, inme *MenuEntry) bool
}

func PageMenusFromPage(p Page) (PageMenus, error) <span class="cov0" title="0">{
        params := p.Params()

        ms, ok := params["menus"]
        if !ok </span><span class="cov0" title="0">{
                ms, ok = params["menu"]
        }</span>

        <span class="cov0" title="0">pm := PageMenus{}

        if !ok </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov0" title="0">me := MenuEntry{Page: p, Name: p.LinkTitle(), Weight: p.Weight()}

        // Could be the name of the menu to attach it to
        mname, err := cast.ToStringE(ms)

        if err == nil </span><span class="cov0" title="0">{
                me.Menu = mname
                pm[mname] = &amp;me
                return pm, nil
        }</span>

        // Could be a slice of strings
        <span class="cov0" title="0">mnames, err := cast.ToStringSliceE(ms)

        if err == nil </span><span class="cov0" title="0">{
                for _, mname := range mnames </span><span class="cov0" title="0">{
                        me.Menu = mname
                        pm[mname] = &amp;me
                }</span>
                <span class="cov0" title="0">return pm, nil</span>
        }

        <span class="cov0" title="0">var wrapErr = func(err error) error </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "unable to process menus for page %q", p.Path())
        }</span>

        // Could be a structured menu entry
        <span class="cov0" title="0">menus, err := maps.ToStringMapE(ms)
        if err != nil </span><span class="cov0" title="0">{
                return pm, wrapErr(err)
        }</span>

        <span class="cov0" title="0">for name, menu := range menus </span><span class="cov0" title="0">{
                menuEntry := MenuEntry{Page: p, Name: p.LinkTitle(), Weight: p.Weight(), Menu: name}
                if menu != nil </span><span class="cov0" title="0">{
                        ime, err := maps.ToStringMapE(menu)
                        if err != nil </span><span class="cov0" title="0">{
                                return pm, wrapErr(err)
                        }</span>

                        <span class="cov0" title="0">if err = menuEntry.MarshallMap(ime); err != nil </span><span class="cov0" title="0">{
                                return pm, wrapErr(err)
                        }</span>
                }
                <span class="cov0" title="0">pm[name] = &amp;menuEntry</span>
        }

        <span class="cov0" title="0">return pm, nil</span>
}

func NewMenuQueryProvider(
        pagem PageMenusGetter,
        sitem MenusGetter,
        p Page) MenuQueryProvider <span class="cov0" title="0">{
        return &amp;pageMenus{
                p:     p,
                pagem: pagem,
                sitem: sitem,
        }
}</span>

type pageMenus struct {
        pagem PageMenusGetter
        sitem MenusGetter
        p     Page
}

func (pm *pageMenus) HasMenuCurrent(menuID string, me *MenuEntry) bool <span class="cov0" title="0">{
        if !types.IsNil(me.Page) &amp;&amp; me.Page.IsSection() </span><span class="cov0" title="0">{
                if ok, _ := me.Page.IsAncestor(pm.p); ok </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">if !me.HasChildren() </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">menus := pm.pagem.Menus()

        if m, ok := menus[menuID]; ok </span><span class="cov0" title="0">{
                for _, child := range me.Children </span><span class="cov0" title="0">{
                        if child.IsEqual(m) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">if pm.HasMenuCurrent(menuID, child) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov0" title="0">if pm.p == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, child := range me.Children </span><span class="cov0" title="0">{
                if child.isSamePage(pm.p) </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">if pm.HasMenuCurrent(menuID, child) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">return false</span>
}

func (pm *pageMenus) IsMenuCurrent(menuID string, inme *MenuEntry) bool <span class="cov0" title="0">{
        menus := pm.pagem.Menus()

        if me, ok := menus[menuID]; ok </span><span class="cov0" title="0">{
                if me.IsEqual(inme) </span><span class="cov0" title="0">{
                        return true
                }</span>
        }

        <span class="cov0" title="0">if pm.p == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">if !inme.isSamePage(pm.p) </span><span class="cov0" title="0">{
                return false
        }</span>

        // This resource may be included in several menus.
        // Search for it to make sure that it is in the menu with the given menuId.
        <span class="cov0" title="0">if menu, ok := pm.sitem.Menus()[menuID]; ok </span><span class="cov0" title="0">{
                for _, menuEntry := range menu </span><span class="cov0" title="0">{
                        if menuEntry.IsSameResource(inme) </span><span class="cov0" title="0">{
                                return true
                        }</span>

                        <span class="cov0" title="0">descendantFound := pm.isSameAsDescendantMenu(inme, menuEntry)
                        if descendantFound </span><span class="cov0" title="0">{
                                return descendantFound
                        }</span>

                }
        }

        <span class="cov0" title="0">return false</span>
}

func (pm *pageMenus) isSameAsDescendantMenu(inme *MenuEntry, parent *MenuEntry) bool <span class="cov0" title="0">{
        if parent.HasChildren() </span><span class="cov0" title="0">{
                for _, child := range parent.Children </span><span class="cov0" title="0">{
                        if child.IsSameResource(inme) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                        <span class="cov0" title="0">descendantFound := pm.isSameAsDescendantMenu(inme, child)
                        if descendantFound </span><span class="cov0" title="0">{
                                return descendantFound
                        }</span>
                }
        }
        <span class="cov0" title="0">return false</span>
}

var NopPageMenus = new(nopPageMenus)

type nopPageMenus int

func (m nopPageMenus) Menus() PageMenus <span class="cov0" title="0">{
        return PageMenus{}
}</span>

func (m nopPageMenus) HasMenuCurrent(menuID string, me *MenuEntry) bool <span class="cov0" title="0">{
        return false
}</span>

func (m nopPageMenus) IsMenuCurrent(menuID string, inme *MenuEntry) bool <span class="cov0" title="0">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file181" style="display: none">package output

import (
        "strings"

        //        "fmt"

        "github.com/gohugoio/hugo/docshelper"
)

// This is is just some helpers used to create some JSON used in the Hugo docs.
func init() <span class="cov8" title="1">{
        docsProvider := func() docshelper.DocProvider </span><span class="cov0" title="0">{
                return docshelper.DocProvider{
                        "output": map[string]interface{}{
                                "formats": DefaultFormats,
                                "layouts": createLayoutExamples(),
                        },
                }
        }</span>

        <span class="cov8" title="1">docshelper.AddDocProviderFunc(docsProvider)</span>
}

func createLayoutExamples() interface{} <span class="cov0" title="0">{
        type Example struct {
                Example      string
                Kind         string
                OutputFormat string
                Suffix       string
                Layouts      []string `json:"Template Lookup Order"`
        }

        var (
                basicExamples []Example
                demoLayout    = "demolayout"
                demoType      = "demotype"
        )

        for _, example := range []struct {
                name string
                d    LayoutDescriptor
                f    Format
        }{
                // Taxonomy output.LayoutDescriptor={categories category taxonomy en  false Type Section
                {"Single page in \"posts\" section", LayoutDescriptor{Kind: "page", Type: "posts"}, HTMLFormat},
                {"Base template for single page in \"posts\" section", LayoutDescriptor{Baseof: true, Kind: "page", Type: "posts"}, HTMLFormat},
                {"Single page in \"posts\" section with layout set", LayoutDescriptor{Kind: "page", Type: "posts", Layout: demoLayout}, HTMLFormat},
                {"Base template for single page in \"posts\" section with layout set", LayoutDescriptor{Baseof: true, Kind: "page", Type: "posts", Layout: demoLayout}, HTMLFormat},
                {"AMP single page", LayoutDescriptor{Kind: "page", Type: "posts"}, AMPFormat},
                {"AMP single page, French language", LayoutDescriptor{Kind: "page", Type: "posts", Lang: "fr"}, AMPFormat},
                // All section or typeless pages gets "page" as type
                {"Home page", LayoutDescriptor{Kind: "home", Type: "page"}, HTMLFormat},
                {"Base template for home page", LayoutDescriptor{Baseof: true, Kind: "home", Type: "page"}, HTMLFormat},
                {"Home page with type set", LayoutDescriptor{Kind: "home", Type: demoType}, HTMLFormat},
                {"Base template for home page with type set", LayoutDescriptor{Baseof: true, Kind: "home", Type: demoType}, HTMLFormat},
                {"Home page with layout set", LayoutDescriptor{Kind: "home", Type: "page", Layout: demoLayout}, HTMLFormat},
                {"AMP home, French language", LayoutDescriptor{Kind: "home", Type: "page", Lang: "fr"}, AMPFormat},
                {"JSON home", LayoutDescriptor{Kind: "home", Type: "page"}, JSONFormat},
                {"RSS home", LayoutDescriptor{Kind: "home", Type: "page"}, RSSFormat},
                {"RSS section posts", LayoutDescriptor{Kind: "section", Type: "posts"}, RSSFormat},
                {"Taxonomy in categories", LayoutDescriptor{Kind: "taxonomy", Type: "categories", Section: "category"}, RSSFormat},
                {"Term in categories", LayoutDescriptor{Kind: "term", Type: "categories", Section: "category"}, RSSFormat},
                {"Section list for \"posts\" section", LayoutDescriptor{Kind: "section", Type: "posts", Section: "posts"}, HTMLFormat},
                {"Section list for \"posts\" section with type set to \"blog\"", LayoutDescriptor{Kind: "section", Type: "blog", Section: "posts"}, HTMLFormat},
                {"Section list for \"posts\" section with layout set to \"demoLayout\"", LayoutDescriptor{Kind: "section", Layout: demoLayout, Section: "posts"}, HTMLFormat},

                {"Taxonomy list in categories", LayoutDescriptor{Kind: "taxonomy", Type: "categories", Section: "category"}, HTMLFormat},
                {"Taxonomy term in categories", LayoutDescriptor{Kind: "term", Type: "categories", Section: "category"}, HTMLFormat},
        } </span><span class="cov0" title="0">{

                l := NewLayoutHandler()
                layouts, _ := l.For(example.d, example.f)

                basicExamples = append(basicExamples, Example{
                        Example:      example.name,
                        Kind:         example.d.Kind,
                        OutputFormat: example.f.Name,
                        Suffix:       example.f.MediaType.FirstSuffix.Suffix,
                        Layouts:      makeLayoutsPresentable(layouts),
                })
        }</span>

        <span class="cov0" title="0">return basicExamples</span>
}

func makeLayoutsPresentable(l []string) []string <span class="cov0" title="0">{
        var filtered []string
        for _, ll := range l </span><span class="cov0" title="0">{
                if strings.Contains(ll, "page/") </span><span class="cov0" title="0">{
                        // This is a valid lookup, but it's more confusing than useful.
                        continue</span>
                }
                <span class="cov0" title="0">ll = "layouts/" + strings.TrimPrefix(ll, "_text/")

                if !strings.Contains(ll, "indexes") </span><span class="cov0" title="0">{
                        filtered = append(filtered, ll)
                }</span>
        }

        <span class="cov0" title="0">return filtered</span>
}
</pre>
		
		<pre class="file" id="file182" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package output

import (
        "strings"
        "sync"

        "github.com/gohugoio/hugo/helpers"
)

// These may be used as content sections with potential conflicts. Avoid that.
var reservedSections = map[string]bool{
        "shortcodes": true,
        "partials":   true,
}

// LayoutDescriptor describes how a layout should be chosen. This is
// typically built from a Page.
type LayoutDescriptor struct {
        Type    string
        Section string
        Kind    string
        Lang    string
        Layout  string
        // LayoutOverride indicates what we should only look for the above layout.
        LayoutOverride bool

        RenderingHook bool
        Baseof        bool
}

func (d LayoutDescriptor) isList() bool <span class="cov8" title="1">{
        return !d.RenderingHook &amp;&amp; d.Kind != "page" &amp;&amp; d.Kind != "404"
}</span>

// LayoutHandler calculates the layout template to use to render a given output type.
type LayoutHandler struct {
        mu    sync.RWMutex
        cache map[layoutCacheKey][]string
}

type layoutCacheKey struct {
        d LayoutDescriptor
        f string
}

// NewLayoutHandler creates a new LayoutHandler.
func NewLayoutHandler() *LayoutHandler <span class="cov8" title="1">{
        return &amp;LayoutHandler{cache: make(map[layoutCacheKey][]string)}
}</span>

// For returns a layout for the given LayoutDescriptor and options.
// Layouts are rendered and cached internally.
func (l *LayoutHandler) For(d LayoutDescriptor, f Format) ([]string, error) <span class="cov8" title="1">{
        // We will get lots of requests for the same layouts, so avoid recalculations.
        key := layoutCacheKey{d, f.Name}
        l.mu.RLock()
        if cacheVal, found := l.cache[key]; found </span><span class="cov0" title="0">{
                l.mu.RUnlock()
                return cacheVal, nil
        }</span>
        <span class="cov8" title="1">l.mu.RUnlock()

        layouts := resolvePageTemplate(d, f)

        layouts = helpers.UniqueStringsReuse(layouts)

        l.mu.Lock()
        l.cache[key] = layouts
        l.mu.Unlock()

        return layouts, nil</span>
}

type layoutBuilder struct {
        layoutVariations []string
        typeVariations   []string
        d                LayoutDescriptor
        f                Format
}

func (l *layoutBuilder) addLayoutVariations(vars ...string) <span class="cov8" title="1">{
        for _, layoutVar := range vars </span><span class="cov8" title="1">{
                if l.d.Baseof &amp;&amp; layoutVar != "baseof" </span><span class="cov8" title="1">{
                        l.layoutVariations = append(l.layoutVariations, layoutVar+"-baseof")
                        continue</span>
                }
                <span class="cov8" title="1">if !l.d.RenderingHook &amp;&amp; !l.d.Baseof &amp;&amp; l.d.LayoutOverride &amp;&amp; layoutVar != l.d.Layout </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">l.layoutVariations = append(l.layoutVariations, layoutVar)</span>
        }
}

func (l *layoutBuilder) addTypeVariations(vars ...string) <span class="cov8" title="1">{
        for _, typeVar := range vars </span><span class="cov8" title="1">{
                if !reservedSections[typeVar] </span><span class="cov8" title="1">{
                        if l.d.RenderingHook </span><span class="cov8" title="1">{
                                typeVar = typeVar + renderingHookRoot
                        }</span>
                        <span class="cov8" title="1">l.typeVariations = append(l.typeVariations, typeVar)</span>
                }
        }
}

func (l *layoutBuilder) addSectionType() <span class="cov8" title="1">{
        if l.d.Section != "" </span><span class="cov8" title="1">{
                l.addTypeVariations(l.d.Section)
        }</span>
}

func (l *layoutBuilder) addKind() <span class="cov8" title="1">{
        l.addLayoutVariations(l.d.Kind)
        l.addTypeVariations(l.d.Kind)
}</span>

const renderingHookRoot = "/_markup"

func resolvePageTemplate(d LayoutDescriptor, f Format) []string <span class="cov8" title="1">{
        b := &amp;layoutBuilder{d: d, f: f}

        if !d.RenderingHook &amp;&amp; d.Layout != "" </span><span class="cov8" title="1">{
                b.addLayoutVariations(d.Layout)
        }</span>
        <span class="cov8" title="1">if d.Type != "" </span><span class="cov8" title="1">{
                b.addTypeVariations(d.Type)
        }</span>

        <span class="cov8" title="1">if d.RenderingHook </span><span class="cov8" title="1">{
                b.addLayoutVariations(d.Kind)
                b.addSectionType()
        }</span>

        <span class="cov8" title="1">switch d.Kind </span>{
        case "page":<span class="cov8" title="1">
                b.addLayoutVariations("single")
                b.addSectionType()</span>
        case "home":<span class="cov8" title="1">
                b.addLayoutVariations("index", "home")
                // Also look in the root
                b.addTypeVariations("")</span>
        case "section":<span class="cov8" title="1">
                if d.Section != "" </span><span class="cov8" title="1">{
                        b.addLayoutVariations(d.Section)
                }</span>
                <span class="cov8" title="1">b.addSectionType()
                b.addKind()</span>
        case "term":<span class="cov8" title="1">
                b.addKind()
                if d.Section != "" </span><span class="cov8" title="1">{
                        b.addLayoutVariations(d.Section)
                }</span>
                <span class="cov8" title="1">b.addLayoutVariations("taxonomy")
                b.addTypeVariations("taxonomy")
                b.addSectionType()</span>
        case "taxonomy":<span class="cov8" title="1">
                if d.Section != "" </span><span class="cov8" title="1">{
                        b.addLayoutVariations(d.Section + ".terms")
                }</span>
                <span class="cov8" title="1">b.addSectionType()
                b.addLayoutVariations("terms")
                // For legacy reasons this is deliberately put last.
                b.addKind()</span>
        case "404":<span class="cov8" title="1">
                b.addLayoutVariations("404")
                b.addTypeVariations("")</span>
        }

        <span class="cov8" title="1">isRSS := f.Name == RSSFormat.Name
        if !d.RenderingHook &amp;&amp; !d.Baseof &amp;&amp; isRSS </span><span class="cov8" title="1">{
                // The historic and common rss.xml case
                b.addLayoutVariations("")
        }</span>

        <span class="cov8" title="1">if d.Baseof || d.Kind != "404" </span><span class="cov8" title="1">{
                // Most have _default in their lookup path
                b.addTypeVariations("_default")
        }</span>

        <span class="cov8" title="1">if d.isList() </span><span class="cov8" title="1">{
                // Add the common list type
                b.addLayoutVariations("list")
        }</span>

        <span class="cov8" title="1">if d.Baseof </span><span class="cov8" title="1">{
                b.addLayoutVariations("baseof")
        }</span>

        <span class="cov8" title="1">layouts := b.resolveVariations()

        if !d.RenderingHook &amp;&amp; !d.Baseof &amp;&amp; isRSS </span><span class="cov8" title="1">{
                layouts = append(layouts, "_internal/_default/rss.xml")
        }</span>

        <span class="cov8" title="1">return layouts</span>
}

func (l *layoutBuilder) resolveVariations() []string <span class="cov8" title="1">{
        var layouts []string

        var variations []string
        name := strings.ToLower(l.f.Name)

        if l.d.Lang != "" </span><span class="cov8" title="1">{
                // We prefer the most specific type before language.
                variations = append(variations, []string{l.d.Lang + "." + name, name, l.d.Lang}...)
        }</span> else<span class="cov8" title="1"> {
                variations = append(variations, name)
        }</span>

        <span class="cov8" title="1">variations = append(variations, "")

        for _, typeVar := range l.typeVariations </span><span class="cov8" title="1">{
                for _, variation := range variations </span><span class="cov8" title="1">{
                        for _, layoutVar := range l.layoutVariations </span><span class="cov8" title="1">{
                                if variation == "" &amp;&amp; layoutVar == "" </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">s := constructLayoutPath(typeVar, layoutVar, variation, l.f.MediaType.FirstSuffix.Suffix)
                                if s != "" </span><span class="cov8" title="1">{
                                        layouts = append(layouts, s)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return layouts</span>
}

// constructLayoutPath constructs a layout path given a type, layout,
// variations, and extension.  The path constructed follows the pattern of
// type/layout.variations.extension.  If any value is empty, it will be left out
// of the path construction.
//
// Path construction requires at least 2 of 3 out of layout, variations, and extension.
// If more than one of those is empty, an empty string is returned.
func constructLayoutPath(typ, layout, variations, extension string) string <span class="cov8" title="1">{
        // we already know that layout and variations are not both empty because of
        // checks in resolveVariants().
        if extension == "" &amp;&amp; (layout == "" || variations == "") </span><span class="cov8" title="1">{
                return ""
        }</span>

        // Commence valid path construction...

        <span class="cov8" title="1">var (
                p       strings.Builder
                needDot bool
        )

        if typ != "" </span><span class="cov8" title="1">{
                p.WriteString(typ)
                p.WriteString("/")
        }</span>

        <span class="cov8" title="1">if layout != "" </span><span class="cov8" title="1">{
                p.WriteString(layout)
                needDot = true
        }</span>

        <span class="cov8" title="1">if variations != "" </span><span class="cov8" title="1">{
                if needDot </span><span class="cov8" title="1">{
                        p.WriteString(".")
                }</span>
                <span class="cov8" title="1">p.WriteString(variations)
                needDot = true</span>
        }

        <span class="cov8" title="1">if extension != "" </span><span class="cov8" title="1">{
                if needDot </span><span class="cov8" title="1">{
                        p.WriteString(".")
                }</span>
                <span class="cov8" title="1">p.WriteString(extension)</span>
        }

        <span class="cov8" title="1">return p.String()</span>
}
</pre>
		
		<pre class="file" id="file183" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package output

import (
        "encoding/json"
        "fmt"
        "reflect"
        "sort"
        "strings"

        "github.com/pkg/errors"

        "github.com/mitchellh/mapstructure"

        "github.com/gohugoio/hugo/media"
)

// Format represents an output representation, usually to a file on disk.
type Format struct {
        // The Name is used as an identifier. Internal output formats (i.e. HTML and RSS)
        // can be overridden by providing a new definition for those types.
        Name string `json:"name"`

        MediaType media.Type `json:"-"`

        // Must be set to a value when there are two or more conflicting mediatype for the same resource.
        Path string `json:"path"`

        // The base output file name used when not using "ugly URLs", defaults to "index".
        BaseName string `json:"baseName"`

        // The value to use for rel links
        //
        // See https://www.w3schools.com/tags/att_link_rel.asp
        //
        // AMP has a special requirement in this department, see:
        // https://www.ampproject.org/docs/guides/deploy/discovery
        // I.e.:
        // &lt;link rel="amphtml" href="https://www.example.com/url/to/amp/document.html"&gt;
        Rel string `json:"rel"`

        // The protocol to use, i.e. "webcal://". Defaults to the protocol of the baseURL.
        Protocol string `json:"protocol"`

        // IsPlainText decides whether to use text/template or html/template
        // as template parser.
        IsPlainText bool `json:"isPlainText"`

        // IsHTML returns whether this format is int the HTML family. This includes
        // HTML, AMP etc. This is used to decide when to create alias redirects etc.
        IsHTML bool `json:"isHTML"`

        // Enable to ignore the global uglyURLs setting.
        NoUgly bool `json:"noUgly"`

        // Enable if it doesn't make sense to include this format in an alternative
        // format listing, CSS being one good example.
        // Note that we use the term "alternative" and not "alternate" here, as it
        // does not necessarily replace the other format, it is an alternative representation.
        NotAlternative bool `json:"notAlternative"`

        // Setting this will make this output format control the value of
        // .Permalink and .RelPermalink for a rendered Page.
        // If not set, these values will point to the main (first) output format
        // configured. That is probably the behaviour you want in most situations,
        // as you probably don't want to link back to the RSS version of a page, as an
        // example. AMP would, however, be a good example of an output format where this
        // behaviour is wanted.
        Permalinkable bool `json:"permalinkable"`

        // Setting this to a non-zero value will be used as the first sort criteria.
        Weight int `json:"weight"`
}

// An ordered list of built-in output formats.
var (
        AMPFormat = Format{
                Name:          "AMP",
                MediaType:     media.HTMLType,
                BaseName:      "index",
                Path:          "amp",
                Rel:           "amphtml",
                IsHTML:        true,
                Permalinkable: true,
                // See https://www.ampproject.org/learn/overview/
        }

        CalendarFormat = Format{
                Name:        "Calendar",
                MediaType:   media.CalendarType,
                IsPlainText: true,
                Protocol:    "webcal://",
                BaseName:    "index",
                Rel:         "alternate",
        }

        CSSFormat = Format{
                Name:           "CSS",
                MediaType:      media.CSSType,
                BaseName:       "styles",
                IsPlainText:    true,
                Rel:            "stylesheet",
                NotAlternative: true,
        }
        CSVFormat = Format{
                Name:        "CSV",
                MediaType:   media.CSVType,
                BaseName:    "index",
                IsPlainText: true,
                Rel:         "alternate",
        }

        HTMLFormat = Format{
                Name:          "HTML",
                MediaType:     media.HTMLType,
                BaseName:      "index",
                Rel:           "canonical",
                IsHTML:        true,
                Permalinkable: true,

                // Weight will be used as first sort criteria. HTML will, by default,
                // be rendered first, but set it to 10 so it's easy to put one above it.
                Weight: 10,
        }

        JSONFormat = Format{
                Name:        "JSON",
                MediaType:   media.JSONType,
                BaseName:    "index",
                IsPlainText: true,
                Rel:         "alternate",
        }

        WebAppManifestFormat = Format{
                Name:           "WebAppManifest",
                MediaType:      media.WebAppManifestType,
                BaseName:       "manifest",
                IsPlainText:    true,
                NotAlternative: true,
                Rel:            "manifest",
        }

        RobotsTxtFormat = Format{
                Name:        "ROBOTS",
                MediaType:   media.TextType,
                BaseName:    "robots",
                IsPlainText: true,
                Rel:         "alternate",
        }

        RSSFormat = Format{
                Name:      "RSS",
                MediaType: media.RSSType,
                BaseName:  "index",
                NoUgly:    true,
                Rel:       "alternate",
        }

        SitemapFormat = Format{
                Name:      "Sitemap",
                MediaType: media.XMLType,
                BaseName:  "sitemap",
                NoUgly:    true,
                Rel:       "sitemap",
        }
)

// DefaultFormats contains the default output formats supported by Hugo.
var DefaultFormats = Formats{
        AMPFormat,
        CalendarFormat,
        CSSFormat,
        CSVFormat,
        HTMLFormat,
        JSONFormat,
        WebAppManifestFormat,
        RobotsTxtFormat,
        RSSFormat,
        SitemapFormat,
}

func init() <span class="cov8" title="1">{
        sort.Sort(DefaultFormats)
}</span>

// Formats is a slice of Format.
type Formats []Format

func (formats Formats) Len() int      <span class="cov8" title="1">{ return len(formats) }</span>
func (formats Formats) Swap(i, j int) <span class="cov8" title="1">{ formats[i], formats[j] = formats[j], formats[i] }</span>
func (formats Formats) Less(i, j int) bool <span class="cov8" title="1">{
        fi, fj := formats[i], formats[j]
        if fi.Weight == fj.Weight </span><span class="cov8" title="1">{
                return fi.Name &lt; fj.Name
        }</span>

        <span class="cov8" title="1">if fj.Weight == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return fi.Weight &gt; 0 &amp;&amp; fi.Weight &lt; fj.Weight</span>
}

// GetBySuffix gets a output format given as suffix, e.g. "html".
// It will return false if no format could be found, or if the suffix given
// is ambiguous.
// The lookup is case insensitive.
func (formats Formats) GetBySuffix(suffix string) (f Format, found bool) <span class="cov8" title="1">{
        for _, ff := range formats </span><span class="cov8" title="1">{
                for _, suffix2 := range ff.MediaType.Suffixes() </span><span class="cov8" title="1">{
                        if strings.EqualFold(suffix, suffix2) </span><span class="cov8" title="1">{
                                if found </span><span class="cov8" title="1">{
                                        // ambiguous
                                        found = false
                                        return
                                }</span>
                                <span class="cov8" title="1">f = ff
                                found = true</span>
                        }
                }
        }
        <span class="cov8" title="1">return</span>
}

// GetByName gets a format by its identifier name.
func (formats Formats) GetByName(name string) (f Format, found bool) <span class="cov8" title="1">{
        for _, ff := range formats </span><span class="cov8" title="1">{
                if strings.EqualFold(name, ff.Name) </span><span class="cov8" title="1">{
                        f = ff
                        found = true
                        return
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// GetByNames gets a list of formats given a list of identifiers.
func (formats Formats) GetByNames(names ...string) (Formats, error) <span class="cov0" title="0">{
        var types []Format

        for _, name := range names </span><span class="cov0" title="0">{
                tpe, ok := formats.GetByName(name)
                if !ok </span><span class="cov0" title="0">{
                        return types, fmt.Errorf("OutputFormat with key %q not found", name)
                }</span>
                <span class="cov0" title="0">types = append(types, tpe)</span>
        }
        <span class="cov0" title="0">return types, nil</span>
}

// FromFilename gets a Format given a filename.
func (formats Formats) FromFilename(filename string) (f Format, found bool) <span class="cov8" title="1">{
        // mytemplate.amp.html
        // mytemplate.html
        // mytemplate
        var ext, outFormat string

        parts := strings.Split(filename, ".")
        if len(parts) &gt; 2 </span><span class="cov8" title="1">{
                outFormat = parts[1]
                ext = parts[2]
        }</span> else<span class="cov8" title="1"> if len(parts) &gt; 1 </span><span class="cov8" title="1">{
                ext = parts[1]
        }</span>

        <span class="cov8" title="1">if outFormat != "" </span><span class="cov8" title="1">{
                return formats.GetByName(outFormat)
        }</span>

        <span class="cov8" title="1">if ext != "" </span><span class="cov8" title="1">{
                f, found = formats.GetBySuffix(ext)
                if !found &amp;&amp; len(parts) == 2 </span><span class="cov8" title="1">{
                        // For extensionless output formats (e.g. Netlify's _redirects)
                        // we must fall back to using the extension as format lookup.
                        f, found = formats.GetByName(ext)
                }</span>
        }
        <span class="cov8" title="1">return</span>
}

// DecodeFormats takes a list of output format configurations and merges those,
// in the order given, with the Hugo defaults as the last resort.
func DecodeFormats(mediaTypes media.Types, maps ...map[string]interface{}) (Formats, error) <span class="cov8" title="1">{
        f := make(Formats, len(DefaultFormats))
        copy(f, DefaultFormats)

        for _, m := range maps </span><span class="cov8" title="1">{
                for k, v := range m </span><span class="cov8" title="1">{
                        found := false
                        for i, vv := range f </span><span class="cov8" title="1">{
                                if strings.EqualFold(k, vv.Name) </span><span class="cov8" title="1">{
                                        // Merge it with the existing
                                        if err := decode(mediaTypes, v, &amp;f[i]); err != nil </span><span class="cov0" title="0">{
                                                return f, err
                                        }</span>
                                        <span class="cov8" title="1">found = true</span>
                                }
                        }
                        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                                var newOutFormat Format
                                newOutFormat.Name = k
                                if err := decode(mediaTypes, v, &amp;newOutFormat); err != nil </span><span class="cov8" title="1">{
                                        return f, err
                                }</span>

                                // We need values for these
                                <span class="cov8" title="1">if newOutFormat.BaseName == "" </span><span class="cov0" title="0">{
                                        newOutFormat.BaseName = "index"
                                }</span>
                                <span class="cov8" title="1">if newOutFormat.Rel == "" </span><span class="cov8" title="1">{
                                        newOutFormat.Rel = "alternate"
                                }</span>

                                <span class="cov8" title="1">f = append(f, newOutFormat)</span>

                        }
                }
        }

        <span class="cov8" title="1">sort.Sort(f)

        return f, nil</span>
}

func decode(mediaTypes media.Types, input interface{}, output *Format) error <span class="cov8" title="1">{
        config := &amp;mapstructure.DecoderConfig{
                Metadata:         nil,
                Result:           output,
                WeaklyTypedInput: true,
                DecodeHook: func(a reflect.Type, b reflect.Type, c interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                        if a.Kind() == reflect.Map </span><span class="cov8" title="1">{
                                dataVal := reflect.Indirect(reflect.ValueOf(c))
                                for _, key := range dataVal.MapKeys() </span><span class="cov8" title="1">{
                                        keyStr, ok := key.Interface().(string)
                                        if !ok </span><span class="cov0" title="0">{
                                                // Not a string key
                                                continue</span>
                                        }
                                        <span class="cov8" title="1">if strings.EqualFold(keyStr, "mediaType") </span><span class="cov8" title="1">{
                                                // If mediaType is a string, look it up and replace it
                                                // in the map.
                                                vv := dataVal.MapIndex(key)
                                                vvi := vv.Interface()

                                                switch vviv := vvi.(type) </span>{
                                                case media.Type:<span class="cov8" title="1"></span>
                                                // OK
                                                case string:<span class="cov8" title="1">
                                                        mediaType, found := mediaTypes.GetByType(vviv)
                                                        if !found </span><span class="cov8" title="1">{
                                                                return c, fmt.Errorf("media type %q not found", vviv)
                                                        }</span>
                                                        <span class="cov8" title="1">dataVal.SetMapIndex(key, reflect.ValueOf(mediaType))</span>
                                                default:<span class="cov0" title="0">
                                                        return nil, errors.Errorf("invalid output format configuration; wrong type for media type, expected string (e.g. text/html), got %T", vvi)</span>
                                                }
                                        }
                                }
                        }
                        <span class="cov8" title="1">return c, nil</span>
                },
        }

        <span class="cov8" title="1">decoder, err := mapstructure.NewDecoder(config)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if err = decoder.Decode(input); err != nil </span><span class="cov8" title="1">{
                return errors.Wrap(err, "failed to decode output format configuration")
        }</span>

        <span class="cov8" title="1">return nil</span>

}

// BaseFilename returns the base filename of f including an extension (ie.
// "index.xml").
func (f Format) BaseFilename() string <span class="cov0" title="0">{
        return f.BaseName + f.MediaType.FirstSuffix.FullSuffix
}</span>

// MarshalJSON returns the JSON encoding of f.
func (f Format) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        type Alias Format
        return json.Marshal(&amp;struct {
                MediaType string `json:"mediaType"`
                Alias
        }{
                MediaType: f.MediaType.String(),
                Alias:     (Alias)(f),
        })
}</span>
</pre>
		
		<pre class="file" id="file184" style="display: none">// Copyright 2015 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package parser

import (
        "encoding/json"
        "errors"
        "io"

        "github.com/gohugoio/hugo/parser/metadecoders"

        toml "github.com/pelletier/go-toml/v2"

        yaml "gopkg.in/yaml.v2"

        xml "github.com/clbanning/mxj/v2"
)

const (
        yamlDelimLf = "---\n"
        tomlDelimLf = "+++\n"
)

func InterfaceToConfig(in interface{}, format metadecoders.Format, w io.Writer) error <span class="cov8" title="1">{
        if in == nil </span><span class="cov8" title="1">{
                return errors.New("input was nil")
        }</span>

        <span class="cov8" title="1">switch format </span>{
        case metadecoders.YAML:<span class="cov8" title="1">
                b, err := yaml.Marshal(in)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">_, err = w.Write(b)
                return err</span>

        case metadecoders.TOML:<span class="cov8" title="1">
                enc := toml.NewEncoder(w)
                enc.SetIndentTables(true)
                return enc.Encode(in)</span>
        case metadecoders.JSON:<span class="cov8" title="1">
                b, err := json.MarshalIndent(in, "", "   ")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">_, err = w.Write(b)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">_, err = w.Write([]byte{'\n'})
                return err</span>
        case metadecoders.XML:<span class="cov0" title="0">
                b, err := xml.AnyXmlIndent(in, "", "\t", "root")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = w.Write(b)
                return err</span>
        default:<span class="cov8" title="1">
                return errors.New("unsupported Format provided")</span>
        }
}

func InterfaceToFrontMatter(in interface{}, format metadecoders.Format, w io.Writer) error <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return errors.New("input was nil")
        }</span>

        <span class="cov0" title="0">switch format </span>{
        case metadecoders.YAML:<span class="cov0" title="0">
                _, err := w.Write([]byte(yamlDelimLf))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = InterfaceToConfig(in, format, w)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = w.Write([]byte(yamlDelimLf))
                return err</span>

        case metadecoders.TOML:<span class="cov0" title="0">
                _, err := w.Write([]byte(tomlDelimLf))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">err = InterfaceToConfig(in, format, w)

                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">_, err = w.Write([]byte("\n" + tomlDelimLf))
                return err</span>

        default:<span class="cov0" title="0">
                return InterfaceToConfig(in, format, w)</span>
        }
}
</pre>
		
		<pre class="file" id="file185" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package parser

import (
        "bytes"
        "encoding/json"
        "regexp"
        "unicode"
        "unicode/utf8"
)

// Regexp definitions
var (
        keyMatchRegex    = regexp.MustCompile(`\"(\w+)\":`)
        wordBarrierRegex = regexp.MustCompile(`(\w)([A-Z])`)
)

// Code adapted from https://gist.github.com/piersy/b9934790a8892db1a603820c0c23e4a7
type LowerCaseCamelJSONMarshaller struct {
        Value interface{}
}

func (c LowerCaseCamelJSONMarshaller) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        marshalled, err := json.Marshal(c.Value)

        converted := keyMatchRegex.ReplaceAllFunc(
                marshalled,
                func(match []byte) []byte </span><span class="cov0" title="0">{
                        // Attributes on the form XML, JSON etc.
                        if bytes.Equal(match, bytes.ToUpper(match)) </span><span class="cov0" title="0">{
                                return bytes.ToLower(match)
                        }</span>

                        // Empty keys are valid JSON, only lowercase if we do not have an
                        // empty key.
                        <span class="cov0" title="0">if len(match) &gt; 2 </span><span class="cov0" title="0">{
                                // Decode first rune after the double quotes
                                r, width := utf8.DecodeRune(match[1:])
                                r = unicode.ToLower(r)
                                utf8.EncodeRune(match[1:width+1], r)
                        }</span>
                        <span class="cov0" title="0">return match</span>
                },
        )

        <span class="cov0" title="0">return converted, err</span>
}
</pre>
		
		<pre class="file" id="file186" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metadecoders

import (
        "bytes"
        "encoding/csv"
        "encoding/json"
        "fmt"
        "regexp"
        "strings"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/niklasfasching/go-org/org"

        xml "github.com/clbanning/mxj/v2"
        toml "github.com/pelletier/go-toml/v2"
        "github.com/pkg/errors"
        "github.com/spf13/afero"
        "github.com/spf13/cast"
        jww "github.com/spf13/jwalterweatherman"
        yaml "gopkg.in/yaml.v2"
)

// Decoder provides some configuration options for the decoders.
type Decoder struct {
        // Delimiter is the field delimiter used in the CSV decoder. It defaults to ','.
        Delimiter rune

        // Comment, if not 0, is the comment character ued in the CSV decoder. Lines beginning with the
        // Comment character without preceding whitespace are ignored.
        Comment rune
}

// OptionsKey is used in cache keys.
func (d Decoder) OptionsKey() string <span class="cov0" title="0">{
        var sb strings.Builder
        sb.WriteRune(d.Delimiter)
        sb.WriteRune(d.Comment)
        return sb.String()
}</span>

// Default is a Decoder in its default configuration.
var Default = Decoder{
        Delimiter: ',',
}

// UnmarshalToMap will unmarshall data in format f into a new map. This is
// what's needed for Hugo's front matter decoding.
func (d Decoder) UnmarshalToMap(data []byte, f Format) (map[string]interface{}, error) <span class="cov8" title="1">{
        m := make(map[string]interface{})
        if data == nil </span><span class="cov0" title="0">{
                return m, nil
        }</span>

        <span class="cov8" title="1">err := d.UnmarshalTo(data, f, &amp;m)

        return m, err</span>
}

// UnmarshalFileToMap is the same as UnmarshalToMap, but reads the data from
// the given filename.
func (d Decoder) UnmarshalFileToMap(fs afero.Fs, filename string) (map[string]interface{}, error) <span class="cov0" title="0">{
        format := FormatFromString(filename)
        if format == "" </span><span class="cov0" title="0">{
                return nil, errors.Errorf("%q is not a valid configuration format", filename)
        }</span>

        <span class="cov0" title="0">data, err := afero.ReadFile(fs, filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return d.UnmarshalToMap(data, format)</span>
}

// UnmarshalStringTo tries to unmarshal data to a new instance of type typ.
func (d Decoder) UnmarshalStringTo(data string, typ interface{}) (interface{}, error) <span class="cov8" title="1">{
        data = strings.TrimSpace(data)
        // We only check for the possible types in YAML, JSON and TOML.
        switch typ.(type) </span>{
        case string:<span class="cov8" title="1">
                return data, nil</span>
        case map[string]interface{}:<span class="cov8" title="1">
                format := d.FormatFromContentString(data)
                return d.UnmarshalToMap([]byte(data), format)</span>
        case []interface{}:<span class="cov8" title="1">
                // A standalone slice. Let YAML handle it.
                return d.Unmarshal([]byte(data), YAML)</span>
        case bool:<span class="cov0" title="0">
                return cast.ToBoolE(data)</span>
        case int:<span class="cov8" title="1">
                return cast.ToIntE(data)</span>
        case int64:<span class="cov8" title="1">
                return cast.ToInt64E(data)</span>
        case float64:<span class="cov8" title="1">
                return cast.ToFloat64E(data)</span>
        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unmarshal: %T not supported", typ)</span>
        }
}

// Unmarshal will unmarshall data in format f into an interface{}.
// This is what's needed for Hugo's /data handling.
func (d Decoder) Unmarshal(data []byte, f Format) (interface{}, error) <span class="cov8" title="1">{
        if data == nil </span><span class="cov0" title="0">{
                switch f </span>{
                case CSV:<span class="cov0" title="0">
                        return make([][]string, 0), nil</span>
                default:<span class="cov0" title="0">
                        return make(map[string]interface{}), nil</span>
                }
        }
        <span class="cov8" title="1">var v interface{}
        err := d.UnmarshalTo(data, f, &amp;v)

        return v, err</span>
}

// UnmarshalTo unmarshals data in format f into v.
func (d Decoder) UnmarshalTo(data []byte, f Format, v interface{}) error <span class="cov8" title="1">{
        var err error

        switch f </span>{
        case ORG:<span class="cov8" title="1">
                err = d.unmarshalORG(data, v)</span>
        case JSON:<span class="cov8" title="1">
                err = json.Unmarshal(data, v)</span>
        case XML:<span class="cov8" title="1">
                var xmlRoot xml.Map
                xmlRoot, err = xml.NewMapXml(data)

                var xmlValue map[string]interface{}
                if err == nil </span><span class="cov8" title="1">{
                        xmlRootName, err := xmlRoot.Root()
                        if err != nil </span><span class="cov0" title="0">{
                                return toFileError(f, errors.Wrap(err, "failed to unmarshal XML"))
                        }</span>
                        <span class="cov8" title="1">xmlValue = xmlRoot[xmlRootName].(map[string]interface{})</span>
                }

                <span class="cov8" title="1">switch v := v.(type) </span>{
                case *map[string]interface{}:<span class="cov8" title="1">
                        *v = xmlValue</span>
                case *interface{}:<span class="cov8" title="1">
                        *v = xmlValue</span>
                }
        case TOML:<span class="cov8" title="1">
                err = toml.Unmarshal(data, v)</span>
        case YAML:<span class="cov8" title="1">
                err = yaml.Unmarshal(data, v)
                if err != nil </span><span class="cov0" title="0">{
                        return toFileError(f, errors.Wrap(err, "failed to unmarshal YAML"))
                }</span>

                // To support boolean keys, the YAML package unmarshals maps to
                // map[interface{}]interface{}. Here we recurse through the result
                // and change all maps to map[string]interface{} like we would've
                // gotten from `json`.
                <span class="cov8" title="1">var ptr interface{}
                switch v.(type) </span>{
                case *map[string]interface{}:<span class="cov8" title="1">
                        ptr = *v.(*map[string]interface{})</span>
                case *interface{}:<span class="cov8" title="1">
                        ptr = *v.(*interface{})</span>
                default:<span class="cov0" title="0"></span>
                        // Not a map.
                }

                <span class="cov8" title="1">if ptr != nil </span><span class="cov8" title="1">{
                        if mm, changed := stringifyMapKeys(ptr); changed </span><span class="cov8" title="1">{
                                switch v.(type) </span>{
                                case *map[string]interface{}:<span class="cov0" title="0">
                                        *v.(*map[string]interface{}) = mm.(map[string]interface{})</span>
                                case *interface{}:<span class="cov8" title="1">
                                        *v.(*interface{}) = mm</span>
                                }
                        }
                }
        case CSV:<span class="cov8" title="1">
                return d.unmarshalCSV(data, v)</span>

        default:<span class="cov0" title="0">
                return errors.Errorf("unmarshal of format %q is not supported", f)</span>
        }

        <span class="cov8" title="1">if err == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return toFileError(f, errors.Wrap(err, "unmarshal failed"))</span>
}

func (d Decoder) unmarshalCSV(data []byte, v interface{}) error <span class="cov8" title="1">{
        r := csv.NewReader(bytes.NewReader(data))
        r.Comma = d.Delimiter
        r.Comment = d.Comment

        records, err := r.ReadAll()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">switch v.(type) </span>{
        case *interface{}:<span class="cov8" title="1">
                *v.(*interface{}) = records</span>
        default:<span class="cov8" title="1">
                return errors.Errorf("CSV cannot be unmarshaled into %T", v)</span>

        }

        <span class="cov8" title="1">return nil</span>
}

func parseORGDate(s string) string <span class="cov8" title="1">{
        r := regexp.MustCompile(`[&lt;\[](\d{4}-\d{2}-\d{2}) .*[&gt;\]]`)
        if m := r.FindStringSubmatch(s); m != nil </span><span class="cov8" title="1">{
                return m[1]
        }</span>
        <span class="cov0" title="0">return s</span>
}

func (d Decoder) unmarshalORG(data []byte, v interface{}) error <span class="cov8" title="1">{
        config := org.New()
        config.Log = jww.WARN
        document := config.Parse(bytes.NewReader(data), "")
        if document.Error != nil </span><span class="cov0" title="0">{
                return document.Error
        }</span>
        <span class="cov8" title="1">frontMatter := make(map[string]interface{}, len(document.BufferSettings))
        for k, v := range document.BufferSettings </span><span class="cov8" title="1">{
                k = strings.ToLower(k)
                if strings.HasSuffix(k, "[]") </span><span class="cov0" title="0">{
                        frontMatter[k[:len(k)-2]] = strings.Fields(v)
                }</span> else<span class="cov8" title="1"> if k == "tags" || k == "categories" || k == "aliases" </span><span class="cov0" title="0">{
                        jww.WARN.Printf("Please use '#+%s[]:' notation, automatic conversion is deprecated.", k)
                        frontMatter[k] = strings.Fields(v)
                }</span> else<span class="cov8" title="1"> if k == "date" </span><span class="cov8" title="1">{
                        frontMatter[k] = parseORGDate(v)
                }</span> else<span class="cov8" title="1"> {
                        frontMatter[k] = v
                }</span>
        }
        <span class="cov8" title="1">switch v.(type) </span>{
        case *map[string]interface{}:<span class="cov8" title="1">
                *v.(*map[string]interface{}) = frontMatter</span>
        default:<span class="cov8" title="1">
                *v.(*interface{}) = frontMatter</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func toFileError(f Format, err error) error <span class="cov8" title="1">{
        return herrors.ToFileError(string(f), err)
}</span>

// stringifyMapKeys recurses into in and changes all instances of
// map[interface{}]interface{} to map[string]interface{}. This is useful to
// work around the impedance mismatch between JSON and YAML unmarshaling that's
// described here: https://github.com/go-yaml/yaml/issues/139
//
// Inspired by https://github.com/stripe/stripe-mock, MIT licensed
func stringifyMapKeys(in interface{}) (interface{}, bool) <span class="cov8" title="1">{
        switch in := in.(type) </span>{
        case []interface{}:<span class="cov8" title="1">
                for i, v := range in </span><span class="cov8" title="1">{
                        if vv, replaced := stringifyMapKeys(v); replaced </span><span class="cov8" title="1">{
                                in[i] = vv
                        }</span>
                }
        case map[string]interface{}:<span class="cov8" title="1">
                for k, v := range in </span><span class="cov8" title="1">{
                        if vv, changed := stringifyMapKeys(v); changed </span><span class="cov8" title="1">{
                                in[k] = vv
                        }</span>
                }
        case map[interface{}]interface{}:<span class="cov8" title="1">
                res := make(map[string]interface{})
                var (
                        ok  bool
                        err error
                )
                for k, v := range in </span><span class="cov8" title="1">{
                        var ks string

                        if ks, ok = k.(string); !ok </span><span class="cov8" title="1">{
                                ks, err = cast.ToStringE(k)
                                if err != nil </span><span class="cov0" title="0">{
                                        ks = fmt.Sprintf("%v", k)
                                }</span>
                        }
                        <span class="cov8" title="1">if vv, replaced := stringifyMapKeys(v); replaced </span><span class="cov8" title="1">{
                                res[ks] = vv
                        }</span> else<span class="cov8" title="1"> {
                                res[ks] = v
                        }</span>
                }
                <span class="cov8" title="1">return res, true</span>
        }

        <span class="cov8" title="1">return nil, false</span>
}
</pre>
		
		<pre class="file" id="file187" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metadecoders

import (
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/media"
)

type Format string

const (
        // These are the supported metdata  formats in Hugo. Most of these are also
        // supported as /data formats.
        ORG  Format = "org"
        JSON Format = "json"
        TOML Format = "toml"
        YAML Format = "yaml"
        CSV  Format = "csv"
        XML  Format = "xml"
)

// FormatFromString turns formatStr, typically a file extension without any ".",
// into a Format. It returns an empty string for unknown formats.
func FormatFromString(formatStr string) Format <span class="cov8" title="1">{
        formatStr = strings.ToLower(formatStr)
        if strings.Contains(formatStr, ".") </span><span class="cov8" title="1">{
                // Assume a filename
                formatStr = strings.TrimPrefix(filepath.Ext(formatStr), ".")
        }</span>
        <span class="cov8" title="1">switch formatStr </span>{
        case "yaml", "yml":<span class="cov8" title="1">
                return YAML</span>
        case "json":<span class="cov8" title="1">
                return JSON</span>
        case "toml":<span class="cov8" title="1">
                return TOML</span>
        case "org":<span class="cov8" title="1">
                return ORG</span>
        case "csv":<span class="cov0" title="0">
                return CSV</span>
        case "xml":<span class="cov8" title="1">
                return XML</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// FormatFromMediaType gets the Format given a MIME type, empty string
// if unknown.
func FormatFromMediaType(m media.Type) Format <span class="cov8" title="1">{
        for _, suffix := range m.Suffixes() </span><span class="cov8" title="1">{
                if f := FormatFromString(suffix); f != "" </span><span class="cov8" title="1">{
                        return f
                }</span>
        }

        <span class="cov8" title="1">return ""</span>
}

// FormatFromContentString tries to detect the format (JSON, YAML, TOML or XML)
// in the given string.
// It return an empty string if no format could be detected.
func (d Decoder) FormatFromContentString(data string) Format <span class="cov8" title="1">{
        csvIdx := strings.IndexRune(data, d.Delimiter)
        jsonIdx := strings.Index(data, "{")
        yamlIdx := strings.Index(data, ":")
        xmlIdx := strings.Index(data, "&lt;")
        tomlIdx := strings.Index(data, "=")

        if isLowerIndexThan(csvIdx, jsonIdx, yamlIdx, xmlIdx, tomlIdx) </span><span class="cov8" title="1">{
                return CSV
        }</span>

        <span class="cov8" title="1">if isLowerIndexThan(jsonIdx, yamlIdx, xmlIdx, tomlIdx) </span><span class="cov8" title="1">{
                return JSON
        }</span>

        <span class="cov8" title="1">if isLowerIndexThan(yamlIdx, xmlIdx, tomlIdx) </span><span class="cov8" title="1">{
                return YAML
        }</span>

        <span class="cov8" title="1">if isLowerIndexThan(xmlIdx, tomlIdx) </span><span class="cov8" title="1">{
                return XML
        }</span>

        <span class="cov8" title="1">if tomlIdx != -1 </span><span class="cov8" title="1">{
                return TOML
        }</span>

        <span class="cov8" title="1">return ""</span>
}

func isLowerIndexThan(first int, others ...int) bool <span class="cov8" title="1">{
        if first == -1 </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for _, other := range others </span><span class="cov8" title="1">{
                if other != -1 &amp;&amp; other &lt; first </span><span class="cov0" title="0">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file188" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pageparser

import (
        "bytes"
        "fmt"
        "regexp"
        "strconv"
)

type Item struct {
        Type     ItemType
        Pos      int
        Val      []byte
        isString bool
}

type Items []Item

func (i Item) ValStr() string <span class="cov8" title="1">{
        return string(i.Val)
}</span>

func (i Item) ValTyped() interface{} <span class="cov8" title="1">{
        str := i.ValStr()
        if i.isString </span><span class="cov8" title="1">{
                // A quoted value that is a string even if it looks like a number etc.
                return str
        }</span>

        <span class="cov8" title="1">if boolRe.MatchString(str) </span><span class="cov8" title="1">{
                return str == "true"
        }</span>

        <span class="cov8" title="1">if intRe.MatchString(str) </span><span class="cov8" title="1">{
                num, err := strconv.Atoi(str)
                if err != nil </span><span class="cov0" title="0">{
                        return str
                }</span>
                <span class="cov8" title="1">return num</span>
        }

        <span class="cov8" title="1">if floatRe.MatchString(str) </span><span class="cov8" title="1">{
                num, err := strconv.ParseFloat(str, 64)
                if err != nil </span><span class="cov0" title="0">{
                        return str
                }</span>
                <span class="cov8" title="1">return num</span>
        }

        <span class="cov8" title="1">return str</span>
}

func (i Item) IsText() bool <span class="cov0" title="0">{
        return i.Type == tText
}</span>

func (i Item) IsNonWhitespace() bool <span class="cov0" title="0">{
        return len(bytes.TrimSpace(i.Val)) &gt; 0
}</span>

func (i Item) IsShortcodeName() bool <span class="cov0" title="0">{
        return i.Type == tScName
}</span>

func (i Item) IsInlineShortcodeName() bool <span class="cov0" title="0">{
        return i.Type == tScNameInline
}</span>

func (i Item) IsLeftShortcodeDelim() bool <span class="cov0" title="0">{
        return i.Type == tLeftDelimScWithMarkup || i.Type == tLeftDelimScNoMarkup
}</span>

func (i Item) IsRightShortcodeDelim() bool <span class="cov0" title="0">{
        return i.Type == tRightDelimScWithMarkup || i.Type == tRightDelimScNoMarkup
}</span>

func (i Item) IsShortcodeClose() bool <span class="cov0" title="0">{
        return i.Type == tScClose
}</span>

func (i Item) IsShortcodeParam() bool <span class="cov0" title="0">{
        return i.Type == tScParam
}</span>

func (i Item) IsShortcodeParamVal() bool <span class="cov0" title="0">{
        return i.Type == tScParamVal
}</span>

func (i Item) IsShortcodeMarkupDelimiter() bool <span class="cov0" title="0">{
        return i.Type == tLeftDelimScWithMarkup || i.Type == tRightDelimScWithMarkup
}</span>

func (i Item) IsFrontMatter() bool <span class="cov0" title="0">{
        return i.Type &gt;= TypeFrontMatterYAML &amp;&amp; i.Type &lt;= TypeFrontMatterORG
}</span>

func (i Item) IsDone() bool <span class="cov0" title="0">{
        return i.Type == tError || i.Type == tEOF
}</span>

func (i Item) IsEOF() bool <span class="cov0" title="0">{
        return i.Type == tEOF
}</span>

func (i Item) IsError() bool <span class="cov0" title="0">{
        return i.Type == tError
}</span>

func (i Item) String() string <span class="cov0" title="0">{
        switch </span>{
        case i.Type == tEOF:<span class="cov0" title="0">
                return "EOF"</span>
        case i.Type == tError:<span class="cov0" title="0">
                return string(i.Val)</span>
        case i.Type &gt; tKeywordMarker:<span class="cov0" title="0">
                return fmt.Sprintf("&lt;%s&gt;", i.Val)</span>
        case len(i.Val) &gt; 50:<span class="cov0" title="0">
                return fmt.Sprintf("%v:%.20q...", i.Type, i.Val)</span>
        }
        <span class="cov0" title="0">return fmt.Sprintf("%v:[%s]", i.Type, i.Val)</span>
}

type ItemType int

const (
        tError ItemType = iota
        tEOF

        // page items
        TypeLeadSummaryDivider // &lt;!--more--&gt;,  # more
        TypeFrontMatterYAML
        TypeFrontMatterTOML
        TypeFrontMatterJSON
        TypeFrontMatterORG
        TypeEmoji
        TypeIgnore // // The BOM Unicode byte order marker and possibly others

        // shortcode items
        tLeftDelimScNoMarkup
        tRightDelimScNoMarkup
        tLeftDelimScWithMarkup
        tRightDelimScWithMarkup
        tScClose
        tScName
        tScNameInline
        tScParam
        tScParamVal

        tText // plain text

        // preserved for later - keywords come after this
        tKeywordMarker
)

var (
        boolRe  = regexp.MustCompile(`^(true$)|(false$)`)
        intRe   = regexp.MustCompile(`^[-+]?\d+$`)
        floatRe = regexp.MustCompile(`^[-+]?\d*\.\d+$`)
)
</pre>
		
		<pre class="file" id="file189" style="display: none">// Code generated by "stringer -type ItemType"; DO NOT EDIT.

package pageparser

import "strconv"

const _ItemType_name = "tErrortEOFTypeHTMLStartTypeLeadSummaryDividerTypeFrontMatterYAMLTypeFrontMatterTOMLTypeFrontMatterJSONTypeFrontMatterORGTypeEmojiTypeIgnoretLeftDelimScNoMarkuptRightDelimScNoMarkuptLeftDelimScWithMarkuptRightDelimScWithMarkuptScClosetScNametScNameInlinetScParamtScParamValtTexttKeywordMarker"

var _ItemType_index = [...]uint16{0, 6, 10, 23, 45, 64, 83, 102, 120, 129, 139, 159, 180, 202, 225, 233, 240, 253, 261, 272, 277, 291}

func (i ItemType) String() string <span class="cov0" title="0">{
        if i &lt; 0 || i &gt;= ItemType(len(_ItemType_index)-1) </span><span class="cov0" title="0">{
                return "ItemType(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov0" title="0">return _ItemType_name[_ItemType_index[i]:_ItemType_index[i+1]]</span>
}
</pre>
		
		<pre class="file" id="file190" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pageparser

import (
        "bytes"
        "fmt"
        "unicode"
        "unicode/utf8"
)

const eof = -1

// returns the next state in scanner.
type stateFunc func(*pageLexer) stateFunc

type pageLexer struct {
        input      []byte
        stateStart stateFunc
        state      stateFunc
        pos        int // input position
        start      int // item start position
        width      int // width of last element

        // Contains lexers for shortcodes and other main section
        // elements.
        sectionHandlers *sectionHandlers

        cfg Config

        // The summary divider to look for.
        summaryDivider []byte
        // Set when we have parsed any summary divider
        summaryDividerChecked bool
        // Whether we're in a HTML comment.
        isInHTMLComment bool

        lexerShortcodeState

        // items delivered to client
        items Items
}

// Implement the Result interface
func (l *pageLexer) Iterator() *Iterator <span class="cov0" title="0">{
        return l.newIterator()
}</span>

func (l *pageLexer) Input() []byte <span class="cov0" title="0">{
        return l.input
}</span>

type Config struct {
        EnableEmoji bool
}

// note: the input position here is normally 0 (start), but
// can be set if position of first shortcode is known
func newPageLexer(input []byte, stateStart stateFunc, cfg Config) *pageLexer <span class="cov8" title="1">{
        lexer := &amp;pageLexer{
                input:      input,
                stateStart: stateStart,
                cfg:        cfg,
                lexerShortcodeState: lexerShortcodeState{
                        currLeftDelimItem:  tLeftDelimScNoMarkup,
                        currRightDelimItem: tRightDelimScNoMarkup,
                        openShortcodes:     make(map[string]bool),
                },
                items: make([]Item, 0, 5),
        }

        lexer.sectionHandlers = createSectionHandlers(lexer)

        return lexer
}</span>

func (l *pageLexer) newIterator() *Iterator <span class="cov8" title="1">{
        return &amp;Iterator{l: l, lastPos: -1}
}</span>

// main loop
func (l *pageLexer) run() *pageLexer <span class="cov8" title="1">{
        for l.state = l.stateStart; l.state != nil; </span><span class="cov8" title="1">{
                l.state = l.state(l)
        }</span>
        <span class="cov8" title="1">return l</span>
}

// Page syntax
var (
        byteOrderMark     = '\ufeff'
        summaryDivider    = []byte("&lt;!--more--&gt;")
        summaryDividerOrg = []byte("# more")
        delimTOML         = []byte("+++")
        delimYAML         = []byte("---")
        delimOrg          = []byte("#+")
        htmlCommentStart  = []byte("&lt;!--")
        htmlCommentEnd    = []byte("--&gt;")

        emojiDelim = byte(':')
)

func (l *pageLexer) next() rune <span class="cov8" title="1">{
        if l.pos &gt;= len(l.input) </span><span class="cov8" title="1">{
                l.width = 0
                return eof
        }</span>

        <span class="cov8" title="1">runeValue, runeWidth := utf8.DecodeRune(l.input[l.pos:])
        l.width = runeWidth
        l.pos += l.width
        return runeValue</span>
}

// peek, but no consume
func (l *pageLexer) peek() rune <span class="cov8" title="1">{
        r := l.next()
        l.backup()
        return r
}</span>

// steps back one
func (l *pageLexer) backup() <span class="cov8" title="1">{
        l.pos -= l.width
}</span>

// sends an item back to the client.
func (l *pageLexer) emit(t ItemType) <span class="cov8" title="1">{
        l.items = append(l.items, Item{t, l.start, l.input[l.start:l.pos], false})
        l.start = l.pos
}</span>

// sends a string item back to the client.
func (l *pageLexer) emitString(t ItemType) <span class="cov8" title="1">{
        l.items = append(l.items, Item{t, l.start, l.input[l.start:l.pos], true})
        l.start = l.pos
}</span>

func (l *pageLexer) isEOF() bool <span class="cov8" title="1">{
        return l.pos &gt;= len(l.input)
}</span>

// special case, do not send '\\' back to client
func (l *pageLexer) ignoreEscapesAndEmit(t ItemType, isString bool) <span class="cov8" title="1">{
        val := bytes.Map(func(r rune) rune </span><span class="cov8" title="1">{
                if r == '\\' </span><span class="cov8" title="1">{
                        return -1
                }</span>
                <span class="cov8" title="1">return r</span>
        }, l.input[l.start:l.pos])
        <span class="cov8" title="1">l.items = append(l.items, Item{t, l.start, val, isString})
        l.start = l.pos</span>
}

// gets the current value (for debugging and error handling)
func (l *pageLexer) current() []byte <span class="cov8" title="1">{
        return l.input[l.start:l.pos]
}</span>

// ignore current element
func (l *pageLexer) ignore() <span class="cov8" title="1">{
        l.start = l.pos
}</span>

var lf = []byte("\n")

// nil terminates the parser
func (l *pageLexer) errorf(format string, args ...interface{}) stateFunc <span class="cov8" title="1">{
        l.items = append(l.items, Item{tError, l.start, []byte(fmt.Sprintf(format, args...)), true})
        return nil
}</span>

func (l *pageLexer) consumeCRLF() bool <span class="cov8" title="1">{
        var consumed bool
        for _, r := range crLf </span><span class="cov8" title="1">{
                if l.next() != r </span><span class="cov8" title="1">{
                        l.backup()
                }</span> else<span class="cov8" title="1"> {
                        consumed = true
                }</span>
        }
        <span class="cov8" title="1">return consumed</span>
}

func (l *pageLexer) consumeToNextLine() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                r := l.next()
                if r == eof || isEndOfLine(r) </span><span class="cov8" title="1">{
                        return
                }</span>
        }
}

func (l *pageLexer) consumeToSpace() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                r := l.next()
                if r == eof || unicode.IsSpace(r) </span><span class="cov8" title="1">{
                        l.backup()
                        return
                }</span>
        }
}

func (l *pageLexer) consumeSpace() <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                r := l.next()
                if r == eof || !unicode.IsSpace(r) </span><span class="cov8" title="1">{
                        l.backup()
                        return
                }</span>
        }
}

// lex a string starting at ":"
func lexEmoji(l *pageLexer) stateFunc <span class="cov8" title="1">{
        pos := l.pos + 1
        valid := false

        for i := pos; i &lt; len(l.input); i++ </span><span class="cov8" title="1">{
                if i &gt; pos &amp;&amp; l.input[i] == emojiDelim </span><span class="cov8" title="1">{
                        pos = i + 1
                        valid = true
                        break</span>
                }
                <span class="cov8" title="1">r, _ := utf8.DecodeRune(l.input[i:])
                if !(isAlphaNumericOrHyphen(r) || r == '+') </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">if valid </span><span class="cov8" title="1">{
                l.pos = pos
                l.emit(TypeEmoji)
        }</span> else<span class="cov8" title="1"> {
                l.pos++
                l.emit(tText)
        }</span>

        <span class="cov8" title="1">return lexMainSection</span>
}

type sectionHandlers struct {
        l *pageLexer

        // Set when none of the sections are found so we
        // can safely stop looking and skip to the end.
        skipAll bool

        handlers    []*sectionHandler
        skipIndexes []int
}

func (s *sectionHandlers) skip() int <span class="cov8" title="1">{
        if s.skipAll </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov8" title="1">s.skipIndexes = s.skipIndexes[:0]
        var shouldSkip bool
        for _, skipper := range s.handlers </span><span class="cov8" title="1">{
                idx := skipper.skip()
                if idx != -1 </span><span class="cov8" title="1">{
                        shouldSkip = true
                        s.skipIndexes = append(s.skipIndexes, idx)
                }</span>
        }

        <span class="cov8" title="1">if !shouldSkip </span><span class="cov8" title="1">{
                s.skipAll = true
                return -1
        }</span>

        <span class="cov8" title="1">return minIndex(s.skipIndexes...)</span>
}

func createSectionHandlers(l *pageLexer) *sectionHandlers <span class="cov8" title="1">{
        shortCodeHandler := &amp;sectionHandler{
                l: l,
                skipFunc: func(l *pageLexer) int </span><span class="cov8" title="1">{
                        return l.index(leftDelimSc)
                }</span>,
                lexFunc: func(origin stateFunc, l *pageLexer) (stateFunc, bool) <span class="cov8" title="1">{
                        if !l.isShortCodeStart() </span><span class="cov8" title="1">{
                                return origin, false
                        }</span>

                        <span class="cov8" title="1">if l.isInline </span><span class="cov8" title="1">{
                                // If we're inside an inline shortcode, the only valid shortcode markup is
                                // the markup which closes it.
                                b := l.input[l.pos+3:]
                                end := indexNonWhiteSpace(b, '/')
                                if end != len(l.input)-1 </span><span class="cov8" title="1">{
                                        b = bytes.TrimSpace(b[end+1:])
                                        if end == -1 || !bytes.HasPrefix(b, []byte(l.currShortcodeName+" ")) </span><span class="cov8" title="1">{
                                                return l.errorf("inline shortcodes do not support nesting"), true
                                        }</span>
                                }
                        }

                        <span class="cov8" title="1">if l.hasPrefix(leftDelimScWithMarkup) </span><span class="cov8" title="1">{
                                l.currLeftDelimItem = tLeftDelimScWithMarkup
                                l.currRightDelimItem = tRightDelimScWithMarkup
                        }</span> else<span class="cov8" title="1"> {
                                l.currLeftDelimItem = tLeftDelimScNoMarkup
                                l.currRightDelimItem = tRightDelimScNoMarkup
                        }</span>

                        <span class="cov8" title="1">return lexShortcodeLeftDelim, true</span>
                },
        }

        <span class="cov8" title="1">summaryDividerHandler := &amp;sectionHandler{
                l: l,
                skipFunc: func(l *pageLexer) int </span><span class="cov8" title="1">{
                        if l.summaryDividerChecked || l.summaryDivider == nil </span><span class="cov8" title="1">{
                                return -1
                        }</span>
                        <span class="cov8" title="1">return l.index(l.summaryDivider)</span>
                },
                lexFunc: func(origin stateFunc, l *pageLexer) (stateFunc, bool) <span class="cov8" title="1">{
                        if !l.hasPrefix(l.summaryDivider) </span><span class="cov0" title="0">{
                                return origin, false
                        }</span>

                        <span class="cov8" title="1">l.summaryDividerChecked = true
                        l.pos += len(l.summaryDivider)
                        // This makes it a little easier to reason about later.
                        l.consumeSpace()
                        l.emit(TypeLeadSummaryDivider)

                        return origin, true</span>
                },
        }

        <span class="cov8" title="1">handlers := []*sectionHandler{shortCodeHandler, summaryDividerHandler}

        if l.cfg.EnableEmoji </span><span class="cov8" title="1">{
                emojiHandler := &amp;sectionHandler{
                        l: l,
                        skipFunc: func(l *pageLexer) int </span><span class="cov8" title="1">{
                                return l.indexByte(emojiDelim)
                        }</span>,
                        lexFunc: func(origin stateFunc, l *pageLexer) (stateFunc, bool) <span class="cov8" title="1">{
                                return lexEmoji, true
                        }</span>,
                }

                <span class="cov8" title="1">handlers = append(handlers, emojiHandler)</span>
        }

        <span class="cov8" title="1">return &amp;sectionHandlers{
                l:           l,
                handlers:    handlers,
                skipIndexes: make([]int, len(handlers)),
        }</span>
}

func (s *sectionHandlers) lex(origin stateFunc) stateFunc <span class="cov8" title="1">{
        if s.skipAll </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov8" title="1">if s.l.pos &gt; s.l.start </span><span class="cov8" title="1">{
                s.l.emit(tText)
        }</span>

        <span class="cov8" title="1">for _, handler := range s.handlers </span><span class="cov8" title="1">{
                if handler.skipAll </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">next, handled := handler.lexFunc(origin, handler.l)
                if next == nil || handled </span><span class="cov8" title="1">{
                        return next
                }</span>
        }

        // Not handled by the above.
        <span class="cov8" title="1">s.l.pos++

        return origin</span>
}

type sectionHandler struct {
        l *pageLexer

        // No more sections of this type.
        skipAll bool

        // Returns the index of the next match, -1 if none found.
        skipFunc func(l *pageLexer) int

        // Lex lexes the current section and returns the next state func and
        // a bool telling if this section was handled.
        // Note that returning nil as the next state will terminate the
        // lexer.
        lexFunc func(origin stateFunc, l *pageLexer) (stateFunc, bool)
}

func (s *sectionHandler) skip() int <span class="cov8" title="1">{
        if s.skipAll </span><span class="cov8" title="1">{
                return -1
        }</span>

        <span class="cov8" title="1">idx := s.skipFunc(s.l)
        if idx == -1 </span><span class="cov8" title="1">{
                s.skipAll = true
        }</span>
        <span class="cov8" title="1">return idx</span>
}

func lexMainSection(l *pageLexer) stateFunc <span class="cov8" title="1">{
        if l.isEOF() </span><span class="cov8" title="1">{
                return lexDone
        }</span>

        <span class="cov8" title="1">if l.isInHTMLComment </span><span class="cov8" title="1">{
                return lexEndFrontMatterHTMLComment
        }</span>

        // Fast forward as far as possible.
        <span class="cov8" title="1">skip := l.sectionHandlers.skip()

        if skip == -1 </span><span class="cov8" title="1">{
                l.pos = len(l.input)
                return lexDone
        }</span> else<span class="cov8" title="1"> if skip &gt; 0 </span><span class="cov8" title="1">{
                l.pos += skip
        }</span>

        <span class="cov8" title="1">next := l.sectionHandlers.lex(lexMainSection)
        if next != nil </span><span class="cov8" title="1">{
                return next
        }</span>

        <span class="cov8" title="1">l.pos = len(l.input)
        return lexDone</span>
}

func lexDone(l *pageLexer) stateFunc <span class="cov8" title="1">{
        // Done!
        if l.pos &gt; l.start </span><span class="cov8" title="1">{
                l.emit(tText)
        }</span>
        <span class="cov8" title="1">l.emit(tEOF)
        return nil</span>
}

func (l *pageLexer) printCurrentInput() <span class="cov0" title="0">{
        fmt.Printf("input[%d:]: %q", l.pos, string(l.input[l.pos:]))
}</span>

// state helpers

func (l *pageLexer) index(sep []byte) int <span class="cov8" title="1">{
        return bytes.Index(l.input[l.pos:], sep)
}</span>

func (l *pageLexer) indexByte(sep byte) int <span class="cov8" title="1">{
        return bytes.IndexByte(l.input[l.pos:], sep)
}</span>

func (l *pageLexer) hasPrefix(prefix []byte) bool <span class="cov8" title="1">{
        return bytes.HasPrefix(l.input[l.pos:], prefix)
}</span>

// helper functions

// returns the min index &gt;= 0
func minIndex(indices ...int) int <span class="cov8" title="1">{
        min := -1

        for _, j := range indices </span><span class="cov8" title="1">{
                if j &lt; 0 </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">if min == -1 </span><span class="cov8" title="1">{
                        min = j
                }</span> else<span class="cov8" title="1"> if j &lt; min </span><span class="cov8" title="1">{
                        min = j
                }</span>
        }
        <span class="cov8" title="1">return min</span>
}

func indexNonWhiteSpace(s []byte, in rune) int <span class="cov8" title="1">{
        idx := bytes.IndexFunc(s, func(r rune) bool </span><span class="cov8" title="1">{
                return !unicode.IsSpace(r)
        }</span>)

        <span class="cov8" title="1">if idx == -1 </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov8" title="1">r, _ := utf8.DecodeRune(s[idx:])
        if r == in </span><span class="cov8" title="1">{
                return idx
        }</span>
        <span class="cov8" title="1">return -1</span>
}

func isSpace(r rune) bool <span class="cov8" title="1">{
        return r == ' ' || r == '\t'
}</span>

func isAlphaNumericOrHyphen(r rune) bool <span class="cov8" title="1">{
        // let unquoted YouTube ids as positional params slip through (they contain hyphens)
        return isAlphaNumeric(r) || r == '-'
}</span>

var crLf = []rune{'\r', '\n'}

func isEndOfLine(r rune) bool <span class="cov8" title="1">{
        return r == '\r' || r == '\n'
}</span>

func isAlphaNumeric(r rune) bool <span class="cov8" title="1">{
        return r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r)
}</span>
</pre>
		
		<pre class="file" id="file191" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pageparser

func lexIntroSection(l *pageLexer) stateFunc <span class="cov8" title="1">{
        l.summaryDivider = summaryDivider

LOOP:
        for </span><span class="cov8" title="1">{
                r := l.next()
                if r == eof </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">switch </span>{
                case r == '+':<span class="cov8" title="1">
                        return l.lexFrontMatterSection(TypeFrontMatterTOML, r, "TOML", delimTOML)</span>
                case r == '-':<span class="cov8" title="1">
                        return l.lexFrontMatterSection(TypeFrontMatterYAML, r, "YAML", delimYAML)</span>
                case r == '{':<span class="cov8" title="1">
                        return lexFrontMatterJSON</span>
                case r == '#':<span class="cov8" title="1">
                        return lexFrontMatterOrgMode</span>
                case r == byteOrderMark:<span class="cov8" title="1">
                        l.emit(TypeIgnore)</span>
                case !isSpace(r) &amp;&amp; !isEndOfLine(r):<span class="cov8" title="1">
                        if r == '&lt;' </span><span class="cov8" title="1">{
                                l.backup()
                                if l.hasPrefix(htmlCommentStart) </span><span class="cov8" title="1">{
                                        // This may be commented out front matter, which should
                                        // still be read.
                                        l.consumeToNextLine()
                                        l.isInHTMLComment = true
                                        l.emit(TypeIgnore)
                                        continue LOOP</span>
                                } else<span class="cov8" title="1"> {
                                        return l.errorf("plain HTML documents not supported")
                                }</span>
                        }
                        <span class="cov8" title="1">break LOOP</span>
                }
        }

        // Now move on to the shortcodes.
        <span class="cov8" title="1">return lexMainSection</span>
}

func lexEndFrontMatterHTMLComment(l *pageLexer) stateFunc <span class="cov8" title="1">{
        l.isInHTMLComment = false
        right := l.index(htmlCommentEnd)
        if right == -1 </span><span class="cov8" title="1">{
                return l.errorf("starting HTML comment with no end")
        }</span>
        <span class="cov8" title="1">l.pos += right + len(htmlCommentEnd)
        l.emit(TypeIgnore)

        // Now move on to the shortcodes.
        return lexMainSection</span>
}

func lexFrontMatterJSON(l *pageLexer) stateFunc <span class="cov8" title="1">{
        // Include the left delimiter
        l.backup()

        var (
                inQuote bool
                level   int
        )

        for </span><span class="cov8" title="1">{

                r := l.next()

                switch </span>{
                case r == eof:<span class="cov0" title="0">
                        return l.errorf("unexpected EOF parsing JSON front matter")</span>
                case r == '{':<span class="cov8" title="1">
                        if !inQuote </span><span class="cov8" title="1">{
                                level++
                        }</span>
                case r == '}':<span class="cov8" title="1">
                        if !inQuote </span><span class="cov8" title="1">{
                                level--
                        }</span>
                case r == '"':<span class="cov8" title="1">
                        inQuote = !inQuote</span>
                case r == '\\':<span class="cov8" title="1">
                        // This may be an escaped quote. Make sure it's not marked as a
                        // real one.
                        l.next()</span>
                }

                <span class="cov8" title="1">if level == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">l.consumeCRLF()
        l.emit(TypeFrontMatterJSON)

        return lexMainSection</span>
}

func lexFrontMatterOrgMode(l *pageLexer) stateFunc <span class="cov8" title="1">{
        /*
                #+TITLE: Test File For chaseadamsio/goorgeous
                #+AUTHOR: Chase Adams
                #+DESCRIPTION: Just another golang parser for org content!
        */

        l.summaryDivider = summaryDividerOrg

        l.backup()

        if !l.hasPrefix(delimOrg) </span><span class="cov0" title="0">{
                return lexMainSection
        }</span>

        // Read lines until we no longer see a #+ prefix
<span class="cov8" title="1">LOOP:
        for </span><span class="cov8" title="1">{

                r := l.next()

                switch </span>{
                case r == '\n':<span class="cov8" title="1">
                        if !l.hasPrefix(delimOrg) </span><span class="cov8" title="1">{
                                break LOOP</span>
                        }
                case r == eof:<span class="cov0" title="0">
                        break LOOP</span>

                }
        }

        <span class="cov8" title="1">l.emit(TypeFrontMatterORG)

        return lexMainSection</span>
}

// Handle YAML or TOML front matter.
func (l *pageLexer) lexFrontMatterSection(tp ItemType, delimr rune, name string, delim []byte) stateFunc <span class="cov8" title="1">{
        for i := 0; i &lt; 2; i++ </span><span class="cov8" title="1">{
                if r := l.next(); r != delimr </span><span class="cov0" title="0">{
                        return l.errorf("invalid %s delimiter", name)
                }</span>
        }

        // Let front matter start at line 1
        <span class="cov8" title="1">wasEndOfLine := l.consumeCRLF()
        // We don't care about the delimiters.
        l.ignore()

        var r rune

        for </span><span class="cov8" title="1">{
                if !wasEndOfLine </span><span class="cov8" title="1">{
                        r = l.next()
                        if r == eof </span><span class="cov0" title="0">{
                                return l.errorf("EOF looking for end %s front matter delimiter", name)
                        }</span>
                }

                <span class="cov8" title="1">if wasEndOfLine || isEndOfLine(r) </span><span class="cov8" title="1">{
                        if l.hasPrefix(delim) </span><span class="cov8" title="1">{
                                l.emit(tp)
                                l.pos += 3
                                l.consumeCRLF()
                                l.ignore()
                                break</span>
                        }
                }

                <span class="cov8" title="1">wasEndOfLine = false</span>
        }

        <span class="cov8" title="1">return lexMainSection</span>
}
</pre>
		
		<pre class="file" id="file192" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pageparser

type lexerShortcodeState struct {
        currLeftDelimItem  ItemType
        currRightDelimItem ItemType
        isInline           bool
        currShortcodeName  string          // is only set when a shortcode is in opened state
        closingState       int             // &gt; 0 = on its way to be closed
        elementStepNum     int             // step number in element
        paramElements      int             // number of elements (name + value = 2) found first
        openShortcodes     map[string]bool // set of shortcodes in open state

}

// Shortcode syntax
var (
        leftDelimSc            = []byte("{{")
        leftDelimScNoMarkup    = []byte("{{&lt;")
        rightDelimScNoMarkup   = []byte("&gt;}}")
        leftDelimScWithMarkup  = []byte("{{%")
        rightDelimScWithMarkup = []byte("%}}")
        leftComment            = []byte("/*") // comments in this context us used to to mark shortcodes as "not really a shortcode"
        rightComment           = []byte("*/")
)

func (l *pageLexer) isShortCodeStart() bool <span class="cov8" title="1">{
        return l.hasPrefix(leftDelimScWithMarkup) || l.hasPrefix(leftDelimScNoMarkup)
}</span>

func lexShortcodeLeftDelim(l *pageLexer) stateFunc <span class="cov8" title="1">{
        l.pos += len(l.currentLeftShortcodeDelim())
        if l.hasPrefix(leftComment) </span><span class="cov8" title="1">{
                return lexShortcodeComment
        }</span>
        <span class="cov8" title="1">l.emit(l.currentLeftShortcodeDelimItem())
        l.elementStepNum = 0
        l.paramElements = 0
        return lexInsideShortcode</span>
}

func lexShortcodeComment(l *pageLexer) stateFunc <span class="cov8" title="1">{
        posRightComment := l.index(append(rightComment, l.currentRightShortcodeDelim()...))
        if posRightComment &lt;= 1 </span><span class="cov8" title="1">{
                return l.errorf("comment must be closed")
        }</span>
        // we emit all as text, except the comment markers
        <span class="cov8" title="1">l.emit(tText)
        l.pos += len(leftComment)
        l.ignore()
        l.pos += posRightComment - len(leftComment)
        l.emit(tText)
        l.pos += len(rightComment)
        l.ignore()
        l.pos += len(l.currentRightShortcodeDelim())
        l.emit(tText)
        return lexMainSection</span>
}

func lexShortcodeRightDelim(l *pageLexer) stateFunc <span class="cov8" title="1">{
        l.closingState = 0
        l.pos += len(l.currentRightShortcodeDelim())
        l.emit(l.currentRightShortcodeDelimItem())
        return lexMainSection
}</span>

// either:
// 1. param
// 2. "param" or "param\"
// 3. param="123" or param="123\"
// 4. param="Some \"escaped\" text"
// 5. `param`
// 6. param=`123`
func lexShortcodeParam(l *pageLexer, escapedQuoteStart bool) stateFunc <span class="cov8" title="1">{
        first := true
        nextEq := false

        var r rune

        for </span><span class="cov8" title="1">{
                r = l.next()
                if first </span><span class="cov8" title="1">{
                        if r == '"' || (r == '`' &amp;&amp; !escapedQuoteStart) </span><span class="cov8" title="1">{
                                // a positional param with quotes
                                if l.paramElements == 2 </span><span class="cov8" title="1">{
                                        return l.errorf("got quoted positional parameter. Cannot mix named and positional parameters")
                                }</span>
                                <span class="cov8" title="1">l.paramElements = 1
                                l.backup()
                                if r == '"' </span><span class="cov8" title="1">{
                                        return lexShortcodeQuotedParamVal(l, !escapedQuoteStart, tScParam)
                                }</span>
                                <span class="cov8" title="1">return lexShortCodeParamRawStringVal(l, tScParam)</span>

                        } else<span class="cov8" title="1"> if r == '`' &amp;&amp; escapedQuoteStart </span><span class="cov8" title="1">{
                                return l.errorf("unrecognized escape character")
                        }</span>
                        <span class="cov8" title="1">first = false</span>
                } else<span class="cov8" title="1"> if r == '=' </span><span class="cov8" title="1">{
                        // a named param
                        l.backup()
                        nextEq = true
                        break</span>
                }

                <span class="cov8" title="1">if !isAlphaNumericOrHyphen(r) &amp;&amp; r != '.' </span><span class="cov8" title="1">{ // Floats have period
                        l.backup()
                        break</span>
                }
        }

        <span class="cov8" title="1">if l.paramElements == 0 </span><span class="cov8" title="1">{
                l.paramElements++

                if nextEq </span><span class="cov8" title="1">{
                        l.paramElements++
                }</span>
        } else<span class="cov8" title="1"> {
                if nextEq &amp;&amp; l.paramElements == 1 </span><span class="cov8" title="1">{
                        return l.errorf("got named parameter '%s'. Cannot mix named and positional parameters", l.current())
                }</span> else<span class="cov8" title="1"> if !nextEq &amp;&amp; l.paramElements == 2 </span><span class="cov8" title="1">{
                        return l.errorf("got positional parameter '%s'. Cannot mix named and positional parameters", l.current())
                }</span>
        }

        <span class="cov8" title="1">l.emit(tScParam)
        return lexInsideShortcode</span>
}

func lexShortcodeParamVal(l *pageLexer) stateFunc <span class="cov8" title="1">{
        l.consumeToSpace()
        l.emit(tScParamVal)
        return lexInsideShortcode
}</span>

func lexShortCodeParamRawStringVal(l *pageLexer, typ ItemType) stateFunc <span class="cov8" title="1">{
        openBacktickFound := false

Loop:
        for </span><span class="cov8" title="1">{
                switch r := l.next(); </span>{
                case r == '`':<span class="cov8" title="1">
                        if openBacktickFound </span><span class="cov8" title="1">{
                                l.backup()
                                break Loop</span>
                        } else<span class="cov8" title="1"> {
                                openBacktickFound = true
                                l.ignore()
                        }</span>
                case r == eof:<span class="cov8" title="1">
                        return l.errorf("unterminated raw string in shortcode parameter-argument: '%s'", l.current())</span>
                }
        }

        <span class="cov8" title="1">l.emitString(typ)
        l.next()
        l.ignore()

        return lexInsideShortcode</span>
}

func lexShortcodeQuotedParamVal(l *pageLexer, escapedQuotedValuesAllowed bool, typ ItemType) stateFunc <span class="cov8" title="1">{
        openQuoteFound := false
        escapedInnerQuoteFound := false
        escapedQuoteState := 0

Loop:
        for </span><span class="cov8" title="1">{
                switch r := l.next(); </span>{
                case r == '\\':<span class="cov8" title="1">
                        if l.peek() == '"' </span><span class="cov8" title="1">{
                                if openQuoteFound &amp;&amp; !escapedQuotedValuesAllowed </span><span class="cov8" title="1">{
                                        l.backup()
                                        break Loop</span>
                                } else<span class="cov8" title="1"> if openQuoteFound </span><span class="cov8" title="1">{
                                        // the coming quote is inside
                                        escapedInnerQuoteFound = true
                                        escapedQuoteState = 1
                                }</span>
                        } else<span class="cov8" title="1"> if l.peek() == '`' </span><span class="cov8" title="1">{
                                return l.errorf("unrecognized escape character")
                        }</span>
                case r == eof, r == '\n':<span class="cov8" title="1">
                        return l.errorf("unterminated quoted string in shortcode parameter-argument: '%s'", l.current())</span>
                case r == '"':<span class="cov8" title="1">
                        if escapedQuoteState == 0 </span><span class="cov8" title="1">{
                                if openQuoteFound </span><span class="cov8" title="1">{
                                        l.backup()
                                        break Loop</span>

                                } else<span class="cov8" title="1"> {
                                        openQuoteFound = true
                                        l.ignore()
                                }</span>
                        } else<span class="cov8" title="1"> {
                                escapedQuoteState = 0
                        }</span>
                }
        }

        <span class="cov8" title="1">if escapedInnerQuoteFound </span><span class="cov8" title="1">{
                l.ignoreEscapesAndEmit(typ, true)
        }</span> else<span class="cov8" title="1"> {
                l.emitString(typ)
        }</span>

        <span class="cov8" title="1">r := l.next()

        if r == '\\' </span><span class="cov8" title="1">{
                if l.peek() == '"' </span><span class="cov8" title="1">{
                        // ignore the escaped closing quote
                        l.ignore()
                        l.next()
                        l.ignore()
                }</span>
        } else<span class="cov8" title="1"> if r == '"' </span><span class="cov8" title="1">{
                // ignore closing quote
                l.ignore()
        }</span> else<span class="cov0" title="0"> {
                // handled by next state
                l.backup()
        }</span>

        <span class="cov8" title="1">return lexInsideShortcode</span>
}

// Inline shortcodes has the form {{&lt; myshortcode.inline &gt;}}
var inlineIdentifier = []byte("inline ")

// scans an alphanumeric inside shortcode
func lexIdentifierInShortcode(l *pageLexer) stateFunc <span class="cov8" title="1">{
        lookForEnd := false
Loop:
        for </span><span class="cov8" title="1">{
                switch r := l.next(); </span>{
                case isAlphaNumericOrHyphen(r):<span class="cov8" title="1"></span>
                // Allow forward slash inside names to make it possible to create namespaces.
                case r == '/':<span class="cov8" title="1"></span>
                case r == '.':<span class="cov8" title="1">
                        l.isInline = l.hasPrefix(inlineIdentifier)
                        if !l.isInline </span><span class="cov8" title="1">{
                                return l.errorf("period in shortcode name only allowed for inline identifiers")
                        }</span>
                default:<span class="cov8" title="1">
                        l.backup()
                        word := string(l.input[l.start:l.pos])
                        if l.closingState &gt; 0 &amp;&amp; !l.openShortcodes[word] </span><span class="cov8" title="1">{
                                return l.errorf("closing tag for shortcode '%s' does not match start tag", word)
                        }</span> else<span class="cov8" title="1"> if l.closingState &gt; 0 </span><span class="cov8" title="1">{
                                l.openShortcodes[word] = false
                                lookForEnd = true
                        }</span>

                        <span class="cov8" title="1">l.closingState = 0
                        l.currShortcodeName = word
                        l.openShortcodes[word] = true
                        l.elementStepNum++
                        if l.isInline </span><span class="cov8" title="1">{
                                l.emit(tScNameInline)
                        }</span> else<span class="cov8" title="1"> {
                                l.emit(tScName)
                        }</span>
                        <span class="cov8" title="1">break Loop</span>
                }
        }

        <span class="cov8" title="1">if lookForEnd </span><span class="cov8" title="1">{
                return lexEndOfShortcode
        }</span>
        <span class="cov8" title="1">return lexInsideShortcode</span>
}

func lexEndOfShortcode(l *pageLexer) stateFunc <span class="cov8" title="1">{
        l.isInline = false
        if l.hasPrefix(l.currentRightShortcodeDelim()) </span><span class="cov8" title="1">{
                return lexShortcodeRightDelim
        }</span>
        <span class="cov8" title="1">switch r := l.next(); </span>{
        case isSpace(r):<span class="cov8" title="1">
                l.ignore()</span>
        default:<span class="cov8" title="1">
                return l.errorf("unclosed shortcode")</span>
        }
        <span class="cov8" title="1">return lexEndOfShortcode</span>
}

// scans the elements inside shortcode tags
func lexInsideShortcode(l *pageLexer) stateFunc <span class="cov8" title="1">{
        if l.hasPrefix(l.currentRightShortcodeDelim()) </span><span class="cov8" title="1">{
                return lexShortcodeRightDelim
        }</span>
        <span class="cov8" title="1">switch r := l.next(); </span>{
        case r == eof:<span class="cov0" title="0">
                // eol is allowed inside shortcodes; this may go to end of document before it fails
                return l.errorf("unclosed shortcode action")</span>
        case isSpace(r), isEndOfLine(r):<span class="cov8" title="1">
                l.ignore()</span>
        case r == '=':<span class="cov8" title="1">
                l.consumeSpace()
                l.ignore()
                peek := l.peek()
                if peek == '"' || peek == '\\' </span><span class="cov8" title="1">{
                        return lexShortcodeQuotedParamVal(l, peek != '\\', tScParamVal)
                }</span> else<span class="cov8" title="1"> if peek == '`' </span><span class="cov8" title="1">{
                        return lexShortCodeParamRawStringVal(l, tScParamVal)
                }</span>
                <span class="cov8" title="1">return lexShortcodeParamVal</span>
        case r == '/':<span class="cov8" title="1">
                if l.currShortcodeName == "" </span><span class="cov8" title="1">{
                        return l.errorf("got closing shortcode, but none is open")
                }</span>
                <span class="cov8" title="1">l.closingState++
                l.isInline = false
                l.emit(tScClose)</span>
        case r == '\\':<span class="cov8" title="1">
                l.ignore()
                if l.peek() == '"' || l.peek() == '`' </span><span class="cov8" title="1">{
                        return lexShortcodeParam(l, true)
                }</span>
        case l.elementStepNum &gt; 0 &amp;&amp; (isAlphaNumericOrHyphen(r) || r == '"' || r == '`'):<span class="cov8" title="1"> // positional params can have quotes
                l.backup()
                return lexShortcodeParam(l, false)</span>
        case isAlphaNumeric(r):<span class="cov8" title="1">
                l.backup()
                return lexIdentifierInShortcode</span>
        default:<span class="cov8" title="1">
                return l.errorf("unrecognized character in shortcode action: %#U. Note: Parameters with non-alphanumeric args must be quoted", r)</span>
        }
        <span class="cov8" title="1">return lexInsideShortcode</span>
}

func (l *pageLexer) currentLeftShortcodeDelimItem() ItemType <span class="cov8" title="1">{
        return l.currLeftDelimItem
}</span>

func (l *pageLexer) currentRightShortcodeDelimItem() ItemType <span class="cov8" title="1">{
        return l.currRightDelimItem
}</span>

func (l *pageLexer) currentLeftShortcodeDelim() []byte <span class="cov8" title="1">{
        if l.currLeftDelimItem == tLeftDelimScWithMarkup </span><span class="cov8" title="1">{
                return leftDelimScWithMarkup
        }</span>
        <span class="cov8" title="1">return leftDelimScNoMarkup</span>
}

func (l *pageLexer) currentRightShortcodeDelim() []byte <span class="cov8" title="1">{
        if l.currRightDelimItem == tRightDelimScWithMarkup </span><span class="cov8" title="1">{
                return rightDelimScWithMarkup
        }</span>
        <span class="cov8" title="1">return rightDelimScNoMarkup</span>
}
</pre>
		
		<pre class="file" id="file193" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pageparser

import (
        "bytes"
        "io"
        "io/ioutil"

        "github.com/gohugoio/hugo/parser/metadecoders"
        "github.com/pkg/errors"
)

// Result holds the parse result.
type Result interface {
        // Iterator returns a new Iterator positioned at the beginning of the parse tree.
        Iterator() *Iterator
        // Input returns the input to Parse.
        Input() []byte
}

var _ Result = (*pageLexer)(nil)

// Parse parses the page in the given reader according to the given Config.
// TODO(bep) now that we have improved the "lazy order" init, it *may* be
// some potential saving in doing a buffered approach where the first pass does
// the frontmatter only.
func Parse(r io.Reader, cfg Config) (Result, error) <span class="cov0" title="0">{
        return parseSection(r, cfg, lexIntroSection)
}</span>

type ContentFrontMatter struct {
        Content           []byte
        FrontMatter       map[string]interface{}
        FrontMatterFormat metadecoders.Format
}

// ParseFrontMatterAndContent is a convenience method to extract front matter
// and content from a content page.
func ParseFrontMatterAndContent(r io.Reader) (ContentFrontMatter, error) <span class="cov0" title="0">{
        var cf ContentFrontMatter

        psr, err := Parse(r, Config{})
        if err != nil </span><span class="cov0" title="0">{
                return cf, err
        }</span>

        <span class="cov0" title="0">var frontMatterSource []byte

        iter := psr.Iterator()

        walkFn := func(item Item) bool </span><span class="cov0" title="0">{
                if frontMatterSource != nil </span><span class="cov0" title="0">{
                        // The rest is content.
                        cf.Content = psr.Input()[item.Pos:]
                        // Done
                        return false
                }</span> else<span class="cov0" title="0"> if item.IsFrontMatter() </span><span class="cov0" title="0">{
                        cf.FrontMatterFormat = FormatFromFrontMatterType(item.Type)
                        frontMatterSource = item.Val
                }</span>
                <span class="cov0" title="0">return true</span>
        }

        <span class="cov0" title="0">iter.PeekWalk(walkFn)

        cf.FrontMatter, err = metadecoders.Default.UnmarshalToMap(frontMatterSource, cf.FrontMatterFormat)
        return cf, err</span>
}

func FormatFromFrontMatterType(typ ItemType) metadecoders.Format <span class="cov8" title="1">{
        switch typ </span>{
        case TypeFrontMatterJSON:<span class="cov8" title="1">
                return metadecoders.JSON</span>
        case TypeFrontMatterORG:<span class="cov8" title="1">
                return metadecoders.ORG</span>
        case TypeFrontMatterTOML:<span class="cov8" title="1">
                return metadecoders.TOML</span>
        case TypeFrontMatterYAML:<span class="cov8" title="1">
                return metadecoders.YAML</span>
        default:<span class="cov8" title="1">
                return ""</span>
        }
}

// ParseMain parses starting with the main section. Used in tests.
func ParseMain(r io.Reader, cfg Config) (Result, error) <span class="cov0" title="0">{
        return parseSection(r, cfg, lexMainSection)
}</span>

func parseSection(r io.Reader, cfg Config, start stateFunc) (Result, error) <span class="cov0" title="0">{
        b, err := ioutil.ReadAll(r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to read page content")
        }</span>
        <span class="cov0" title="0">return parseBytes(b, cfg, start)</span>
}

func parseBytes(b []byte, cfg Config, start stateFunc) (Result, error) <span class="cov0" title="0">{
        lexer := newPageLexer(b, start, cfg)
        lexer.run()
        return lexer, nil
}</span>

// An Iterator has methods to iterate a parsed page with support going back
// if needed.
type Iterator struct {
        l       *pageLexer
        lastPos int // position of the last item returned by nextItem
}

// consumes and returns the next item
func (t *Iterator) Next() Item <span class="cov8" title="1">{
        t.lastPos++
        return t.Current()
}</span>

// Input returns the input source.
func (t *Iterator) Input() []byte <span class="cov0" title="0">{
        return t.l.Input()
}</span>

var errIndexOutOfBounds = Item{tError, 0, []byte("no more tokens"), true}

// Current will repeatably return the current item.
func (t *Iterator) Current() Item <span class="cov8" title="1">{
        if t.lastPos &gt;= len(t.l.items) </span><span class="cov0" title="0">{
                return errIndexOutOfBounds
        }</span>
        <span class="cov8" title="1">return t.l.items[t.lastPos]</span>
}

// backs up one token.
func (t *Iterator) Backup() <span class="cov0" title="0">{
        if t.lastPos &lt; 0 </span><span class="cov0" title="0">{
                panic("need to go forward before going back")</span>
        }
        <span class="cov0" title="0">t.lastPos--</span>
}

// check for non-error and non-EOF types coming next
func (t *Iterator) IsValueNext() bool <span class="cov0" title="0">{
        i := t.Peek()
        return i.Type != tError &amp;&amp; i.Type != tEOF
}</span>

// look at, but do not consume, the next item
// repeated, sequential calls will return the same item
func (t *Iterator) Peek() Item <span class="cov0" title="0">{
        return t.l.items[t.lastPos+1]
}</span>

// PeekWalk will feed the next items in the iterator to walkFn
// until it returns false.
func (t *Iterator) PeekWalk(walkFn func(item Item) bool) <span class="cov0" title="0">{
        for i := t.lastPos + 1; i &lt; len(t.l.items); i++ </span><span class="cov0" title="0">{
                item := t.l.items[i]
                if !walkFn(item) </span><span class="cov0" title="0">{
                        break</span>
                }
        }
}

// Consume is a convenience method to consume the next n tokens,
// but back off Errors and EOF.
func (t *Iterator) Consume(cnt int) <span class="cov0" title="0">{
        for i := 0; i &lt; cnt; i++ </span><span class="cov0" title="0">{
                token := t.Next()
                if token.Type == tError || token.Type == tEOF </span><span class="cov0" title="0">{
                        t.Backup()
                        break</span>
                }
        }
}

// LineNumber returns the current line number. Used for logging.
func (t *Iterator) LineNumber() int <span class="cov0" title="0">{
        return bytes.Count(t.l.input[:t.Current().Pos], lf) + 1
}</span>
</pre>
		
		<pre class="file" id="file194" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package publisher

import (
        "bytes"
        "regexp"
        "sort"
        "strings"
        "sync"
        "unicode"
        "unicode/utf8"

        "golang.org/x/net/html"

        "github.com/gohugoio/hugo/helpers"
)

const eof = -1

var (
        htmlJsonFixer = strings.NewReplacer(", ", "\n")
        jsonAttrRe    = regexp.MustCompile(`'?(.*?)'?:.*`)
        classAttrRe   = regexp.MustCompile(`(?i)^class$|transition`)

        skipInnerElementRe = regexp.MustCompile(`(?i)^(pre|textarea|script|style)`)
        skipAllElementRe   = regexp.MustCompile(`(?i)^!DOCTYPE`)
        endTagRe           = regexp.MustCompile(`(?i)&lt;\/\s*([a-zA-Z]+)\s*&gt;$`)

        exceptionList = map[string]bool{
                "thead": true,
                "tbody": true,
                "tfoot": true,
                "td":    true,
                "tr":    true,
        }
)

func newHTMLElementsCollector() *htmlElementsCollector <span class="cov8" title="1">{
        return &amp;htmlElementsCollector{
                elementSet: make(map[string]bool),
        }
}</span>

func newHTMLElementsCollectorWriter(collector *htmlElementsCollector) *htmlElementsCollectorWriter <span class="cov8" title="1">{
        w := &amp;htmlElementsCollectorWriter{
                collector: collector,
                state:     htmlLexStart,
        }

        w.defaultLexElementInside = w.lexElementInside(htmlLexStart)

        return w
}</span>

// HTMLElements holds lists of tags and attribute values for classes and id.
type HTMLElements struct {
        Tags    []string `json:"tags"`
        Classes []string `json:"classes"`
        IDs     []string `json:"ids"`
}

func (h *HTMLElements) Merge(other HTMLElements) <span class="cov0" title="0">{
        h.Tags = append(h.Tags, other.Tags...)
        h.Classes = append(h.Classes, other.Classes...)
        h.IDs = append(h.IDs, other.IDs...)

        h.Tags = helpers.UniqueStringsReuse(h.Tags)
        h.Classes = helpers.UniqueStringsReuse(h.Classes)
        h.IDs = helpers.UniqueStringsReuse(h.IDs)
}</span>

func (h *HTMLElements) Sort() <span class="cov0" title="0">{
        sort.Strings(h.Tags)
        sort.Strings(h.Classes)
        sort.Strings(h.IDs)
}</span>

type htmlElement struct {
        Tag     string
        Classes []string
        IDs     []string
}

type htmlElementsCollector struct {
        // Contains the raw HTML string. We will get the same element
        // several times, and want to avoid costly reparsing when this
        // is used for aggregated data only.
        elementSet map[string]bool

        elements []htmlElement

        mu sync.RWMutex
}

func (c *htmlElementsCollector) getHTMLElements() HTMLElements <span class="cov8" title="1">{
        var (
                classes []string
                ids     []string
                tags    []string
        )

        for _, el := range c.elements </span><span class="cov8" title="1">{
                classes = append(classes, el.Classes...)
                ids = append(ids, el.IDs...)
                tags = append(tags, el.Tag)
        }</span>

        <span class="cov8" title="1">classes = helpers.UniqueStringsSorted(classes)
        ids = helpers.UniqueStringsSorted(ids)
        tags = helpers.UniqueStringsSorted(tags)

        els := HTMLElements{
                Classes: classes,
                IDs:     ids,
                Tags:    tags,
        }

        return els</span>
}

type htmlElementsCollectorWriter struct {
        collector *htmlElementsCollector

        r     rune   // Current rune
        width int    // The width in bytes of r
        input []byte // The current slice written to Write
        pos   int    // The current position in input

        err error

        inQuote rune

        buff bytes.Buffer

        // Current state
        state htmlCollectorStateFunc

        // Precompiled state funcs
        defaultLexElementInside htmlCollectorStateFunc
}

// Write collects HTML elements from p, which must contain complete runes.
func (w *htmlElementsCollectorWriter) Write(p []byte) (int, error) <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">w.input = p

        for </span><span class="cov8" title="1">{
                w.r = w.next()
                if w.r == eof || w.r == utf8.RuneError </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">w.state = w.state(w)</span>
        }

        <span class="cov8" title="1">w.pos = 0
        w.input = nil

        return len(p), nil</span>
}

func (l *htmlElementsCollectorWriter) backup() <span class="cov8" title="1">{
        l.pos -= l.width
        l.r, _ = utf8.DecodeRune(l.input[l.pos:])
}</span>

func (w *htmlElementsCollectorWriter) consumeBuffUntil(condition func() bool, resolve htmlCollectorStateFunc) htmlCollectorStateFunc <span class="cov8" title="1">{
        var s htmlCollectorStateFunc
        s = func(*htmlElementsCollectorWriter) htmlCollectorStateFunc </span><span class="cov8" title="1">{
                w.buff.WriteRune(w.r)
                if condition() </span><span class="cov8" title="1">{
                        w.buff.Reset()
                        return resolve
                }</span>
                <span class="cov8" title="1">return s</span>
        }
        <span class="cov8" title="1">return s</span>
}

func (w *htmlElementsCollectorWriter) consumeRuneUntil(condition func(r rune) bool, resolve htmlCollectorStateFunc) htmlCollectorStateFunc <span class="cov8" title="1">{
        var s htmlCollectorStateFunc
        s = func(*htmlElementsCollectorWriter) htmlCollectorStateFunc </span><span class="cov8" title="1">{
                if condition(w.r) </span><span class="cov8" title="1">{
                        return resolve
                }</span>
                <span class="cov8" title="1">return s</span>
        }
        <span class="cov8" title="1">return s</span>
}

// Starts with e.g. "&lt;body " or "&lt;div"
func (w *htmlElementsCollectorWriter) lexElementInside(resolve htmlCollectorStateFunc) htmlCollectorStateFunc <span class="cov8" title="1">{
        var s htmlCollectorStateFunc
        s = func(w *htmlElementsCollectorWriter) htmlCollectorStateFunc </span><span class="cov8" title="1">{
                w.buff.WriteRune(w.r)

                // Skip any text inside a quote.
                if w.r == '\'' || w.r == '"' </span><span class="cov8" title="1">{
                        if w.inQuote == w.r </span><span class="cov8" title="1">{
                                w.inQuote = 0
                        }</span> else<span class="cov8" title="1"> if w.inQuote == 0 </span><span class="cov8" title="1">{
                                w.inQuote = w.r
                        }</span>
                }

                <span class="cov8" title="1">if w.inQuote != 0 </span><span class="cov8" title="1">{
                        return s
                }</span>

                <span class="cov8" title="1">if w.r == '&gt;' </span><span class="cov8" title="1">{

                        // Work with the bytes slice as long as it's practical,
                        // to save memory allocations.
                        b := w.buff.Bytes()

                        defer func() </span><span class="cov8" title="1">{
                                w.buff.Reset()
                        }</span>()

                        // First check if we have processed this element before.
                        <span class="cov8" title="1">w.collector.mu.RLock()

                        seen := w.collector.elementSet[string(b)]
                        w.collector.mu.RUnlock()
                        if seen </span><span class="cov8" title="1">{
                                return resolve
                        }</span>

                        <span class="cov8" title="1">s := w.buff.String()

                        if s == "" </span><span class="cov0" title="0">{
                                return resolve
                        }</span>

                        // Parse each collected element.
                        <span class="cov8" title="1">el, err := parseHTMLElement(s)
                        if err != nil </span><span class="cov0" title="0">{
                                w.err = err
                                return resolve
                        }</span>

                        // Write this tag to the element set.
                        <span class="cov8" title="1">w.collector.mu.Lock()
                        w.collector.elementSet[s] = true
                        w.collector.elements = append(w.collector.elements, el)
                        w.collector.mu.Unlock()

                        return resolve</span>

                }

                <span class="cov8" title="1">return s</span>
        }

        <span class="cov8" title="1">return s</span>
}

func (l *htmlElementsCollectorWriter) next() rune <span class="cov8" title="1">{
        if l.pos &gt;= len(l.input) </span><span class="cov8" title="1">{
                l.width = 0
                return eof
        }</span>

        <span class="cov8" title="1">runeValue, runeWidth := utf8.DecodeRune(l.input[l.pos:])

        l.width = runeWidth
        l.pos += l.width
        return runeValue</span>
}

// returns the next state in HTML element scanner.
type htmlCollectorStateFunc func(*htmlElementsCollectorWriter) htmlCollectorStateFunc

// At "&lt;", buffer empty.
// Potentially starting a HTML element.
func htmlLexElementStart(w *htmlElementsCollectorWriter) htmlCollectorStateFunc <span class="cov8" title="1">{
        if w.r == '&gt;' || unicode.IsSpace(w.r) </span><span class="cov8" title="1">{
                if w.buff.Len() &lt; 2 || bytes.HasPrefix(w.buff.Bytes(), []byte("&lt;/")) </span><span class="cov8" title="1">{
                        w.buff.Reset()
                        return htmlLexStart
                }</span>

                <span class="cov8" title="1">tagName := w.buff.Bytes()[1:]

                switch </span>{
                case skipInnerElementRe.Match(tagName):<span class="cov8" title="1">
                        // pre, script etc. We collect classes etc. on the surrounding
                        // element, but skip the inner content.
                        w.backup()

                        // tagName will be overwritten, so make a copy.
                        tagNameCopy := make([]byte, len(tagName))
                        copy(tagNameCopy, tagName)

                        return w.lexElementInside(
                                w.consumeBuffUntil(
                                        func() bool </span><span class="cov8" title="1">{
                                                if w.r != '&gt;' </span><span class="cov8" title="1">{
                                                        return false
                                                }</span>
                                                <span class="cov8" title="1">m := endTagRe.FindSubmatch(w.buff.Bytes())
                                                if m == nil </span><span class="cov8" title="1">{
                                                        return false
                                                }</span>
                                                <span class="cov8" title="1">return bytes.EqualFold(m[1], tagNameCopy)</span>
                                        },
                                        htmlLexStart,
                                ))
                case skipAllElementRe.Match(tagName):<span class="cov8" title="1">
                        // E.g. "&lt;!DOCTYPE ..."
                        w.buff.Reset()
                        return w.consumeRuneUntil(func(r rune) bool </span><span class="cov8" title="1">{
                                return r == '&gt;'
                        }</span>, htmlLexStart)
                default:<span class="cov8" title="1">
                        w.backup()
                        return w.defaultLexElementInside</span>
                }
        }

        <span class="cov8" title="1">w.buff.WriteRune(w.r)

        // If it's a comment, skip to its end.
        if w.r == '-' &amp;&amp; bytes.Equal(w.buff.Bytes(), []byte("&lt;!--")) </span><span class="cov8" title="1">{
                w.buff.Reset()
                return htmlLexToEndOfComment
        }</span>

        <span class="cov8" title="1">return htmlLexElementStart</span>
}

// Entry state func.
// Looks for a opening bracket, '&lt;'.
func htmlLexStart(w *htmlElementsCollectorWriter) htmlCollectorStateFunc <span class="cov8" title="1">{
        if w.r == '&lt;' </span><span class="cov8" title="1">{
                w.backup()
                w.buff.Reset()
                return htmlLexElementStart
        }</span>

        <span class="cov8" title="1">return htmlLexStart</span>
}

// After "&lt;!--", buff empty.
func htmlLexToEndOfComment(w *htmlElementsCollectorWriter) htmlCollectorStateFunc <span class="cov8" title="1">{
        w.buff.WriteRune(w.r)

        if w.r == '&gt;' &amp;&amp; bytes.HasSuffix(w.buff.Bytes(), []byte("--&gt;")) </span><span class="cov8" title="1">{
                // Done, start looking for HTML elements again.
                return htmlLexStart
        }</span>

        <span class="cov8" title="1">return htmlLexToEndOfComment</span>
}

func parseHTMLElement(elStr string) (el htmlElement, err error) <span class="cov8" title="1">{

        tagName := parseStartTag(elStr)

        el.Tag = strings.ToLower(tagName)
        tagNameToParse := el.Tag

        // The net/html parser does not handle single table elements as input, e.g. tbody.
        // We only care about the element/class/ids, so just store away the original tag name
        // and pretend it's a &lt;div&gt;.
        if exceptionList[el.Tag] </span><span class="cov8" title="1">{
                elStr = strings.Replace(elStr, tagName, "div", 1)
                tagNameToParse = "div"
        }</span>

        <span class="cov8" title="1">n, err := html.Parse(strings.NewReader(elStr))
        if err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">var walk func(*html.Node)
        walk = func(n *html.Node) </span><span class="cov8" title="1">{
                if n.Type == html.ElementNode &amp;&amp; n.Data == tagNameToParse </span><span class="cov8" title="1">{
                        for _, a := range n.Attr </span><span class="cov8" title="1">{
                                switch </span>{
                                case strings.EqualFold(a.Key, "id"):<span class="cov8" title="1">
                                        // There should be only one, but one never knows...
                                        el.IDs = append(el.IDs, a.Val)</span>
                                default:<span class="cov8" title="1">
                                        if classAttrRe.MatchString(a.Key) </span><span class="cov8" title="1">{
                                                el.Classes = append(el.Classes, strings.Fields(a.Val)...)
                                        }</span> else<span class="cov8" title="1"> {
                                                key := strings.ToLower(a.Key)
                                                val := strings.TrimSpace(a.Val)
                                                if strings.Contains(key, "class") &amp;&amp; strings.HasPrefix(val, "{") </span><span class="cov8" title="1">{
                                                        // This looks like a Vue or AlpineJS class binding.
                                                        val = htmlJsonFixer.Replace(strings.Trim(val, "{}"))
                                                        lines := strings.Split(val, "\n")
                                                        for i, l := range lines </span><span class="cov8" title="1">{
                                                                lines[i] = strings.TrimSpace(l)
                                                        }</span>
                                                        <span class="cov8" title="1">val = strings.Join(lines, "\n")
                                                        val = jsonAttrRe.ReplaceAllString(val, "$1")
                                                        el.Classes = append(el.Classes, strings.Fields(val)...)</span>
                                                }
                                        }
                                }
                        }
                }

                <span class="cov8" title="1">for c := n.FirstChild; c != nil; c = c.NextSibling </span><span class="cov8" title="1">{
                        walk(c)
                }</span>
        }

        <span class="cov8" title="1">walk(n)

        return</span>
}

// Variants of s
//    &lt;body class="b a"&gt;
//    &lt;div&gt;
func parseStartTag(s string) string <span class="cov8" title="1">{
        spaceIndex := strings.IndexFunc(s, func(r rune) bool </span><span class="cov8" title="1">{
                return unicode.IsSpace(r)
        }</span>)

        <span class="cov8" title="1">if spaceIndex == -1 </span><span class="cov8" title="1">{
                return s[1 : len(s)-1]
        }</span>

        <span class="cov8" title="1">return s[1:spaceIndex]</span>
}
</pre>
		
		<pre class="file" id="file195" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package publisher

import (
        "errors"
        "io"
        "net/url"
        "sync/atomic"

        "github.com/gohugoio/hugo/resources"

        "github.com/gohugoio/hugo/media"

        "github.com/gohugoio/hugo/minifiers"

        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/helpers"

        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/transform"
        "github.com/gohugoio/hugo/transform/livereloadinject"
        "github.com/gohugoio/hugo/transform/metainject"
        "github.com/gohugoio/hugo/transform/urlreplacers"
)

// Descriptor describes the needed publishing chain for an item.
type Descriptor struct {
        // The content to publish.
        Src io.Reader

        // The OutputFormat of the this content.
        OutputFormat output.Format

        // Where to publish this content. This is a filesystem-relative path.
        TargetPath string

        // Counter for the end build summary.
        StatCounter *uint64

        // Configuration that trigger pre-processing.
        // LiveReload script will be injected if this is != nil
        LiveReloadBaseURL *url.URL

        // Enable to inject the Hugo generated tag in the header. Is currently only
        // injected on the home page for HTML type of output formats.
        AddHugoGeneratorTag bool

        // If set, will replace all relative URLs with this one.
        AbsURLPath string

        // Enable to minify the output using the OutputFormat defined above to
        // pick the correct minifier configuration.
        Minify bool
}

// DestinationPublisher is the default and currently only publisher in Hugo. This
// publisher prepares and publishes an item to the defined destination, e.g. /public.
type DestinationPublisher struct {
        fs                    afero.Fs
        min                   minifiers.Client
        htmlElementsCollector *htmlElementsCollector
}

// NewDestinationPublisher creates a new DestinationPublisher.
func NewDestinationPublisher(rs *resources.Spec, outputFormats output.Formats, mediaTypes media.Types) (pub DestinationPublisher, err error) <span class="cov0" title="0">{
        fs := rs.BaseFs.PublishFs
        cfg := rs.Cfg
        var classCollector *htmlElementsCollector
        if rs.BuildConfig.WriteStats </span><span class="cov0" title="0">{
                classCollector = newHTMLElementsCollector()
        }</span>
        <span class="cov0" title="0">pub = DestinationPublisher{fs: fs, htmlElementsCollector: classCollector}
        pub.min, err = minifiers.New(mediaTypes, outputFormats, cfg)
        return</span>
}

// Publish applies any relevant transformations and writes the file
// to its destination, e.g. /public.
func (p DestinationPublisher) Publish(d Descriptor) error <span class="cov0" title="0">{
        if d.TargetPath == "" </span><span class="cov0" title="0">{
                return errors.New("Publish: must provide a TargetPath")
        }</span>

        <span class="cov0" title="0">src := d.Src

        transformers := p.createTransformerChain(d)

        if len(transformers) != 0 </span><span class="cov0" title="0">{
                b := bp.GetBuffer()
                defer bp.PutBuffer(b)

                if err := transformers.Apply(b, d.Src); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // This is now what we write to disk.
                <span class="cov0" title="0">src = b</span>
        }

        <span class="cov0" title="0">f, err := helpers.OpenFileForWriting(p.fs, d.TargetPath)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()

        var w io.Writer = f

        if p.htmlElementsCollector != nil &amp;&amp; d.OutputFormat.IsHTML </span><span class="cov0" title="0">{
                w = io.MultiWriter(w, newHTMLElementsCollectorWriter(p.htmlElementsCollector))
        }</span>

        <span class="cov0" title="0">_, err = io.Copy(w, src)
        if err == nil &amp;&amp; d.StatCounter != nil </span><span class="cov0" title="0">{
                atomic.AddUint64(d.StatCounter, uint64(1))
        }</span>

        <span class="cov0" title="0">return err</span>
}

func (p DestinationPublisher) PublishStats() PublishStats <span class="cov0" title="0">{
        if p.htmlElementsCollector == nil </span><span class="cov0" title="0">{
                return PublishStats{}
        }</span>

        <span class="cov0" title="0">return PublishStats{
                HTMLElements: p.htmlElementsCollector.getHTMLElements(),
        }</span>
}

type PublishStats struct {
        HTMLElements HTMLElements `json:"htmlElements"`
}

// Publisher publishes a result file.
type Publisher interface {
        Publish(d Descriptor) error
        PublishStats() PublishStats
}

// XML transformer := transform.New(urlreplacers.NewAbsURLInXMLTransformer(path))
func (p DestinationPublisher) createTransformerChain(f Descriptor) transform.Chain <span class="cov0" title="0">{
        transformers := transform.NewEmpty()

        isHTML := f.OutputFormat.IsHTML

        if f.AbsURLPath != "" </span><span class="cov0" title="0">{
                if isHTML </span><span class="cov0" title="0">{
                        transformers = append(transformers, urlreplacers.NewAbsURLTransformer(f.AbsURLPath))
                }</span> else<span class="cov0" title="0"> {
                        // Assume XML.
                        transformers = append(transformers, urlreplacers.NewAbsURLInXMLTransformer(f.AbsURLPath))
                }</span>
        }

        <span class="cov0" title="0">if isHTML </span><span class="cov0" title="0">{
                if f.LiveReloadBaseURL != nil </span><span class="cov0" title="0">{
                        transformers = append(transformers, livereloadinject.New(*f.LiveReloadBaseURL))
                }</span>

                // This is only injected on the home page.
                <span class="cov0" title="0">if f.AddHugoGeneratorTag </span><span class="cov0" title="0">{
                        transformers = append(transformers, metainject.HugoGenerator)
                }</span>

        }

        <span class="cov0" title="0">if p.min.MinifyOutput </span><span class="cov0" title="0">{
                minifyTransformer := p.min.Transformer(f.OutputFormat.MediaType)
                if minifyTransformer != nil </span><span class="cov0" title="0">{
                        transformers = append(transformers, minifyTransformer)
                }</span>
        }

        <span class="cov0" title="0">return transformers</span>
}
</pre>
		
		<pre class="file" id="file196" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package related holds code to help finding related content.
package related

import (
        "errors"
        "fmt"
        "math"
        "sort"
        "strings"
        "time"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/common/types"
        "github.com/mitchellh/mapstructure"
)

var (
        _        Keyword = (*StringKeyword)(nil)
        zeroDate         = time.Time{}

        // DefaultConfig is the default related config.
        DefaultConfig = Config{
                Threshold: 80,
                Indices: IndexConfigs{
                        IndexConfig{Name: "keywords", Weight: 100},
                        IndexConfig{Name: "date", Weight: 10},
                },
        }
)

/*
Config is the top level configuration element used to configure how to retrieve
related content in Hugo.

An example site config.toml:

        [related]
        threshold = 1
        [[related.indices]]
        name = "keywords"
        weight = 200
        [[related.indices]]
        name  = "tags"
        weight = 100
        [[related.indices]]
        name  = "date"
        weight = 1
        pattern = "2006"
*/
type Config struct {
        // Only include matches &gt;= threshold, a normalized rank between 0 and 100.
        Threshold int

        // To get stable "See also" sections we, by default, exclude newer related pages.
        IncludeNewer bool

        // Will lower case all string values and queries to the indices.
        // May get better results, but at a slight performance cost.
        ToLower bool

        Indices IndexConfigs
}

// Add adds a given index.
func (c *Config) Add(index IndexConfig) <span class="cov0" title="0">{
        if c.ToLower </span><span class="cov0" title="0">{
                index.ToLower = true
        }</span>
        <span class="cov0" title="0">c.Indices = append(c.Indices, index)</span>
}

// IndexConfigs holds a set of index configurations.
type IndexConfigs []IndexConfig

// IndexConfig configures an index.
type IndexConfig struct {
        // The index name. This directly maps to a field or Param name.
        Name string

        // Contextual pattern used to convert the Param value into a string.
        // Currently only used for dates. Can be used to, say, bump posts in the same
        // time frame when searching for related documents.
        // For dates it follows Go's time.Format patterns, i.e.
        // "2006" for YYYY and "200601" for YYYYMM.
        Pattern string

        // This field's weight when doing multi-index searches. Higher is "better".
        Weight int

        // Will lower case all string values in and queries tothis index.
        // May get better accurate results, but at a slight performance cost.
        ToLower bool
}

// Document is the interface an indexable document in Hugo must fulfill.
type Document interface {
        // RelatedKeywords returns a list of keywords for the given index config.
        RelatedKeywords(cfg IndexConfig) ([]Keyword, error)

        // When this document was or will be published.
        PublishDate() time.Time

        // Name is used as an tiebreaker if both Weight and PublishDate are
        // the same.
        Name() string
}

// InvertedIndex holds an inverted index, also sometimes named posting list, which
// lists, for every possible search term, the documents that contain that term.
type InvertedIndex struct {
        cfg   Config
        index map[string]map[Keyword][]Document

        minWeight int
        maxWeight int
}

func (idx *InvertedIndex) getIndexCfg(name string) (IndexConfig, bool) <span class="cov8" title="1">{
        for _, conf := range idx.cfg.Indices </span><span class="cov8" title="1">{
                if conf.Name == name </span><span class="cov8" title="1">{
                        return conf, true
                }</span>
        }

        <span class="cov0" title="0">return IndexConfig{}, false</span>
}

// NewInvertedIndex creates a new InvertedIndex.
// Documents to index must be added in Add.
func NewInvertedIndex(cfg Config) *InvertedIndex <span class="cov8" title="1">{
        idx := &amp;InvertedIndex{index: make(map[string]map[Keyword][]Document), cfg: cfg}
        for _, conf := range cfg.Indices </span><span class="cov8" title="1">{
                idx.index[conf.Name] = make(map[Keyword][]Document)
                if conf.Weight &lt; idx.minWeight </span><span class="cov0" title="0">{
                        // By default, the weight scale starts at 0, but we allow
                        // negative weights.
                        idx.minWeight = conf.Weight
                }</span>
                <span class="cov8" title="1">if conf.Weight &gt; idx.maxWeight </span><span class="cov8" title="1">{
                        idx.maxWeight = conf.Weight
                }</span>
        }
        <span class="cov8" title="1">return idx</span>
}

// Add documents to the inverted index.
// The value must support == and !=.
func (idx *InvertedIndex) Add(docs ...Document) error <span class="cov8" title="1">{
        var err error
        for _, config := range idx.cfg.Indices </span><span class="cov8" title="1">{
                if config.Weight == 0 </span><span class="cov0" title="0">{
                        // Disabled
                        continue</span>
                }
                <span class="cov8" title="1">setm := idx.index[config.Name]

                for _, doc := range docs </span><span class="cov8" title="1">{
                        var words []Keyword
                        words, err = doc.RelatedKeywords(config)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">for _, keyword := range words </span><span class="cov8" title="1">{
                                setm[keyword] = append(setm[keyword], doc)
                        }</span>
                }
        }

        <span class="cov8" title="1">return err</span>
}

// queryElement holds the index name and keywords that can be used to compose a
// search for related content.
type queryElement struct {
        Index    string
        Keywords []Keyword
}

func newQueryElement(index string, keywords ...Keyword) queryElement <span class="cov8" title="1">{
        return queryElement{Index: index, Keywords: keywords}
}</span>

type ranks []*rank

type rank struct {
        Doc     Document
        Weight  int
        Matches int
}

func (r *rank) addWeight(w int) <span class="cov8" title="1">{
        r.Weight += w
        r.Matches++
}</span>

func newRank(doc Document, weight int) *rank <span class="cov8" title="1">{
        return &amp;rank{Doc: doc, Weight: weight, Matches: 1}
}</span>

func (r ranks) Len() int      <span class="cov8" title="1">{ return len(r) }</span>
func (r ranks) Swap(i, j int) <span class="cov8" title="1">{ r[i], r[j] = r[j], r[i] }</span>
func (r ranks) Less(i, j int) bool <span class="cov8" title="1">{
        if r[i].Weight == r[j].Weight </span><span class="cov8" title="1">{
                if r[i].Doc.PublishDate() == r[j].Doc.PublishDate() </span><span class="cov8" title="1">{
                        return r[i].Doc.Name() &lt; r[j].Doc.Name()
                }</span>
                <span class="cov8" title="1">return r[i].Doc.PublishDate().After(r[j].Doc.PublishDate())</span>
        }
        <span class="cov8" title="1">return r[i].Weight &gt; r[j].Weight</span>
}

// SearchDoc finds the documents matching any of the keywords in the given indices
// against the given document.
// The resulting document set will be sorted according to number of matches
// and the index weights, and any matches with a rank below the configured
// threshold (normalize to 0..100) will be removed.
// If an index name is provided, only that index will be queried.
func (idx *InvertedIndex) SearchDoc(doc Document, indices ...string) ([]Document, error) <span class="cov8" title="1">{
        var q []queryElement

        var configs IndexConfigs

        if len(indices) == 0 </span><span class="cov8" title="1">{
                configs = idx.cfg.Indices
        }</span> else<span class="cov8" title="1"> {
                configs = make(IndexConfigs, len(indices))
                for i, indexName := range indices </span><span class="cov8" title="1">{
                        cfg, found := idx.getIndexCfg(indexName)
                        if !found </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("index %q not found", indexName)
                        }</span>
                        <span class="cov8" title="1">configs[i] = cfg</span>
                }
        }

        <span class="cov8" title="1">for _, cfg := range configs </span><span class="cov8" title="1">{
                keywords, err := doc.RelatedKeywords(cfg)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">q = append(q, newQueryElement(cfg.Name, keywords...))</span>

        }

        <span class="cov8" title="1">return idx.searchDate(doc.PublishDate(), q...)</span>
}

// ToKeywords returns a Keyword slice of the given input.
func (cfg IndexConfig) ToKeywords(v interface{}) ([]Keyword, error) <span class="cov8" title="1">{
        var (
                keywords []Keyword
                toLower  = cfg.ToLower
        )
        switch vv := v.(type) </span>{
        case string:<span class="cov0" title="0">
                if toLower </span><span class="cov0" title="0">{
                        vv = strings.ToLower(vv)
                }</span>
                <span class="cov0" title="0">keywords = append(keywords, StringKeyword(vv))</span>
        case []string:<span class="cov8" title="1">
                if toLower </span><span class="cov8" title="1">{
                        vc := make([]string, len(vv))
                        copy(vc, vv)
                        for i := 0; i &lt; len(vc); i++ </span><span class="cov8" title="1">{
                                vc[i] = strings.ToLower(vc[i])
                        }</span>
                        <span class="cov8" title="1">vv = vc</span>
                }
                <span class="cov8" title="1">keywords = append(keywords, StringsToKeywords(vv...)...)</span>
        case time.Time:<span class="cov0" title="0">
                layout := "2006"
                if cfg.Pattern != "" </span><span class="cov0" title="0">{
                        layout = cfg.Pattern
                }</span>
                <span class="cov0" title="0">keywords = append(keywords, StringKeyword(vv.Format(layout)))</span>
        case nil:<span class="cov0" title="0">
                return keywords, nil</span>
        default:<span class="cov0" title="0">
                return keywords, fmt.Errorf("indexing currently not supported for index %q and type %T", cfg.Name, vv)</span>
        }

        <span class="cov8" title="1">return keywords, nil</span>
}

// SearchKeyValues finds the documents matching any of the keywords in the given indices.
// The resulting document set will be sorted according to number of matches
// and the index weights, and any matches with a rank below the configured
// threshold (normalize to 0..100) will be removed.
func (idx *InvertedIndex) SearchKeyValues(args ...types.KeyValues) ([]Document, error) <span class="cov0" title="0">{
        q := make([]queryElement, len(args))

        for i, arg := range args </span><span class="cov0" title="0">{
                var keywords []Keyword
                key := arg.KeyString()
                if key == "" </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("index %q not valid", arg.Key)
                }</span>
                <span class="cov0" title="0">conf, found := idx.getIndexCfg(key)
                if !found </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("index %q not found", key)
                }</span>

                <span class="cov0" title="0">for _, val := range arg.Values </span><span class="cov0" title="0">{
                        k, err := conf.ToKeywords(val)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov0" title="0">keywords = append(keywords, k...)</span>
                }

                <span class="cov0" title="0">q[i] = newQueryElement(conf.Name, keywords...)</span>

        }

        <span class="cov0" title="0">return idx.search(q...)</span>
}

func (idx *InvertedIndex) search(query ...queryElement) ([]Document, error) <span class="cov8" title="1">{
        return idx.searchDate(zeroDate, query...)
}</span>

func (idx *InvertedIndex) searchDate(upperDate time.Time, query ...queryElement) ([]Document, error) <span class="cov8" title="1">{
        matchm := make(map[Document]*rank, 200)
        applyDateFilter := !idx.cfg.IncludeNewer &amp;&amp; !upperDate.IsZero()

        for _, el := range query </span><span class="cov8" title="1">{
                setm, found := idx.index[el.Index]
                if !found </span><span class="cov0" title="0">{
                        return []Document{}, fmt.Errorf("index for %q not found", el.Index)
                }</span>

                <span class="cov8" title="1">config, found := idx.getIndexCfg(el.Index)
                if !found </span><span class="cov0" title="0">{
                        return []Document{}, fmt.Errorf("index config for %q not found", el.Index)
                }</span>

                <span class="cov8" title="1">for _, kw := range el.Keywords </span><span class="cov8" title="1">{
                        if docs, found := setm[kw]; found </span><span class="cov8" title="1">{
                                for _, doc := range docs </span><span class="cov8" title="1">{
                                        if applyDateFilter </span><span class="cov8" title="1">{
                                                // Exclude newer than the limit given
                                                if doc.PublishDate().After(upperDate) </span><span class="cov8" title="1">{
                                                        continue</span>
                                                }
                                        }
                                        <span class="cov8" title="1">r, found := matchm[doc]
                                        if !found </span><span class="cov8" title="1">{
                                                matchm[doc] = newRank(doc, config.Weight)
                                        }</span> else<span class="cov8" title="1"> {
                                                r.addWeight(config.Weight)
                                        }</span>
                                }
                        }
                }
        }

        <span class="cov8" title="1">if len(matchm) == 0 </span><span class="cov0" title="0">{
                return []Document{}, nil
        }</span>

        <span class="cov8" title="1">matches := make(ranks, 0, 100)

        for _, v := range matchm </span><span class="cov8" title="1">{
                avgWeight := v.Weight / v.Matches
                weight := norm(avgWeight, idx.minWeight, idx.maxWeight)
                threshold := idx.cfg.Threshold / v.Matches

                if weight &gt;= threshold </span><span class="cov8" title="1">{
                        matches = append(matches, v)
                }</span>
        }

        <span class="cov8" title="1">sort.Stable(matches)

        result := make([]Document, len(matches))

        for i, m := range matches </span><span class="cov8" title="1">{
                result[i] = m.Doc
        }</span>

        <span class="cov8" title="1">return result, nil</span>
}

// normalizes num to a number between 0 and 100.
func norm(num, min, max int) int <span class="cov8" title="1">{
        if min &gt; max </span><span class="cov0" title="0">{
                panic("min &gt; max")</span>
        }
        <span class="cov8" title="1">return int(math.Floor((float64(num-min) / float64(max-min) * 100) + 0.5))</span>
}

// DecodeConfig decodes a slice of map into Config.
func DecodeConfig(m maps.Params) (Config, error) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return Config{}, errors.New("no related config provided")
        }</span>

        <span class="cov0" title="0">if len(m) == 0 </span><span class="cov0" title="0">{
                return Config{}, errors.New("empty related config provided")
        }</span>

        <span class="cov0" title="0">var c Config

        if err := mapstructure.WeakDecode(m, &amp;c); err != nil </span><span class="cov0" title="0">{
                return c, err
        }</span>

        <span class="cov0" title="0">if c.Threshold &lt; 0 || c.Threshold &gt; 100 </span><span class="cov0" title="0">{
                return Config{}, errors.New("related threshold must be between 0 and 100")
        }</span>

        <span class="cov0" title="0">if c.ToLower </span><span class="cov0" title="0">{
                for i := range c.Indices </span><span class="cov0" title="0">{
                        c.Indices[i].ToLower = true
                }</span>
        }

        <span class="cov0" title="0">return c, nil</span>
}

// StringKeyword is a string search keyword.
type StringKeyword string

func (s StringKeyword) String() string <span class="cov0" title="0">{
        return string(s)
}</span>

// Keyword is the interface a keyword in the search index must implement.
type Keyword interface {
        String() string
}

// StringsToKeywords converts the given slice of strings to a slice of Keyword.
func StringsToKeywords(s ...string) []Keyword <span class="cov8" title="1">{
        kw := make([]Keyword, len(s))

        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                kw[i] = StringKeyword(s[i])
        }</span>

        <span class="cov8" title="1">return kw</span>
}
</pre>
		
		<pre class="file" id="file197" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package releaser

import (
        "fmt"
        "regexp"
        "sort"
        "strconv"
        "strings"

        "github.com/gohugoio/hugo/common/hexec"
)

var issueRe = regexp.MustCompile(`(?i)(?:Updates?|Closes?|Fix.*|See) #(\d+)`)

type changeLog struct {
        Version string
        Notes   gitInfos
        All     gitInfos
        Docs    gitInfos

        // Overall stats
        Repo             *gitHubRepo
        ContributorCount int
        ThemeCount       int
}

func newChangeLog(infos, docInfos gitInfos) *changeLog <span class="cov0" title="0">{
        log := &amp;changeLog{
                Docs: docInfos,
        }

        for _, info := range infos </span><span class="cov0" title="0">{
                // TODO(bep) improve
                if regexp.MustCompile("(?i)deprecate|note").MatchString(info.Subject) </span><span class="cov0" title="0">{
                        log.Notes = append(log.Notes, info)
                }</span>

                <span class="cov0" title="0">log.All = append(log.All, info)
                info.Subject = strings.TrimSpace(info.Subject)</span>

        }

        <span class="cov0" title="0">return log</span>
}

type gitInfo struct {
        Hash    string
        Author  string
        Subject string
        Body    string

        GitHubCommit *gitHubCommit
}

func (g gitInfo) Issues() []int <span class="cov0" title="0">{
        return extractIssues(g.Body)
}</span>

func (g gitInfo) AuthorID() string <span class="cov0" title="0">{
        if g.GitHubCommit != nil </span><span class="cov0" title="0">{
                return g.GitHubCommit.Author.Login
        }</span>
        <span class="cov0" title="0">return g.Author</span>
}

func extractIssues(body string) []int <span class="cov8" title="1">{
        var i []int
        m := issueRe.FindAllStringSubmatch(body, -1)
        for _, mm := range m </span><span class="cov8" title="1">{
                issueID, err := strconv.Atoi(mm[1])
                if err != nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">i = append(i, issueID)</span>
        }
        <span class="cov8" title="1">return i</span>
}

type gitInfos []gitInfo

func git(args ...string) (string, error) <span class="cov8" title="1">{
        cmd, _ := hexec.SafeCommand("git", args...)
        out, err := cmd.CombinedOutput()
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("git failed: %q: %q (%q)", err, out, args)
        }</span>
        <span class="cov8" title="1">return string(out), nil</span>
}

func getGitInfos(tag, repo, repoPath string, remote bool) (gitInfos, error) <span class="cov8" title="1">{
        return getGitInfosBefore("HEAD", tag, repo, repoPath, remote)
}</span>

type countribCount struct {
        Author       string
        GitHubAuthor gitHubAuthor
        Count        int
}

func (c countribCount) AuthorLink() string <span class="cov0" title="0">{
        if c.GitHubAuthor.HTMLURL != "" </span><span class="cov0" title="0">{
                return fmt.Sprintf("[@%s](%s)", c.GitHubAuthor.Login, c.GitHubAuthor.HTMLURL)
        }</span>

        <span class="cov0" title="0">if !strings.Contains(c.Author, "@") </span><span class="cov0" title="0">{
                return c.Author
        }</span>

        <span class="cov0" title="0">return c.Author[:strings.Index(c.Author, "@")]</span>
}

type contribCounts []countribCount

func (c contribCounts) Less(i, j int) bool <span class="cov0" title="0">{ return c[i].Count &gt; c[j].Count }</span>
func (c contribCounts) Len() int           <span class="cov0" title="0">{ return len(c) }</span>
func (c contribCounts) Swap(i, j int)      <span class="cov0" title="0">{ c[i], c[j] = c[j], c[i] }</span>

func (g gitInfos) ContribCountPerAuthor() contribCounts <span class="cov0" title="0">{
        var c contribCounts

        counters := make(map[string]countribCount)

        for _, gi := range g </span><span class="cov0" title="0">{
                authorID := gi.AuthorID()
                if count, ok := counters[authorID]; ok </span><span class="cov0" title="0">{
                        count.Count = count.Count + 1
                        counters[authorID] = count
                }</span> else<span class="cov0" title="0"> {
                        var ghA gitHubAuthor
                        if gi.GitHubCommit != nil </span><span class="cov0" title="0">{
                                ghA = gi.GitHubCommit.Author
                        }</span>
                        <span class="cov0" title="0">authorCount := countribCount{Count: 1, Author: gi.Author, GitHubAuthor: ghA}
                        counters[authorID] = authorCount</span>
                }
        }

        <span class="cov0" title="0">for _, v := range counters </span><span class="cov0" title="0">{
                c = append(c, v)
        }</span>

        <span class="cov0" title="0">sort.Sort(c)
        return c</span>
}

func getGitInfosBefore(ref, tag, repo, repoPath string, remote bool) (gitInfos, error) <span class="cov8" title="1">{
        client := newGitHubAPI(repo)
        var g gitInfos

        log, err := gitLogBefore(ref, tag, repoPath)
        if err != nil </span><span class="cov0" title="0">{
                return g, err
        }</span>

        <span class="cov8" title="1">log = strings.Trim(log, "\n\x1e'")
        entries := strings.Split(log, "\x1e")

        for _, entry := range entries </span><span class="cov8" title="1">{
                items := strings.Split(entry, "\x1f")
                gi := gitInfo{}

                if len(items) &gt; 0 </span><span class="cov8" title="1">{
                        gi.Hash = items[0]
                }</span>
                <span class="cov8" title="1">if len(items) &gt; 1 </span><span class="cov8" title="1">{
                        gi.Author = items[1]
                }</span>
                <span class="cov8" title="1">if len(items) &gt; 2 </span><span class="cov8" title="1">{
                        gi.Subject = items[2]
                }</span>
                <span class="cov8" title="1">if len(items) &gt; 3 </span><span class="cov8" title="1">{
                        gi.Body = items[3]
                }</span>

                <span class="cov8" title="1">if remote &amp;&amp; gi.Hash != "" </span><span class="cov0" title="0">{
                        gc, err := client.fetchCommit(gi.Hash)
                        if err == nil </span><span class="cov0" title="0">{
                                gi.GitHubCommit = &amp;gc
                        }</span>
                }
                <span class="cov8" title="1">g = append(g, gi)</span>
        }

        <span class="cov8" title="1">return g, nil</span>
}

// Ignore autogenerated commits etc. in change log. This is a regexp.
const ignoredCommits = "snapcraft:|Merge commit|Squashed"

func gitLogBefore(ref, tag, repoPath string) (string, error) <span class="cov8" title="1">{
        var prevTag string
        var err error
        if tag != "" </span><span class="cov8" title="1">{
                prevTag = tag
        }</span> else<span class="cov0" title="0"> {
                prevTag, err = gitVersionTagBefore(ref)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov8" title="1">defaultArgs := []string{"log", "-E", fmt.Sprintf("--grep=%s", ignoredCommits), "--invert-grep", "--pretty=format:%x1e%h%x1f%aE%x1f%s%x1f%b", "--abbrev-commit", prevTag + ".." + ref}

        var args []string

        if repoPath != "" </span><span class="cov0" title="0">{
                args = append([]string{"-C", repoPath}, defaultArgs...)
        }</span> else<span class="cov8" title="1"> {
                args = defaultArgs
        }</span>

        <span class="cov8" title="1">log, err := git(args...)
        if err != nil </span><span class="cov0" title="0">{
                return ",", err
        }</span>

        <span class="cov8" title="1">return log, err</span>
}

func gitVersionTagBefore(ref string) (string, error) <span class="cov8" title="1">{
        return gitShort("describe", "--tags", "--abbrev=0", "--always", "--match", "v[0-9]*", ref+"^")
}</span>

func gitShort(args ...string) (output string, err error) <span class="cov8" title="1">{
        output, err = git(args...)
        return strings.Replace(strings.Split(output, "\n")[0], "'", "", -1), err
}</span>

func tagExists(tag string) (bool, error) <span class="cov8" title="1">{
        out, err := git("tag", "-l", tag)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">if strings.Contains(out, tag) </span><span class="cov8" title="1">{
                return true, nil
        }</span>

        <span class="cov8" title="1">return false, nil</span>
}
</pre>
		
		<pre class="file" id="file198" style="display: none">package releaser

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "net/http"
        "os"
        "strings"
)

var (
        gitHubCommitsAPI      = "https://api.github.com/repos/gohugoio/REPO/commits/%s"
        gitHubRepoAPI         = "https://api.github.com/repos/gohugoio/REPO"
        gitHubContributorsAPI = "https://api.github.com/repos/gohugoio/REPO/contributors"
)

type gitHubAPI struct {
        commitsAPITemplate      string
        repoAPI                 string
        contributorsAPITemplate string
}

func newGitHubAPI(repo string) *gitHubAPI <span class="cov8" title="1">{
        return &amp;gitHubAPI{
                commitsAPITemplate:      strings.Replace(gitHubCommitsAPI, "REPO", repo, -1),
                repoAPI:                 strings.Replace(gitHubRepoAPI, "REPO", repo, -1),
                contributorsAPITemplate: strings.Replace(gitHubContributorsAPI, "REPO", repo, -1),
        }
}</span>

type gitHubCommit struct {
        Author  gitHubAuthor `json:"author"`
        HTMLURL string       `json:"html_url"`
}

type gitHubAuthor struct {
        ID        int    `json:"id"`
        Login     string `json:"login"`
        HTMLURL   string `json:"html_url"`
        AvatarURL string `json:"avatar_url"`
}

type gitHubRepo struct {
        ID           int    `json:"id"`
        Name         string `json:"name"`
        Description  string `json:"description"`
        HTMLURL      string `json:"html_url"`
        Stars        int    `json:"stargazers_count"`
        Contributors []gitHubContributor
}

type gitHubContributor struct {
        ID            int    `json:"id"`
        Login         string `json:"login"`
        HTMLURL       string `json:"html_url"`
        Contributions int    `json:"contributions"`
}

func (g *gitHubAPI) fetchCommit(ref string) (gitHubCommit, error) <span class="cov0" title="0">{
        var commit gitHubCommit

        u := fmt.Sprintf(g.commitsAPITemplate, ref)

        req, err := http.NewRequest("GET", u, nil)
        if err != nil </span><span class="cov0" title="0">{
                return commit, err
        }</span>

        <span class="cov0" title="0">err = doGitHubRequest(req, &amp;commit)

        return commit, err</span>
}

func (g *gitHubAPI) fetchRepo() (gitHubRepo, error) <span class="cov0" title="0">{
        var repo gitHubRepo

        req, err := http.NewRequest("GET", g.repoAPI, nil)
        if err != nil </span><span class="cov0" title="0">{
                return repo, err
        }</span>

        <span class="cov0" title="0">err = doGitHubRequest(req, &amp;repo)
        if err != nil </span><span class="cov0" title="0">{
                return repo, err
        }</span>

        <span class="cov0" title="0">var contributors []gitHubContributor
        page := 0
        for </span><span class="cov0" title="0">{
                page++
                var currPage []gitHubContributor
                url := fmt.Sprintf(g.contributorsAPITemplate+"?page=%d", page)

                req, err = http.NewRequest("GET", url, nil)
                if err != nil </span><span class="cov0" title="0">{
                        return repo, err
                }</span>

                <span class="cov0" title="0">err = doGitHubRequest(req, &amp;currPage)
                if err != nil </span><span class="cov0" title="0">{
                        return repo, err
                }</span>
                <span class="cov0" title="0">if len(currPage) == 0 </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov0" title="0">contributors = append(contributors, currPage...)</span>

        }

        <span class="cov0" title="0">repo.Contributors = contributors

        return repo, err</span>
}

func doGitHubRequest(req *http.Request, v interface{}) error <span class="cov0" title="0">{
        addGitHubToken(req)

        resp, err := http.DefaultClient.Do(req)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        if isError(resp) </span><span class="cov0" title="0">{
                b, _ := ioutil.ReadAll(resp.Body)
                return fmt.Errorf("GitHub lookup failed: %s", string(b))
        }</span>

        <span class="cov0" title="0">return json.NewDecoder(resp.Body).Decode(v)</span>
}

func isError(resp *http.Response) bool <span class="cov0" title="0">{
        return resp.StatusCode &lt; 200 || resp.StatusCode &gt; 299
}</span>

func addGitHubToken(req *http.Request) <span class="cov0" title="0">{
        gitHubToken := os.Getenv("GITHUB_TOKEN")
        if gitHubToken != "" </span><span class="cov0" title="0">{
                req.Header.Add("Authorization", "token "+gitHubToken)
        }</span>
}
</pre>
		
		<pre class="file" id="file199" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package releaser implements a set of utilities and a wrapper around Goreleaser
// to help automate the Hugo release process.
package releaser

import (
        "bytes"
        "fmt"
        "io"
        "io/ioutil"
        "net/http"
        "os"
        "path/filepath"
        "strings"
        "text/template"
)

const (
        issueLinkTemplate                        = "#%d"
        linkTemplate                             = "[%s](%s)"
        releaseNotesMarkdownTemplatePatchRelease = `
{{ if eq (len .All) 1 }}
This is a bug-fix release with one important fix.
{{ else }}
This is a bug-fix release with a couple of important fixes.
{{ end }}
{{ range .All }}
{{- if .GitHubCommit -}}
* {{ .Subject }} {{ .Hash }} {{ . | authorURL }} {{ range .Issues }}{{ . | issue }} {{ end }}
{{ else -}}
* {{ .Subject }} {{ range .Issues }}{{ . | issue }} {{ end }}
{{ end -}}
{{- end }}


`
        releaseNotesMarkdownTemplate = `
{{- $contribsPerAuthor := .All.ContribCountPerAuthor -}}
{{- $docsContribsPerAuthor := .Docs.ContribCountPerAuthor -}}

This release represents **{{ len .All }} contributions by {{ len $contribsPerAuthor }} contributors** to the main Hugo code base.

{{- if  gt (len $contribsPerAuthor) 3 -}}
{{- $u1 := index $contribsPerAuthor 0 -}}
{{- $u2 := index $contribsPerAuthor 1 -}}
{{- $u3 := index $contribsPerAuthor 2 -}}
{{- $u4 := index $contribsPerAuthor 3 -}}
{{- $u1.AuthorLink }} leads the Hugo development with a significant amount of contributions, but also a big shoutout to {{ $u2.AuthorLink }}, {{ $u3.AuthorLink }}, and {{ $u4.AuthorLink }} for their ongoing contributions.
And thanks to [@digitalcraftsman](https://github.com/digitalcraftsman) for his ongoing work on keeping the themes site in pristine condition.
{{ end }}
Many have also been busy writing and fixing the documentation in [hugoDocs](https://github.com/gohugoio/hugoDocs),
which has received **{{ len .Docs }} contributions by {{ len $docsContribsPerAuthor }} contributors**.
{{- if  gt (len $docsContribsPerAuthor) 3 -}}
{{- $u1 := index $docsContribsPerAuthor 0 -}}
{{- $u2 := index $docsContribsPerAuthor 1 -}}
{{- $u3 := index $docsContribsPerAuthor 2 -}}
{{- $u4 := index $docsContribsPerAuthor 3 }} A special thanks to {{ $u1.AuthorLink }}, {{ $u2.AuthorLink }}, {{ $u3.AuthorLink }}, and {{ $u4.AuthorLink }} for their work on the documentation site.
{{ end }}

Hugo now has:

{{ with .Repo -}}
* {{ .Stars }}+ [stars](https://github.com/gohugoio/hugo/stargazers)
* {{ len .Contributors }}+ [contributors](https://github.com/gohugoio/hugo/graphs/contributors)
{{- end -}}
{{ with .ThemeCount }}
* {{ . }}+ [themes](http://themes.gohugo.io/)
{{ end }}
{{ with .Notes }}
## Notes
{{ template "change-section" . }}
{{- end -}}
{{ with .All }}
## Changes
{{ template "change-section" . }}
{{ end }}

{{ define "change-section" }}
{{ range . }}
{{- if .GitHubCommit -}}
* {{ .Subject }} {{ .Hash }} {{ . | authorURL }} {{ range .Issues }}{{ . | issue }} {{ end }}
{{ else -}}
* {{ .Subject }} {{ range .Issues }}{{ . | issue }} {{ end }}
{{ end -}}
{{- end }}
{{ end }}
`
)

var templateFuncs = template.FuncMap{
        "isPatch": func(c changeLog) bool <span class="cov0" title="0">{
                return !strings.HasSuffix(c.Version, "0")
        }</span>,
        "issue": func(id int) string <span class="cov0" title="0">{
                return fmt.Sprintf(issueLinkTemplate, id)
        }</span>,
        "commitURL": func(info gitInfo) string <span class="cov0" title="0">{
                if info.GitHubCommit.HTMLURL == "" </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf(linkTemplate, info.Hash, info.GitHubCommit.HTMLURL)</span>
        },
        "authorURL": func(info gitInfo) string <span class="cov0" title="0">{
                if info.GitHubCommit.Author.Login == "" </span><span class="cov0" title="0">{
                        return ""
                }</span>
                <span class="cov0" title="0">return fmt.Sprintf(linkTemplate, "@"+info.GitHubCommit.Author.Login, info.GitHubCommit.Author.HTMLURL)</span>
        },
}

func writeReleaseNotes(version string, infosMain, infosDocs gitInfos, to io.Writer) error <span class="cov0" title="0">{
        client := newGitHubAPI("hugo")
        changes := newChangeLog(infosMain, infosDocs)
        changes.Version = version
        repo, err := client.fetchRepo()
        if err == nil </span><span class="cov0" title="0">{
                changes.Repo = &amp;repo
        }</span>
        <span class="cov0" title="0">themeCount, err := fetchThemeCount()
        if err == nil </span><span class="cov0" title="0">{
                changes.ThemeCount = themeCount
        }</span>

        <span class="cov0" title="0">mtempl := releaseNotesMarkdownTemplate

        if !strings.HasSuffix(version, "0") </span><span class="cov0" title="0">{
                mtempl = releaseNotesMarkdownTemplatePatchRelease
        }</span>

        <span class="cov0" title="0">tmpl, err := template.New("").Funcs(templateFuncs).Parse(mtempl)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err = tmpl.Execute(to, changes)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func fetchThemeCount() (int, error) <span class="cov0" title="0">{
        resp, err := http.Get("https://raw.githubusercontent.com/gohugoio/hugoThemesSiteBuilder/main/themes.txt")
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov0" title="0">defer resp.Body.Close()

        b, _ := ioutil.ReadAll(resp.Body)
        return bytes.Count(b, []byte("\n")) - bytes.Count(b, []byte("#")), nil</span>
}

func getReleaseNotesFilename(version string) string <span class="cov0" title="0">{
        return filepath.FromSlash(fmt.Sprintf("temp/%s-relnotes-ready.md", version))

}</span>

func (r *ReleaseHandler) writeReleaseNotesToTemp(version string, isPatch bool, infosMain, infosDocs gitInfos) (string, error) <span class="cov0" title="0">{
        filename := getReleaseNotesFilename(version)

        var w io.WriteCloser

        if !r.try </span><span class="cov0" title="0">{
                f, err := os.Create(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov0" title="0">defer f.Close()

                w = f</span>

        } else<span class="cov0" title="0"> {
                w = os.Stdout
        }</span>

        <span class="cov0" title="0">if err := writeReleaseNotes(version, infosMain, infosDocs, w); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return filename, nil</span>
}
</pre>
		
		<pre class="file" id="file200" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package releaser implements a set of utilities and a wrapper around Goreleaser
// to help automate the Hugo release process.
package releaser

import (
        "fmt"
        "io/ioutil"
        "log"
        "os"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/gohugoio/hugo/common/hexec"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/pkg/errors"
)

const commitPrefix = "releaser:"

// ReleaseHandler provides functionality to release a new version of Hugo.
// Test this locally without doing an actual release:
// go run -tags release main.go release --skip-publish --try -r 0.90.0
// Or a variation of the above -- the skip-publish flag makes sure that any changes are performed to the local Git only.
type ReleaseHandler struct {
        cliVersion string

        skipPublish bool

        // Just simulate, no actual changes.
        try bool

        git func(args ...string) (string, error)
}

func (r ReleaseHandler) calculateVersions() (hugo.Version, hugo.Version) <span class="cov0" title="0">{
        newVersion := hugo.MustParseVersion(r.cliVersion)
        finalVersion := newVersion.Next()
        finalVersion.PatchLevel = 0

        if newVersion.Suffix != "-test" </span><span class="cov0" title="0">{
                newVersion.Suffix = ""
        }</span>

        <span class="cov0" title="0">finalVersion.Suffix = "-DEV"

        return newVersion, finalVersion</span>
}

// New initialises a ReleaseHandler.
func New(version string, skipPublish, try bool) *ReleaseHandler <span class="cov0" title="0">{
        // When triggered from CI release branch
        version = strings.TrimPrefix(version, "release-")
        version = strings.TrimPrefix(version, "v")
        rh := &amp;ReleaseHandler{cliVersion: version, skipPublish: skipPublish, try: try}

        if try </span><span class="cov0" title="0">{
                rh.git = func(args ...string) (string, error) </span><span class="cov0" title="0">{
                        fmt.Println("git", strings.Join(args, " "))
                        return "", nil
                }</span>
        } else<span class="cov0" title="0"> {
                rh.git = git
        }</span>

        <span class="cov0" title="0">return rh</span>
}

// Run creates a new release.
func (r *ReleaseHandler) Run() error <span class="cov0" title="0">{
        if os.Getenv("GITHUB_TOKEN") == "" </span><span class="cov0" title="0">{
                return errors.New("GITHUB_TOKEN not set, create one here with the repo scope selected: https://github.com/settings/tokens/new")
        }</span>

        <span class="cov0" title="0">fmt.Printf("Start release from %q\n", wd())

        newVersion, finalVersion := r.calculateVersions()

        version := newVersion.String()
        tag := "v" + version
        isPatch := newVersion.PatchLevel &gt; 0
        mainVersion := newVersion
        mainVersion.PatchLevel = 0

        // Exit early if tag already exists
        exists, err := tagExists(tag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if exists </span><span class="cov0" title="0">{
                return fmt.Errorf("tag %q already exists", tag)
        }</span>

        <span class="cov0" title="0">var changeLogFromTag string

        if newVersion.PatchLevel == 0 </span><span class="cov0" title="0">{
                // There may have been patch releases between, so set the tag explicitly.
                changeLogFromTag = "v" + newVersion.Prev().String()
                exists, _ := tagExists(changeLogFromTag)
                if !exists </span><span class="cov0" title="0">{
                        // fall back to one that exists.
                        changeLogFromTag = ""
                }</span>
        }

        <span class="cov0" title="0">var (
                gitCommits     gitInfos
                gitCommitsDocs gitInfos
        )

        defer r.gitPush() // TODO(bep)

        gitCommits, err = getGitInfos(changeLogFromTag, "hugo", "", !r.try)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // TODO(bep) explicit tag?
        <span class="cov0" title="0">gitCommitsDocs, err = getGitInfos("", "hugoDocs", "../hugoDocs", !r.try)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">releaseNotesFile, err := r.writeReleaseNotesToTemp(version, isPatch, gitCommits, gitCommitsDocs)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := r.git("add", releaseNotesFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">commitMsg := fmt.Sprintf("%s Add release notes for %s", commitPrefix, newVersion)
        commitMsg += "\n[ci skip]"

        if _, err := r.git("commit", "-m", commitMsg); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := r.bumpVersions(newVersion); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := r.git("commit", "-a", "-m", fmt.Sprintf("%s Bump versions for release of %s\n\n[ci skip]", commitPrefix, newVersion)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if _, err := r.git("tag", "-a", tag, "-m", fmt.Sprintf("%s %s\n\n[ci skip]", commitPrefix, newVersion)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !r.skipPublish </span><span class="cov0" title="0">{
                if _, err := r.git("push", "origin", tag); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if err := r.release(releaseNotesFile); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := r.bumpVersions(finalVersion); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if !r.try </span><span class="cov0" title="0">{
                // No longer needed.
                if err := os.Remove(releaseNotesFile); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">if _, err := r.git("commit", "-a", "-m", fmt.Sprintf("%s Prepare repository for %s\n\n[ci skip]", commitPrefix, finalVersion)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ReleaseHandler) gitPush() <span class="cov0" title="0">{
        if r.skipPublish </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">if _, err := r.git("push", "origin", "HEAD"); err != nil </span><span class="cov0" title="0">{
                log.Fatal("push failed:", err)
        }</span>
}

func (r *ReleaseHandler) release(releaseNotesFile string) error <span class="cov0" title="0">{
        if r.try </span><span class="cov0" title="0">{
                fmt.Println("Skip goreleaser...")
                return nil
        }</span>

        <span class="cov0" title="0">args := []string{"--parallelism", "3", "--timeout", "120m", "--rm-dist", "--release-notes", releaseNotesFile}
        if r.skipPublish </span><span class="cov0" title="0">{
                args = append(args, "--skip-publish")
        }</span>

        <span class="cov0" title="0">cmd, _ := hexec.SafeCommand("goreleaser", args...)
        cmd.Stdout = os.Stdout
        cmd.Stderr = os.Stderr
        err := cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "goreleaser failed")
        }</span>
        <span class="cov0" title="0">return nil</span>
}

func (r *ReleaseHandler) bumpVersions(ver hugo.Version) error <span class="cov0" title="0">{
        toDev := ""

        if ver.Suffix != "" </span><span class="cov0" title="0">{
                toDev = ver.Suffix
        }</span>

        <span class="cov0" title="0">if err := r.replaceInFile("common/hugo/version_current.go",
                `Number:(\s{4,})(.*),`, fmt.Sprintf(`Number:${1}%.2f,`, ver.Number),
                `PatchLevel:(\s*)(.*),`, fmt.Sprintf(`PatchLevel:${1}%d,`, ver.PatchLevel),
                `Suffix:(\s{4,})".*",`, fmt.Sprintf(`Suffix:${1}"%s",`, toDev)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">snapcraftGrade := "stable"
        if ver.Suffix != "" </span><span class="cov0" title="0">{
                snapcraftGrade = "devel"
        }</span>
        <span class="cov0" title="0">if err := r.replaceInFile("snap/snapcraft.yaml",
                `version: "(.*)"`, fmt.Sprintf(`version: "%s"`, ver),
                `grade: (.*) #`, fmt.Sprintf(`grade: %s #`, snapcraftGrade)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var minVersion string
        if ver.Suffix != "" </span><span class="cov0" title="0">{
                // People use the DEV version in daily use, and we cannot create new themes
                // with the next version before it is released.
                minVersion = ver.Prev().String()
        }</span> else<span class="cov0" title="0"> {
                minVersion = ver.String()
        }</span>

        <span class="cov0" title="0">if err := r.replaceInFile("commands/new.go",
                `min_version = "(.*)"`, fmt.Sprintf(`min_version = "%s"`, minVersion)); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func (r *ReleaseHandler) replaceInFile(filename string, oldNew ...string) error <span class="cov0" title="0">{
        filename = filepath.FromSlash(filename)
        fi, err := os.Stat(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if r.try </span><span class="cov0" title="0">{
                fmt.Printf("Replace in %q: %q\n", filename, oldNew)
                return nil
        }</span>

        <span class="cov0" title="0">b, err := ioutil.ReadFile(filename)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">newContent := string(b)

        for i := 0; i &lt; len(oldNew); i += 2 </span><span class="cov0" title="0">{
                re := regexp.MustCompile(oldNew[i])
                newContent = re.ReplaceAllString(newContent, oldNew[i+1])
        }</span>

        <span class="cov0" title="0">return ioutil.WriteFile(filename, []byte(newContent), fi.Mode())</span>
}

func isCI() bool <span class="cov8" title="1">{
        return os.Getenv("CI") != ""
}</span>

func wd() string <span class="cov0" title="0">{
        p, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                log.Fatal(err)
        }</span>
        <span class="cov0" title="0">return p</span>

}
</pre>
		
		<pre class="file" id="file201" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "image"

        "github.com/gohugoio/hugo/common/hugio"
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/media"

        "github.com/gohugoio/hugo/resources/images/exif"

        "github.com/gohugoio/hugo/resources/resource"
)

var (
        _ error = (*errorResource)(nil)
        // Imnage covers all current Resource implementations.
        _ resource.Image = (*errorResource)(nil)
        // The list of user facing and exported interfaces in resource.go
        // Note that if we're missing some interface here, the user will still
        // get an error, but not as pretty.
        _ resource.ContentResource         = (*errorResource)(nil)
        _ resource.ReadSeekCloserResource  = (*errorResource)(nil)
        _ resource.ResourcesLanguageMerger = (*resource.Resources)(nil)
        // Make sure it also fails when passed to a pipe function.
        _ ResourceTransformer = (*errorResource)(nil)
)

// NewErrorResource wraps err in a Resource where all but the Err method will panic.
func NewErrorResource(err error) resource.Resource <span class="cov0" title="0">{
        return &amp;errorResource{error: err}
}</span>

type errorResource struct {
        error
}

func (e *errorResource) Err() error <span class="cov0" title="0">{
        return e.error
}</span>

func (e *errorResource) ReadSeekCloser() (hugio.ReadSeekCloser, error) <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Content() (interface{}, error) <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) ResourceType() string <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) MediaType() media.Type <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Permalink() string <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) RelPermalink() string <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Name() string <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Title() string <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Params() maps.Params <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Data() interface{} <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Height() int <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Width() int <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Fill(spec string) (resource.Image, error) <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Fit(spec string) (resource.Image, error) <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Resize(spec string) (resource.Image, error) <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Filter(filters ...interface{}) (resource.Image, error) <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Exif() *exif.Exif <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) DecodeImage() (image.Image, error) <span class="cov0" title="0">{
        panic(e.error)</span>
}

func (e *errorResource) Transform(...ResourceTransformation) (ResourceTransformer, error) <span class="cov0" title="0">{
        panic(e.error)</span>
}
</pre>
		
		<pre class="file" id="file202" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "encoding/json"
        "fmt"
        "image"
        "image/color"
        "image/draw"
        _ "image/gif"
        _ "image/png"
        "io"
        "io/ioutil"
        "os"
        "path"
        "path/filepath"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/common/paths"

        "github.com/disintegration/gift"

        "github.com/gohugoio/hugo/cache/filecache"
        "github.com/gohugoio/hugo/resources/images/exif"

        "github.com/gohugoio/hugo/resources/resource"

        "github.com/pkg/errors"
        _errors "github.com/pkg/errors"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/resources/images"

        // Blind import for image.Decode
        _ "golang.org/x/image/webp"
)

var (
        _ resource.Image  = (*imageResource)(nil)
        _ resource.Source = (*imageResource)(nil)
        _ resource.Cloner = (*imageResource)(nil)
)

// ImageResource represents an image resource.
type imageResource struct {
        *images.Image

        // When a image is processed in a chain, this holds the reference to the
        // original (first).
        root *imageResource

        metaInit    sync.Once
        metaInitErr error
        meta        *imageMeta

        baseResource
}

type imageMeta struct {
        Exif *exif.Exif
}

func (i *imageResource) Exif() *exif.Exif <span class="cov8" title="1">{
        return i.root.getExif()
}</span>

func (i *imageResource) getExif() *exif.Exif <span class="cov8" title="1">{
        i.metaInit.Do(func() </span><span class="cov8" title="1">{
                supportsExif := i.Format == images.JPEG || i.Format == images.TIFF
                if !supportsExif </span><span class="cov8" title="1">{
                        return
                }</span>

                <span class="cov8" title="1">key := i.getImageMetaCacheTargetPath()

                read := func(info filecache.ItemInfo, r io.ReadSeeker) error </span><span class="cov8" title="1">{
                        meta := &amp;imageMeta{}
                        data, err := ioutil.ReadAll(r)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">if err = json.Unmarshal(data, &amp;meta); err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>

                        <span class="cov8" title="1">i.meta = meta

                        return nil</span>
                }

                <span class="cov8" title="1">create := func(info filecache.ItemInfo, w io.WriteCloser) (err error) </span><span class="cov8" title="1">{
                        f, err := i.root.ReadSeekCloser()
                        if err != nil </span><span class="cov0" title="0">{
                                i.metaInitErr = err
                                return
                        }</span>
                        <span class="cov8" title="1">defer f.Close()

                        x, err := i.getSpec().imaging.DecodeExif(f)
                        if err != nil </span><span class="cov0" title="0">{
                                i.getSpec().Logger.Warnf("Unable to decode Exif metadata from image: %s", i.Key())
                                return nil
                        }</span>

                        <span class="cov8" title="1">i.meta = &amp;imageMeta{Exif: x}

                        // Also write it to cache
                        enc := json.NewEncoder(w)
                        return enc.Encode(i.meta)</span>
                }

                <span class="cov8" title="1">_, i.metaInitErr = i.getSpec().imageCache.fileCache.ReadOrCreate(key, read, create)</span>
        })

        <span class="cov8" title="1">if i.metaInitErr != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("metadata init failed: %s", i.metaInitErr))</span>
        }

        <span class="cov8" title="1">if i.meta == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return i.meta.Exif</span>
}

func (i *imageResource) Clone() resource.Resource <span class="cov0" title="0">{
        gr := i.baseResource.Clone().(baseResource)
        return &amp;imageResource{
                root:         i.root,
                Image:        i.WithSpec(gr),
                baseResource: gr,
        }
}</span>

func (i *imageResource) cloneWithUpdates(u *transformationUpdate) (baseResource, error) <span class="cov8" title="1">{
        base, err := i.baseResource.cloneWithUpdates(u)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var img *images.Image

        if u.isContentChanged() </span><span class="cov8" title="1">{
                img = i.WithSpec(base)
        }</span> else<span class="cov0" title="0"> {
                img = i.Image
        }</span>

        <span class="cov8" title="1">return &amp;imageResource{
                root:         i.root,
                Image:        img,
                baseResource: base,
        }, nil</span>
}

// Resize resizes the image to the specified width and height using the specified resampling
// filter and returns the transformed image. If one of width or height is 0, the image aspect
// ratio is preserved.
func (i *imageResource) Resize(spec string) (resource.Image, error) <span class="cov8" title="1">{
        conf, err := i.decodeImageConfig("resize", spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return i.doWithImageConfig(conf, func(src image.Image) (image.Image, error) </span><span class="cov8" title="1">{
                return i.Proc.ApplyFiltersFromConfig(src, conf)
        }</span>)
}

// Fit scales down the image using the specified resample filter to fit the specified
// maximum width and height.
func (i *imageResource) Fit(spec string) (resource.Image, error) <span class="cov8" title="1">{
        conf, err := i.decodeImageConfig("fit", spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return i.doWithImageConfig(conf, func(src image.Image) (image.Image, error) </span><span class="cov8" title="1">{
                return i.Proc.ApplyFiltersFromConfig(src, conf)
        }</span>)
}

// Fill scales the image to the smallest possible size that will cover the specified dimensions,
// crops the resized image to the specified dimensions using the given anchor point.
// Space delimited config: 200x300 TopLeft
func (i *imageResource) Fill(spec string) (resource.Image, error) <span class="cov8" title="1">{
        conf, err := i.decodeImageConfig("fill", spec)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">img, err := i.doWithImageConfig(conf, func(src image.Image) (image.Image, error) </span><span class="cov8" title="1">{
                return i.Proc.ApplyFiltersFromConfig(src, conf)
        }</span>)

        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if conf.Anchor == 0 &amp;&amp; img.Width() == 0 || img.Height() == 0 </span><span class="cov8" title="1">{
                // See https://github.com/gohugoio/hugo/issues/7955
                // Smartcrop fails silently in some rare cases.
                // Fall back to a center fill.
                conf.Anchor = gift.CenterAnchor
                conf.AnchorStr = "center"
                return i.doWithImageConfig(conf, func(src image.Image) (image.Image, error) </span><span class="cov8" title="1">{
                        return i.Proc.ApplyFiltersFromConfig(src, conf)
                }</span>)
        }

        <span class="cov8" title="1">return img, err</span>
}

func (i *imageResource) Filter(filters ...interface{}) (resource.Image, error) <span class="cov8" title="1">{
        conf := images.GetDefaultImageConfig("filter", i.Proc.Cfg)

        var gfilters []gift.Filter

        for _, f := range filters </span><span class="cov8" title="1">{
                gfilters = append(gfilters, images.ToFilters(f)...)
        }</span>

        <span class="cov8" title="1">conf.Key = helpers.HashString(gfilters)
        conf.TargetFormat = i.Format

        return i.doWithImageConfig(conf, func(src image.Image) (image.Image, error) </span><span class="cov8" title="1">{
                return i.Proc.Filter(src, gfilters...)
        }</span>)
}

// Serialize image processing. The imaging library spins up its own set of Go routines,
// so there is not much to gain from adding more load to the mix. That
// can even have negative effect in low resource scenarios.
// Note that this only effects the non-cached scenario. Once the processed
// image is written to disk, everything is fast, fast fast.
const imageProcWorkers = 1

var imageProcSem = make(chan bool, imageProcWorkers)

func (i *imageResource) doWithImageConfig(conf images.ImageConfig, f func(src image.Image) (image.Image, error)) (resource.Image, error) <span class="cov8" title="1">{
        img, err := i.getSpec().imageCache.getOrCreate(i, conf, func() (*imageResource, image.Image, error) </span><span class="cov8" title="1">{
                imageProcSem &lt;- true
                defer func() </span><span class="cov8" title="1">{
                        &lt;-imageProcSem
                }</span>()

                <span class="cov8" title="1">errOp := conf.Action
                errPath := i.getSourceFilename()

                src, err := i.DecodeImage()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, &amp;os.PathError{Op: errOp, Path: errPath, Err: err}
                }</span>

                <span class="cov8" title="1">converted, err := f(src)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, nil, &amp;os.PathError{Op: errOp, Path: errPath, Err: err}
                }</span>

                <span class="cov8" title="1">hasAlpha := !images.IsOpaque(converted)
                shouldFill := conf.BgColor != nil &amp;&amp; hasAlpha
                shouldFill = shouldFill || (!conf.TargetFormat.SupportsTransparency() &amp;&amp; hasAlpha)
                var bgColor color.Color

                if shouldFill </span><span class="cov8" title="1">{
                        bgColor = conf.BgColor
                        if bgColor == nil </span><span class="cov0" title="0">{
                                bgColor = i.Proc.Cfg.BgColor
                        }</span>
                        <span class="cov8" title="1">tmp := image.NewRGBA(converted.Bounds())
                        draw.Draw(tmp, tmp.Bounds(), image.NewUniform(bgColor), image.Point{}, draw.Src)
                        draw.Draw(tmp, tmp.Bounds(), converted, converted.Bounds().Min, draw.Over)
                        converted = tmp</span>
                }

                <span class="cov8" title="1">if conf.TargetFormat == images.PNG </span><span class="cov8" title="1">{
                        // Apply the colour palette from the source
                        if paletted, ok := src.(*image.Paletted); ok </span><span class="cov8" title="1">{
                                palette := paletted.Palette
                                if bgColor != nil &amp;&amp; len(palette) &lt; 256 </span><span class="cov8" title="1">{
                                        palette = images.AddColorToPalette(bgColor, palette)
                                }</span> else<span class="cov8" title="1"> if bgColor != nil </span><span class="cov8" title="1">{
                                        images.ReplaceColorInPalette(bgColor, palette)
                                }</span>
                                <span class="cov8" title="1">tmp := image.NewPaletted(converted.Bounds(), palette)
                                draw.FloydSteinberg.Draw(tmp, tmp.Bounds(), converted, converted.Bounds().Min)
                                converted = tmp</span>
                        }
                }

                <span class="cov8" title="1">ci := i.clone(converted)
                ci.setBasePath(conf)
                ci.Format = conf.TargetFormat
                ci.setMediaType(conf.TargetFormat.MediaType())

                return ci, converted, nil</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                if i.root != nil &amp;&amp; i.root.getFileInfo() != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "image %q", i.root.getFileInfo().Meta().Filename)
                }</span>
        }
        <span class="cov8" title="1">return img, nil</span>
}

func (i *imageResource) decodeImageConfig(action, spec string) (images.ImageConfig, error) <span class="cov8" title="1">{
        conf, err := images.DecodeImageConfig(action, spec, i.Proc.Cfg, i.Format)
        if err != nil </span><span class="cov0" title="0">{
                return conf, err
        }</span>

        <span class="cov8" title="1">return conf, nil</span>
}

// DecodeImage decodes the image source into an Image.
// This an internal method and may change.
func (i *imageResource) DecodeImage() (image.Image, error) <span class="cov8" title="1">{
        f, err := i.ReadSeekCloser()
        if err != nil </span><span class="cov0" title="0">{
                return nil, _errors.Wrap(err, "failed to open image for decode")
        }</span>
        <span class="cov8" title="1">defer f.Close()
        img, _, err := image.Decode(f)
        return img, err</span>
}

func (i *imageResource) clone(img image.Image) *imageResource <span class="cov8" title="1">{
        spec := i.baseResource.Clone().(baseResource)

        var image *images.Image
        if img != nil </span><span class="cov8" title="1">{
                image = i.WithImage(img)
        }</span> else<span class="cov8" title="1"> {
                image = i.WithSpec(spec)
        }</span>

        <span class="cov8" title="1">return &amp;imageResource{
                Image:        image,
                root:         i.root,
                baseResource: spec,
        }</span>
}

func (i *imageResource) setBasePath(conf images.ImageConfig) <span class="cov8" title="1">{
        i.getResourcePaths().relTargetDirFile = i.relTargetPathFromConfig(conf)
}</span>

func (i *imageResource) getImageMetaCacheTargetPath() string <span class="cov8" title="1">{
        const imageMetaVersionNumber = 1 // Increment to invalidate the meta cache

        cfgHash := i.getSpec().imaging.Cfg.CfgHash
        df := i.getResourcePaths().relTargetDirFile
        if fi := i.getFileInfo(); fi != nil </span><span class="cov8" title="1">{
                df.dir = filepath.Dir(fi.Meta().Path)
        }</span>
        <span class="cov8" title="1">p1, _ := paths.FileAndExt(df.file)
        h, _ := i.hash()
        idStr := helpers.HashString(h, i.size(), imageMetaVersionNumber, cfgHash)
        p := path.Join(df.dir, fmt.Sprintf("%s_%s.json", p1, idStr))
        return p</span>
}

func (i *imageResource) relTargetPathFromConfig(conf images.ImageConfig) dirFile <span class="cov8" title="1">{
        p1, p2 := paths.FileAndExt(i.getResourcePaths().relTargetDirFile.file)
        if conf.TargetFormat != i.Format </span><span class="cov8" title="1">{
                p2 = conf.TargetFormat.DefaultExtension()
        }</span>

        <span class="cov8" title="1">h, _ := i.hash()
        idStr := fmt.Sprintf("_hu%s_%d", h, i.size())

        // Do not change for no good reason.
        const md5Threshold = 100

        key := conf.GetKey(i.Format)

        // It is useful to have the key in clear text, but when nesting transforms, it
        // can easily be too long to read, and maybe even too long
        // for the different OSes to handle.
        if len(p1)+len(idStr)+len(p2) &gt; md5Threshold </span><span class="cov8" title="1">{
                key = helpers.MD5String(p1 + key + p2)
                huIdx := strings.Index(p1, "_hu")
                if huIdx != -1 </span><span class="cov8" title="1">{
                        p1 = p1[:huIdx]
                }</span> else<span class="cov8" title="1"> {
                        // This started out as a very long file name. Making it even longer
                        // could melt ice in the Arctic.
                        p1 = ""
                }</span>
        } else<span class="cov8" title="1"> if strings.Contains(p1, idStr) </span><span class="cov0" title="0">{
                // On scaling an already scaled image, we get the file info from the original.
                // Repeating the same info in the filename makes it stuttery for no good reason.
                idStr = ""
        }</span>

        <span class="cov8" title="1">return dirFile{
                dir:  i.getResourcePaths().relTargetDirFile.dir,
                file: fmt.Sprintf("%s%s_%s%s", p1, idStr, key, p2),
        }</span>
}
</pre>
		
		<pre class="file" id="file203" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "image"
        "io"
        "path/filepath"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/resources/images"

        "github.com/gohugoio/hugo/cache/filecache"
        "github.com/gohugoio/hugo/helpers"
)

type imageCache struct {
        pathSpec *helpers.PathSpec

        fileCache *filecache.Cache

        mu    sync.RWMutex
        store map[string]*resourceAdapter
}

func (c *imageCache) deleteIfContains(s string) <span class="cov0" title="0">{
        c.mu.Lock()
        defer c.mu.Unlock()
        s = c.normalizeKeyBase(s)
        for k := range c.store </span><span class="cov0" title="0">{
                if strings.Contains(k, s) </span><span class="cov0" title="0">{
                        delete(c.store, k)
                }</span>
        }
}

// The cache key is a lowercase path with Unix style slashes and it always starts with
// a leading slash.
func (c *imageCache) normalizeKey(key string) string <span class="cov8" title="1">{
        return "/" + c.normalizeKeyBase(key)
}</span>

func (c *imageCache) normalizeKeyBase(key string) string <span class="cov8" title="1">{
        return strings.Trim(strings.ToLower(filepath.ToSlash(key)), "/")
}</span>

func (c *imageCache) clear() <span class="cov8" title="1">{
        c.mu.Lock()
        defer c.mu.Unlock()
        c.store = make(map[string]*resourceAdapter)
}</span>

func (c *imageCache) getOrCreate(
        parent *imageResource, conf images.ImageConfig,
        createImage func() (*imageResource, image.Image, error)) (*resourceAdapter, error) <span class="cov8" title="1">{
        relTarget := parent.relTargetPathFromConfig(conf)
        memKey := parent.relTargetPathForRel(relTarget.path(), false, false, false)
        memKey = c.normalizeKey(memKey)

        // For the file cache we want to generate and store it once if possible.
        fileKeyPath := relTarget
        if fi := parent.root.getFileInfo(); fi != nil </span><span class="cov8" title="1">{
                fileKeyPath.dir = filepath.ToSlash(filepath.Dir(fi.Meta().Path))
        }</span>
        <span class="cov8" title="1">fileKey := fileKeyPath.path()

        // First check the in-memory store, then the disk.
        c.mu.RLock()
        cachedImage, found := c.store[memKey]
        c.mu.RUnlock()

        if found </span><span class="cov8" title="1">{
                return cachedImage, nil
        }</span>

        <span class="cov8" title="1">var img *imageResource

        // These funcs are protected by a named lock.
        // read clones the parent to its new name and copies
        // the content to the destinations.
        read := func(info filecache.ItemInfo, r io.ReadSeeker) error </span><span class="cov8" title="1">{
                img = parent.clone(nil)
                rp := img.getResourcePaths()
                rp.relTargetDirFile.file = relTarget.file
                img.setSourceFilename(info.Name)

                if err := img.InitConfig(r); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">r.Seek(0, 0)

                w, err := img.openDestinationsForWriting()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if w == nil </span><span class="cov0" title="0">{
                        // Nothing to write.
                        return nil
                }</span>

                <span class="cov8" title="1">defer w.Close()
                _, err = io.Copy(w, r)

                return err</span>
        }

        // create creates the image and encodes it to the cache (w).
        <span class="cov8" title="1">create := func(info filecache.ItemInfo, w io.WriteCloser) (err error) </span><span class="cov8" title="1">{
                defer w.Close()

                var conv image.Image
                img, conv, err = createImage()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">rp := img.getResourcePaths()
                rp.relTargetDirFile.file = relTarget.file
                img.setSourceFilename(info.Name)

                return img.EncodeTo(conf, conv, w)</span>
        }

        // Now look in the file cache.

        // The definition of this counter is not that we have processed that amount
        // (e.g. resized etc.), it can be fetched from file cache,
        //  but the count of processed image variations for this site.
        <span class="cov8" title="1">c.pathSpec.ProcessingStats.Incr(&amp;c.pathSpec.ProcessingStats.ProcessedImages)

        _, err := c.fileCache.ReadOrCreate(fileKey, read, create)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // The file is now stored in this cache.
        <span class="cov8" title="1">img.setSourceFs(c.fileCache.Fs)

        c.mu.Lock()
        if cachedImage, found = c.store[memKey]; found </span><span class="cov0" title="0">{
                c.mu.Unlock()
                return cachedImage, nil
        }</span>

        <span class="cov8" title="1">imgAdapter := newResourceAdapter(parent.getSpec(), true, img)
        c.store[memKey] = imgAdapter
        c.mu.Unlock()

        return imgAdapter, nil</span>
}

func newImageCache(fileCache *filecache.Cache, ps *helpers.PathSpec) *imageCache <span class="cov8" title="1">{
        return &amp;imageCache{fileCache: fileCache, pathSpec: ps, store: make(map[string]*resourceAdapter)}
}</span>
</pre>
		
		<pre class="file" id="file204" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import (
        "encoding/hex"
        "image/color"
        "strings"

        "github.com/pkg/errors"
)

// AddColorToPalette adds c as the first color in p if not already there.
// Note that it does no additional checks, so callers must make sure
// that the palette is valid for the relevant format.
func AddColorToPalette(c color.Color, p color.Palette) color.Palette <span class="cov8" title="1">{
        var found bool
        for _, cc := range p </span><span class="cov8" title="1">{
                if c == cc </span><span class="cov8" title="1">{
                        found = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                p = append(color.Palette{c}, p...)
        }</span>

        <span class="cov8" title="1">return p</span>
}

// ReplaceColorInPalette will replace the color in palette p closest to c in Euclidean
// R,G,B,A space with c.
func ReplaceColorInPalette(c color.Color, p color.Palette) <span class="cov8" title="1">{
        p[p.Index(c)] = c
}</span>

func hexStringToColor(s string) (color.Color, error) <span class="cov8" title="1">{
        s = strings.TrimPrefix(s, "#")

        if len(s) != 3 &amp;&amp; len(s) != 6 </span><span class="cov8" title="1">{
                return nil, errors.Errorf("invalid color code: %q", s)
        }</span>

        <span class="cov8" title="1">s = strings.ToLower(s)

        if len(s) == 3 </span><span class="cov8" title="1">{
                var v string
                for _, r := range s </span><span class="cov8" title="1">{
                        v += string(r) + string(r)
                }</span>
                <span class="cov8" title="1">s = v</span>
        }

        // Standard colors.
        <span class="cov8" title="1">if s == "ffffff" </span><span class="cov8" title="1">{
                return color.White, nil
        }</span>

        <span class="cov8" title="1">if s == "000000" </span><span class="cov8" title="1">{
                return color.Black, nil
        }</span>

        // Set Alfa to white.
        <span class="cov8" title="1">s += "ff"

        b, err := hex.DecodeString(s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return color.RGBA{b[0], b[1], b[2], b[3]}, nil</span>
}
</pre>
		
		<pre class="file" id="file205" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import (
        "fmt"
        "image/color"
        "strconv"
        "strings"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/media"

        "github.com/pkg/errors"

        "github.com/bep/gowebp/libwebp/webpoptions"

        "github.com/disintegration/gift"

        "github.com/mitchellh/mapstructure"
)

var (
        imageFormats = map[string]Format{
                ".jpg":  JPEG,
                ".jpeg": JPEG,
                ".jpe":  JPEG,
                ".jif":  JPEG,
                ".jfif": JPEG,
                ".png":  PNG,
                ".tif":  TIFF,
                ".tiff": TIFF,
                ".bmp":  BMP,
                ".gif":  GIF,
                ".webp": WEBP,
        }

        imageFormatsBySubType = map[string]Format{
                media.JPEGType.SubType: JPEG,
                media.PNGType.SubType:  PNG,
                media.TIFFType.SubType: TIFF,
                media.BMPType.SubType:  BMP,
                media.GIFType.SubType:  GIF,
                media.WEBPType.SubType: WEBP,
        }

        // Add or increment if changes to an image format's processing requires
        // re-generation.
        imageFormatsVersions = map[Format]int{
                PNG:  3, // Fix transparency issue with 32 bit images.
                WEBP: 2, // Fix transparency issue with 32 bit images.
        }

        // Increment to mark all processed images as stale. Only use when absolutely needed.
        // See the finer grained smartCropVersionNumber and imageFormatsVersions.
        mainImageVersionNumber = 0
)

var anchorPositions = map[string]gift.Anchor{
        strings.ToLower("Center"):      gift.CenterAnchor,
        strings.ToLower("TopLeft"):     gift.TopLeftAnchor,
        strings.ToLower("Top"):         gift.TopAnchor,
        strings.ToLower("TopRight"):    gift.TopRightAnchor,
        strings.ToLower("Left"):        gift.LeftAnchor,
        strings.ToLower("Right"):       gift.RightAnchor,
        strings.ToLower("BottomLeft"):  gift.BottomLeftAnchor,
        strings.ToLower("Bottom"):      gift.BottomAnchor,
        strings.ToLower("BottomRight"): gift.BottomRightAnchor,
}

// These encoding hints are currently only relevant for Webp.
var hints = map[string]webpoptions.EncodingPreset{
        "picture": webpoptions.EncodingPresetPicture,
        "photo":   webpoptions.EncodingPresetPhoto,
        "drawing": webpoptions.EncodingPresetDrawing,
        "icon":    webpoptions.EncodingPresetIcon,
        "text":    webpoptions.EncodingPresetText,
}

var imageFilters = map[string]gift.Resampling{

        strings.ToLower("NearestNeighbor"):   gift.NearestNeighborResampling,
        strings.ToLower("Box"):               gift.BoxResampling,
        strings.ToLower("Linear"):            gift.LinearResampling,
        strings.ToLower("Hermite"):           hermiteResampling,
        strings.ToLower("MitchellNetravali"): mitchellNetravaliResampling,
        strings.ToLower("CatmullRom"):        catmullRomResampling,
        strings.ToLower("BSpline"):           bSplineResampling,
        strings.ToLower("Gaussian"):          gaussianResampling,
        strings.ToLower("Lanczos"):           gift.LanczosResampling,
        strings.ToLower("Hann"):              hannResampling,
        strings.ToLower("Hamming"):           hammingResampling,
        strings.ToLower("Blackman"):          blackmanResampling,
        strings.ToLower("Bartlett"):          bartlettResampling,
        strings.ToLower("Welch"):             welchResampling,
        strings.ToLower("Cosine"):            cosineResampling,
}

func ImageFormatFromExt(ext string) (Format, bool) <span class="cov8" title="1">{
        f, found := imageFormats[ext]
        return f, found
}</span>

func ImageFormatFromMediaSubType(sub string) (Format, bool) <span class="cov0" title="0">{
        f, found := imageFormatsBySubType[sub]
        return f, found
}</span>

const (
        defaultJPEGQuality    = 75
        defaultResampleFilter = "box"
        defaultBgColor        = "ffffff"
        defaultHint           = "photo"
)

var defaultImaging = Imaging{
        ResampleFilter: defaultResampleFilter,
        BgColor:        defaultBgColor,
        Hint:           defaultHint,
        Quality:        defaultJPEGQuality,
}

func DecodeConfig(m map[string]interface{}) (ImagingConfig, error) <span class="cov8" title="1">{
        if m == nil </span><span class="cov8" title="1">{
                m = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">i := ImagingConfig{
                Cfg:     defaultImaging,
                CfgHash: helpers.HashString(m),
        }

        if err := mapstructure.WeakDecode(m, &amp;i.Cfg); err != nil </span><span class="cov0" title="0">{
                return i, err
        }</span>

        <span class="cov8" title="1">if err := i.Cfg.init(); err != nil </span><span class="cov8" title="1">{
                return i, err
        }</span>

        <span class="cov8" title="1">var err error
        i.BgColor, err = hexStringToColor(i.Cfg.BgColor)
        if err != nil </span><span class="cov0" title="0">{
                return i, err
        }</span>

        <span class="cov8" title="1">if i.Cfg.Anchor != "" &amp;&amp; i.Cfg.Anchor != smartCropIdentifier </span><span class="cov8" title="1">{
                anchor, found := anchorPositions[i.Cfg.Anchor]
                if !found </span><span class="cov8" title="1">{
                        return i, errors.Errorf("invalid anchor value %q in imaging config", i.Anchor)
                }</span>
                <span class="cov8" title="1">i.Anchor = anchor</span>
        } else<span class="cov8" title="1"> {
                i.Cfg.Anchor = smartCropIdentifier
        }</span>

        <span class="cov8" title="1">filter, found := imageFilters[i.Cfg.ResampleFilter]
        if !found </span><span class="cov8" title="1">{
                return i, fmt.Errorf("%q is not a valid resample filter", filter)
        }</span>
        <span class="cov8" title="1">i.ResampleFilter = filter

        if strings.TrimSpace(i.Cfg.Exif.IncludeFields) == "" &amp;&amp; strings.TrimSpace(i.Cfg.Exif.ExcludeFields) == "" </span><span class="cov8" title="1">{
                // Don't change this for no good reason. Please don't.
                i.Cfg.Exif.ExcludeFields = "GPS|Exif|Exposure[M|P|B]|Contrast|Resolution|Sharp|JPEG|Metering|Sensing|Saturation|ColorSpace|Flash|WhiteBalance"
        }</span>

        <span class="cov8" title="1">return i, nil</span>
}

func DecodeImageConfig(action, config string, defaults ImagingConfig, sourceFormat Format) (ImageConfig, error) <span class="cov8" title="1">{
        var (
                c   ImageConfig = GetDefaultImageConfig(action, defaults)
                err error
        )

        c.Action = action

        if config == "" </span><span class="cov8" title="1">{
                return c, errors.New("image config cannot be empty")
        }</span>

        <span class="cov8" title="1">parts := strings.Fields(config)
        for _, part := range parts </span><span class="cov8" title="1">{
                part = strings.ToLower(part)

                if part == smartCropIdentifier </span><span class="cov0" title="0">{
                        c.AnchorStr = smartCropIdentifier
                }</span> else<span class="cov8" title="1"> if pos, ok := anchorPositions[part]; ok </span><span class="cov8" title="1">{
                        c.Anchor = pos
                        c.AnchorStr = part
                }</span> else<span class="cov8" title="1"> if filter, ok := imageFilters[part]; ok </span><span class="cov8" title="1">{
                        c.Filter = filter
                        c.FilterStr = part
                }</span> else<span class="cov8" title="1"> if hint, ok := hints[part]; ok </span><span class="cov0" title="0">{
                        c.Hint = hint
                }</span> else<span class="cov8" title="1"> if part[0] == '#' </span><span class="cov8" title="1">{
                        c.BgColorStr = part[1:]
                        c.BgColor, err = hexStringToColor(c.BgColorStr)
                        if err != nil </span><span class="cov0" title="0">{
                                return c, err
                        }</span>
                } else<span class="cov8" title="1"> if part[0] == 'q' </span><span class="cov8" title="1">{
                        c.Quality, err = strconv.Atoi(part[1:])
                        if err != nil </span><span class="cov0" title="0">{
                                return c, err
                        }</span>
                        <span class="cov8" title="1">if c.Quality &lt; 1 || c.Quality &gt; 100 </span><span class="cov0" title="0">{
                                return c, errors.New("quality ranges from 1 to 100 inclusive")
                        }</span>
                        <span class="cov8" title="1">c.qualitySetForImage = true</span>
                } else<span class="cov8" title="1"> if part[0] == 'r' </span><span class="cov8" title="1">{
                        c.Rotate, err = strconv.Atoi(part[1:])
                        if err != nil </span><span class="cov0" title="0">{
                                return c, err
                        }</span>
                } else<span class="cov8" title="1"> if strings.Contains(part, "x") </span><span class="cov8" title="1">{
                        widthHeight := strings.Split(part, "x")
                        if len(widthHeight) &lt;= 2 </span><span class="cov8" title="1">{
                                first := widthHeight[0]
                                if first != "" </span><span class="cov8" title="1">{
                                        c.Width, err = strconv.Atoi(first)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return c, err
                                        }</span>
                                }

                                <span class="cov8" title="1">if len(widthHeight) == 2 </span><span class="cov8" title="1">{
                                        second := widthHeight[1]
                                        if second != "" </span><span class="cov8" title="1">{
                                                c.Height, err = strconv.Atoi(second)
                                                if err != nil </span><span class="cov0" title="0">{
                                                        return c, err
                                                }</span>
                                        }
                                }
                        } else<span class="cov0" title="0"> {
                                return c, errors.New("invalid image dimensions")
                        }</span>
                } else<span class="cov8" title="1"> if f, ok := ImageFormatFromExt("." + part); ok </span><span class="cov0" title="0">{
                        c.TargetFormat = f
                }</span>
        }

        <span class="cov8" title="1">if c.Width == 0 &amp;&amp; c.Height == 0 </span><span class="cov8" title="1">{
                return c, errors.New("must provide Width or Height")
        }</span>

        <span class="cov8" title="1">if c.FilterStr == "" </span><span class="cov8" title="1">{
                c.FilterStr = defaults.Cfg.ResampleFilter
                c.Filter = defaults.ResampleFilter
        }</span>

        <span class="cov8" title="1">if c.Hint == 0 </span><span class="cov8" title="1">{
                c.Hint = webpoptions.EncodingPresetPhoto
        }</span>

        <span class="cov8" title="1">if c.AnchorStr == "" </span><span class="cov8" title="1">{
                c.AnchorStr = defaults.Cfg.Anchor
                c.Anchor = defaults.Anchor
        }</span>

        // default to the source format
        <span class="cov8" title="1">if c.TargetFormat == 0 </span><span class="cov8" title="1">{
                c.TargetFormat = sourceFormat
        }</span>

        <span class="cov8" title="1">if c.Quality &lt;= 0 &amp;&amp; c.TargetFormat.RequiresDefaultQuality() </span><span class="cov0" title="0">{
                // We need a quality setting for all JPEGs and WEBPs.
                c.Quality = defaults.Cfg.Quality
        }</span>

        <span class="cov8" title="1">if c.BgColor == nil &amp;&amp; c.TargetFormat != sourceFormat </span><span class="cov0" title="0">{
                if sourceFormat.SupportsTransparency() &amp;&amp; !c.TargetFormat.SupportsTransparency() </span><span class="cov0" title="0">{
                        c.BgColor = defaults.BgColor
                        c.BgColorStr = defaults.Cfg.BgColor
                }</span>
        }

        <span class="cov8" title="1">return c, nil</span>
}

// ImageConfig holds configuration to create a new image from an existing one, resize etc.
type ImageConfig struct {
        // This defines the output format of the output image. It defaults to the source format.
        TargetFormat Format

        Action string

        // If set, this will be used as the key in filenames etc.
        Key string

        // Quality ranges from 1 to 100 inclusive, higher is better.
        // This is only relevant for JPEG and WEBP images.
        // Default is 75.
        Quality            int
        qualitySetForImage bool // Whether the above is set for this image.

        // Rotate rotates an image by the given angle counter-clockwise.
        // The rotation will be performed first.
        Rotate int

        // Used to fill any transparency.
        // When set in site config, it's used when converting to a format that does
        // not support transparency.
        // When set per image operation, it's used even for formats that does support
        // transparency.
        BgColor    color.Color
        BgColorStr string

        // Hint about what type of picture this is. Used to optimize encoding
        // when target is set to webp.
        Hint webpoptions.EncodingPreset

        Width  int
        Height int

        Filter    gift.Resampling
        FilterStr string

        Anchor    gift.Anchor
        AnchorStr string
}

func (i ImageConfig) GetKey(format Format) string <span class="cov0" title="0">{
        if i.Key != "" </span><span class="cov0" title="0">{
                return i.Action + "_" + i.Key
        }</span>

        <span class="cov0" title="0">k := strconv.Itoa(i.Width) + "x" + strconv.Itoa(i.Height)
        if i.Action != "" </span><span class="cov0" title="0">{
                k += "_" + i.Action
        }</span>
        // This slightly odd construct is here to preserve the old image keys.
        <span class="cov0" title="0">if i.qualitySetForImage || i.TargetFormat.RequiresDefaultQuality() </span><span class="cov0" title="0">{
                k += "_q" + strconv.Itoa(i.Quality)
        }</span>
        <span class="cov0" title="0">if i.Rotate != 0 </span><span class="cov0" title="0">{
                k += "_r" + strconv.Itoa(i.Rotate)
        }</span>
        <span class="cov0" title="0">if i.BgColorStr != "" </span><span class="cov0" title="0">{
                k += "_bg" + i.BgColorStr
        }</span>

        <span class="cov0" title="0">if i.TargetFormat == WEBP </span><span class="cov0" title="0">{
                k += "_h" + strconv.Itoa(int(i.Hint))
        }</span>

        <span class="cov0" title="0">anchor := i.AnchorStr
        if anchor == smartCropIdentifier </span><span class="cov0" title="0">{
                anchor = anchor + strconv.Itoa(smartCropVersionNumber)
        }</span>

        <span class="cov0" title="0">k += "_" + i.FilterStr

        if strings.EqualFold(i.Action, "fill") </span><span class="cov0" title="0">{
                k += "_" + anchor
        }</span>

        <span class="cov0" title="0">if v, ok := imageFormatsVersions[format]; ok </span><span class="cov0" title="0">{
                k += "_" + strconv.Itoa(v)
        }</span>

        <span class="cov0" title="0">if mainImageVersionNumber &gt; 0 </span><span class="cov0" title="0">{
                k += "_" + strconv.Itoa(mainImageVersionNumber)
        }</span>

        <span class="cov0" title="0">return k</span>
}

type ImagingConfig struct {
        BgColor        color.Color
        Hint           webpoptions.EncodingPreset
        ResampleFilter gift.Resampling
        Anchor         gift.Anchor

        // Config as provided by the user.
        Cfg Imaging

        // Hash of the config map provided by the user.
        CfgHash string
}

// Imaging contains default image processing configuration. This will be fetched
// from site (or language) config.
type Imaging struct {
        // Default image quality setting (1-100). Only used for JPEG images.
        Quality int

        // Resample filter to use in resize operations.
        ResampleFilter string

        // Hint about what type of image this is.
        // Currently only used when encoding to Webp.
        // Default is "photo".
        // Valid values are "picture", "photo", "drawing", "icon", or "text".
        Hint string

        // The anchor to use in Fill. Default is "smart", i.e. Smart Crop.
        Anchor string

        // Default color used in fill operations (e.g. "fff" for white).
        BgColor string

        Exif ExifConfig
}

func (cfg *Imaging) init() error <span class="cov8" title="1">{
        if cfg.Quality &lt; 0 || cfg.Quality &gt; 100 </span><span class="cov8" title="1">{
                return errors.New("image quality must be a number between 1 and 100")
        }</span>

        <span class="cov8" title="1">cfg.BgColor = strings.ToLower(strings.TrimPrefix(cfg.BgColor, "#"))
        cfg.Anchor = strings.ToLower(cfg.Anchor)
        cfg.ResampleFilter = strings.ToLower(cfg.ResampleFilter)
        cfg.Hint = strings.ToLower(cfg.Hint)

        return nil</span>
}

type ExifConfig struct {

        // Regexp matching the Exif fields you want from the (massive) set of Exif info
        // available. As we cache this info to disk, this is for performance and
        // disk space reasons more than anything.
        // If you want it all, put ".*" in this config setting.
        // Note that if neither this or ExcludeFields is set, Hugo will return a small
        // default set.
        IncludeFields string

        // Regexp matching the Exif fields you want to exclude. This may be easier to use
        // than IncludeFields above, depending on what you want.
        ExcludeFields string

        // Hugo extracts the "photo taken" date/time into .Date by default.
        // Set this to true to turn it off.
        DisableDate bool

        // Hugo extracts the "photo taken where" (GPS latitude and longitude) into
        // .Long and .Lat. Set this to true to turn it off.
        DisableLatLong bool
}
</pre>
		
		<pre class="file" id="file206" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package exif

import (
        "bytes"
        "fmt"
        "io"
        "math/big"
        "regexp"
        "strings"
        "time"
        "unicode"
        "unicode/utf8"

        "github.com/bep/tmc"

        _exif "github.com/rwcarlsen/goexif/exif"
        "github.com/rwcarlsen/goexif/tiff"
)

const exifTimeLayout = "2006:01:02 15:04:05"

type Exif struct {
        Lat  float64
        Long float64
        Date time.Time
        Tags Tags
}

type Decoder struct {
        includeFieldsRe  *regexp.Regexp
        excludeFieldsrRe *regexp.Regexp
        noDate           bool
        noLatLong        bool
}

func IncludeFields(expression string) func(*Decoder) error <span class="cov8" title="1">{
        return func(d *Decoder) error </span><span class="cov8" title="1">{
                re, err := compileRegexp(expression)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">d.includeFieldsRe = re
                return nil</span>
        }
}

func ExcludeFields(expression string) func(*Decoder) error <span class="cov0" title="0">{
        return func(d *Decoder) error </span><span class="cov0" title="0">{
                re, err := compileRegexp(expression)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">d.excludeFieldsrRe = re
                return nil</span>
        }
}

func WithLatLongDisabled(disabled bool) func(*Decoder) error <span class="cov0" title="0">{
        return func(d *Decoder) error </span><span class="cov0" title="0">{
                d.noLatLong = disabled
                return nil
        }</span>
}

func WithDateDisabled(disabled bool) func(*Decoder) error <span class="cov0" title="0">{
        return func(d *Decoder) error </span><span class="cov0" title="0">{
                d.noDate = disabled
                return nil
        }</span>
}

func compileRegexp(expression string) (*regexp.Regexp, error) <span class="cov8" title="1">{
        expression = strings.TrimSpace(expression)
        if expression == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">if !strings.HasPrefix(expression, "(") </span><span class="cov8" title="1">{
                // Make it case insensitive
                expression = "(?i)" + expression
        }</span>

        <span class="cov8" title="1">return regexp.Compile(expression)</span>
}

func NewDecoder(options ...func(*Decoder) error) (*Decoder, error) <span class="cov8" title="1">{
        d := &amp;Decoder{}
        for _, opt := range options </span><span class="cov8" title="1">{
                if err := opt(d); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return d, nil</span>
}

func (d *Decoder) Decode(r io.Reader) (ex *Exif, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = fmt.Errorf("Exif failed: %v", r)
                }</span>
        }()

        <span class="cov8" title="1">var x *_exif.Exif
        x, err = _exif.Decode(r)
        if err != nil </span><span class="cov8" title="1">{
                if err.Error() == "EOF" </span><span class="cov0" title="0">{
                        // Found no Exif
                        return nil, nil
                }</span>
                <span class="cov8" title="1">return</span>
        }

        <span class="cov8" title="1">var tm time.Time
        var lat, long float64

        if !d.noDate </span><span class="cov8" title="1">{
                tm, _ = x.DateTime()
        }</span>

        <span class="cov8" title="1">if !d.noLatLong </span><span class="cov8" title="1">{
                lat, long, _ = x.LatLong()
        }</span>

        <span class="cov8" title="1">walker := &amp;exifWalker{x: x, vals: make(map[string]interface{}), includeMatcher: d.includeFieldsRe, excludeMatcher: d.excludeFieldsrRe}
        if err = x.Walk(walker); err != nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">ex = &amp;Exif{Lat: lat, Long: long, Date: tm, Tags: walker.vals}

        return</span>
}

func decodeTag(x *_exif.Exif, f _exif.FieldName, t *tiff.Tag) (interface{}, error) <span class="cov8" title="1">{
        switch t.Format() </span>{
        case tiff.StringVal, tiff.UndefVal:<span class="cov8" title="1">
                s := nullString(t.Val)
                if strings.Contains(string(f), "DateTime") </span><span class="cov8" title="1">{
                        if d, err := tryParseDate(x, s); err == nil </span><span class="cov8" title="1">{
                                return d, nil
                        }</span>
                }
                <span class="cov8" title="1">return s, nil</span>
        case tiff.OtherVal:<span class="cov0" title="0">
                return "unknown", nil</span>
        }

        <span class="cov8" title="1">var rv []interface{}

        for i := 0; i &lt; int(t.Count); i++ </span><span class="cov8" title="1">{
                switch t.Format() </span>{
                case tiff.RatVal:<span class="cov8" title="1">
                        n, d, _ := t.Rat2(i)
                        rat := big.NewRat(n, d)
                        if n == 1 </span><span class="cov8" title="1">{
                                rv = append(rv, rat)
                        }</span> else<span class="cov0" title="0"> {
                                f, _ := rat.Float64()
                                rv = append(rv, f)
                        }</span>

                case tiff.FloatVal:<span class="cov0" title="0">
                        v, _ := t.Float(i)
                        rv = append(rv, v)</span>
                case tiff.IntVal:<span class="cov8" title="1">
                        v, _ := t.Int(i)
                        rv = append(rv, v)</span>
                }
        }

        <span class="cov8" title="1">if t.Count == 1 </span><span class="cov8" title="1">{
                if len(rv) == 1 </span><span class="cov8" title="1">{
                        return rv[0], nil
                }</span>
        }

        <span class="cov0" title="0">return rv, nil</span>
}

// Code borrowed from exif.DateTime and adjusted.
func tryParseDate(x *_exif.Exif, s string) (time.Time, error) <span class="cov8" title="1">{
        dateStr := strings.TrimRight(s, "\x00")
        // TODO(bep): look for timezone offset, GPS time, etc.
        timeZone := time.Local
        if tz, _ := x.TimeZone(); tz != nil </span><span class="cov0" title="0">{
                timeZone = tz
        }</span>
        <span class="cov8" title="1">return time.ParseInLocation(exifTimeLayout, dateStr, timeZone)</span>
}

type exifWalker struct {
        x              *_exif.Exif
        vals           map[string]interface{}
        includeMatcher *regexp.Regexp
        excludeMatcher *regexp.Regexp
}

func (e *exifWalker) Walk(f _exif.FieldName, tag *tiff.Tag) error <span class="cov8" title="1">{
        name := string(f)
        if e.excludeMatcher != nil &amp;&amp; e.excludeMatcher.MatchString(name) </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">if e.includeMatcher != nil &amp;&amp; !e.includeMatcher.MatchString(name) </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">val, err := decodeTag(e.x, f, tag)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">e.vals[name] = val
        return nil</span>
}

func nullString(in []byte) string <span class="cov8" title="1">{
        var rv bytes.Buffer
        for len(in) &gt; 0 </span><span class="cov8" title="1">{
                r, size := utf8.DecodeRune(in)
                if unicode.IsGraphic(r) </span><span class="cov8" title="1">{
                        rv.WriteRune(r)
                }</span>
                <span class="cov8" title="1">in = in[size:]</span>
        }
        <span class="cov8" title="1">return rv.String()</span>
}

var tcodec *tmc.Codec

func init() <span class="cov8" title="1">{
        var err error
        tcodec, err = tmc.New()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
}

type Tags map[string]interface{}

func (v *Tags) UnmarshalJSON(b []byte) error <span class="cov8" title="1">{
        vv := make(map[string]interface{})
        if err := tcodec.Unmarshal(b, &amp;vv); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">*v = vv

        return nil</span>
}

func (v Tags) MarshalJSON() ([]byte, error) <span class="cov8" title="1">{
        return tcodec.Marshal(v)
}</span>
</pre>
		
		<pre class="file" id="file207" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package images provides template functions for manipulating images.
package images

import (
        "fmt"

        "github.com/gohugoio/hugo/common/hugio"
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/resources/resource"

        "github.com/disintegration/gift"
        "github.com/spf13/cast"
)

// Increment for re-generation of images using these filters.
const filterAPIVersion = 0

type Filters struct {
}

// Overlay creates a filter that overlays src at position x y.
func (*Filters) Overlay(src ImageSource, x, y interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(src.Key(), x, y),
                Filter:  overlayFilter{src: src, x: cast.ToInt(x), y: cast.ToInt(y)},
        }
}</span>

// Text creates a filter that draws text with the given options.
func (*Filters) Text(text string, options ...interface{}) gift.Filter <span class="cov0" title="0">{
        tf := textFilter{
                text:        text,
                color:       "#ffffff",
                size:        20,
                x:           10,
                y:           10,
                linespacing: 2,
        }

        var opt maps.Params
        if len(options) &gt; 0 </span><span class="cov0" title="0">{
                opt = maps.MustToParamsAndPrepare(options[0])
                for option, v := range opt </span><span class="cov0" title="0">{
                        switch option </span>{
                        case "color":<span class="cov0" title="0">
                                tf.color = cast.ToString(v)</span>
                        case "size":<span class="cov0" title="0">
                                tf.size = cast.ToFloat64(v)</span>
                        case "x":<span class="cov0" title="0">
                                tf.x = cast.ToInt(v)</span>
                        case "y":<span class="cov0" title="0">
                                tf.y = cast.ToInt(v)</span>
                        case "linespacing":<span class="cov0" title="0">
                                tf.linespacing = cast.ToInt(v)</span>
                        case "font":<span class="cov0" title="0">
                                if err, ok := v.(error); ok </span><span class="cov0" title="0">{
                                        panic(fmt.Sprintf("invalid font source: %s", err))</span>
                                }
                                <span class="cov0" title="0">fontSource, ok1 := v.(hugio.ReadSeekCloserProvider)
                                identifier, ok2 := v.(resource.Identifier)

                                if !(ok1 &amp;&amp; ok2) </span><span class="cov0" title="0">{
                                        panic(fmt.Sprintf("invalid text font source: %T", v))</span>
                                }

                                <span class="cov0" title="0">tf.fontSource = fontSource

                                // The input value isn't hashable and will not make a stable key.
                                // Replace it with a string in the map used as basis for the
                                // hash string.
                                opt["font"] = identifier.Key()</span>

                        }
                }
        }

        <span class="cov0" title="0">return filter{
                Options: newFilterOpts(text, opt),
                Filter:  tf,
        }</span>
}

// Brightness creates a filter that changes the brightness of an image.
// The percentage parameter must be in range (-100, 100).
func (*Filters) Brightness(percentage interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(percentage),
                Filter:  gift.Brightness(cast.ToFloat32(percentage)),
        }
}</span>

// ColorBalance creates a filter that changes the color balance of an image.
// The percentage parameters for each color channel (red, green, blue) must be in range (-100, 500).
func (*Filters) ColorBalance(percentageRed, percentageGreen, percentageBlue interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(percentageRed, percentageGreen, percentageBlue),
                Filter:  gift.ColorBalance(cast.ToFloat32(percentageRed), cast.ToFloat32(percentageGreen), cast.ToFloat32(percentageBlue)),
        }
}</span>

// Colorize creates a filter that produces a colorized version of an image.
// The hue parameter is the angle on the color wheel, typically in range (0, 360).
// The saturation parameter must be in range (0, 100).
// The percentage parameter specifies the strength of the effect, it must be in range (0, 100).
func (*Filters) Colorize(hue, saturation, percentage interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(hue, saturation, percentage),
                Filter:  gift.Colorize(cast.ToFloat32(hue), cast.ToFloat32(saturation), cast.ToFloat32(percentage)),
        }
}</span>

// Contrast creates a filter that changes the contrast of an image.
// The percentage parameter must be in range (-100, 100).
func (*Filters) Contrast(percentage interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(percentage),
                Filter:  gift.Contrast(cast.ToFloat32(percentage)),
        }
}</span>

// Gamma creates a filter that performs a gamma correction on an image.
// The gamma parameter must be positive. Gamma = 1 gives the original image.
// Gamma less than 1 darkens the image and gamma greater than 1 lightens it.
func (*Filters) Gamma(gamma interface{}) gift.Filter <span class="cov8" title="1">{
        return filter{
                Options: newFilterOpts(gamma),
                Filter:  gift.Gamma(cast.ToFloat32(gamma)),
        }
}</span>

// GaussianBlur creates a filter that applies a gaussian blur to an image.
func (*Filters) GaussianBlur(sigma interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(sigma),
                Filter:  gift.GaussianBlur(cast.ToFloat32(sigma)),
        }
}</span>

// Grayscale creates a filter that produces a grayscale version of an image.
func (*Filters) Grayscale() gift.Filter <span class="cov8" title="1">{
        return filter{
                Filter: gift.Grayscale(),
        }
}</span>

// Hue creates a filter that rotates the hue of an image.
// The hue angle shift is typically in range -180 to 180.
func (*Filters) Hue(shift interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(shift),
                Filter:  gift.Hue(cast.ToFloat32(shift)),
        }
}</span>

// Invert creates a filter that negates the colors of an image.
func (*Filters) Invert() gift.Filter <span class="cov8" title="1">{
        return filter{
                Filter: gift.Invert(),
        }
}</span>

// Pixelate creates a filter that applies a pixelation effect to an image.
func (*Filters) Pixelate(size interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(size),
                Filter:  gift.Pixelate(cast.ToInt(size)),
        }
}</span>

// Saturation creates a filter that changes the saturation of an image.
func (*Filters) Saturation(percentage interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(percentage),
                Filter:  gift.Saturation(cast.ToFloat32(percentage)),
        }
}</span>

// Sepia creates a filter that produces a sepia-toned version of an image.
func (*Filters) Sepia(percentage interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(percentage),
                Filter:  gift.Sepia(cast.ToFloat32(percentage)),
        }
}</span>

// Sigmoid creates a filter that changes the contrast of an image using a sigmoidal function and returns the adjusted image.
// It's a non-linear contrast change useful for photo adjustments as it preserves highlight and shadow detail.
func (*Filters) Sigmoid(midpoint, factor interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(midpoint, factor),
                Filter:  gift.Sigmoid(cast.ToFloat32(midpoint), cast.ToFloat32(factor)),
        }
}</span>

// UnsharpMask creates a filter that sharpens an image.
// The sigma parameter is used in a gaussian function and affects the radius of effect.
// Sigma must be positive. Sharpen radius roughly equals 3 * sigma.
// The amount parameter controls how much darker and how much lighter the edge borders become. Typically between 0.5 and 1.5.
// The threshold parameter controls the minimum brightness change that will be sharpened. Typically between 0 and 0.05.
func (*Filters) UnsharpMask(sigma, amount, threshold interface{}) gift.Filter <span class="cov0" title="0">{
        return filter{
                Options: newFilterOpts(sigma, amount, threshold),
                Filter:  gift.UnsharpMask(cast.ToFloat32(sigma), cast.ToFloat32(amount), cast.ToFloat32(threshold)),
        }
}</span>

type filter struct {
        Options filterOpts
        gift.Filter
}

// For cache-busting.
type filterOpts struct {
        Version int
        Vals    interface{}
}

func newFilterOpts(vals ...interface{}) filterOpts <span class="cov8" title="1">{
        return filterOpts{
                Version: filterAPIVersion,
                Vals:    vals,
        }
}</span>
</pre>
		
		<pre class="file" id="file208" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import (
        "fmt"
        "image"
        "image/color"
        "image/draw"
        "image/gif"
        "image/jpeg"
        "image/png"
        "io"
        "sync"

        "github.com/bep/gowebp/libwebp/webpoptions"
        "github.com/gohugoio/hugo/resources/images/webp"

        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/resources/images/exif"

        "github.com/disintegration/gift"
        "golang.org/x/image/bmp"
        "golang.org/x/image/tiff"

        "github.com/gohugoio/hugo/common/hugio"
        "github.com/pkg/errors"
)

func NewImage(f Format, proc *ImageProcessor, img image.Image, s Spec) *Image <span class="cov0" title="0">{
        if img != nil </span><span class="cov0" title="0">{
                return &amp;Image{
                        Format: f,
                        Proc:   proc,
                        Spec:   s,
                        imageConfig: &amp;imageConfig{
                                config:       imageConfigFromImage(img),
                                configLoaded: true,
                        },
                }
        }</span>
        <span class="cov0" title="0">return &amp;Image{Format: f, Proc: proc, Spec: s, imageConfig: &amp;imageConfig{}}</span>
}

type Image struct {
        Format Format
        Proc   *ImageProcessor
        Spec   Spec
        *imageConfig
}

func (i *Image) EncodeTo(conf ImageConfig, img image.Image, w io.Writer) error <span class="cov0" title="0">{
        switch conf.TargetFormat </span>{
        case JPEG:<span class="cov0" title="0">

                var rgba *image.RGBA
                quality := conf.Quality

                if nrgba, ok := img.(*image.NRGBA); ok </span><span class="cov0" title="0">{
                        if nrgba.Opaque() </span><span class="cov0" title="0">{
                                rgba = &amp;image.RGBA{
                                        Pix:    nrgba.Pix,
                                        Stride: nrgba.Stride,
                                        Rect:   nrgba.Rect,
                                }
                        }</span>
                }
                <span class="cov0" title="0">if rgba != nil </span><span class="cov0" title="0">{
                        return jpeg.Encode(w, rgba, &amp;jpeg.Options{Quality: quality})
                }</span>
                <span class="cov0" title="0">return jpeg.Encode(w, img, &amp;jpeg.Options{Quality: quality})</span>
        case PNG:<span class="cov0" title="0">
                encoder := png.Encoder{CompressionLevel: png.DefaultCompression}
                return encoder.Encode(w, img)</span>

        case GIF:<span class="cov0" title="0">
                return gif.Encode(w, img, &amp;gif.Options{
                        NumColors: 256,
                })</span>
        case TIFF:<span class="cov0" title="0">
                return tiff.Encode(w, img, &amp;tiff.Options{Compression: tiff.Deflate, Predictor: true})</span>

        case BMP:<span class="cov0" title="0">
                return bmp.Encode(w, img)</span>
        case WEBP:<span class="cov0" title="0">
                return webp.Encode(
                        w,
                        img, webpoptions.EncodingOptions{
                                Quality:        conf.Quality,
                                EncodingPreset: webpoptions.EncodingPreset(conf.Hint),
                                UseSharpYuv:    true,
                        },
                )</span>
        default:<span class="cov0" title="0">
                return errors.New("format not supported")</span>
        }
}

// Height returns i's height.
func (i *Image) Height() int <span class="cov0" title="0">{
        i.initConfig()
        return i.config.Height
}</span>

// Width returns i's width.
func (i *Image) Width() int <span class="cov0" title="0">{
        i.initConfig()
        return i.config.Width
}</span>

func (i Image) WithImage(img image.Image) *Image <span class="cov0" title="0">{
        i.Spec = nil
        i.imageConfig = &amp;imageConfig{
                config:       imageConfigFromImage(img),
                configLoaded: true,
        }

        return &amp;i
}</span>

func (i Image) WithSpec(s Spec) *Image <span class="cov0" title="0">{
        i.Spec = s
        i.imageConfig = &amp;imageConfig{}
        return &amp;i
}</span>

// InitConfig reads the image config from the given reader.
func (i *Image) InitConfig(r io.Reader) error <span class="cov0" title="0">{
        var err error
        i.configInit.Do(func() </span><span class="cov0" title="0">{
                i.config, _, err = image.DecodeConfig(r)
        }</span>)
        <span class="cov0" title="0">return err</span>
}

func (i *Image) initConfig() error <span class="cov0" title="0">{
        var err error
        i.configInit.Do(func() </span><span class="cov0" title="0">{
                if i.configLoaded </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov0" title="0">var f hugio.ReadSeekCloser

                f, err = i.Spec.ReadSeekCloser()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov0" title="0">defer f.Close()

                i.config, _, err = image.DecodeConfig(f)</span>
        })

        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return errors.Wrap(err, "failed to load image config")
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func NewImageProcessor(cfg ImagingConfig) (*ImageProcessor, error) <span class="cov0" title="0">{
        e := cfg.Cfg.Exif
        exifDecoder, err := exif.NewDecoder(
                exif.WithDateDisabled(e.DisableDate),
                exif.WithLatLongDisabled(e.DisableLatLong),
                exif.ExcludeFields(e.ExcludeFields),
                exif.IncludeFields(e.IncludeFields),
        )
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return &amp;ImageProcessor{
                Cfg:         cfg,
                exifDecoder: exifDecoder,
        }, nil</span>
}

type ImageProcessor struct {
        Cfg         ImagingConfig
        exifDecoder *exif.Decoder
}

func (p *ImageProcessor) DecodeExif(r io.Reader) (*exif.Exif, error) <span class="cov0" title="0">{
        return p.exifDecoder.Decode(r)
}</span>

func (p *ImageProcessor) ApplyFiltersFromConfig(src image.Image, conf ImageConfig) (image.Image, error) <span class="cov0" title="0">{
        var filters []gift.Filter

        if conf.Rotate != 0 </span><span class="cov0" title="0">{
                // Apply any rotation before any resize.
                filters = append(filters, gift.Rotate(float32(conf.Rotate), color.Transparent, gift.NearestNeighborInterpolation))
        }</span>

        <span class="cov0" title="0">switch conf.Action </span>{
        case "resize":<span class="cov0" title="0">
                filters = append(filters, gift.Resize(conf.Width, conf.Height, conf.Filter))</span>
        case "fill":<span class="cov0" title="0">
                if conf.AnchorStr == smartCropIdentifier </span><span class="cov0" title="0">{
                        bounds, err := p.smartCrop(src, conf.Width, conf.Height, conf.Filter)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        // First crop it, then resize it.
                        <span class="cov0" title="0">filters = append(filters, gift.Crop(bounds))
                        filters = append(filters, gift.Resize(conf.Width, conf.Height, conf.Filter))</span>

                } else<span class="cov0" title="0"> {
                        filters = append(filters, gift.ResizeToFill(conf.Width, conf.Height, conf.Filter, conf.Anchor))
                }</span>
        case "fit":<span class="cov0" title="0">
                filters = append(filters, gift.ResizeToFit(conf.Width, conf.Height, conf.Filter))</span>
        default:<span class="cov0" title="0">
                return nil, errors.Errorf("unsupported action: %q", conf.Action)</span>
        }

        <span class="cov0" title="0">img, err := p.Filter(src, filters...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">return img, nil</span>
}

func (p *ImageProcessor) Filter(src image.Image, filters ...gift.Filter) (image.Image, error) <span class="cov0" title="0">{
        g := gift.New(filters...)
        bounds := g.Bounds(src.Bounds())
        var dst draw.Image
        switch src.(type) </span>{
        case *image.RGBA:<span class="cov0" title="0">
                dst = image.NewRGBA(bounds)</span>
        case *image.NRGBA:<span class="cov0" title="0">
                dst = image.NewNRGBA(bounds)</span>
        case *image.Gray:<span class="cov0" title="0">
                dst = image.NewGray(bounds)</span>
        default:<span class="cov0" title="0">
                dst = image.NewNRGBA(bounds)</span>
        }
        <span class="cov0" title="0">g.Draw(dst, src)
        return dst, nil</span>
}

func GetDefaultImageConfig(action string, defaults ImagingConfig) ImageConfig <span class="cov8" title="1">{
        return ImageConfig{
                Action:  action,
                Hint:    defaults.Hint,
                Quality: defaults.Cfg.Quality,
        }
}</span>

type Spec interface {
        // Loads the image source.
        ReadSeekCloser() (hugio.ReadSeekCloser, error)
}

// Format is an image file format.
type Format int

const (
        JPEG Format = iota + 1
        PNG
        GIF
        TIFF
        BMP
        WEBP
)

// RequiresDefaultQuality returns if the default quality needs to be applied to
// images of this format.
func (f Format) RequiresDefaultQuality() bool <span class="cov0" title="0">{
        return f == JPEG || f == WEBP
}</span>

// SupportsTransparency reports whether it supports transparency in any form.
func (f Format) SupportsTransparency() bool <span class="cov0" title="0">{
        return f != JPEG
}</span>

// DefaultExtension returns the default file extension of this format, starting with a dot.
// For example: .jpg for JPEG
func (f Format) DefaultExtension() string <span class="cov0" title="0">{
        return f.MediaType().FirstSuffix.FullSuffix
}</span>

// MediaType returns the media type of this image, e.g. image/jpeg for JPEG
func (f Format) MediaType() media.Type <span class="cov0" title="0">{
        switch f </span>{
        case JPEG:<span class="cov0" title="0">
                return media.JPEGType</span>
        case PNG:<span class="cov0" title="0">
                return media.PNGType</span>
        case GIF:<span class="cov0" title="0">
                return media.GIFType</span>
        case TIFF:<span class="cov0" title="0">
                return media.TIFFType</span>
        case BMP:<span class="cov0" title="0">
                return media.BMPType</span>
        case WEBP:<span class="cov0" title="0">
                return media.WEBPType</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("%d is not a valid image format", f))</span>
        }
}

type imageConfig struct {
        config       image.Config
        configInit   sync.Once
        configLoaded bool
}

func imageConfigFromImage(img image.Image) image.Config <span class="cov0" title="0">{
        b := img.Bounds()
        return image.Config{Width: b.Max.X, Height: b.Max.Y}
}</span>

func ToFilters(in interface{}) []gift.Filter <span class="cov0" title="0">{
        switch v := in.(type) </span>{
        case []gift.Filter:<span class="cov0" title="0">
                return v</span>
        case []filter:<span class="cov0" title="0">
                vv := make([]gift.Filter, len(v))
                for i, f := range v </span><span class="cov0" title="0">{
                        vv[i] = f
                }</span>
                <span class="cov0" title="0">return vv</span>
        case gift.Filter:<span class="cov0" title="0">
                return []gift.Filter{v}</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("%T is not an image filter", in))</span>
        }
}

// IsOpaque returns false if the image has alpha channel and there is at least 1
// pixel that is not (fully) opaque.
func IsOpaque(img image.Image) bool <span class="cov0" title="0">{
        if oim, ok := img.(interface {
                Opaque() bool
        }); ok </span><span class="cov0" title="0">{
                return oim.Opaque()
        }</span>

        <span class="cov0" title="0">return false</span>
}

// ImageSource identifies and decodes an image.
type ImageSource interface {
        DecodeImage() (image.Image, error)
        Key() string
}
</pre>
		
		<pre class="file" id="file209" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import (
        "fmt"
        "image"
        "image/draw"

        "github.com/disintegration/gift"
)

var _ gift.Filter = (*overlayFilter)(nil)

type overlayFilter struct {
        src  ImageSource
        x, y int
}

func (f overlayFilter) Draw(dst draw.Image, src image.Image, options *gift.Options) <span class="cov0" title="0">{
        overlaySrc, err := f.src.DecodeImage()
        if err != nil </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("failed to decode image: %s", err))</span>
        }

        <span class="cov0" title="0">gift.New().Draw(dst, src)
        gift.New().DrawAt(dst, overlaySrc, image.Pt(f.x, f.y), gift.OverOperator)</span>
}

func (f overlayFilter) Bounds(srcBounds image.Rectangle) image.Rectangle <span class="cov0" title="0">{
        return image.Rect(0, 0, srcBounds.Dx(), srcBounds.Dy())
}</span>
</pre>
		
		<pre class="file" id="file210" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import "math"

// We moved from imaging to the gift package for image processing at some point.
// That package had more, but also less resampling filters. So we add the missing
// ones here. They are fairly exotic, but someone may use them, so keep them here
// for now.
//
// The filters below are ported from https://github.com/disintegration/imaging/blob/9aab30e6aa535fe3337b489b76759ef97dfaf362/resize.go#L369
// MIT License.

var (
        // Hermite cubic spline filter (BC-spline; B=0; C=0).
        hermiteResampling = resamp{
                name:    "Hermite",
                support: 1.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 1.0 </span><span class="cov0" title="0">{
                                return bcspline(x, 0.0, 0.0)
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // Mitchell-Netravali cubic filter (BC-spline; B=1/3; C=1/3).
        mitchellNetravaliResampling = resamp{
                name:    "MitchellNetravali",
                support: 2.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 2.0 </span><span class="cov0" title="0">{
                                return bcspline(x, 1.0/3.0, 1.0/3.0)
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // Catmull-Rom - sharp cubic filter (BC-spline; B=0; C=0.5).
        catmullRomResampling = resamp{
                name:    "CatmullRomResampling",
                support: 2.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 2.0 </span><span class="cov0" title="0">{
                                return bcspline(x, 0.0, 0.5)
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // BSpline is a smooth cubic filter (BC-spline; B=1; C=0).
        bSplineResampling = resamp{
                name:    "BSplineResampling",
                support: 2.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 2.0 </span><span class="cov0" title="0">{
                                return bcspline(x, 1.0, 0.0)
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // Gaussian blurring filter.
        gaussianResampling = resamp{
                name:    "GaussianResampling",
                support: 2.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 2.0 </span><span class="cov0" title="0">{
                                return float32(math.Exp(float64(-2 * x * x)))
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        //  Hann-windowed sinc filter (3 lobes).
        hannResampling = resamp{
                name:    "HannResampling",
                support: 3.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 3.0 </span><span class="cov0" title="0">{
                                return sinc(x) * float32(0.5+0.5*math.Cos(math.Pi*float64(x)/3.0))
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        hammingResampling = resamp{
                name:    "HammingResampling",
                support: 3.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 3.0 </span><span class="cov0" title="0">{
                                return sinc(x) * float32(0.54+0.46*math.Cos(math.Pi*float64(x)/3.0))
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // Blackman-windowed sinc filter (3 lobes).
        blackmanResampling = resamp{
                name:    "BlackmanResampling",
                support: 3.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 3.0 </span><span class="cov0" title="0">{
                                return sinc(x) * float32(0.42-0.5*math.Cos(math.Pi*float64(x)/3.0+math.Pi)+0.08*math.Cos(2.0*math.Pi*float64(x)/3.0))
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        bartlettResampling = resamp{
                name:    "BartlettResampling",
                support: 3.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 3.0 </span><span class="cov0" title="0">{
                                return sinc(x) * (3.0 - x) / 3.0
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // Welch-windowed sinc filter (parabolic window, 3 lobes).
        welchResampling = resamp{
                name:    "WelchResampling",
                support: 3.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 3.0 </span><span class="cov0" title="0">{
                                return sinc(x) * (1.0 - (x * x / 9.0))
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }

        // Cosine-windowed sinc filter (3 lobes).
        cosineResampling = resamp{
                name:    "CosineResampling",
                support: 3.0,
                kernel: func(x float32) float32 <span class="cov0" title="0">{
                        x = absf32(x)
                        if x &lt; 3.0 </span><span class="cov0" title="0">{
                                return sinc(x) * float32(math.Cos((math.Pi/2.0)*(float64(x)/3.0)))
                        }</span>
                        <span class="cov0" title="0">return 0</span>
                },
        }
)

// The following code is borrowed from https://raw.githubusercontent.com/disintegration/gift/master/resize.go
// MIT licensed.
type resamp struct {
        name    string
        support float32
        kernel  func(float32) float32
}

func (r resamp) String() string <span class="cov8" title="1">{
        return r.name
}</span>

func (r resamp) Support() float32 <span class="cov0" title="0">{
        return r.support
}</span>

func (r resamp) Kernel(x float32) float32 <span class="cov0" title="0">{
        return r.kernel(x)
}</span>

func bcspline(x, b, c float32) float32 <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                x = -x
        }</span>
        <span class="cov0" title="0">if x &lt; 1 </span><span class="cov0" title="0">{
                return ((12-9*b-6*c)*x*x*x + (-18+12*b+6*c)*x*x + (6 - 2*b)) / 6
        }</span>
        <span class="cov0" title="0">if x &lt; 2 </span><span class="cov0" title="0">{
                return ((-b-6*c)*x*x*x + (6*b+30*c)*x*x + (-12*b-48*c)*x + (8*b + 24*c)) / 6
        }</span>
        <span class="cov0" title="0">return 0</span>
}

func absf32(x float32) float32 <span class="cov0" title="0">{
        if x &lt; 0 </span><span class="cov0" title="0">{
                return -x
        }</span>
        <span class="cov0" title="0">return x</span>
}

func sinc(x float32) float32 <span class="cov0" title="0">{
        if x == 0 </span><span class="cov0" title="0">{
                return 1
        }</span>
        <span class="cov0" title="0">return float32(math.Sin(math.Pi*float64(x)) / (math.Pi * float64(x)))</span>
}
</pre>
		
		<pre class="file" id="file211" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import (
        "image"
        "math"

        "github.com/disintegration/gift"

        "github.com/muesli/smartcrop"
)

const (
        // Do not change.
        smartCropIdentifier = "smart"

        // This is just a increment, starting on 1. If Smart Crop improves its cropping, we
        // need a way to trigger a re-generation of the crops in the wild, so increment this.
        smartCropVersionNumber = 1
)

func (p *ImageProcessor) newSmartCropAnalyzer(filter gift.Resampling) smartcrop.Analyzer <span class="cov0" title="0">{
        return smartcrop.NewAnalyzer(imagingResizer{p: p, filter: filter})
}</span>

// Needed by smartcrop
type imagingResizer struct {
        p      *ImageProcessor
        filter gift.Resampling
}

func (r imagingResizer) Resize(img image.Image, width, height uint) image.Image <span class="cov0" title="0">{
        // See https://github.com/gohugoio/hugo/issues/7955#issuecomment-861710681
        scaleX, scaleY := calcFactorsNfnt(width, height, float64(img.Bounds().Dx()), float64(img.Bounds().Dy()))
        if width == 0 </span><span class="cov0" title="0">{
                width = uint(math.Ceil(float64(img.Bounds().Dx()) / scaleX))
        }</span>
        <span class="cov0" title="0">if height == 0 </span><span class="cov0" title="0">{
                height = uint(math.Ceil(float64(img.Bounds().Dy()) / scaleY))
        }</span>
        <span class="cov0" title="0">result, _ := r.p.Filter(img, gift.Resize(int(width), int(height), r.filter))
        return result</span>
}

func (p *ImageProcessor) smartCrop(img image.Image, width, height int, filter gift.Resampling) (image.Rectangle, error) <span class="cov0" title="0">{
        if width &lt;= 0 || height &lt;= 0 </span><span class="cov0" title="0">{
                return image.Rectangle{}, nil
        }</span>

        <span class="cov0" title="0">srcBounds := img.Bounds()
        srcW := srcBounds.Dx()
        srcH := srcBounds.Dy()

        if srcW &lt;= 0 || srcH &lt;= 0 </span><span class="cov0" title="0">{
                return image.Rectangle{}, nil
        }</span>

        <span class="cov0" title="0">if srcW == width &amp;&amp; srcH == height </span><span class="cov0" title="0">{
                return srcBounds, nil
        }</span>

        <span class="cov0" title="0">smart := p.newSmartCropAnalyzer(filter)

        rect, err := smart.FindBestCrop(img, width, height)
        if err != nil </span><span class="cov0" title="0">{
                return image.Rectangle{}, err
        }</span>

        <span class="cov0" title="0">return img.Bounds().Intersect(rect), nil</span>
}

// Calculates scaling factors using old and new image dimensions.
// Code borrowed from https://github.com/nfnt/resize/blob/83c6a9932646f83e3267f353373d47347b6036b2/resize.go#L593
func calcFactorsNfnt(width, height uint, oldWidth, oldHeight float64) (scaleX, scaleY float64) <span class="cov0" title="0">{
        if width == 0 </span><span class="cov0" title="0">{
                if height == 0 </span><span class="cov0" title="0">{
                        scaleX = 1.0
                        scaleY = 1.0
                }</span> else<span class="cov0" title="0"> {
                        scaleY = oldHeight / float64(height)
                        scaleX = scaleY
                }</span>
        } else<span class="cov0" title="0"> {
                scaleX = oldWidth / float64(width)
                if height == 0 </span><span class="cov0" title="0">{
                        scaleY = scaleX
                }</span> else<span class="cov0" title="0"> {
                        scaleY = oldHeight / float64(height)
                }</span>
        }
        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file212" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import (
        "image"
        "image/draw"
        "io"
        "strings"

        "github.com/disintegration/gift"
        "github.com/gohugoio/hugo/common/hugio"

        "golang.org/x/image/font"
        "golang.org/x/image/font/gofont/goregular"
        "golang.org/x/image/font/opentype"
        "golang.org/x/image/math/fixed"
)

var _ gift.Filter = (*textFilter)(nil)

type textFilter struct {
        text, color string
        x, y        int
        size        float64
        linespacing int
        fontSource  hugio.ReadSeekCloserProvider
}

func (f textFilter) Draw(dst draw.Image, src image.Image, options *gift.Options) <span class="cov0" title="0">{
        color, err := hexStringToColor(f.color)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Load and parse font
        <span class="cov0" title="0">ttf := goregular.TTF
        if f.fontSource != nil </span><span class="cov0" title="0">{
                rs, err := f.fontSource.ReadSeekCloser()
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov0" title="0">defer rs.Close()
                ttf, err = io.ReadAll(rs)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
        }
        <span class="cov0" title="0">otf, err := opentype.Parse(ttf)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        // Set font options
        <span class="cov0" title="0">face, err := opentype.NewFace(otf, &amp;opentype.FaceOptions{
                Size:    f.size,
                DPI:     72,
                Hinting: font.HintingNone,
        })
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }

        <span class="cov0" title="0">d := font.Drawer{
                Dst:  dst,
                Src:  image.NewUniform(color),
                Face: face,
        }

        gift.New().Draw(dst, src)

        // Draw text, consider and include linebreaks
        maxWidth := dst.Bounds().Dx() - 20
        fontHeight := face.Metrics().Ascent.Ceil()

        // Correct y position based on font and size
        f.y = f.y + fontHeight

        // Start position
        y := f.y
        d.Dot = fixed.P(f.x, f.y)

        // Draw text and break line at max width
        parts := strings.Fields(f.text)
        for _, str := range parts </span><span class="cov0" title="0">{
                strWith := font.MeasureString(face, str)
                if (d.Dot.X.Ceil() + strWith.Ceil()) &gt;= maxWidth </span><span class="cov0" title="0">{
                        y = y + fontHeight + f.linespacing
                        d.Dot = fixed.P(f.x, y)
                }</span>
                <span class="cov0" title="0">d.DrawString(str + " ")</span>
        }
}

func (f textFilter) Bounds(srcBounds image.Rectangle) image.Rectangle <span class="cov0" title="0">{
        return image.Rect(0, 0, srcBounds.Dx(), srcBounds.Dy())
}</span>
</pre>
		
		<pre class="file" id="file213" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package internal

import "github.com/gohugoio/hugo/helpers"

// ResourceTransformationKey are provided by the different transformation implementations.
// It identifies the transformation (name) and its configuration (elements).
// We combine this in a chain with the rest of the transformations
// with the target filename and a content hash of the origin to use as cache key.
type ResourceTransformationKey struct {
        Name     string
        elements []interface{}
}

// NewResourceTransformationKey creates a new ResourceTransformationKey from the transformation
// name and elements. We will create a 64 bit FNV hash from the elements, which when combined
// with the other key elements should be unique for all practical applications.
func NewResourceTransformationKey(name string, elements ...interface{}) ResourceTransformationKey <span class="cov8" title="1">{
        return ResourceTransformationKey{Name: name, elements: elements}
}</span>

// Value returns the Key as a string.
// Do not change this without good reasons.
func (k ResourceTransformationKey) Value() string <span class="cov8" title="1">{
        if len(k.elements) == 0 </span><span class="cov0" title="0">{
                return k.Name
        }</span>

        <span class="cov8" title="1">return k.Name + "_" + helpers.HashString(k.elements...)</span>
}
</pre>
		
		<pre class="file" id="file214" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package jsconfig

import (
        "path/filepath"
        "sort"
        "sync"
)

// Builder builds a jsconfig.json file that, currently, is used only to assist
// intellinsense in editors.
type Builder struct {
        sourceRootsMu sync.RWMutex
        sourceRoots   map[string]bool
}

// NewBuilder creates a new Builder.
func NewBuilder() *Builder <span class="cov8" title="1">{
        return &amp;Builder{sourceRoots: make(map[string]bool)}
}</span>

// Build builds a new Config with paths relative to dir.
// This method is thread safe.
func (b *Builder) Build(dir string) *Config <span class="cov8" title="1">{
        b.sourceRootsMu.RLock()
        defer b.sourceRootsMu.RUnlock()

        if len(b.sourceRoots) == 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">conf := newJSConfig()

        var roots []string
        for root := range b.sourceRoots </span><span class="cov8" title="1">{
                rel, err := filepath.Rel(dir, filepath.Join(root, "*"))
                if err == nil </span><span class="cov8" title="1">{
                        roots = append(roots, rel)
                }</span>
        }
        <span class="cov8" title="1">sort.Strings(roots)
        conf.CompilerOptions.Paths["*"] = roots

        return conf</span>
}

// AddSourceRoot adds a new source root.
// This method is thread safe.
func (b *Builder) AddSourceRoot(root string) <span class="cov8" title="1">{
        b.sourceRootsMu.RLock()
        found := b.sourceRoots[root]
        b.sourceRootsMu.RUnlock()

        if found </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">b.sourceRootsMu.Lock()
        b.sourceRoots[root] = true
        b.sourceRootsMu.Unlock()</span>
}

// CompilerOptions holds compilerOptions for jsonconfig.json.
type CompilerOptions struct {
        BaseURL string              `json:"baseUrl"`
        Paths   map[string][]string `json:"paths"`
}

// Config holds the data for jsconfig.json.
type Config struct {
        CompilerOptions CompilerOptions `json:"compilerOptions"`
}

func newJSConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                CompilerOptions: CompilerOptions{
                        BaseURL: ".",
                        Paths:   make(map[string][]string),
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file215" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package page contains the core interfaces and types for the Page resource,
// a core component in Hugo.
package page

import (
        "html/template"

        "github.com/gohugoio/hugo/identity"

        "github.com/bep/gitmap"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/tpl"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/compare"
        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/gohugoio/hugo/navigation"
        "github.com/gohugoio/hugo/related"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/gohugoio/hugo/source"
)

// Clear clears any global package state.
func Clear() error <span class="cov0" title="0">{
        spc.clear()
        return nil
}</span>

// AlternativeOutputFormatsProvider provides alternative output formats for a
// Page.
type AlternativeOutputFormatsProvider interface {
        // AlternativeOutputFormats gives the alternative output formats for the
        // current output.
        // Note that we use the term "alternative" and not "alternate" here, as it
        // does not necessarily replace the other format, it is an alternative representation.
        AlternativeOutputFormats() OutputFormats
}

// AuthorProvider provides author information.
type AuthorProvider interface {
        Author() Author
        Authors() AuthorList
}

// ChildCareProvider provides accessors to child resources.
type ChildCareProvider interface {
        Pages() Pages

        // RegularPages returns a list of pages of kind 'Page'.
        // In Hugo 0.57 we changed the Pages method so it returns all page
        // kinds, even sections. If you want the old behaviour, you can
        // use RegularPages.
        RegularPages() Pages

        // RegularPagesRecursive returns all regular pages below the current
        // section.
        RegularPagesRecursive() Pages

        Resources() resource.Resources
}

// ContentProvider provides the content related values for a Page.
type ContentProvider interface {
        Content() (interface{}, error)
        Plain() string
        PlainWords() []string
        Summary() template.HTML
        Truncated() bool
        FuzzyWordCount() int
        WordCount() int
        ReadingTime() int
        Len() int
}

// FileProvider provides the source file.
type FileProvider interface {
        File() source.File
}

// GetPageProvider provides the GetPage method.
type GetPageProvider interface {
        // GetPage looks up a page for the given ref.
        //    {{ with .GetPage "blog" }}{{ .Title }}{{ end }}
        //
        // This will return nil when no page could be found, and will return
        // an error if the ref is ambiguous.
        GetPage(ref string) (Page, error)

        // GetPageWithTemplateInfo is for internal use only.
        GetPageWithTemplateInfo(info tpl.Info, ref string) (Page, error)
}

// GitInfoProvider provides Git info.
type GitInfoProvider interface {
        GitInfo() *gitmap.GitInfo
}

// InSectionPositioner provides section navigation.
type InSectionPositioner interface {
        NextInSection() Page
        PrevInSection() Page
}

// InternalDependencies is considered an internal interface.
type InternalDependencies interface {
        GetRelatedDocsHandler() *RelatedDocsHandler
}

// OutputFormatsProvider provides the OutputFormats of a Page.
type OutputFormatsProvider interface {
        OutputFormats() OutputFormats
}

// Page is the core interface in Hugo.
type Page interface {
        ContentProvider
        TableOfContentsProvider
        PageWithoutContent
}

// PageMetaProvider provides page metadata, typically provided via front matter.
type PageMetaProvider interface {
        // The 4 page dates
        resource.Dated

        // Aliases forms the base for redirects generation.
        Aliases() []string

        // BundleType returns the bundle type: "leaf", "branch" or an empty string if it is none.
        // See https://gohugo.io/content-management/page-bundles/
        BundleType() files.ContentClass

        // A configured description.
        Description() string

        // Whether this is a draft. Will only be true if run with the --buildDrafts (-D) flag.
        Draft() bool

        // IsHome returns whether this is the home page.
        IsHome() bool

        // Configured keywords.
        Keywords() []string

        // The Page Kind. One of page, home, section, taxonomy, term.
        Kind() string

        // The configured layout to use to render this page. Typically set in front matter.
        Layout() string

        // The title used for links.
        LinkTitle() string

        // IsNode returns whether this is an item of one of the list types in Hugo,
        // i.e. not a regular content
        IsNode() bool

        // IsPage returns whether this is a regular content
        IsPage() bool

        // Param looks for a param in Page and then in Site config.
        Param(key interface{}) (interface{}, error)

        // Path gets the relative path, including file name and extension if relevant,
        // to the source of this Page. It will be relative to any content root.
        Path() string

        // This is just a temporary bridge method. Use Path in templates.
        Pathc() string

        // The slug, typically defined in front matter.
        Slug() string

        // This page's language code. Will be the same as the site's.
        Lang() string

        // IsSection returns whether this is a section
        IsSection() bool

        // Section returns the first path element below the content root.
        Section() string

        // Returns a slice of sections (directories if it's a file) to this
        // Page.
        SectionsEntries() []string

        // SectionsPath is SectionsEntries joined with a /.
        SectionsPath() string

        // Sitemap returns the sitemap configuration for this page.
        Sitemap() config.Sitemap

        // Type is a discriminator used to select layouts etc. It is typically set
        // in front matter, but will fall back to the root section.
        Type() string

        // The configured weight, used as the first sort value in the default
        // page sort if non-zero.
        Weight() int
}

// PageRenderProvider provides a way for a Page to render content.
type PageRenderProvider interface {
        Render(layout ...string) (template.HTML, error)
        RenderString(args ...interface{}) (template.HTML, error)
}

// PageWithoutContent is the Page without any of the content methods.
type PageWithoutContent interface {
        RawContentProvider
        resource.Resource
        PageMetaProvider
        resource.LanguageProvider

        // For pages backed by a file.
        FileProvider

        GitInfoProvider

        // Output formats
        OutputFormatsProvider
        AlternativeOutputFormatsProvider

        // Tree navigation
        ChildCareProvider
        TreeProvider

        // Horizontal navigation
        InSectionPositioner
        PageRenderProvider
        PaginatorProvider
        Positioner
        navigation.PageMenusProvider

        // TODO(bep)
        AuthorProvider

        // Page lookups/refs
        GetPageProvider
        RefProvider

        resource.TranslationKeyProvider
        TranslationsProvider

        SitesProvider

        // Helper methods
        ShortcodeInfoProvider
        compare.Eqer
        maps.Scratcher
        RelatedKeywordsProvider

        // GetTerms gets the terms of a given taxonomy,
        // e.g. GetTerms("categories")
        GetTerms(taxonomy string) Pages

        // Used in change/dependency tracking.
        identity.Provider

        DeprecatedWarningPageMethods
}

// Positioner provides next/prev navigation.
type Positioner interface {
        Next() Page
        Prev() Page

        // Deprecated: Use Prev. Will be removed in Hugo 0.57
        PrevPage() Page

        // Deprecated: Use Next. Will be removed in Hugo 0.57
        NextPage() Page
}

// RawContentProvider provides the raw, unprocessed content of the page.
type RawContentProvider interface {
        RawContent() string
}

// RefProvider provides the methods needed to create reflinks to pages.
type RefProvider interface {
        Ref(argsm map[string]interface{}) (string, error)
        RefFrom(argsm map[string]interface{}, source interface{}) (string, error)
        RelRef(argsm map[string]interface{}) (string, error)
        RelRefFrom(argsm map[string]interface{}, source interface{}) (string, error)
}

// RelatedKeywordsProvider allows a Page to be indexed.
type RelatedKeywordsProvider interface {
        // Make it indexable as a related.Document
        RelatedKeywords(cfg related.IndexConfig) ([]related.Keyword, error)
}

// ShortcodeInfoProvider provides info about the shortcodes in a Page.
type ShortcodeInfoProvider interface {
        // HasShortcode return whether the page has a shortcode with the given name.
        // This method is mainly motivated with the Hugo Docs site's need for a list
        // of pages with the `todo` shortcode in it.
        HasShortcode(name string) bool
}

// SitesProvider provide accessors to get sites.
type SitesProvider interface {
        Site() Site
        Sites() Sites
}

// TableOfContentsProvider provides the table of contents for a Page.
type TableOfContentsProvider interface {
        TableOfContents() template.HTML
}

// TranslationsProvider provides access to any translations.
type TranslationsProvider interface {

        // IsTranslated returns whether this content file is translated to
        // other language(s).
        IsTranslated() bool

        // AllTranslations returns all translations, including the current Page.
        AllTranslations() Pages

        // Translations returns the translations excluding the current Page.
        Translations() Pages
}

// TreeProvider provides section tree navigation.
type TreeProvider interface {

        // IsAncestor returns whether the current page is an ancestor of the given
        // Note that this method is not relevant for taxonomy lists and taxonomy terms pages.
        IsAncestor(other interface{}) (bool, error)

        // CurrentSection returns the page's current section or the page itself if home or a section.
        // Note that this will return nil for pages that is not regular, home or section pages.
        CurrentSection() Page

        // IsDescendant returns whether the current page is a descendant of the given
        // Note that this method is not relevant for taxonomy lists and taxonomy terms pages.
        IsDescendant(other interface{}) (bool, error)

        // FirstSection returns the section on level 1 below home, e.g. "/docs".
        // For the home page, this will return itself.
        FirstSection() Page

        // InSection returns whether the given page is in the current section.
        // Note that this will always return false for pages that are
        // not either regular, home or section pages.
        InSection(other interface{}) (bool, error)

        // Parent returns a section's parent section or a page's section.
        // To get a section's subsections, see Page's Sections method.
        Parent() Page

        // Sections returns this section's subsections, if any.
        // Note that for non-sections, this method will always return an empty list.
        Sections() Pages

        // Page returns a reference to the Page itself, kept here mostly
        // for legacy reasons.
        Page() Page
}

// DeprecatedWarningPageMethods lists deprecated Page methods that will trigger
// a WARNING if invoked.
// This was added in Hugo 0.55.
type DeprecatedWarningPageMethods interface { // This was emptied in Hugo 0.93.0.
}

// Move here to trigger ERROR instead of WARNING.
// TODO(bep) create wrappers and put into the Page once it has some methods.
type DeprecatedErrorPageMethods interface{}
</pre>
		
		<pre class="file" id="file216" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package page contains the core interfaces and types for the Page resource,
// a core component in Hugo.
package page

import (
        "fmt"
)

// Data represents the .Data element in a Page in Hugo. We make this
// a type so we can do lazy loading of .Data.Pages
type Data map[string]interface{}

// Pages returns the pages stored with key "pages". If this is a func,
// it will be invoked.
func (d Data) Pages() Pages <span class="cov8" title="1">{
        v, found := d["pages"]
        if !found </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">switch vv := v.(type) </span>{
        case Pages:<span class="cov8" title="1">
                return vv</span>
        case func() Pages:<span class="cov8" title="1">
                return vv()</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("%T is not Pages", v))</span>
        }
}
</pre>
		
		<pre class="file" id="file217" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import "strings"

const (
        KindPage = "page"

        // The rest are node types; home page, sections etc.

        KindHome    = "home"
        KindSection = "section"

        // Note tha before Hugo 0.73 these were confusingly named
        // taxonomy (now: term)
        // taxonomyTerm (now: taxonomy)
        KindTaxonomy = "taxonomy"
        KindTerm     = "term"
)

var kindMap = map[string]string{
        strings.ToLower(KindPage):     KindPage,
        strings.ToLower(KindHome):     KindHome,
        strings.ToLower(KindSection):  KindSection,
        strings.ToLower(KindTaxonomy): KindTaxonomy,
        strings.ToLower(KindTerm):     KindTerm,

        // Legacy, pre v0.53.0.
        "taxonomyterm": KindTaxonomy,
}

// GetKind gets the page kind given a string, empty if not found.
func GetKind(s string) string <span class="cov8" title="1">{
        return kindMap[strings.ToLower(s)]
}</span>
</pre>
		
		<pre class="file" id="file218" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "html/template"

        "github.com/gohugoio/hugo/lazy"
)

// OutputFormatContentProvider represents the method set that is "outputFormat aware" and that we
// provide lazy initialization for in case they get invoked outside of their normal rendering context, e.g. via .Translations.
// Note that this set is currently not complete, but should cover the most common use cases.
// For the others, the implementation will be from the page.NoopPage.
type OutputFormatContentProvider interface {
        ContentProvider
        TableOfContentsProvider
        PageRenderProvider
}

// LazyContentProvider initializes itself when read. Each method of the
// ContentProvider interface initializes a content provider and shares it
// with other methods.
//
// Used in cases where we cannot guarantee whether the content provider
// will be needed. Must create via NewLazyContentProvider.
type LazyContentProvider struct {
        init *lazy.Init
        cp   OutputFormatContentProvider
}

// NewLazyContentProvider returns a LazyContentProvider initialized with
// function f. The resulting LazyContentProvider calls f in order to
// retrieve a ContentProvider
func NewLazyContentProvider(f func() (OutputFormatContentProvider, error)) *LazyContentProvider <span class="cov0" title="0">{
        lcp := LazyContentProvider{
                init: lazy.New(),
                cp:   NopPage,
        }
        lcp.init.Add(func() (interface{}, error) </span><span class="cov0" title="0">{
                cp, err := f()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">lcp.cp = cp
                return nil, nil</span>
        })
        <span class="cov0" title="0">return &amp;lcp</span>
}

func (lcp *LazyContentProvider) Reset() <span class="cov0" title="0">{
        lcp.init.Reset()
}</span>

func (lcp *LazyContentProvider) Content() (interface{}, error) <span class="cov0" title="0">{
        lcp.init.Do()
        return lcp.cp.Content()
}</span>

func (lcp *LazyContentProvider) Plain() string <span class="cov0" title="0">{
        lcp.init.Do()
        return lcp.cp.Plain()
}</span>

func (lcp *LazyContentProvider) PlainWords() []string <span class="cov0" title="0">{
        lcp.init.Do()
        return lcp.cp.PlainWords()
}</span>

func (lcp *LazyContentProvider) Summary() template.HTML <span class="cov0" title="0">{
        lcp.init.Do()
        return lcp.cp.Summary()
}</span>

func (lcp *LazyContentProvider) Truncated() bool <span class="cov0" title="0">{
        lcp.init.Do()
        return lcp.cp.Truncated()
}</span>

func (lcp *LazyContentProvider) FuzzyWordCount() int <span class="cov0" title="0">{
        lcp.init.Do()
        return lcp.cp.FuzzyWordCount()
}</span>

func (lcp *LazyContentProvider) WordCount() int <span class="cov0" title="0">{
        lcp.init.Do()
        return lcp.cp.WordCount()
}</span>

func (lcp *LazyContentProvider) ReadingTime() int <span class="cov0" title="0">{
        lcp.init.Do()
        return lcp.cp.ReadingTime()
}</span>

func (lcp *LazyContentProvider) Len() int <span class="cov0" title="0">{
        lcp.init.Do()
        return lcp.cp.Len()
}</span>

func (lcp *LazyContentProvider) Render(layout ...string) (template.HTML, error) <span class="cov0" title="0">{
        lcp.init.Do()
        return lcp.cp.Render(layout...)
}</span>

func (lcp *LazyContentProvider) RenderString(args ...interface{}) (template.HTML, error) <span class="cov0" title="0">{
        lcp.init.Do()
        return lcp.cp.RenderString(args...)
}</span>

func (lcp *LazyContentProvider) TableOfContents() template.HTML <span class="cov0" title="0">{
        lcp.init.Do()
        return lcp.cp.TableOfContents()
}</span>
</pre>
		
		<pre class="file" id="file219" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is autogenerated.

package page

import (
        "encoding/json"
        "github.com/bep/gitmap"
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/hugofs/files"
        "github.com/gohugoio/hugo/identity"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/navigation"
        "github.com/gohugoio/hugo/source"
        "html/template"
        "time"
)

func MarshalPageToJSON(p Page) ([]byte, error) <span class="cov0" title="0">{
        content, err := p.Content()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">plain := p.Plain()
        plainWords := p.PlainWords()
        summary := p.Summary()
        truncated := p.Truncated()
        fuzzyWordCount := p.FuzzyWordCount()
        wordCount := p.WordCount()
        readingTime := p.ReadingTime()
        length := p.Len()
        tableOfContents := p.TableOfContents()
        rawContent := p.RawContent()
        resourceType := p.ResourceType()
        mediaType := p.MediaType()
        permalink := p.Permalink()
        relPermalink := p.RelPermalink()
        name := p.Name()
        title := p.Title()
        params := p.Params()
        data := p.Data()
        date := p.Date()
        lastmod := p.Lastmod()
        publishDate := p.PublishDate()
        expiryDate := p.ExpiryDate()
        aliases := p.Aliases()
        bundleType := p.BundleType()
        description := p.Description()
        draft := p.Draft()
        isHome := p.IsHome()
        keywords := p.Keywords()
        kind := p.Kind()
        layout := p.Layout()
        linkTitle := p.LinkTitle()
        isNode := p.IsNode()
        isPage := p.IsPage()
        path := p.Path()
        pathc := p.Pathc()
        slug := p.Slug()
        lang := p.Lang()
        isSection := p.IsSection()
        section := p.Section()
        sectionsEntries := p.SectionsEntries()
        sectionsPath := p.SectionsPath()
        sitemap := p.Sitemap()
        typ := p.Type()
        weight := p.Weight()
        language := p.Language()
        file := p.File()
        gitInfo := p.GitInfo()
        outputFormats := p.OutputFormats()
        alternativeOutputFormats := p.AlternativeOutputFormats()
        menus := p.Menus()
        translationKey := p.TranslationKey()
        isTranslated := p.IsTranslated()
        allTranslations := p.AllTranslations()
        translations := p.Translations()
        getIdentity := p.GetIdentity()

        s := struct {
                Content                  interface{}
                Plain                    string
                PlainWords               []string
                Summary                  template.HTML
                Truncated                bool
                FuzzyWordCount           int
                WordCount                int
                ReadingTime              int
                Len                      int
                TableOfContents          template.HTML
                RawContent               string
                ResourceType             string
                MediaType                media.Type
                Permalink                string
                RelPermalink             string
                Name                     string
                Title                    string
                Params                   maps.Params
                Data                     interface{}
                Date                     time.Time
                Lastmod                  time.Time
                PublishDate              time.Time
                ExpiryDate               time.Time
                Aliases                  []string
                BundleType               files.ContentClass
                Description              string
                Draft                    bool
                IsHome                   bool
                Keywords                 []string
                Kind                     string
                Layout                   string
                LinkTitle                string
                IsNode                   bool
                IsPage                   bool
                Path                     string
                Pathc                    string
                Slug                     string
                Lang                     string
                IsSection                bool
                Section                  string
                SectionsEntries          []string
                SectionsPath             string
                Sitemap                  config.Sitemap
                Type                     string
                Weight                   int
                Language                 *langs.Language
                File                     source.File
                GitInfo                  *gitmap.GitInfo
                OutputFormats            OutputFormats
                AlternativeOutputFormats OutputFormats
                Menus                    navigation.PageMenus
                TranslationKey           string
                IsTranslated             bool
                AllTranslations          Pages
                Translations             Pages
                GetIdentity              identity.Identity
        }{
                Content:                  content,
                Plain:                    plain,
                PlainWords:               plainWords,
                Summary:                  summary,
                Truncated:                truncated,
                FuzzyWordCount:           fuzzyWordCount,
                WordCount:                wordCount,
                ReadingTime:              readingTime,
                Len:                      length,
                TableOfContents:          tableOfContents,
                RawContent:               rawContent,
                ResourceType:             resourceType,
                MediaType:                mediaType,
                Permalink:                permalink,
                RelPermalink:             relPermalink,
                Name:                     name,
                Title:                    title,
                Params:                   params,
                Data:                     data,
                Date:                     date,
                Lastmod:                  lastmod,
                PublishDate:              publishDate,
                ExpiryDate:               expiryDate,
                Aliases:                  aliases,
                BundleType:               bundleType,
                Description:              description,
                Draft:                    draft,
                IsHome:                   isHome,
                Keywords:                 keywords,
                Kind:                     kind,
                Layout:                   layout,
                LinkTitle:                linkTitle,
                IsNode:                   isNode,
                IsPage:                   isPage,
                Path:                     path,
                Pathc:                    pathc,
                Slug:                     slug,
                Lang:                     lang,
                IsSection:                isSection,
                Section:                  section,
                SectionsEntries:          sectionsEntries,
                SectionsPath:             sectionsPath,
                Sitemap:                  sitemap,
                Type:                     typ,
                Weight:                   weight,
                Language:                 language,
                File:                     file,
                GitInfo:                  gitInfo,
                OutputFormats:            outputFormats,
                AlternativeOutputFormats: alternativeOutputFormats,
                Menus:                    menus,
                TranslationKey:           translationKey,
                IsTranslated:             isTranslated,
                AllTranslations:          allTranslations,
                Translations:             translations,
                GetIdentity:              getIdentity,
        }

        return json.Marshal(&amp;s)</span>
}
</pre>
		
		<pre class="file" id="file220" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/hugofs/glob"
        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"
)

// A PageMatcher can be used to match a Page with Glob patterns.
// Note that the pattern matching is case insensitive.
type PageMatcher struct {
        // A Glob pattern matching the content path below /content.
        // Expects Unix-styled slashes.
        // Note that this is the virtual path, so it starts at the mount root
        // with a leading "/".
        Path string

        // A Glob pattern matching the Page's Kind(s), e.g. "{home,section}"
        Kind string

        // A Glob pattern matching the Page's language, e.g. "{en,sv}".
        Lang string
}

// Matches returns whether p matches this matcher.
func (m PageMatcher) Matches(p Page) bool <span class="cov8" title="1">{
        if m.Kind != "" </span><span class="cov8" title="1">{
                g, err := glob.GetGlob(m.Kind)
                if err == nil &amp;&amp; !g.Match(p.Kind()) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">if m.Lang != "" </span><span class="cov8" title="1">{
                g, err := glob.GetGlob(m.Lang)
                if err == nil &amp;&amp; !g.Match(p.Lang()) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">if m.Path != "" </span><span class="cov8" title="1">{
                g, err := glob.GetGlob(m.Path)
                // TODO(bep) Path() vs filepath vs leading slash.
                p := strings.ToLower(filepath.ToSlash(p.Pathc()))
                if !(strings.HasPrefix(p, "/")) </span><span class="cov8" title="1">{
                        p = "/" + p
                }</span>
                <span class="cov8" title="1">if err == nil &amp;&amp; !g.Match(p) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// DecodeCascade decodes in which could be eiter a map or a slice of maps.
func DecodeCascade(in interface{}) (map[PageMatcher]maps.Params, error) <span class="cov0" title="0">{
        m, err := maps.ToSliceStringMap(in)
        if err != nil </span><span class="cov0" title="0">{
                return map[PageMatcher]maps.Params{
                        {}: maps.ToStringMap(in),
                }, nil
        }</span>

        <span class="cov0" title="0">cascade := make(map[PageMatcher]maps.Params)

        for _, vv := range m </span><span class="cov0" title="0">{
                var m PageMatcher
                if mv, found := vv["_target"]; found </span><span class="cov0" title="0">{
                        err := DecodePageMatcher(mv, &amp;m)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                }
                <span class="cov0" title="0">c, found := cascade[m]
                if found </span><span class="cov0" title="0">{
                        // Merge
                        for k, v := range vv </span><span class="cov0" title="0">{
                                if _, found := c[k]; !found </span><span class="cov0" title="0">{
                                        c[k] = v
                                }</span>
                        }
                } else<span class="cov0" title="0"> {
                        cascade[m] = vv
                }</span>
        }

        <span class="cov0" title="0">return cascade, nil</span>
}

// DecodePageMatcher decodes m into v.
func DecodePageMatcher(m interface{}, v *PageMatcher) error <span class="cov8" title="1">{
        if err := mapstructure.WeakDecode(m, v); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">v.Kind = strings.ToLower(v.Kind)
        if v.Kind != "" </span><span class="cov8" title="1">{
                g, _ := glob.GetGlob(v.Kind)
                found := false
                for _, k := range kindMap </span><span class="cov8" title="1">{
                        if g.Match(k) </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return errors.Errorf("%q did not match a valid Page Kind", v.Kind)
                }</span>
        }

        <span class="cov8" title="1">v.Path = filepath.ToSlash(strings.ToLower(v.Path))

        return nil</span>
}
</pre>
		
		<pre class="file" id="file221" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package page contains the core interfaces and types for the Page resource,
// a core component in Hugo.
package page

import (
        "html/template"
        "time"

        "github.com/gohugoio/hugo/identity"

        "github.com/gohugoio/hugo/hugofs/files"
        "github.com/gohugoio/hugo/tpl"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/bep/gitmap"
        "github.com/gohugoio/hugo/navigation"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/source"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/related"
        "github.com/gohugoio/hugo/resources/resource"
)

var (
        NopPage Page = new(nopPage)
        NilPage *nopPage
)

// PageNop implements Page, but does nothing.
type nopPage int

func (p *nopPage) Err() error <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Aliases() []string <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Sitemap() config.Sitemap <span class="cov0" title="0">{
        return config.Sitemap{}
}</span>

func (p *nopPage) Layout() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) RSSLink() template.URL <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Author() Author <span class="cov0" title="0">{
        return Author{}
}</span>

func (p *nopPage) Authors() AuthorList <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) AllTranslations() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) LanguagePrefix() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) AlternativeOutputFormats() OutputFormats <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) BaseFileName() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) BundleType() files.ContentClass <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Content() (interface{}, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (p *nopPage) ContentBaseName() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) CurrentSection() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Data() interface{} <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Date() (t time.Time) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) Description() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) RefFrom(argsm map[string]interface{}, source interface{}) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (p *nopPage) RelRefFrom(argsm map[string]interface{}, source interface{}) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (p *nopPage) Dir() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Draft() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) Eq(other interface{}) bool <span class="cov0" title="0">{
        return p == other
}</span>

func (p *nopPage) ExpiryDate() (t time.Time) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) Ext() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Extension() string <span class="cov0" title="0">{
        return ""
}</span>

var nilFile *source.FileInfo

func (p *nopPage) File() source.File <span class="cov0" title="0">{
        return nilFile
}</span>

func (p *nopPage) FileInfo() hugofs.FileMetaInfo <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Filename() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) FirstSection() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) FuzzyWordCount() int <span class="cov0" title="0">{
        return 0
}</span>

func (p *nopPage) GetPage(ref string) (Page, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *nopPage) GetPageWithTemplateInfo(info tpl.Info, ref string) (Page, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *nopPage) GetParam(key string) interface{} <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) GetTerms(taxonomy string) Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) GitInfo() *gitmap.GitInfo <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) HasMenuCurrent(menuID string, me *navigation.MenuEntry) bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) HasShortcode(name string) bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) Hugo() (h hugo.Info) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) InSection(other interface{}) (bool, error) <span class="cov0" title="0">{
        return false, nil
}</span>

func (p *nopPage) IsAncestor(other interface{}) (bool, error) <span class="cov0" title="0">{
        return false, nil
}</span>

func (p *nopPage) IsDescendant(other interface{}) (bool, error) <span class="cov0" title="0">{
        return false, nil
}</span>

func (p *nopPage) IsDraft() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) IsHome() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) IsMenuCurrent(menuID string, inme *navigation.MenuEntry) bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) IsNode() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) IsPage() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) IsSection() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) IsTranslated() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) Keywords() []string <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Kind() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Lang() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Language() *langs.Language <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Lastmod() (t time.Time) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) Len() int <span class="cov0" title="0">{
        return 0
}</span>

func (p *nopPage) LinkTitle() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) LogicalName() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) MediaType() (m media.Type) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) Menus() (m navigation.PageMenus) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) Name() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Next() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) OutputFormats() OutputFormats <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Pages() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) RegularPages() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) RegularPagesRecursive() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Paginate(seq interface{}, options ...interface{}) (*Pager, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *nopPage) Paginator(options ...interface{}) (*Pager, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *nopPage) Param(key interface{}) (interface{}, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *nopPage) Params() maps.Params <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Page() Page <span class="cov0" title="0">{
        return p
}</span>

func (p *nopPage) Parent() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Path() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Pathc() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Permalink() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Plain() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) PlainWords() []string <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Prev() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) PublishDate() (t time.Time) <span class="cov0" title="0">{
        return
}</span>

func (p *nopPage) PrevInSection() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) NextInSection() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) PrevPage() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) NextPage() Page <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) RawContent() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) ReadingTime() int <span class="cov0" title="0">{
        return 0
}</span>

func (p *nopPage) Ref(argsm map[string]interface{}) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (p *nopPage) RelPermalink() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) RelRef(argsm map[string]interface{}) (string, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (p *nopPage) Render(layout ...string) (template.HTML, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (p *nopPage) RenderString(args ...interface{}) (template.HTML, error) <span class="cov0" title="0">{
        return "", nil
}</span>

func (p *nopPage) ResourceType() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Resources() resource.Resources <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Scratch() *maps.Scratch <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) RelatedKeywords(cfg related.IndexConfig) ([]related.Keyword, error) <span class="cov0" title="0">{
        return nil, nil
}</span>

func (p *nopPage) Section() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Sections() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) SectionsEntries() []string <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) SectionsPath() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Site() Site <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Sites() Sites <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Slug() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) String() string <span class="cov0" title="0">{
        return "nopPage"
}</span>

func (p *nopPage) Summary() template.HTML <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) TableOfContents() template.HTML <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Title() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) TranslationBaseName() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) TranslationKey() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Translations() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (p *nopPage) Truncated() bool <span class="cov0" title="0">{
        return false
}</span>

func (p *nopPage) Type() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) URL() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) UniqueID() string <span class="cov0" title="0">{
        return ""
}</span>

func (p *nopPage) Weight() int <span class="cov0" title="0">{
        return 0
}</span>

func (p *nopPage) WordCount() int <span class="cov0" title="0">{
        return 0
}</span>

func (p *nopPage) GetIdentity() identity.Identity <span class="cov0" title="0">{
        return identity.NewPathIdentity("content", "foo/bar.md")
}</span>
</pre>
		
		<pre class="file" id="file222" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package page contains the core interfaces and types for the Page resource,
// a core component in Hugo.
package page

import (
        "strings"

        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/output"
)

// OutputFormats holds a list of the relevant output formats for a given page.
type OutputFormats []OutputFormat

// OutputFormat links to a representation of a resource.
type OutputFormat struct {
        // Rel contains a value that can be used to construct a rel link.
        // This is value is fetched from the output format definition.
        // Note that for pages with only one output format,
        // this method will always return "canonical".
        // As an example, the AMP output format will, by default, return "amphtml".
        //
        // See:
        // https://www.ampproject.org/docs/guides/deploy/discovery
        //
        // Most other output formats will have "alternate" as value for this.
        Rel string

        Format output.Format

        relPermalink string
        permalink    string
}

// Name returns this OutputFormat's name, i.e. HTML, AMP, JSON etc.
func (o OutputFormat) Name() string <span class="cov0" title="0">{
        return o.Format.Name
}</span>

// MediaType returns this OutputFormat's MediaType (MIME type).
func (o OutputFormat) MediaType() media.Type <span class="cov0" title="0">{
        return o.Format.MediaType
}</span>

// Permalink returns the absolute permalink to this output format.
func (o OutputFormat) Permalink() string <span class="cov0" title="0">{
        return o.permalink
}</span>

// RelPermalink returns the relative permalink to this output format.
func (o OutputFormat) RelPermalink() string <span class="cov0" title="0">{
        return o.relPermalink
}</span>

func NewOutputFormat(relPermalink, permalink string, isCanonical bool, f output.Format) OutputFormat <span class="cov0" title="0">{
        isUserConfigured := true
        for _, d := range output.DefaultFormats </span><span class="cov0" title="0">{
                if strings.EqualFold(d.Name, f.Name) </span><span class="cov0" title="0">{
                        isUserConfigured = false
                }</span>
        }
        <span class="cov0" title="0">rel := f.Rel
        // If the output format is the canonical format for the content, we want
        // to specify this in the "rel" attribute of an HTML "link" element.
        // However, for custom output formats, we don't want to surprise users by
        // overwriting "rel"
        if isCanonical &amp;&amp; !isUserConfigured </span><span class="cov0" title="0">{
                rel = "canonical"
        }</span>
        <span class="cov0" title="0">return OutputFormat{Rel: rel, Format: f, relPermalink: relPermalink, permalink: permalink}</span>
}

// Get gets a OutputFormat given its name, i.e. json, html etc.
// It returns nil if none found.
func (o OutputFormats) Get(name string) *OutputFormat <span class="cov0" title="0">{
        for _, f := range o </span><span class="cov0" title="0">{
                if strings.EqualFold(f.Format.Name, name) </span><span class="cov0" title="0">{
                        return &amp;f
                }</span>
        }
        <span class="cov0" title="0">return nil</span>
}
</pre>
		
		<pre class="file" id="file223" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "path"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/output"
)

const slash = "/"

// TargetPathDescriptor describes how a file path for a given resource
// should look like on the file system. The same descriptor is then later used to
// create both the permalinks and the relative links, paginator URLs etc.
//
// The big motivating behind this is to have only one source of truth for URLs,
// and by that also get rid of most of the fragile string parsing/encoding etc.
//
//
type TargetPathDescriptor struct {
        PathSpec *helpers.PathSpec

        Type output.Format
        Kind string

        Sections []string

        // For regular content pages this is either
        // 1) the Slug, if set,
        // 2) the file base name (TranslationBaseName).
        BaseName string

        // Source directory.
        Dir string

        // Typically a language prefix added to file paths.
        PrefixFilePath string

        // Typically a language prefix added to links.
        PrefixLink string

        // If in multihost mode etc., every link/path needs to be prefixed, even
        // if set in URL.
        ForcePrefix bool

        // URL from front matter if set. Will override any Slug etc.
        URL string

        // Used to create paginator links.
        Addends string

        // The expanded permalink if defined for the section, ready to use.
        ExpandedPermalink string

        // Some types cannot have uglyURLs, even if globally enabled, RSS being one example.
        UglyURLs bool
}

// TODO(bep) move this type.
type TargetPaths struct {

        // Where to store the file on disk relative to the publish dir. OS slashes.
        TargetFilename string

        // The directory to write sub-resources of the above.
        SubResourceBaseTarget string

        // The base for creating links to sub-resources of the above.
        SubResourceBaseLink string

        // The relative permalink to this resources. Unix slashes.
        Link string
}

func (p TargetPaths) RelPermalink(s *helpers.PathSpec) string <span class="cov8" title="1">{
        return s.PrependBasePath(p.Link, false)
}</span>

func (p TargetPaths) PermalinkForOutputFormat(s *helpers.PathSpec, f output.Format) string <span class="cov0" title="0">{
        var baseURL string
        var err error
        if f.Protocol != "" </span><span class="cov0" title="0">{
                baseURL, err = s.BaseURL.WithProtocol(f.Protocol)
                if err != nil </span><span class="cov0" title="0">{
                        return ""
                }</span>
        } else<span class="cov0" title="0"> {
                baseURL = s.BaseURL.String()
        }</span>

        <span class="cov0" title="0">return s.PermalinkForBaseURL(p.Link, baseURL)</span>
}

func isHtmlIndex(s string) bool <span class="cov8" title="1">{
        return strings.HasSuffix(s, "/index.html")
}</span>

func CreateTargetPaths(d TargetPathDescriptor) (tp TargetPaths) <span class="cov8" title="1">{
        if d.Type.Name == "" </span><span class="cov0" title="0">{
                panic("CreateTargetPath: missing type")</span>
        }

        // Normalize all file Windows paths to simplify what's next.
        <span class="cov8" title="1">if helpers.FilePathSeparator != slash </span><span class="cov0" title="0">{
                d.Dir = filepath.ToSlash(d.Dir)
                d.PrefixFilePath = filepath.ToSlash(d.PrefixFilePath)

        }</span>

        <span class="cov8" title="1">if d.URL != "" &amp;&amp; !strings.HasPrefix(d.URL, "/") </span><span class="cov0" title="0">{
                // Treat this as a context relative URL
                d.ForcePrefix = true
        }</span>

        <span class="cov8" title="1">pagePath := slash
        fullSuffix := d.Type.MediaType.FirstSuffix.FullSuffix

        var (
                pagePathDir string
                link        string
                linkDir     string
        )

        // The top level index files, i.e. the home page etc., needs
        // the index base even when uglyURLs is enabled.
        needsBase := true

        isUgly := d.UglyURLs &amp;&amp; !d.Type.NoUgly
        baseNameSameAsType := d.BaseName != "" &amp;&amp; d.BaseName == d.Type.BaseName

        if d.ExpandedPermalink == "" &amp;&amp; baseNameSameAsType </span><span class="cov8" title="1">{
                isUgly = true
        }</span>

        <span class="cov8" title="1">if d.Kind != KindPage &amp;&amp; d.URL == "" &amp;&amp; len(d.Sections) &gt; 0 </span><span class="cov8" title="1">{
                if d.ExpandedPermalink != "" </span><span class="cov0" title="0">{
                        pagePath = pjoin(pagePath, d.ExpandedPermalink)
                }</span> else<span class="cov8" title="1"> {
                        pagePath = pjoin(d.Sections...)
                }</span>
                <span class="cov8" title="1">needsBase = false</span>
        }

        <span class="cov8" title="1">if d.Type.Path != "" </span><span class="cov8" title="1">{
                pagePath = pjoin(pagePath, d.Type.Path)
        }</span>

        <span class="cov8" title="1">if d.Kind != KindHome &amp;&amp; d.URL != "" </span><span class="cov8" title="1">{
                pagePath = pjoin(pagePath, d.URL)

                if d.Addends != "" </span><span class="cov0" title="0">{
                        pagePath = pjoin(pagePath, d.Addends)
                }</span>

                <span class="cov8" title="1">pagePathDir = pagePath
                link = pagePath
                hasDot := strings.Contains(d.URL, ".")
                hasSlash := strings.HasSuffix(d.URL, slash)

                if hasSlash || !hasDot </span><span class="cov8" title="1">{
                        pagePath = pjoin(pagePath, d.Type.BaseName+fullSuffix)
                }</span> else<span class="cov8" title="1"> if hasDot </span><span class="cov8" title="1">{
                        pagePathDir = path.Dir(pagePathDir)
                }</span>

                <span class="cov8" title="1">if !isHtmlIndex(pagePath) </span><span class="cov8" title="1">{
                        link = pagePath
                }</span> else<span class="cov8" title="1"> if !hasSlash </span><span class="cov8" title="1">{
                        link += slash
                }</span>

                <span class="cov8" title="1">linkDir = pagePathDir

                if d.ForcePrefix </span><span class="cov8" title="1">{

                        // Prepend language prefix if not already set in URL
                        if d.PrefixFilePath != "" &amp;&amp; !strings.HasPrefix(d.URL, slash+d.PrefixFilePath) </span><span class="cov8" title="1">{
                                pagePath = pjoin(d.PrefixFilePath, pagePath)
                                pagePathDir = pjoin(d.PrefixFilePath, pagePathDir)
                        }</span>

                        <span class="cov8" title="1">if d.PrefixLink != "" &amp;&amp; !strings.HasPrefix(d.URL, slash+d.PrefixLink) </span><span class="cov8" title="1">{
                                link = pjoin(d.PrefixLink, link)
                                linkDir = pjoin(d.PrefixLink, linkDir)
                        }</span>
                }

        } else<span class="cov8" title="1"> if d.Kind == KindPage </span><span class="cov8" title="1">{

                if d.ExpandedPermalink != "" </span><span class="cov8" title="1">{
                        pagePath = pjoin(pagePath, d.ExpandedPermalink)
                }</span> else<span class="cov8" title="1"> {
                        if d.Dir != "" </span><span class="cov8" title="1">{
                                pagePath = pjoin(pagePath, d.Dir)
                        }</span>
                        <span class="cov8" title="1">if d.BaseName != "" </span><span class="cov8" title="1">{
                                pagePath = pjoin(pagePath, d.BaseName)
                        }</span>
                }

                <span class="cov8" title="1">if d.Addends != "" </span><span class="cov8" title="1">{
                        pagePath = pjoin(pagePath, d.Addends)
                }</span>

                <span class="cov8" title="1">link = pagePath

                // TODO(bep) this should not happen after the fix in https://github.com/gohugoio/hugo/issues/4870
                // but we may need some more testing before we can remove it.
                if baseNameSameAsType </span><span class="cov8" title="1">{
                        link = strings.TrimSuffix(link, d.BaseName)
                }</span>

                <span class="cov8" title="1">pagePathDir = link
                link = link + slash
                linkDir = pagePathDir

                if isUgly </span><span class="cov8" title="1">{
                        pagePath = addSuffix(pagePath, fullSuffix)
                }</span> else<span class="cov8" title="1"> {
                        pagePath = pjoin(pagePath, d.Type.BaseName+fullSuffix)
                }</span>

                <span class="cov8" title="1">if !isHtmlIndex(pagePath) </span><span class="cov8" title="1">{
                        link = pagePath
                }</span>

                <span class="cov8" title="1">if d.PrefixFilePath != "" </span><span class="cov8" title="1">{
                        pagePath = pjoin(d.PrefixFilePath, pagePath)
                        pagePathDir = pjoin(d.PrefixFilePath, pagePathDir)
                }</span>

                <span class="cov8" title="1">if d.PrefixLink != "" </span><span class="cov8" title="1">{
                        link = pjoin(d.PrefixLink, link)
                        linkDir = pjoin(d.PrefixLink, linkDir)
                }</span>

        } else<span class="cov8" title="1"> {
                if d.Addends != "" </span><span class="cov8" title="1">{
                        pagePath = pjoin(pagePath, d.Addends)
                }</span>

                <span class="cov8" title="1">needsBase = needsBase &amp;&amp; d.Addends == ""

                // No permalink expansion etc. for node type pages (for now)
                base := ""

                if needsBase || !isUgly </span><span class="cov8" title="1">{
                        base = d.Type.BaseName
                }</span>

                <span class="cov8" title="1">pagePathDir = pagePath
                link = pagePath
                linkDir = pagePathDir

                if base != "" </span><span class="cov8" title="1">{
                        pagePath = path.Join(pagePath, addSuffix(base, fullSuffix))
                }</span> else<span class="cov8" title="1"> {
                        pagePath = addSuffix(pagePath, fullSuffix)
                }</span>

                <span class="cov8" title="1">if !isHtmlIndex(pagePath) </span><span class="cov8" title="1">{
                        link = pagePath
                }</span> else<span class="cov8" title="1"> {
                        link += slash
                }</span>

                <span class="cov8" title="1">if d.PrefixFilePath != "" </span><span class="cov8" title="1">{
                        pagePath = pjoin(d.PrefixFilePath, pagePath)
                        pagePathDir = pjoin(d.PrefixFilePath, pagePathDir)
                }</span>

                <span class="cov8" title="1">if d.PrefixLink != "" </span><span class="cov8" title="1">{
                        link = pjoin(d.PrefixLink, link)
                        linkDir = pjoin(d.PrefixLink, linkDir)
                }</span>
        }

        <span class="cov8" title="1">pagePath = pjoin(slash, pagePath)
        pagePathDir = strings.TrimSuffix(path.Join(slash, pagePathDir), slash)

        hadSlash := strings.HasSuffix(link, slash)
        link = strings.Trim(link, slash)
        if hadSlash </span><span class="cov8" title="1">{
                link += slash
        }</span>

        <span class="cov8" title="1">if !strings.HasPrefix(link, slash) </span><span class="cov8" title="1">{
                link = slash + link
        }</span>

        <span class="cov8" title="1">linkDir = strings.TrimSuffix(path.Join(slash, linkDir), slash)

        // if page URL is explicitly set in frontmatter,
        // preserve its value without sanitization
        if d.Kind != KindPage || d.URL == "" </span><span class="cov8" title="1">{
                // Note: MakePathSanitized will lower case the path if
                // disablePathToLower isn't set.
                pagePath = d.PathSpec.MakePathSanitized(pagePath)
                pagePathDir = d.PathSpec.MakePathSanitized(pagePathDir)
                link = d.PathSpec.MakePathSanitized(link)
                linkDir = d.PathSpec.MakePathSanitized(linkDir)
        }</span>

        <span class="cov8" title="1">tp.TargetFilename = filepath.FromSlash(pagePath)
        tp.SubResourceBaseTarget = filepath.FromSlash(pagePathDir)
        tp.SubResourceBaseLink = linkDir
        tp.Link = d.PathSpec.URLizeFilename(link)
        if tp.Link == "" </span><span class="cov0" title="0">{
                tp.Link = slash
        }</span>

        <span class="cov8" title="1">return</span>
}

func addSuffix(s, suffix string) string <span class="cov8" title="1">{
        return strings.Trim(s, slash) + suffix
}</span>

// Like path.Join, but preserves one trailing slash if present.
func pjoin(elem ...string) string <span class="cov8" title="1">{
        hadSlash := strings.HasSuffix(elem[len(elem)-1], slash)
        joined := path.Join(elem...)
        if hadSlash &amp;&amp; !strings.HasSuffix(joined, slash) </span><span class="cov8" title="1">{
                return joined + slash
        }</span>
        <span class="cov8" title="1">return joined</span>
}
</pre>
		
		<pre class="file" id="file224" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is autogenerated.

package page

// NewDeprecatedWarningPage adds deprecation warnings to the given implementation.
func NewDeprecatedWarningPage(p DeprecatedWarningPageMethods) DeprecatedWarningPageMethods <span class="cov0" title="0">{
        return &amp;pageDeprecated{p: p}
}</span>

type pageDeprecated struct {
        p DeprecatedWarningPageMethods
}
</pre>
		
		<pre class="file" id="file225" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "errors"
        "fmt"
        "reflect"
        "sort"
        "strings"
        "time"

        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/common/collections"
        "github.com/gohugoio/hugo/compare"

        "github.com/gohugoio/hugo/resources/resource"
)

var (
        _ collections.Slicer   = PageGroup{}
        _ compare.ProbablyEqer = PageGroup{}
        _ compare.ProbablyEqer = PagesGroup{}
)

// PageGroup represents a group of pages, grouped by the key.
// The key is typically a year or similar.
type PageGroup struct {
        Key interface{}
        Pages
}

type mapKeyValues []reflect.Value

func (v mapKeyValues) Len() int      <span class="cov8" title="1">{ return len(v) }</span>
func (v mapKeyValues) Swap(i, j int) <span class="cov8" title="1">{ v[i], v[j] = v[j], v[i] }</span>

type mapKeyByInt struct{ mapKeyValues }

func (s mapKeyByInt) Less(i, j int) bool <span class="cov8" title="1">{ return s.mapKeyValues[i].Int() &lt; s.mapKeyValues[j].Int() }</span>

type mapKeyByStr struct{ mapKeyValues }

func (s mapKeyByStr) Less(i, j int) bool <span class="cov8" title="1">{
        return compare.LessStrings(s.mapKeyValues[i].String(), s.mapKeyValues[j].String())
}</span>

func sortKeys(v []reflect.Value, order string) []reflect.Value <span class="cov8" title="1">{
        if len(v) &lt;= 1 </span><span class="cov8" title="1">{
                return v
        }</span>

        <span class="cov8" title="1">switch v[0].Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                if order == "desc" </span><span class="cov8" title="1">{
                        sort.Sort(sort.Reverse(mapKeyByInt{v}))
                }</span> else<span class="cov8" title="1"> {
                        sort.Sort(mapKeyByInt{v})
                }</span>
        case reflect.String:<span class="cov8" title="1">
                if order == "desc" </span><span class="cov8" title="1">{
                        sort.Sort(sort.Reverse(mapKeyByStr{v}))
                }</span> else<span class="cov8" title="1"> {
                        sort.Sort(mapKeyByStr{v})
                }</span>
        }
        <span class="cov8" title="1">return v</span>
}

// PagesGroup represents a list of page groups.
// This is what you get when doing page grouping in the templates.
type PagesGroup []PageGroup

// Reverse reverses the order of this list of page groups.
func (p PagesGroup) Reverse() PagesGroup <span class="cov8" title="1">{
        for i, j := 0, len(p)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                p[i], p[j] = p[j], p[i]
        }</span>

        <span class="cov8" title="1">return p</span>
}

var (
        errorType   = reflect.TypeOf((*error)(nil)).Elem()
        pagePtrType = reflect.TypeOf((*Page)(nil)).Elem()
        pagesType   = reflect.TypeOf(Pages{})
)

// GroupBy groups by the value in the given field or method name and with the given order.
// Valid values for order is asc, desc, rev and reverse.
func (p Pages) GroupBy(key string, order ...string) (PagesGroup, error) <span class="cov8" title="1">{
        if len(p) &lt; 1 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">direction := "asc"

        if len(order) &gt; 0 &amp;&amp; (strings.ToLower(order[0]) == "desc" || strings.ToLower(order[0]) == "rev" || strings.ToLower(order[0]) == "reverse") </span><span class="cov8" title="1">{
                direction = "desc"
        }</span>

        <span class="cov8" title="1">var ft interface{}
        m, ok := pagePtrType.MethodByName(key)
        if ok </span><span class="cov8" title="1">{
                if m.Type.NumOut() == 0 || m.Type.NumOut() &gt; 2 </span><span class="cov0" title="0">{
                        return nil, errors.New(key + " is a Page method but you can't use it with GroupBy")
                }</span>
                <span class="cov8" title="1">if m.Type.NumOut() == 1 &amp;&amp; m.Type.Out(0).Implements(errorType) </span><span class="cov0" title="0">{
                        return nil, errors.New(key + " is a Page method but you can't use it with GroupBy")
                }</span>
                <span class="cov8" title="1">if m.Type.NumOut() == 2 &amp;&amp; !m.Type.Out(1).Implements(errorType) </span><span class="cov0" title="0">{
                        return nil, errors.New(key + " is a Page method but you can't use it with GroupBy")
                }</span>
                <span class="cov8" title="1">ft = m</span>
        } else<span class="cov0" title="0"> {
                ft, ok = pagePtrType.Elem().FieldByName(key)
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New(key + " is neither a field nor a method of Page")
                }</span>
        }

        <span class="cov8" title="1">var tmp reflect.Value
        switch e := ft.(type) </span>{
        case reflect.StructField:<span class="cov0" title="0">
                tmp = reflect.MakeMap(reflect.MapOf(e.Type, pagesType))</span>
        case reflect.Method:<span class="cov8" title="1">
                tmp = reflect.MakeMap(reflect.MapOf(e.Type.Out(0), pagesType))</span>
        }

        <span class="cov8" title="1">for _, e := range p </span><span class="cov8" title="1">{
                ppv := reflect.ValueOf(e)
                var fv reflect.Value
                switch ft.(type) </span>{
                case reflect.StructField:<span class="cov0" title="0">
                        fv = ppv.Elem().FieldByName(key)</span>
                case reflect.Method:<span class="cov8" title="1">
                        fv = ppv.MethodByName(key).Call([]reflect.Value{})[0]</span>
                }
                <span class="cov8" title="1">if !fv.IsValid() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if !tmp.MapIndex(fv).IsValid() </span><span class="cov8" title="1">{
                        tmp.SetMapIndex(fv, reflect.MakeSlice(pagesType, 0, 0))
                }</span>
                <span class="cov8" title="1">tmp.SetMapIndex(fv, reflect.Append(tmp.MapIndex(fv), ppv))</span>
        }

        <span class="cov8" title="1">sortedKeys := sortKeys(tmp.MapKeys(), direction)
        r := make([]PageGroup, len(sortedKeys))
        for i, k := range sortedKeys </span><span class="cov8" title="1">{
                r[i] = PageGroup{Key: k.Interface(), Pages: tmp.MapIndex(k).Interface().(Pages)}
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

// GroupByParam groups by the given page parameter key's value and with the given order.
// Valid values for order is asc, desc, rev and reverse.
func (p Pages) GroupByParam(key string, order ...string) (PagesGroup, error) <span class="cov8" title="1">{
        if len(p) &lt; 1 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">direction := "asc"

        if len(order) &gt; 0 &amp;&amp; (strings.ToLower(order[0]) == "desc" || strings.ToLower(order[0]) == "rev" || strings.ToLower(order[0]) == "reverse") </span><span class="cov8" title="1">{
                direction = "desc"
        }</span>

        <span class="cov8" title="1">var tmp reflect.Value
        var keyt reflect.Type
        for _, e := range p </span><span class="cov8" title="1">{
                param := resource.GetParamToLower(e, key)
                if param != nil </span><span class="cov8" title="1">{
                        if _, ok := param.([]string); !ok </span><span class="cov8" title="1">{
                                keyt = reflect.TypeOf(param)
                                tmp = reflect.MakeMap(reflect.MapOf(keyt, pagesType))
                                break</span>
                        }
                }
        }
        <span class="cov8" title="1">if !tmp.IsValid() </span><span class="cov8" title="1">{
                return nil, errors.New("there is no such a param")
        }</span>

        <span class="cov8" title="1">for _, e := range p </span><span class="cov8" title="1">{
                param := resource.GetParam(e, key)

                if param == nil || reflect.TypeOf(param) != keyt </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">v := reflect.ValueOf(param)
                if !tmp.MapIndex(v).IsValid() </span><span class="cov8" title="1">{
                        tmp.SetMapIndex(v, reflect.MakeSlice(pagesType, 0, 0))
                }</span>
                <span class="cov8" title="1">tmp.SetMapIndex(v, reflect.Append(tmp.MapIndex(v), reflect.ValueOf(e)))</span>
        }

        <span class="cov8" title="1">var r []PageGroup
        for _, k := range sortKeys(tmp.MapKeys(), direction) </span><span class="cov8" title="1">{
                r = append(r, PageGroup{Key: k.Interface(), Pages: tmp.MapIndex(k).Interface().(Pages)})
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}

func (p Pages) groupByDateField(sorter func(p Pages) Pages, formatter func(p Page) string, order ...string) (PagesGroup, error) <span class="cov8" title="1">{
        if len(p) &lt; 1 </span><span class="cov8" title="1">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">sp := sorter(p)

        if !(len(order) &gt; 0 &amp;&amp; (strings.ToLower(order[0]) == "asc" || strings.ToLower(order[0]) == "rev" || strings.ToLower(order[0]) == "reverse")) </span><span class="cov8" title="1">{
                sp = sp.Reverse()
        }</span>

        <span class="cov8" title="1">if sp == nil </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">date := formatter(sp[0].(Page))
        var r []PageGroup
        r = append(r, PageGroup{Key: date, Pages: make(Pages, 0)})
        r[0].Pages = append(r[0].Pages, sp[0])

        i := 0
        for _, e := range sp[1:] </span><span class="cov8" title="1">{
                date = formatter(e.(Page))
                if r[i].Key.(string) != date </span><span class="cov8" title="1">{
                        r = append(r, PageGroup{Key: date})
                        i++
                }</span>
                <span class="cov8" title="1">r[i].Pages = append(r[i].Pages, e)</span>
        }
        <span class="cov8" title="1">return r, nil</span>
}

// GroupByDate groups by the given page's Date value in
// the given format and with the given order.
// Valid values for order is asc, desc, rev and reverse.
// For valid format strings, see https://golang.org/pkg/time/#Time.Format
func (p Pages) GroupByDate(format string, order ...string) (PagesGroup, error) <span class="cov8" title="1">{
        sorter := func(p Pages) Pages </span><span class="cov8" title="1">{
                return p.ByDate()
        }</span>
        <span class="cov8" title="1">formatter := func(p Page) string </span><span class="cov8" title="1">{
                return p.Date().Format(format)
        }</span>
        <span class="cov8" title="1">return p.groupByDateField(sorter, formatter, order...)</span>
}

// GroupByPublishDate groups by the given page's PublishDate value in
// the given format and with the given order.
// Valid values for order is asc, desc, rev and reverse.
// For valid format strings, see https://golang.org/pkg/time/#Time.Format
func (p Pages) GroupByPublishDate(format string, order ...string) (PagesGroup, error) <span class="cov8" title="1">{
        sorter := func(p Pages) Pages </span><span class="cov8" title="1">{
                return p.ByPublishDate()
        }</span>
        <span class="cov8" title="1">formatter := func(p Page) string </span><span class="cov8" title="1">{
                return p.PublishDate().Format(format)
        }</span>
        <span class="cov8" title="1">return p.groupByDateField(sorter, formatter, order...)</span>
}

// GroupByExpiryDate groups by the given page's ExpireDate value in
// the given format and with the given order.
// Valid values for order is asc, desc, rev and reverse.
// For valid format strings, see https://golang.org/pkg/time/#Time.Format
func (p Pages) GroupByExpiryDate(format string, order ...string) (PagesGroup, error) <span class="cov8" title="1">{
        sorter := func(p Pages) Pages </span><span class="cov8" title="1">{
                return p.ByExpiryDate()
        }</span>
        <span class="cov8" title="1">formatter := func(p Page) string </span><span class="cov8" title="1">{
                return p.ExpiryDate().Format(format)
        }</span>
        <span class="cov8" title="1">return p.groupByDateField(sorter, formatter, order...)</span>
}

// GroupByLastmod groups by the given page's Lastmod value in
// the given format and with the given order.
// Valid values for order is asc, desc, rev and reverse.
// For valid format strings, see https://golang.org/pkg/time/#Time.Format
func (p Pages) GroupByLastmod(format string, order ...string) (PagesGroup, error) <span class="cov8" title="1">{
        sorter := func(p Pages) Pages </span><span class="cov8" title="1">{
                return p.ByLastmod()
        }</span>
        <span class="cov8" title="1">formatter := func(p Page) string </span><span class="cov8" title="1">{
                return p.Lastmod().Format(format)
        }</span>
        <span class="cov8" title="1">return p.groupByDateField(sorter, formatter, order...)</span>
}

// GroupByParamDate groups by a date set as a param on the page in
// the given format and with the given order.
// Valid values for order is asc, desc, rev and reverse.
// For valid format strings, see https://golang.org/pkg/time/#Time.Format
func (p Pages) GroupByParamDate(key string, format string, order ...string) (PagesGroup, error) <span class="cov8" title="1">{
        // Cache the dates.
        dates := make(map[Page]time.Time)

        sorter := func(pages Pages) Pages </span><span class="cov8" title="1">{
                var r Pages

                for _, p := range pages </span><span class="cov8" title="1">{
                        param := resource.GetParam(p, key)
                        var t time.Time

                        if param != nil </span><span class="cov8" title="1">{
                                var ok bool
                                if t, ok = param.(time.Time); !ok </span><span class="cov8" title="1">{
                                        // Probably a string. Try to convert it to time.Time.
                                        t = cast.ToTime(param)
                                }</span>
                        }

                        <span class="cov8" title="1">dates[p] = t
                        r = append(r, p)</span>
                }

                <span class="cov8" title="1">pdate := func(p1, p2 Page) bool </span><span class="cov8" title="1">{
                        return dates[p1].Unix() &lt; dates[p2].Unix()
                }</span>
                <span class="cov8" title="1">pageBy(pdate).Sort(r)
                return r</span>
        }
        <span class="cov8" title="1">formatter := func(p Page) string </span><span class="cov8" title="1">{
                return dates[p].Format(format)
        }</span>
        <span class="cov8" title="1">return p.groupByDateField(sorter, formatter, order...)</span>
}

// ProbablyEq wraps compare.ProbablyEqer
func (p PageGroup) ProbablyEq(other interface{}) bool <span class="cov8" title="1">{
        otherP, ok := other.(PageGroup)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if p.Key != otherP.Key </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return p.Pages.ProbablyEq(otherP.Pages)</span>
}

// Slice is not meant to be used externally. It's a bridge function
// for the template functions. See collections.Slice.
func (p PageGroup) Slice(in interface{}) (interface{}, error) <span class="cov0" title="0">{
        switch items := in.(type) </span>{
        case PageGroup:<span class="cov0" title="0">
                return items, nil</span>
        case []interface{}:<span class="cov0" title="0">
                groups := make(PagesGroup, len(items))
                for i, v := range items </span><span class="cov0" title="0">{
                        g, ok := v.(PageGroup)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("type %T is not a PageGroup", v)
                        }</span>
                        <span class="cov0" title="0">groups[i] = g</span>
                }
                <span class="cov0" title="0">return groups, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid slice type %T", items)</span>
        }
}

// Len returns the number of pages in the page group.
func (psg PagesGroup) Len() int <span class="cov8" title="1">{
        l := 0
        for _, pg := range psg </span><span class="cov8" title="1">{
                l += len(pg.Pages)
        }</span>
        <span class="cov8" title="1">return l</span>
}

// ProbablyEq wraps compare.ProbablyEqer
func (psg PagesGroup) ProbablyEq(other interface{}) bool <span class="cov8" title="1">{
        otherPsg, ok := other.(PagesGroup)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if len(psg) != len(otherPsg) </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">for i := range psg </span><span class="cov8" title="1">{
                if !psg[i].ProbablyEq(otherPsg[i]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

// ToPagesGroup tries to convert seq into a PagesGroup.
func ToPagesGroup(seq interface{}) (PagesGroup, error) <span class="cov0" title="0">{
        switch v := seq.(type) </span>{
        case nil:<span class="cov0" title="0">
                return nil, nil</span>
        case PagesGroup:<span class="cov0" title="0">
                return v, nil</span>
        case []PageGroup:<span class="cov0" title="0">
                return PagesGroup(v), nil</span>
        case []interface{}:<span class="cov0" title="0">
                l := len(v)
                if l == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">switch v[0].(type) </span>{
                case PageGroup:<span class="cov0" title="0">
                        pagesGroup := make(PagesGroup, l)
                        for i, ipg := range v </span><span class="cov0" title="0">{
                                if pg, ok := ipg.(PageGroup); ok </span><span class="cov0" title="0">{
                                        pagesGroup[i] = pg
                                }</span> else<span class="cov0" title="0"> {
                                        return nil, fmt.Errorf("unsupported type in paginate from slice, got %T instead of PageGroup", ipg)
                                }</span>
                        }
                        <span class="cov0" title="0">return pagesGroup, nil</span>
                }
        }

        <span class="cov0" title="0">return nil, nil</span>
}
</pre>
		
		<pre class="file" id="file226" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pagemeta

import (
        "strings"
        "time"

        "github.com/gohugoio/hugo/common/htime"
        "github.com/gohugoio/hugo/common/paths"

        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/resources/resource"

        "github.com/gohugoio/hugo/config"
        "github.com/spf13/cast"
)

// FrontMatterHandler maps front matter into Page fields and .Params.
// Note that we currently have only extracted the date logic.
type FrontMatterHandler struct {
        fmConfig frontmatterConfig

        dateHandler        frontMatterFieldHandler
        lastModHandler     frontMatterFieldHandler
        publishDateHandler frontMatterFieldHandler
        expiryDateHandler  frontMatterFieldHandler

        // A map of all date keys configured, including any custom.
        allDateKeys map[string]bool

        logger loggers.Logger
}

// FrontMatterDescriptor describes how to handle front matter for a given Page.
// It has pointers to values in the receiving page which gets updated.
type FrontMatterDescriptor struct {

        // This the Page's front matter.
        Frontmatter map[string]interface{}

        // This is the Page's base filename (BaseFilename), e.g. page.md., or
        // if page is a leaf bundle, the bundle folder name (ContentBaseName).
        BaseFilename string

        // The content file's mod time.
        ModTime time.Time

        // May be set from the author date in Git.
        GitAuthorDate time.Time

        // The below are pointers to values on Page and will be modified.

        // This is the Page's params.
        Params map[string]interface{}

        // This is the Page's dates.
        Dates *resource.Dates

        // This is the Page's Slug etc.
        PageURLs *URLPath

        // The Location to use to parse dates without time zone info.
        Location *time.Location
}

var dateFieldAliases = map[string][]string{
        fmDate:       {},
        fmLastmod:    {"modified"},
        fmPubDate:    {"pubdate", "published"},
        fmExpiryDate: {"unpublishdate"},
}

// HandleDates updates all the dates given the current configuration and the
// supplied front matter params. Note that this requires all lower-case keys
// in the params map.
func (f FrontMatterHandler) HandleDates(d *FrontMatterDescriptor) error <span class="cov8" title="1">{
        if d.Dates == nil </span><span class="cov0" title="0">{
                panic("missing dates")</span>
        }

        <span class="cov8" title="1">if f.dateHandler == nil </span><span class="cov0" title="0">{
                panic("missing date handler")</span>
        }

        <span class="cov8" title="1">if _, err := f.dateHandler(d); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := f.lastModHandler(d); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := f.publishDateHandler(d); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if _, err := f.expiryDateHandler(d); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// IsDateKey returns whether the given front matter key is considered a date by the current
// configuration.
func (f FrontMatterHandler) IsDateKey(key string) bool <span class="cov8" title="1">{
        return f.allDateKeys[key]
}</span>

// A Zero date is a signal that the name can not be parsed.
// This follows the format as outlined in Jekyll, https://jekyllrb.com/docs/posts/:
// "Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers"
func dateAndSlugFromBaseFilename(location *time.Location, name string) (time.Time, string) <span class="cov8" title="1">{
        withoutExt, _ := paths.FileAndExt(name)

        if len(withoutExt) &lt; 10 </span><span class="cov8" title="1">{
                // This can not be a date.
                return time.Time{}, ""
        }</span>

        <span class="cov8" title="1">d, err := htime.ToTimeInDefaultLocationE(withoutExt[:10], location)
        if err != nil </span><span class="cov8" title="1">{
                return time.Time{}, ""
        }</span>

        // Be a little lenient with the format here.
        <span class="cov8" title="1">slug := strings.Trim(withoutExt[10:], " -_")

        return d, slug</span>
}

type frontMatterFieldHandler func(d *FrontMatterDescriptor) (bool, error)

func (f FrontMatterHandler) newChainedFrontMatterFieldHandler(handlers ...frontMatterFieldHandler) frontMatterFieldHandler <span class="cov8" title="1">{
        return func(d *FrontMatterDescriptor) (bool, error) </span><span class="cov8" title="1">{
                for _, h := range handlers </span><span class="cov8" title="1">{
                        // First successful handler wins.
                        success, err := h(d)
                        if err != nil </span><span class="cov0" title="0">{
                                f.logger.Errorln(err)
                        }</span> else<span class="cov8" title="1"> if success </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                }
                <span class="cov8" title="1">return false, nil</span>
        }
}

type frontmatterConfig struct {
        date        []string
        lastmod     []string
        publishDate []string
        expiryDate  []string
}

const (
        // These are all the date handler identifiers
        // All identifiers not starting with a ":" maps to a front matter parameter.
        fmDate       = "date"
        fmPubDate    = "publishdate"
        fmLastmod    = "lastmod"
        fmExpiryDate = "expirydate"

        // Gets date from filename, e.g 218-02-22-mypage.md
        fmFilename = ":filename"

        // Gets date from file OS mod time.
        fmModTime = ":filemodtime"

        // Gets date from Git
        fmGitAuthorDate = ":git"
)

// This is the config you get when doing nothing.
func newDefaultFrontmatterConfig() frontmatterConfig <span class="cov8" title="1">{
        return frontmatterConfig{
                date:        []string{fmDate, fmPubDate, fmLastmod},
                lastmod:     []string{fmGitAuthorDate, fmLastmod, fmDate, fmPubDate},
                publishDate: []string{fmPubDate, fmDate},
                expiryDate:  []string{fmExpiryDate},
        }
}</span>

func newFrontmatterConfig(cfg config.Provider) (frontmatterConfig, error) <span class="cov8" title="1">{
        c := newDefaultFrontmatterConfig()
        defaultConfig := c

        if cfg.IsSet("frontmatter") </span><span class="cov8" title="1">{
                fm := cfg.GetStringMap("frontmatter")
                for k, v := range fm </span><span class="cov8" title="1">{
                        loki := strings.ToLower(k)
                        switch loki </span>{
                        case fmDate:<span class="cov8" title="1">
                                c.date = toLowerSlice(v)</span>
                        case fmPubDate:<span class="cov8" title="1">
                                c.publishDate = toLowerSlice(v)</span>
                        case fmLastmod:<span class="cov8" title="1">
                                c.lastmod = toLowerSlice(v)</span>
                        case fmExpiryDate:<span class="cov8" title="1">
                                c.expiryDate = toLowerSlice(v)</span>
                        }
                }
        }

        <span class="cov8" title="1">expander := func(c, d []string) []string </span><span class="cov8" title="1">{
                out := expandDefaultValues(c, d)
                out = addDateFieldAliases(out)
                return out
        }</span>

        <span class="cov8" title="1">c.date = expander(c.date, defaultConfig.date)
        c.publishDate = expander(c.publishDate, defaultConfig.publishDate)
        c.lastmod = expander(c.lastmod, defaultConfig.lastmod)
        c.expiryDate = expander(c.expiryDate, defaultConfig.expiryDate)

        return c, nil</span>
}

func addDateFieldAliases(values []string) []string <span class="cov8" title="1">{
        var complete []string

        for _, v := range values </span><span class="cov8" title="1">{
                complete = append(complete, v)
                if aliases, found := dateFieldAliases[v]; found </span><span class="cov8" title="1">{
                        complete = append(complete, aliases...)
                }</span>
        }
        <span class="cov8" title="1">return helpers.UniqueStringsReuse(complete)</span>
}

func expandDefaultValues(values []string, defaults []string) []string <span class="cov8" title="1">{
        var out []string
        for _, v := range values </span><span class="cov8" title="1">{
                if v == ":default" </span><span class="cov8" title="1">{
                        out = append(out, defaults...)
                }</span> else<span class="cov8" title="1"> {
                        out = append(out, v)
                }</span>
        }
        <span class="cov8" title="1">return out</span>
}

func toLowerSlice(in interface{}) []string <span class="cov8" title="1">{
        out := cast.ToStringSlice(in)
        for i := 0; i &lt; len(out); i++ </span><span class="cov8" title="1">{
                out[i] = strings.ToLower(out[i])
        }</span>

        <span class="cov8" title="1">return out</span>
}

// NewFrontmatterHandler creates a new FrontMatterHandler with the given logger and configuration.
// If no logger is provided, one will be created.
func NewFrontmatterHandler(logger loggers.Logger, cfg config.Provider) (FrontMatterHandler, error) <span class="cov8" title="1">{
        if logger == nil </span><span class="cov8" title="1">{
                logger = loggers.NewErrorLogger()
        }</span>

        <span class="cov8" title="1">frontMatterConfig, err := newFrontmatterConfig(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return FrontMatterHandler{}, err
        }</span>

        <span class="cov8" title="1">allDateKeys := make(map[string]bool)
        addKeys := func(vals []string) </span><span class="cov8" title="1">{
                for _, k := range vals </span><span class="cov8" title="1">{
                        if !strings.HasPrefix(k, ":") </span><span class="cov8" title="1">{
                                allDateKeys[k] = true
                        }</span>
                }
        }

        <span class="cov8" title="1">addKeys(frontMatterConfig.date)
        addKeys(frontMatterConfig.expiryDate)
        addKeys(frontMatterConfig.lastmod)
        addKeys(frontMatterConfig.publishDate)

        f := FrontMatterHandler{logger: logger, fmConfig: frontMatterConfig, allDateKeys: allDateKeys}

        if err := f.createHandlers(); err != nil </span><span class="cov0" title="0">{
                return f, err
        }</span>

        <span class="cov8" title="1">return f, nil</span>
}

func (f *FrontMatterHandler) createHandlers() error <span class="cov8" title="1">{
        var err error

        if f.dateHandler, err = f.createDateHandler(f.fmConfig.date,
                func(d *FrontMatterDescriptor, t time.Time) </span><span class="cov8" title="1">{
                        d.Dates.FDate = t
                        setParamIfNotSet(fmDate, t, d)
                }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.lastModHandler, err = f.createDateHandler(f.fmConfig.lastmod,
                func(d *FrontMatterDescriptor, t time.Time) </span><span class="cov8" title="1">{
                        setParamIfNotSet(fmLastmod, t, d)
                        d.Dates.FLastmod = t
                }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.publishDateHandler, err = f.createDateHandler(f.fmConfig.publishDate,
                func(d *FrontMatterDescriptor, t time.Time) </span><span class="cov8" title="1">{
                        setParamIfNotSet(fmPubDate, t, d)
                        d.Dates.FPublishDate = t
                }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if f.expiryDateHandler, err = f.createDateHandler(f.fmConfig.expiryDate,
                func(d *FrontMatterDescriptor, t time.Time) </span><span class="cov8" title="1">{
                        setParamIfNotSet(fmExpiryDate, t, d)
                        d.Dates.FExpiryDate = t
                }</span>); err != nil <span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">return nil</span>
}

func setParamIfNotSet(key string, value interface{}, d *FrontMatterDescriptor) <span class="cov8" title="1">{
        if _, found := d.Params[key]; found </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">d.Params[key] = value</span>
}

func (f FrontMatterHandler) createDateHandler(identifiers []string, setter func(d *FrontMatterDescriptor, t time.Time)) (frontMatterFieldHandler, error) <span class="cov8" title="1">{
        var h *frontmatterFieldHandlers
        var handlers []frontMatterFieldHandler

        for _, identifier := range identifiers </span><span class="cov8" title="1">{
                switch identifier </span>{
                case fmFilename:<span class="cov8" title="1">
                        handlers = append(handlers, h.newDateFilenameHandler(setter))</span>
                case fmModTime:<span class="cov8" title="1">
                        handlers = append(handlers, h.newDateModTimeHandler(setter))</span>
                case fmGitAuthorDate:<span class="cov8" title="1">
                        handlers = append(handlers, h.newDateGitAuthorDateHandler(setter))</span>
                default:<span class="cov8" title="1">
                        handlers = append(handlers, h.newDateFieldHandler(identifier, setter))</span>
                }
        }

        <span class="cov8" title="1">return f.newChainedFrontMatterFieldHandler(handlers...), nil</span>
}

type frontmatterFieldHandlers int

func (f *frontmatterFieldHandlers) newDateFieldHandler(key string, setter func(d *FrontMatterDescriptor, t time.Time)) frontMatterFieldHandler <span class="cov8" title="1">{
        return func(d *FrontMatterDescriptor) (bool, error) </span><span class="cov8" title="1">{
                v, found := d.Frontmatter[key]

                if !found </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">date, err := htime.ToTimeInDefaultLocationE(v, d.Location)
                if err != nil </span><span class="cov0" title="0">{
                        return false, nil
                }</span>

                // We map several date keys to one, so, for example,
                // "expirydate", "unpublishdate" will all set .ExpiryDate (first found).
                <span class="cov8" title="1">setter(d, date)

                // This is the params key as set in front matter.
                d.Params[key] = date

                return true, nil</span>
        }
}

func (f *frontmatterFieldHandlers) newDateFilenameHandler(setter func(d *FrontMatterDescriptor, t time.Time)) frontMatterFieldHandler <span class="cov8" title="1">{
        return func(d *FrontMatterDescriptor) (bool, error) </span><span class="cov8" title="1">{
                date, slug := dateAndSlugFromBaseFilename(d.Location, d.BaseFilename)
                if date.IsZero() </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">setter(d, date)

                if _, found := d.Frontmatter["slug"]; !found </span><span class="cov8" title="1">{
                        // Use slug from filename
                        d.PageURLs.Slug = slug
                }</span>

                <span class="cov8" title="1">return true, nil</span>
        }
}

func (f *frontmatterFieldHandlers) newDateModTimeHandler(setter func(d *FrontMatterDescriptor, t time.Time)) frontMatterFieldHandler <span class="cov8" title="1">{
        return func(d *FrontMatterDescriptor) (bool, error) </span><span class="cov8" title="1">{
                if d.ModTime.IsZero() </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">setter(d, d.ModTime)
                return true, nil</span>
        }
}

func (f *frontmatterFieldHandlers) newDateGitAuthorDateHandler(setter func(d *FrontMatterDescriptor, t time.Time)) frontMatterFieldHandler <span class="cov8" title="1">{
        return func(d *FrontMatterDescriptor) (bool, error) </span><span class="cov8" title="1">{
                if d.GitAuthorDate.IsZero() </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">setter(d, d.GitAuthorDate)
                return true, nil</span>
        }
}
</pre>
		
		<pre class="file" id="file227" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package pagemeta

import (
        "github.com/mitchellh/mapstructure"
)

type URLPath struct {
        URL       string
        Permalink string
        Slug      string
        Section   string
}

const (
        Never       = "never"
        Always      = "always"
        ListLocally = "local"
        Link        = "link"
)

var defaultBuildConfig = BuildConfig{
        List:             Always,
        Render:           Always,
        PublishResources: true,
        set:              true,
}

// BuildConfig holds configuration options about how to handle a Page in Hugo's
// build process.
type BuildConfig struct {
        // Whether to add it to any of the page collections.
        // Note that the page can always be found with .Site.GetPage.
        // Valid values: never, always, local.
        // Setting it to 'local' means they will be available via the local
        // page collections, e.g. $section.Pages.
        // Note: before 0.57.2 this was a bool, so we accept those too.
        List string

        // Whether to render it.
        // Valid values: never, always, link.
        // The value link means it will not be rendered, but it will get a RelPermalink/Permalink.
        // Note that before 0.76.0 this was a bool, so we accept those too.
        Render string

        // Whether to publish its resources. These will still be published on demand,
        // but enabling this can be useful if the originals (e.g. images) are
        // never used.
        PublishResources bool

        set bool // BuildCfg is non-zero if this is set to true.
}

// Disable sets all options to their off value.
func (b *BuildConfig) Disable() <span class="cov0" title="0">{
        b.List = Never
        b.Render = Never
        b.PublishResources = false
        b.set = true
}</span>

func (b BuildConfig) IsZero() bool <span class="cov0" title="0">{
        return !b.set
}</span>

func DecodeBuildConfig(m interface{}) (BuildConfig, error) <span class="cov8" title="1">{
        b := defaultBuildConfig
        if m == nil </span><span class="cov0" title="0">{
                return b, nil
        }</span>

        <span class="cov8" title="1">err := mapstructure.WeakDecode(m, &amp;b)

        // In 0.67.1 we changed the list attribute from a bool to a string (enum).
        // Bool values will become 0 or 1.
        switch b.List </span>{
        case "0":<span class="cov8" title="1">
                b.List = Never</span>
        case "1":<span class="cov8" title="1">
                b.List = Always</span>
        case Always, Never, ListLocally:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                b.List = Always</span>
        }

        // In 0.76.0 we changed the Render from bool to a string.
        <span class="cov8" title="1">switch b.Render </span>{
        case "0":<span class="cov0" title="0">
                b.Render = Never</span>
        case "1":<span class="cov8" title="1">
                b.Render = Always</span>
        case Always, Never, Link:<span class="cov8" title="1"></span>
        default:<span class="cov0" title="0">
                b.Render = Always</span>
        }

        <span class="cov8" title="1">return b, err</span>
}
</pre>
		
		<pre class="file" id="file228" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "fmt"
        "math/rand"

        "github.com/gohugoio/hugo/compare"

        "github.com/gohugoio/hugo/resources/resource"
)

var (
        _ resource.ResourcesConverter = Pages{}
        _ compare.ProbablyEqer        = Pages{}
)

// Pages is a slice of pages. This is the most common list type in Hugo.
type Pages []Page

func (ps Pages) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Pages(%d)", len(ps))
}</span>

// Used in tests.
func (ps Pages) shuffle() <span class="cov8" title="1">{
        for i := range ps </span><span class="cov8" title="1">{
                j := rand.Intn(i + 1)
                ps[i], ps[j] = ps[j], ps[i]
        }</span>
}

// ToResources wraps resource.ResourcesConverter
func (pages Pages) ToResources() resource.Resources <span class="cov0" title="0">{
        r := make(resource.Resources, len(pages))
        for i, p := range pages </span><span class="cov0" title="0">{
                r[i] = p
        }</span>
        <span class="cov0" title="0">return r</span>
}

// ToPages tries to convert seq into Pages.
func ToPages(seq interface{}) (Pages, error) <span class="cov8" title="1">{
        if seq == nil </span><span class="cov8" title="1">{
                return Pages{}, nil
        }</span>

        <span class="cov8" title="1">switch v := seq.(type) </span>{
        case Pages:<span class="cov8" title="1">
                return v, nil</span>
        case *Pages:<span class="cov0" title="0">
                return *(v), nil</span>
        case WeightedPages:<span class="cov0" title="0">
                return v.Pages(), nil</span>
        case PageGroup:<span class="cov0" title="0">
                return v.Pages, nil</span>
        case []Page:<span class="cov8" title="1">
                pages := make(Pages, len(v))
                for i, vv := range v </span><span class="cov8" title="1">{
                        pages[i] = vv
                }</span>
                <span class="cov8" title="1">return pages, nil</span>
        case []interface{}:<span class="cov8" title="1">
                pages := make(Pages, len(v))
                success := true
                for i, vv := range v </span><span class="cov8" title="1">{
                        p, ok := vv.(Page)
                        if !ok </span><span class="cov0" title="0">{
                                success = false
                                break</span>
                        }
                        <span class="cov8" title="1">pages[i] = p</span>
                }
                <span class="cov8" title="1">if success </span><span class="cov8" title="1">{
                        return pages, nil
                }</span>
        }

        <span class="cov8" title="1">return nil, fmt.Errorf("cannot convert type %T to Pages", seq)</span>
}

func (p Pages) Group(key interface{}, in interface{}) (interface{}, error) <span class="cov0" title="0">{
        pages, err := ToPages(in)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return PageGroup{Key: key, Pages: pages}, nil</span>
}

// Len returns the number of pages in the list.
func (p Pages) Len() int <span class="cov8" title="1">{
        return len(p)
}</span>

// ProbablyEq wraps compare.ProbablyEqer
func (pages Pages) ProbablyEq(other interface{}) bool <span class="cov8" title="1">{
        otherPages, ok := other.(Pages)
        if !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if len(pages) != len(otherPages) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">step := 1

        for i := 0; i &lt; len(pages); i += step </span><span class="cov8" title="1">{
                if !pages[i].Eq(otherPages[i]) </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">if i &gt; 50 </span><span class="cov0" title="0">{
                        // This is most likely the same.
                        step = 50
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

func (ps Pages) removeFirstIfFound(p Page) Pages <span class="cov8" title="1">{
        ii := -1
        for i, pp := range ps </span><span class="cov8" title="1">{
                if p.Eq(pp) </span><span class="cov8" title="1">{
                        ii = i
                        break</span>
                }
        }

        <span class="cov8" title="1">if ii != -1 </span><span class="cov8" title="1">{
                ps = append(ps[:ii], ps[ii+1:]...)
        }</span>
        <span class="cov8" title="1">return ps</span>
}

// PagesFactory somehow creates some Pages.
// We do a lot of lazy Pages initialization in Hugo, so we need a type.
type PagesFactory func() Pages
</pre>
		
		<pre class="file" id="file229" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "sync"
)

type pageCacheEntry struct {
        in  []Pages
        out Pages
}

func (entry pageCacheEntry) matches(pageLists []Pages) bool <span class="cov8" title="1">{
        if len(entry.in) != len(pageLists) </span><span class="cov0" title="0">{
                return false
        }</span>
        <span class="cov8" title="1">for i, p := range pageLists </span><span class="cov8" title="1">{
                if !pagesEqual(p, entry.in[i]) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }

        <span class="cov8" title="1">return true</span>
}

type pageCache struct {
        sync.RWMutex
        m map[string][]pageCacheEntry
}

func newPageCache() *pageCache <span class="cov8" title="1">{
        return &amp;pageCache{m: make(map[string][]pageCacheEntry)}
}</span>

func (c *pageCache) clear() <span class="cov0" title="0">{
        c.Lock()
        defer c.Unlock()
        c.m = make(map[string][]pageCacheEntry)
}</span>

// get/getP gets a Pages slice from the cache matching the given key and
// all the provided Pages slices.
// If none found in cache, a copy of the first slice is created.
//
// If an apply func is provided, that func is applied to the newly created copy.
//
// The getP variant' apply func takes a pointer to Pages.
//
// The cache and the execution of the apply func is protected by a RWMutex.
func (c *pageCache) get(key string, apply func(p Pages), pageLists ...Pages) (Pages, bool) <span class="cov8" title="1">{
        return c.getP(key, func(p *Pages) </span><span class="cov8" title="1">{
                if apply != nil </span><span class="cov8" title="1">{
                        apply(*p)
                }</span>
        }, pageLists...)
}

func (c *pageCache) getP(key string, apply func(p *Pages), pageLists ...Pages) (Pages, bool) <span class="cov8" title="1">{
        c.RLock()
        if cached, ok := c.m[key]; ok </span><span class="cov8" title="1">{
                for _, entry := range cached </span><span class="cov8" title="1">{
                        if entry.matches(pageLists) </span><span class="cov8" title="1">{
                                c.RUnlock()
                                return entry.out, true
                        }</span>
                }
        }
        <span class="cov8" title="1">c.RUnlock()

        c.Lock()
        defer c.Unlock()

        // double-check
        if cached, ok := c.m[key]; ok </span><span class="cov8" title="1">{
                for _, entry := range cached </span><span class="cov8" title="1">{
                        if entry.matches(pageLists) </span><span class="cov0" title="0">{
                                return entry.out, true
                        }</span>
                }
        }

        <span class="cov8" title="1">p := pageLists[0]
        pagesCopy := append(Pages(nil), p...)

        if apply != nil </span><span class="cov8" title="1">{
                apply(&amp;pagesCopy)
        }</span>

        <span class="cov8" title="1">entry := pageCacheEntry{in: pageLists, out: pagesCopy}
        if v, ok := c.m[key]; ok </span><span class="cov8" title="1">{
                c.m[key] = append(v, entry)
        }</span> else<span class="cov8" title="1"> {
                c.m[key] = []pageCacheEntry{entry}
        }</span>

        <span class="cov8" title="1">return pagesCopy, false</span>
}

// pagesEqual returns whether p1 and p2 are equal.
func pagesEqual(p1, p2 Pages) bool <span class="cov8" title="1">{
        if p1 == nil &amp;&amp; p2 == nil </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if p1 == nil || p2 == nil </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov8" title="1">if p1.Len() != p2.Len() </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if p1.Len() == 0 </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(p1); i++ </span><span class="cov8" title="1">{
                if p1[i] != p2[i] </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}
</pre>
		
		<pre class="file" id="file230" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "fmt"
)

var _ pagesLanguageMerger = (*Pages)(nil)

type pagesLanguageMerger interface {
        MergeByLanguage(other Pages) Pages
        // Needed for integration with the tpl package.
        MergeByLanguageInterface(other interface{}) (interface{}, error)
}

// MergeByLanguage supplies missing translations in p1 with values from p2.
// The result is sorted by the default sort order for pages.
func (p1 Pages) MergeByLanguage(p2 Pages) Pages <span class="cov0" title="0">{
        merge := func(pages *Pages) </span><span class="cov0" title="0">{
                m := make(map[string]bool)
                for _, p := range *pages </span><span class="cov0" title="0">{
                        m[p.TranslationKey()] = true
                }</span>

                <span class="cov0" title="0">for _, p := range p2 </span><span class="cov0" title="0">{
                        if _, found := m[p.TranslationKey()]; !found </span><span class="cov0" title="0">{
                                *pages = append(*pages, p)
                        }</span>
                }

                <span class="cov0" title="0">SortByDefault(*pages)</span>
        }

        <span class="cov0" title="0">out, _ := spc.getP("pages.MergeByLanguage", merge, p1, p2)

        return out</span>
}

// MergeByLanguageInterface is the generic version of MergeByLanguage. It
// is here just so it can be called from the tpl package.
func (p1 Pages) MergeByLanguageInterface(in interface{}) (interface{}, error) <span class="cov0" title="0">{
        if in == nil </span><span class="cov0" title="0">{
                return p1, nil
        }</span>
        <span class="cov0" title="0">p2, ok := in.(Pages)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("%T cannot be merged by language", in)
        }</span>
        <span class="cov0" title="0">return p1.MergeByLanguage(p2), nil</span>
}
</pre>
		
		<pre class="file" id="file231" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

// Next returns the next page relative to the given
func (p Pages) Next(cur Page) Page <span class="cov8" title="1">{
        x := searchPage(cur, p)
        if x &lt;= 0 </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return p[x-1]</span>
}

// Prev returns the previous page reletive to the given
func (p Pages) Prev(cur Page) Page <span class="cov8" title="1">{
        x := searchPage(cur, p)

        if x == -1 || len(p)-x &lt; 2 </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">return p[x+1]</span>
}
</pre>
		
		<pre class="file" id="file232" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "sync"

        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/related"
        "github.com/pkg/errors"
        "github.com/spf13/cast"
)

var (
        // Assert that Pages and PageGroup implements the PageGenealogist interface.
        _ PageGenealogist = (Pages)(nil)
        _ PageGenealogist = PageGroup{}
)

// A PageGenealogist finds related pages in a page collection. This interface is implemented
// by Pages and PageGroup, which makes it available as `{{ .RegularRelated . }}` etc.
type PageGenealogist interface {

        // Template example:
        // {{ $related := .RegularPages.Related . }}
        Related(doc related.Document) (Pages, error)

        // Template example:
        // {{ $related := .RegularPages.RelatedIndices . "tags" "date" }}
        RelatedIndices(doc related.Document, indices ...interface{}) (Pages, error)

        // Template example:
        // {{ $related := .RegularPages.RelatedTo ( keyVals "tags" "hugo", "rocks")  ( keyVals "date" .Date ) }}
        RelatedTo(args ...types.KeyValues) (Pages, error)
}

// Related searches all the configured indices with the search keywords from the
// supplied document.
func (p Pages) Related(doc related.Document) (Pages, error) <span class="cov8" title="1">{
        result, err := p.searchDoc(doc)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if page, ok := doc.(Page); ok </span><span class="cov8" title="1">{
                return result.removeFirstIfFound(page), nil
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// RelatedIndices searches the given indices with the search keywords from the
// supplied document.
func (p Pages) RelatedIndices(doc related.Document, indices ...interface{}) (Pages, error) <span class="cov8" title="1">{
        indicesStr, err := cast.ToStringSliceE(indices)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result, err := p.searchDoc(doc, indicesStr...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if page, ok := doc.(Page); ok </span><span class="cov8" title="1">{
                return result.removeFirstIfFound(page), nil
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// RelatedTo searches the given indices with the corresponding values.
func (p Pages) RelatedTo(args ...types.KeyValues) (Pages, error) <span class="cov8" title="1">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">return p.search(args...)</span>
}

func (p Pages) search(args ...types.KeyValues) (Pages, error) <span class="cov8" title="1">{
        return p.withInvertedIndex(func(idx *related.InvertedIndex) ([]related.Document, error) </span><span class="cov8" title="1">{
                return idx.SearchKeyValues(args...)
        }</span>)
}

func (p Pages) searchDoc(doc related.Document, indices ...string) (Pages, error) <span class="cov8" title="1">{
        return p.withInvertedIndex(func(idx *related.InvertedIndex) ([]related.Document, error) </span><span class="cov8" title="1">{
                return idx.SearchDoc(doc, indices...)
        }</span>)
}

func (p Pages) withInvertedIndex(search func(idx *related.InvertedIndex) ([]related.Document, error)) (Pages, error) <span class="cov8" title="1">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">d, ok := p[0].(InternalDependencies)
        if !ok </span><span class="cov0" title="0">{
                return nil, errors.Errorf("invalid type %T in related search", p[0])
        }</span>

        <span class="cov8" title="1">cache := d.GetRelatedDocsHandler()

        searchIndex, err := cache.getOrCreateIndex(p)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">result, err := search(searchIndex)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(result) &gt; 0 </span><span class="cov8" title="1">{
                mp := make(Pages, len(result))
                for i, match := range result </span><span class="cov8" title="1">{
                        mp[i] = match.(Page)
                }</span>
                <span class="cov8" title="1">return mp, nil</span>
        }

        <span class="cov0" title="0">return nil, nil</span>
}

type cachedPostingList struct {
        p Pages

        postingList *related.InvertedIndex
}

type RelatedDocsHandler struct {
        cfg related.Config

        postingLists []*cachedPostingList
        mu           sync.RWMutex
}

func NewRelatedDocsHandler(cfg related.Config) *RelatedDocsHandler <span class="cov8" title="1">{
        return &amp;RelatedDocsHandler{cfg: cfg}
}</span>

func (s *RelatedDocsHandler) Clone() *RelatedDocsHandler <span class="cov0" title="0">{
        return NewRelatedDocsHandler(s.cfg)
}</span>

// This assumes that a lock has been acquired.
func (s *RelatedDocsHandler) getIndex(p Pages) *related.InvertedIndex <span class="cov8" title="1">{
        for _, ci := range s.postingLists </span><span class="cov8" title="1">{
                if pagesEqual(p, ci.p) </span><span class="cov8" title="1">{
                        return ci.postingList
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func (s *RelatedDocsHandler) getOrCreateIndex(p Pages) (*related.InvertedIndex, error) <span class="cov8" title="1">{
        s.mu.RLock()
        cachedIndex := s.getIndex(p)
        if cachedIndex != nil </span><span class="cov8" title="1">{
                s.mu.RUnlock()
                return cachedIndex, nil
        }</span>
        <span class="cov8" title="1">s.mu.RUnlock()

        s.mu.Lock()
        defer s.mu.Unlock()

        if cachedIndex := s.getIndex(p); cachedIndex != nil </span><span class="cov0" title="0">{
                return cachedIndex, nil
        }</span>

        <span class="cov8" title="1">searchIndex := related.NewInvertedIndex(s.cfg)

        for _, page := range p </span><span class="cov8" title="1">{
                if err := searchIndex.Add(page); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">s.postingLists = append(s.postingLists, &amp;cachedPostingList{p: p, postingList: searchIndex})

        return searchIndex, nil</span>
}
</pre>
		
		<pre class="file" id="file233" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "sort"

        "github.com/gohugoio/hugo/common/collections"

        "github.com/gohugoio/hugo/resources/resource"

        "github.com/gohugoio/hugo/compare"
        "github.com/spf13/cast"
)

var spc = newPageCache()

/*
 * Implementation of a custom sorter for Pages
 */

// A pageSorter implements the sort interface for Pages
type pageSorter struct {
        pages Pages
        by    pageBy
}

// pageBy is a closure used in the Sort.Less method.
type pageBy func(p1, p2 Page) bool

func getOrdinals(p1, p2 Page) (int, int) <span class="cov8" title="1">{
        p1o, ok1 := p1.(collections.Order)
        if !ok1 </span><span class="cov8" title="1">{
                return -1, -1
        }</span>
        <span class="cov0" title="0">p2o, ok2 := p2.(collections.Order)
        if !ok2 </span><span class="cov0" title="0">{
                return -1, -1
        }</span>

        <span class="cov0" title="0">return p1o.Ordinal(), p2o.Ordinal()</span>
}

// Sort stable sorts the pages given the receiver's sort order.
func (by pageBy) Sort(pages Pages) <span class="cov8" title="1">{
        ps := &amp;pageSorter{
                pages: pages,
                by:    by, // The Sort method's receiver is the function (closure) that defines the sort order.
        }
        sort.Stable(ps)
}</span>

var (

        // DefaultPageSort is the default sort func for pages in Hugo:
        // Order by Ordinal, Weight, Date, LinkTitle and then full file path.
        DefaultPageSort = func(p1, p2 Page) bool <span class="cov8" title="1">{
                o1, o2 := getOrdinals(p1, p2)
                if o1 != o2 &amp;&amp; o1 != -1 &amp;&amp; o2 != -1 </span><span class="cov0" title="0">{
                        return o1 &lt; o2
                }</span>
                <span class="cov8" title="1">if p1.Weight() == p2.Weight() </span><span class="cov8" title="1">{
                        if p1.Date().Unix() == p2.Date().Unix() </span><span class="cov8" title="1">{
                                c := compare.Strings(p1.LinkTitle(), p2.LinkTitle())
                                if c == 0 </span><span class="cov0" title="0">{
                                        if p1.File().IsZero() || p2.File().IsZero() </span><span class="cov0" title="0">{
                                                return p1.File().IsZero()
                                        }</span>
                                        <span class="cov0" title="0">return compare.LessStrings(p1.File().Filename(), p2.File().Filename())</span>
                                }
                                <span class="cov8" title="1">return c &lt; 0</span>
                        }
                        <span class="cov8" title="1">return p1.Date().Unix() &gt; p2.Date().Unix()</span>
                }

                <span class="cov8" title="1">if p2.Weight() == 0 </span><span class="cov8" title="1">{
                        return true
                }</span>

                <span class="cov8" title="1">if p1.Weight() == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">return p1.Weight() &lt; p2.Weight()</span>
        }

        lessPageLanguage = func(p1, p2 Page) bool <span class="cov0" title="0">{
                if p1.Language().Weight == p2.Language().Weight </span><span class="cov0" title="0">{
                        if p1.Date().Unix() == p2.Date().Unix() </span><span class="cov0" title="0">{
                                c := compare.Strings(p1.LinkTitle(), p2.LinkTitle())
                                if c == 0 </span><span class="cov0" title="0">{
                                        if !p1.File().IsZero() &amp;&amp; !p2.File().IsZero() </span><span class="cov0" title="0">{
                                                return compare.LessStrings(p1.File().Filename(), p2.File().Filename())
                                        }</span>
                                }
                                <span class="cov0" title="0">return c &lt; 0</span>
                        }
                        <span class="cov0" title="0">return p1.Date().Unix() &gt; p2.Date().Unix()</span>
                }

                <span class="cov0" title="0">if p2.Language().Weight == 0 </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov0" title="0">if p1.Language().Weight == 0 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov0" title="0">return p1.Language().Weight &lt; p2.Language().Weight</span>
        }

        lessPageTitle = func(p1, p2 Page) bool <span class="cov8" title="1">{
                return compare.LessStrings(p1.Title(), p2.Title())
        }</span>

        lessPageLinkTitle = func(p1, p2 Page) bool <span class="cov8" title="1">{
                return compare.LessStrings(p1.LinkTitle(), p2.LinkTitle())
        }</span>

        lessPageDate = func(p1, p2 Page) bool <span class="cov8" title="1">{
                return p1.Date().Unix() &lt; p2.Date().Unix()
        }</span>

        lessPagePubDate = func(p1, p2 Page) bool <span class="cov8" title="1">{
                return p1.PublishDate().Unix() &lt; p2.PublishDate().Unix()
        }</span>
)

func (ps *pageSorter) Len() int      <span class="cov8" title="1">{ return len(ps.pages) }</span>
func (ps *pageSorter) Swap(i, j int) <span class="cov8" title="1">{ ps.pages[i], ps.pages[j] = ps.pages[j], ps.pages[i] }</span>

// Less is part of sort.Interface. It is implemented by calling the "by" closure in the sorter.
func (ps *pageSorter) Less(i, j int) bool <span class="cov8" title="1">{ return ps.by(ps.pages[i], ps.pages[j]) }</span>

// Limit limits the number of pages returned to n.
func (p Pages) Limit(n int) Pages <span class="cov8" title="1">{
        if len(p) &gt; n </span><span class="cov8" title="1">{
                return p[0:n]
        }</span>
        <span class="cov8" title="1">return p</span>
}

// ByWeight sorts the Pages by weight and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByWeight() Pages <span class="cov8" title="1">{
        const key = "pageSort.ByWeight"
        pages, _ := spc.get(key, pageBy(DefaultPageSort).Sort, p)
        return pages
}</span>

// SortByDefault sorts pages by the default sort.
func SortByDefault(pages Pages) <span class="cov8" title="1">{
        pageBy(DefaultPageSort).Sort(pages)
}</span>

// ByTitle sorts the Pages by title and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByTitle() Pages <span class="cov8" title="1">{
        const key = "pageSort.ByTitle"

        pages, _ := spc.get(key, pageBy(lessPageTitle).Sort, p)
        return pages
}</span>

// ByLinkTitle sorts the Pages by link title and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByLinkTitle() Pages <span class="cov8" title="1">{
        const key = "pageSort.ByLinkTitle"

        pages, _ := spc.get(key, pageBy(lessPageLinkTitle).Sort, p)

        return pages
}</span>

// ByDate sorts the Pages by date and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByDate() Pages <span class="cov8" title="1">{
        const key = "pageSort.ByDate"

        pages, _ := spc.get(key, pageBy(lessPageDate).Sort, p)

        return pages
}</span>

// ByPublishDate sorts the Pages by publish date and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByPublishDate() Pages <span class="cov8" title="1">{
        const key = "pageSort.ByPublishDate"

        pages, _ := spc.get(key, pageBy(lessPagePubDate).Sort, p)

        return pages
}</span>

// ByExpiryDate sorts the Pages by publish date and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByExpiryDate() Pages <span class="cov8" title="1">{
        const key = "pageSort.ByExpiryDate"

        expDate := func(p1, p2 Page) bool </span><span class="cov8" title="1">{
                return p1.ExpiryDate().Unix() &lt; p2.ExpiryDate().Unix()
        }</span>

        <span class="cov8" title="1">pages, _ := spc.get(key, pageBy(expDate).Sort, p)

        return pages</span>
}

// ByLastmod sorts the Pages by the last modification date and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByLastmod() Pages <span class="cov8" title="1">{
        const key = "pageSort.ByLastmod"

        date := func(p1, p2 Page) bool </span><span class="cov8" title="1">{
                return p1.Lastmod().Unix() &lt; p2.Lastmod().Unix()
        }</span>

        <span class="cov8" title="1">pages, _ := spc.get(key, pageBy(date).Sort, p)

        return pages</span>
}

// ByLength sorts the Pages by length and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByLength() Pages <span class="cov8" title="1">{
        const key = "pageSort.ByLength"

        length := func(p1, p2 Page) bool </span><span class="cov8" title="1">{
                p1l, ok1 := p1.(resource.LengthProvider)
                p2l, ok2 := p2.(resource.LengthProvider)

                if !ok1 </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov8" title="1">if !ok2 </span><span class="cov0" title="0">{
                        return false
                }</span>

                <span class="cov8" title="1">return p1l.Len() &lt; p2l.Len()</span>
        }

        <span class="cov8" title="1">pages, _ := spc.get(key, pageBy(length).Sort, p)

        return pages</span>
}

// ByLanguage sorts the Pages by the language's Weight.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByLanguage() Pages <span class="cov0" title="0">{
        const key = "pageSort.ByLanguage"

        pages, _ := spc.get(key, pageBy(lessPageLanguage).Sort, p)

        return pages
}</span>

// SortByLanguage sorts the pages by language.
func SortByLanguage(pages Pages) <span class="cov0" title="0">{
        pageBy(lessPageLanguage).Sort(pages)
}</span>

// Reverse reverses the order in Pages and returns a copy.
//
// Adjacent invocations on the same receiver will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) Reverse() Pages <span class="cov8" title="1">{
        const key = "pageSort.Reverse"

        reverseFunc := func(pages Pages) </span><span class="cov8" title="1">{
                for i, j := 0, len(pages)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                        pages[i], pages[j] = pages[j], pages[i]
                }</span>
        }

        <span class="cov8" title="1">pages, _ := spc.get(key, reverseFunc, p)

        return pages</span>
}

// ByParam sorts the pages according to the given page Params key.
//
// Adjacent invocations on the same receiver with the same paramsKey will return a cached result.
//
// This may safely be executed  in parallel.
func (p Pages) ByParam(paramsKey interface{}) Pages <span class="cov8" title="1">{
        paramsKeyStr := cast.ToString(paramsKey)
        key := "pageSort.ByParam." + paramsKeyStr

        paramsKeyComparator := func(p1, p2 Page) bool </span><span class="cov8" title="1">{
                v1, _ := p1.Param(paramsKeyStr)
                v2, _ := p2.Param(paramsKeyStr)

                if v1 == nil </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">if v2 == nil </span><span class="cov0" title="0">{
                        return true
                }</span>

                <span class="cov8" title="1">isNumeric := func(v interface{}) bool </span><span class="cov8" title="1">{
                        switch v.(type) </span>{
                        case uint8, uint16, uint32, uint64, int, int8, int16, int32, int64, float32, float64:<span class="cov8" title="1">
                                return true</span>
                        default:<span class="cov8" title="1">
                                return false</span>
                        }
                }

                <span class="cov8" title="1">if isNumeric(v1) &amp;&amp; isNumeric(v2) </span><span class="cov8" title="1">{
                        return cast.ToFloat64(v1) &lt; cast.ToFloat64(v2)
                }</span>

                <span class="cov8" title="1">s1 := cast.ToString(v1)
                s2 := cast.ToString(v2)

                return compare.LessStrings(s1, s2)</span>
        }

        <span class="cov8" title="1">pages, _ := spc.get(key, pageBy(paramsKeyComparator).Sort, p)

        return pages</span>
}
</pre>
		
		<pre class="file" id="file234" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import "sort"

// Used in page binary search, the most common in front.
var pageLessFunctions = []func(p1, p2 Page) bool{
        DefaultPageSort,
        lessPageDate,
        lessPagePubDate,
        lessPageTitle,
        lessPageLinkTitle,
}

func searchPage(p Page, pages Pages) int <span class="cov8" title="1">{
        if len(pages) &lt; 1000 </span><span class="cov8" title="1">{
                // For smaller data sets, doing a linear search is faster.
                return searchPageLinear(p, pages, 0)
        }</span>

        <span class="cov0" title="0">less := isPagesProbablySorted(pages, pageLessFunctions...)
        if less == nil </span><span class="cov0" title="0">{
                return searchPageLinear(p, pages, 0)
        }</span>

        <span class="cov0" title="0">i := searchPageBinary(p, pages, less)
        if i != -1 </span><span class="cov0" title="0">{
                return i
        }</span>

        <span class="cov0" title="0">return searchPageLinear(p, pages, 0)</span>
}

func searchPageLinear(p Page, pages Pages, start int) int <span class="cov8" title="1">{
        for i := start; i &lt; len(pages); i++ </span><span class="cov8" title="1">{
                c := pages[i]
                if c.Eq(p) </span><span class="cov8" title="1">{
                        return i
                }</span>
        }
        <span class="cov0" title="0">return -1</span>
}

func searchPageBinary(p Page, pages Pages, less func(p1, p2 Page) bool) int <span class="cov8" title="1">{
        n := len(pages)

        f := func(i int) bool </span><span class="cov8" title="1">{
                c := pages[i]
                isLess := less(c, p)
                return !isLess || c.Eq(p)
        }</span>

        <span class="cov8" title="1">i := sort.Search(n, f)

        if i == n </span><span class="cov0" title="0">{
                return -1
        }</span>

        <span class="cov8" title="1">return searchPageLinear(p, pages, i)</span>
}

// isProbablySorted tests if the pages slice is probably sorted.
func isPagesProbablySorted(pages Pages, lessFuncs ...func(p1, p2 Page) bool) func(p1, p2 Page) bool <span class="cov8" title="1">{
        n := len(pages)
        step := 1
        if n &gt; 500 </span><span class="cov0" title="0">{
                step = 50
        }</span>

        <span class="cov8" title="1">is := func(less func(p1, p2 Page) bool) bool </span><span class="cov8" title="1">{
                samples := 0

                for i := n - 1; i &gt; 0; i = i - step </span><span class="cov8" title="1">{
                        if less(pages[i], pages[i-1]) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">samples++
                        if samples &gt;= 15 </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return samples &gt; 0</span>
        }

        <span class="cov8" title="1">isReverse := func(less func(p1, p2 Page) bool) bool </span><span class="cov8" title="1">{
                samples := 0

                for i := 0; i &lt; n-1; i = i + step </span><span class="cov8" title="1">{
                        if less(pages[i], pages[i+1]) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                        <span class="cov8" title="1">samples++

                        if samples &gt; 15 </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
                <span class="cov8" title="1">return samples &gt; 0</span>
        }

        <span class="cov8" title="1">for _, less := range lessFuncs </span><span class="cov8" title="1">{
                if is(less) </span><span class="cov8" title="1">{
                        return less
                }</span>
                <span class="cov8" title="1">if isReverse(less) </span><span class="cov8" title="1">{
                        return func(p1, p2 Page) bool </span><span class="cov8" title="1">{
                                return less(p2, p1)
                        }</span>
                }
        }

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file235" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "errors"
        "fmt"
        "html/template"
        "math"
        "reflect"

        "github.com/gohugoio/hugo/config"

        "github.com/spf13/cast"
)

// PaginatorProvider provides two ways to create a page paginator.
type PaginatorProvider interface {
        Paginator(options ...interface{}) (*Pager, error)
        Paginate(seq interface{}, options ...interface{}) (*Pager, error)
}

// Pager represents one of the elements in a paginator.
// The number, starting on 1, represents its place.
type Pager struct {
        number int
        *Paginator
}

func (p Pager) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("Pager %d", p.number)
}</span>

type paginatedElement interface {
        Len() int
}

type pagers []*Pager

var (
        paginatorEmptyPages      Pages
        paginatorEmptyPageGroups PagesGroup
)

type Paginator struct {
        paginatedElements []paginatedElement
        pagers
        paginationURLFactory
        total int
        size  int
}

type paginationURLFactory func(int) string

// PageNumber returns the current page's number in the pager sequence.
func (p *Pager) PageNumber() int <span class="cov8" title="1">{
        return p.number
}</span>

// URL returns the URL to the current page.
func (p *Pager) URL() template.HTML <span class="cov8" title="1">{
        return template.HTML(p.paginationURLFactory(p.PageNumber()))
}</span>

// Pages returns the Pages on this page.
// Note: If this return a non-empty result, then PageGroups() will return empty.
func (p *Pager) Pages() Pages <span class="cov8" title="1">{
        if len(p.paginatedElements) == 0 </span><span class="cov8" title="1">{
                return paginatorEmptyPages
        }</span>

        <span class="cov8" title="1">if pages, ok := p.element().(Pages); ok </span><span class="cov8" title="1">{
                return pages
        }</span>

        <span class="cov8" title="1">return paginatorEmptyPages</span>
}

// PageGroups return Page groups for this page.
// Note: If this return non-empty result, then Pages() will return empty.
func (p *Pager) PageGroups() PagesGroup <span class="cov8" title="1">{
        if len(p.paginatedElements) == 0 </span><span class="cov8" title="1">{
                return paginatorEmptyPageGroups
        }</span>

        <span class="cov8" title="1">if groups, ok := p.element().(PagesGroup); ok </span><span class="cov8" title="1">{
                return groups
        }</span>

        <span class="cov8" title="1">return paginatorEmptyPageGroups</span>
}

func (p *Pager) element() paginatedElement <span class="cov8" title="1">{
        if len(p.paginatedElements) == 0 </span><span class="cov8" title="1">{
                return paginatorEmptyPages
        }</span>
        <span class="cov8" title="1">return p.paginatedElements[p.PageNumber()-1]</span>
}

// page returns the Page with the given index
func (p *Pager) page(index int) (Page, error) <span class="cov8" title="1">{
        if pages, ok := p.element().(Pages); ok </span><span class="cov8" title="1">{
                if pages != nil &amp;&amp; len(pages) &gt; index </span><span class="cov8" title="1">{
                        return pages[index], nil
                }</span>
                <span class="cov8" title="1">return nil, nil</span>
        }

        // must be PagesGroup
        // this construction looks clumsy, but ...
        // ... it is the difference between 99.5% and 100% test coverage :-)
        <span class="cov8" title="1">groups := p.element().(PagesGroup)

        i := 0
        for _, v := range groups </span><span class="cov8" title="1">{
                for _, page := range v.Pages </span><span class="cov8" title="1">{
                        if i == index </span><span class="cov8" title="1">{
                                return page, nil
                        }</span>
                        <span class="cov8" title="1">i++</span>
                }
        }
        <span class="cov8" title="1">return nil, nil</span>
}

// NumberOfElements gets the number of elements on this page.
func (p *Pager) NumberOfElements() int <span class="cov8" title="1">{
        return p.element().Len()
}</span>

// HasPrev tests whether there are page(s) before the current.
func (p *Pager) HasPrev() bool <span class="cov8" title="1">{
        return p.PageNumber() &gt; 1
}</span>

// Prev returns the pager for the previous page.
func (p *Pager) Prev() *Pager <span class="cov8" title="1">{
        if !p.HasPrev() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return p.pagers[p.PageNumber()-2]</span>
}

// HasNext tests whether there are page(s) after the current.
func (p *Pager) HasNext() bool <span class="cov8" title="1">{
        return p.PageNumber() &lt; len(p.paginatedElements)
}</span>

// Next returns the pager for the next page.
func (p *Pager) Next() *Pager <span class="cov8" title="1">{
        if !p.HasNext() </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">return p.pagers[p.PageNumber()]</span>
}

// First returns the pager for the first page.
func (p *Pager) First() *Pager <span class="cov8" title="1">{
        return p.pagers[0]
}</span>

// Last returns the pager for the last page.
func (p *Pager) Last() *Pager <span class="cov8" title="1">{
        return p.pagers[len(p.pagers)-1]
}</span>

// Pagers returns a list of pagers that can be used to build a pagination menu.
func (p *Paginator) Pagers() pagers <span class="cov8" title="1">{
        return p.pagers
}</span>

// PageSize returns the size of each paginator page.
func (p *Paginator) PageSize() int <span class="cov8" title="1">{
        return p.size
}</span>

// TotalPages returns the number of pages in the paginator.
func (p *Paginator) TotalPages() int <span class="cov8" title="1">{
        return len(p.paginatedElements)
}</span>

// TotalNumberOfElements returns the number of elements on all pages in this paginator.
func (p *Paginator) TotalNumberOfElements() int <span class="cov8" title="1">{
        return p.total
}</span>

func splitPages(pages Pages, size int) []paginatedElement <span class="cov8" title="1">{
        var split []paginatedElement
        for low, j := 0, len(pages); low &lt; j; low += size </span><span class="cov8" title="1">{
                high := int(math.Min(float64(low+size), float64(len(pages))))
                split = append(split, pages[low:high])
        }</span>

        <span class="cov8" title="1">return split</span>
}

func splitPageGroups(pageGroups PagesGroup, size int) []paginatedElement <span class="cov8" title="1">{
        type keyPage struct {
                key  interface{}
                page Page
        }

        var (
                split     []paginatedElement
                flattened []keyPage
        )

        for _, g := range pageGroups </span><span class="cov8" title="1">{
                for _, p := range g.Pages </span><span class="cov8" title="1">{
                        flattened = append(flattened, keyPage{g.Key, p})
                }</span>
        }

        <span class="cov8" title="1">numPages := len(flattened)

        for low, j := 0, numPages; low &lt; j; low += size </span><span class="cov8" title="1">{
                high := int(math.Min(float64(low+size), float64(numPages)))

                var (
                        pg         PagesGroup
                        key        interface{}
                        groupIndex = -1
                )

                for k := low; k &lt; high; k++ </span><span class="cov8" title="1">{
                        kp := flattened[k]
                        if key == nil || key != kp.key </span><span class="cov8" title="1">{
                                key = kp.key
                                pg = append(pg, PageGroup{Key: key})
                                groupIndex++
                        }</span>
                        <span class="cov8" title="1">pg[groupIndex].Pages = append(pg[groupIndex].Pages, kp.page)</span>
                }
                <span class="cov8" title="1">split = append(split, pg)</span>
        }

        <span class="cov8" title="1">return split</span>
}

func ResolvePagerSize(cfg config.Provider, options ...interface{}) (int, error) <span class="cov0" title="0">{
        if len(options) == 0 </span><span class="cov0" title="0">{
                return cfg.GetInt("paginate"), nil
        }</span>

        <span class="cov0" title="0">if len(options) &gt; 1 </span><span class="cov0" title="0">{
                return -1, errors.New("too many arguments, 'pager size' is currently the only option")
        }</span>

        <span class="cov0" title="0">pas, err := cast.ToIntE(options[0])

        if err != nil || pas &lt;= 0 </span><span class="cov0" title="0">{
                return -1, errors.New(("'pager size' must be a positive integer"))
        }</span>

        <span class="cov0" title="0">return pas, nil</span>
}

func Paginate(td TargetPathDescriptor, seq interface{}, pagerSize int) (*Paginator, error) <span class="cov0" title="0">{
        if pagerSize &lt;= 0 </span><span class="cov0" title="0">{
                return nil, errors.New("'paginate' configuration setting must be positive to paginate")
        }</span>

        <span class="cov0" title="0">urlFactory := newPaginationURLFactory(td)

        var paginator *Paginator

        groups, err := ToPagesGroup(seq)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">if groups != nil </span><span class="cov0" title="0">{
                paginator, _ = newPaginatorFromPageGroups(groups, pagerSize, urlFactory)
        }</span> else<span class="cov0" title="0"> {
                pages, err := ToPages(seq)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">paginator, _ = newPaginatorFromPages(pages, pagerSize, urlFactory)</span>
        }

        <span class="cov0" title="0">return paginator, nil</span>
}

// probablyEqual checks page lists for probable equality.
// It may return false positives.
// The motivation behind this is to avoid potential costly reflect.DeepEqual
// when "probably" is good enough.
func probablyEqualPageLists(a1 interface{}, a2 interface{}) bool <span class="cov8" title="1">{
        if a1 == nil || a2 == nil </span><span class="cov8" title="1">{
                return a1 == a2
        }</span>

        <span class="cov8" title="1">t1 := reflect.TypeOf(a1)
        t2 := reflect.TypeOf(a2)

        if t1 != t2 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if g1, ok := a1.(PagesGroup); ok </span><span class="cov8" title="1">{
                g2 := a2.(PagesGroup)
                if len(g1) != len(g2) </span><span class="cov8" title="1">{
                        return false
                }</span>
                <span class="cov8" title="1">if len(g1) == 0 </span><span class="cov8" title="1">{
                        return true
                }</span>
                <span class="cov8" title="1">if g1.Len() != g2.Len() </span><span class="cov8" title="1">{
                        return false
                }</span>

                <span class="cov8" title="1">return g1[0].Pages[0] == g2[0].Pages[0]</span>
        }

        <span class="cov8" title="1">p1, err1 := ToPages(a1)
        p2, err2 := ToPages(a2)

        // probably the same wrong type
        if err1 != nil &amp;&amp; err2 != nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if len(p1) != len(p2) </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if len(p1) == 0 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">return p1[0] == p2[0]</span>
}

func newPaginatorFromPages(pages Pages, size int, urlFactory paginationURLFactory) (*Paginator, error) <span class="cov8" title="1">{
        if size &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("Paginator size must be positive")
        }</span>

        <span class="cov8" title="1">split := splitPages(pages, size)

        return newPaginator(split, len(pages), size, urlFactory)</span>
}

func newPaginatorFromPageGroups(pageGroups PagesGroup, size int, urlFactory paginationURLFactory) (*Paginator, error) <span class="cov8" title="1">{
        if size &lt;= 0 </span><span class="cov8" title="1">{
                return nil, errors.New("Paginator size must be positive")
        }</span>

        <span class="cov8" title="1">split := splitPageGroups(pageGroups, size)

        return newPaginator(split, pageGroups.Len(), size, urlFactory)</span>
}

func newPaginator(elements []paginatedElement, total, size int, urlFactory paginationURLFactory) (*Paginator, error) <span class="cov8" title="1">{
        p := &amp;Paginator{total: total, paginatedElements: elements, size: size, paginationURLFactory: urlFactory}

        var ps pagers

        if len(elements) &gt; 0 </span><span class="cov8" title="1">{
                ps = make(pagers, len(elements))
                for i := range p.paginatedElements </span><span class="cov8" title="1">{
                        ps[i] = &amp;Pager{number: (i + 1), Paginator: p}
                }</span>
        } else<span class="cov8" title="1"> {
                ps = make(pagers, 1)
                ps[0] = &amp;Pager{number: 1, Paginator: p}
        }</span>

        <span class="cov8" title="1">p.pagers = ps

        return p, nil</span>
}

func newPaginationURLFactory(d TargetPathDescriptor) paginationURLFactory <span class="cov8" title="1">{
        return func(pageNumber int) string </span><span class="cov8" title="1">{
                pathDescriptor := d
                var rel string
                if pageNumber &gt; 1 </span><span class="cov8" title="1">{
                        rel = fmt.Sprintf("/%s/%d/", d.PathSpec.PaginatePath, pageNumber)
                        pathDescriptor.Addends = rel
                }</span>

                <span class="cov8" title="1">return CreateTargetPaths(pathDescriptor).RelPermalink(d.PathSpec)</span>
        }
}
</pre>
		
		<pre class="file" id="file236" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "fmt"
        "os"
        "path"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"
        "time"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/helpers"
)

// PermalinkExpander holds permalin mappings per section.
type PermalinkExpander struct {
        // knownPermalinkAttributes maps :tags in a permalink specification to a
        // function which, given a page and the tag, returns the resulting string
        // to be used to replace that tag.
        knownPermalinkAttributes map[string]pageToPermaAttribute

        expanders map[string]func(Page) (string, error)

        ps *helpers.PathSpec
}

// Time for checking date formats. Every field is different than the
// Go reference time for date formatting. This ensures that formatting this date
// with a Go time format always has a different output than the format itself.
var referenceTime = time.Date(2019, time.November, 9, 23, 1, 42, 1, time.UTC)

// Return the callback for the given permalink attribute and a boolean indicating if the attribute is valid or not.
func (p PermalinkExpander) callback(attr string) (pageToPermaAttribute, bool) <span class="cov8" title="1">{
        if callback, ok := p.knownPermalinkAttributes[attr]; ok </span><span class="cov8" title="1">{
                return callback, true
        }</span>

        <span class="cov8" title="1">if strings.HasPrefix(attr, "sections[") </span><span class="cov8" title="1">{
                fn := p.toSliceFunc(strings.TrimPrefix(attr, "sections"))
                return func(p Page, s string) (string, error) </span><span class="cov8" title="1">{
                        return path.Join(fn(p.CurrentSection().SectionsEntries())...), nil
                }</span>, true
        }

        // Make sure this comes after all the other checks.
        <span class="cov8" title="1">if referenceTime.Format(attr) != attr </span><span class="cov8" title="1">{
                return p.pageToPermalinkDate, true
        }</span>

        <span class="cov0" title="0">return nil, false</span>
}

// NewPermalinkExpander creates a new PermalinkExpander configured by the given
// PathSpec.
func NewPermalinkExpander(ps *helpers.PathSpec) (PermalinkExpander, error) <span class="cov8" title="1">{
        p := PermalinkExpander{ps: ps}

        p.knownPermalinkAttributes = map[string]pageToPermaAttribute{
                "year":        p.pageToPermalinkDate,
                "month":       p.pageToPermalinkDate,
                "monthname":   p.pageToPermalinkDate,
                "day":         p.pageToPermalinkDate,
                "weekday":     p.pageToPermalinkDate,
                "weekdayname": p.pageToPermalinkDate,
                "yearday":     p.pageToPermalinkDate,
                "section":     p.pageToPermalinkSection,
                "sections":    p.pageToPermalinkSections,
                "title":       p.pageToPermalinkTitle,
                "slug":        p.pageToPermalinkSlugElseTitle,
                "filename":    p.pageToPermalinkFilename,
        }

        patterns := ps.Cfg.GetStringMapString("permalinks")
        if patterns == nil </span><span class="cov8" title="1">{
                return p, nil
        }</span>

        <span class="cov8" title="1">e, err := p.parse(patterns)
        if err != nil </span><span class="cov0" title="0">{
                return p, err
        }</span>

        <span class="cov8" title="1">p.expanders = e

        return p, nil</span>
}

// Expand expands the path in p according to the rules defined for the given key.
// If no rules are found for the given key, an empty string is returned.
func (l PermalinkExpander) Expand(key string, p Page) (string, error) <span class="cov8" title="1">{
        expand, found := l.expanders[key]

        if !found </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">return expand(p)</span>
}

func (l PermalinkExpander) parse(patterns map[string]string) (map[string]func(Page) (string, error), error) <span class="cov8" title="1">{
        expanders := make(map[string]func(Page) (string, error))

        // Allow " " and / to represent the root section.
        const sectionCutSet = " /" + string(os.PathSeparator)

        for k, pattern := range patterns </span><span class="cov8" title="1">{
                k = strings.Trim(k, sectionCutSet)

                if !l.validate(pattern) </span><span class="cov0" title="0">{
                        return nil, &amp;permalinkExpandError{pattern: pattern, err: errPermalinkIllFormed}
                }</span>

                <span class="cov8" title="1">pattern := pattern
                matches := attributeRegexp.FindAllStringSubmatch(pattern, -1)

                callbacks := make([]pageToPermaAttribute, len(matches))
                replacements := make([]string, len(matches))
                for i, m := range matches </span><span class="cov8" title="1">{
                        replacement := m[0]
                        attr := replacement[1:]
                        replacements[i] = replacement
                        callback, ok := l.callback(attr)

                        if !ok </span><span class="cov0" title="0">{
                                return nil, &amp;permalinkExpandError{pattern: pattern, err: errPermalinkAttributeUnknown}
                        }</span>

                        <span class="cov8" title="1">callbacks[i] = callback</span>
                }

                <span class="cov8" title="1">expanders[k] = func(p Page) (string, error) </span><span class="cov8" title="1">{
                        if matches == nil </span><span class="cov0" title="0">{
                                return pattern, nil
                        }</span>

                        <span class="cov8" title="1">newField := pattern

                        for i, replacement := range replacements </span><span class="cov8" title="1">{
                                attr := replacement[1:]
                                callback := callbacks[i]
                                newAttr, err := callback(p, attr)
                                if err != nil </span><span class="cov0" title="0">{
                                        return "", &amp;permalinkExpandError{pattern: pattern, err: err}
                                }</span>

                                <span class="cov8" title="1">newField = strings.Replace(newField, replacement, newAttr, 1)</span>

                        }

                        <span class="cov8" title="1">return newField, nil</span>
                }

        }

        <span class="cov8" title="1">return expanders, nil</span>
}

// pageToPermaAttribute is the type of a function which, given a page and a tag
// can return a string to go in that position in the page (or an error)
type pageToPermaAttribute func(Page, string) (string, error)

var attributeRegexp = regexp.MustCompile(`:\w+(\[.+\])?`)

// validate determines if a PathPattern is well-formed
func (l PermalinkExpander) validate(pp string) bool <span class="cov8" title="1">{
        fragments := strings.Split(pp[1:], "/")
        bail := false
        for i := range fragments </span><span class="cov8" title="1">{
                if bail </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">if len(fragments[i]) == 0 </span><span class="cov8" title="1">{
                        bail = true
                        continue</span>
                }

                <span class="cov8" title="1">matches := attributeRegexp.FindAllStringSubmatch(fragments[i], -1)
                if matches == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">for _, match := range matches </span><span class="cov8" title="1">{
                        k := match[0][1:]
                        if _, ok := l.callback(k); !ok </span><span class="cov0" title="0">{
                                return false
                        }</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

type permalinkExpandError struct {
        pattern string
        err     error
}

func (pee *permalinkExpandError) Error() string <span class="cov0" title="0">{
        return fmt.Sprintf("error expanding %q: %s", pee.pattern, pee.err)
}</span>

var (
        errPermalinkIllFormed        = errors.New("permalink ill-formed")
        errPermalinkAttributeUnknown = errors.New("permalink attribute not recognised")
)

func (l PermalinkExpander) pageToPermalinkDate(p Page, dateField string) (string, error) <span class="cov8" title="1">{
        // a Page contains a Node which provides a field Date, time.Time
        switch dateField </span>{
        case "year":<span class="cov8" title="1">
                return strconv.Itoa(p.Date().Year()), nil</span>
        case "month":<span class="cov8" title="1">
                return fmt.Sprintf("%02d", int(p.Date().Month())), nil</span>
        case "monthname":<span class="cov8" title="1">
                return p.Date().Month().String(), nil</span>
        case "day":<span class="cov8" title="1">
                return fmt.Sprintf("%02d", p.Date().Day()), nil</span>
        case "weekday":<span class="cov8" title="1">
                return strconv.Itoa(int(p.Date().Weekday())), nil</span>
        case "weekdayname":<span class="cov8" title="1">
                return p.Date().Weekday().String(), nil</span>
        case "yearday":<span class="cov8" title="1">
                return strconv.Itoa(p.Date().YearDay()), nil</span>
        }

        <span class="cov8" title="1">return p.Date().Format(dateField), nil</span>
}

// pageToPermalinkTitle returns the URL-safe form of the title
func (l PermalinkExpander) pageToPermalinkTitle(p Page, _ string) (string, error) <span class="cov8" title="1">{
        return l.ps.URLize(p.Title()), nil
}</span>

// pageToPermalinkFilename returns the URL-safe form of the filename
func (l PermalinkExpander) pageToPermalinkFilename(p Page, _ string) (string, error) <span class="cov8" title="1">{
        name := p.File().TranslationBaseName()
        if name == "index" </span><span class="cov0" title="0">{
                // Page bundles; the directory name will hopefully have a better name.
                dir := strings.TrimSuffix(p.File().Dir(), helpers.FilePathSeparator)
                _, name = filepath.Split(dir)
        }</span>

        <span class="cov8" title="1">return l.ps.URLize(name), nil</span>
}

// if the page has a slug, return the slug, else return the title
func (l PermalinkExpander) pageToPermalinkSlugElseTitle(p Page, a string) (string, error) <span class="cov8" title="1">{
        if p.Slug() != "" </span><span class="cov8" title="1">{
                return l.ps.URLize(p.Slug()), nil
        }</span>
        <span class="cov0" title="0">return l.pageToPermalinkTitle(p, a)</span>
}

func (l PermalinkExpander) pageToPermalinkSection(p Page, _ string) (string, error) <span class="cov8" title="1">{
        return p.Section(), nil
}</span>

func (l PermalinkExpander) pageToPermalinkSections(p Page, _ string) (string, error) <span class="cov8" title="1">{
        return p.CurrentSection().SectionsPath(), nil
}</span>

var (
        nilSliceFunc = func(s []string) []string <span class="cov8" title="1">{
                return nil
        }</span>
        allSliceFunc = func(s []string) []string <span class="cov8" title="1">{
                return s
        }</span>
)

// toSliceFunc returns a slice func that slices s according to the cut spec.
// The cut spec must be on form [low:high] (one or both can be omitted),
// also allowing single slice indices (e.g. [2]) and the special [last] keyword
// giving the last element of the slice.
// The returned function will be lenient and not panic in out of bounds situation.
//
// The current use case for this is to use parts of the sections path in permalinks.
func (l PermalinkExpander) toSliceFunc(cut string) func(s []string) []string <span class="cov8" title="1">{
        cut = strings.ToLower(strings.TrimSpace(cut))
        if cut == "" </span><span class="cov8" title="1">{
                return allSliceFunc
        }</span>

        <span class="cov8" title="1">if len(cut) &lt; 3 || (cut[0] != '[' || cut[len(cut)-1] != ']') </span><span class="cov8" title="1">{
                return nilSliceFunc
        }</span>

        <span class="cov8" title="1">toNFunc := func(s string, low bool) func(ss []string) int </span><span class="cov8" title="1">{
                if s == "" </span><span class="cov8" title="1">{
                        if low </span><span class="cov8" title="1">{
                                return func(ss []string) int </span><span class="cov8" title="1">{
                                        return 0
                                }</span>
                        } else<span class="cov8" title="1"> {
                                return func(ss []string) int </span><span class="cov8" title="1">{
                                        return len(ss)
                                }</span>
                        }
                }

                <span class="cov8" title="1">if s == "last" </span><span class="cov8" title="1">{
                        return func(ss []string) int </span><span class="cov8" title="1">{
                                return len(ss) - 1
                        }</span>
                }

                <span class="cov8" title="1">n, _ := strconv.Atoi(s)
                if n &lt; 0 </span><span class="cov8" title="1">{
                        n = 0
                }</span>
                <span class="cov8" title="1">return func(ss []string) int </span><span class="cov8" title="1">{
                        // Prevent out of bound situations. It would not make
                        // much sense to panic here.
                        if n &gt; len(ss) </span><span class="cov8" title="1">{
                                return len(ss)
                        }</span>
                        <span class="cov8" title="1">return n</span>
                }
        }

        <span class="cov8" title="1">opsStr := cut[1 : len(cut)-1]
        opts := strings.Split(opsStr, ":")

        if !strings.Contains(opsStr, ":") </span><span class="cov8" title="1">{
                toN := toNFunc(opts[0], true)
                return func(s []string) []string </span><span class="cov8" title="1">{
                        if len(s) == 0 </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">v := s[toN(s)]
                        if v == "" </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">return []string{v}</span>
                }
        }

        <span class="cov8" title="1">toN1, toN2 := toNFunc(opts[0], true), toNFunc(opts[1], false)

        return func(s []string) []string </span><span class="cov8" title="1">{
                if len(s) == 0 </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">return s[toN1(s):toN2(s)]</span>
        }

}
</pre>
		
		<pre class="file" id="file237" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "html/template"
        "time"

        "github.com/gohugoio/hugo/common/maps"

        "github.com/gohugoio/hugo/config"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/navigation"
)

// Site represents a site in the build. This is currently a very narrow interface,
// but the actual implementation will be richer, see hugolib.SiteInfo.
type Site interface {
        Language() *langs.Language
        RegularPages() Pages
        Pages() Pages
        IsServer() bool
        ServerPort() int
        Title() string
        Sites() Sites
        Hugo() hugo.Info
        BaseURL() template.URL
        Taxonomies() interface{}
        LastChange() time.Time
        Menus() navigation.Menus
        Params() maps.Params
        Data() map[string]interface{}
}

// Sites represents an ordered list of sites (languages).
type Sites []Site

// First is a convenience method to get the first Site, i.e. the main language.
func (s Sites) First() Site <span class="cov0" title="0">{
        if len(s) == 0 </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return s[0]</span>
}

type testSite struct {
        h hugo.Info
        l *langs.Language
}

func (t testSite) Hugo() hugo.Info <span class="cov0" title="0">{
        return t.h
}</span>

func (t testSite) ServerPort() int <span class="cov0" title="0">{
        return 1313
}</span>

func (testSite) LastChange() (t time.Time) <span class="cov0" title="0">{
        return
}</span>

func (t testSite) Title() string <span class="cov0" title="0">{
        return "foo"
}</span>

func (t testSite) Sites() Sites <span class="cov0" title="0">{
        return nil
}</span>

func (t testSite) IsServer() bool <span class="cov0" title="0">{
        return false
}</span>

func (t testSite) Language() *langs.Language <span class="cov0" title="0">{
        return t.l
}</span>

func (t testSite) Pages() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (t testSite) RegularPages() Pages <span class="cov0" title="0">{
        return nil
}</span>

func (t testSite) Menus() navigation.Menus <span class="cov0" title="0">{
        return nil
}</span>

func (t testSite) Taxonomies() interface{} <span class="cov0" title="0">{
        return nil
}</span>

func (t testSite) BaseURL() template.URL <span class="cov0" title="0">{
        return ""
}</span>

func (t testSite) Params() maps.Params <span class="cov0" title="0">{
        return nil
}</span>

func (t testSite) Data() map[string]interface{} <span class="cov0" title="0">{
        return nil
}</span>

// NewDummyHugoSite creates a new minimal test site.
func NewDummyHugoSite(cfg config.Provider) Site <span class="cov0" title="0">{
        return testSite{
                h: hugo.NewInfo(hugo.EnvironmentProduction, nil),
                l: langs.NewLanguage("en", cfg),
        }
}</span>
</pre>
		
		<pre class="file" id="file238" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package page

import (
        "fmt"
        "sort"

        "github.com/gohugoio/hugo/common/collections"
)

var _ collections.Slicer = WeightedPage{}

// WeightedPages is a list of Pages with their corresponding (and relative) weight
// [{Weight: 30, Page: *1}, {Weight: 40, Page: *2}]
type WeightedPages []WeightedPage

// Page will return the Page (of Kind taxonomyList) that represents this set
// of pages. This method will panic if p is empty, as that should never happen.
func (p WeightedPages) Page() Page <span class="cov0" title="0">{
        if len(p) == 0 </span><span class="cov0" title="0">{
                panic("WeightedPages is empty")</span>
        }

        <span class="cov0" title="0">first := p[0]

        // TODO(bep) fix tests
        if first.owner == nil </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">return first.owner</span>
}

// A WeightedPage is a Page with a weight.
type WeightedPage struct {
        Weight int
        Page

        // Reference to the owning Page. This avoids having to do
        // manual .Site.GetPage lookups. It is implemented in this roundabout way
        // because we cannot add additional state to the WeightedPages slice
        // without breaking lots of templates in the wild.
        owner Page
}

func NewWeightedPage(weight int, p Page, owner Page) WeightedPage <span class="cov0" title="0">{
        return WeightedPage{Weight: weight, Page: p, owner: owner}
}</span>

func (w WeightedPage) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("WeightedPage(%d,%q)", w.Weight, w.Page.Title())
}</span>

// Slice is not meant to be used externally. It's a bridge function
// for the template functions. See collections.Slice.
func (p WeightedPage) Slice(in interface{}) (interface{}, error) <span class="cov0" title="0">{
        switch items := in.(type) </span>{
        case WeightedPages:<span class="cov0" title="0">
                return items, nil</span>
        case []interface{}:<span class="cov0" title="0">
                weighted := make(WeightedPages, len(items))
                for i, v := range items </span><span class="cov0" title="0">{
                        g, ok := v.(WeightedPage)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("type %T is not a WeightedPage", v)
                        }</span>
                        <span class="cov0" title="0">weighted[i] = g</span>
                }
                <span class="cov0" title="0">return weighted, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid slice type %T", items)</span>
        }
}

// Pages returns the Pages in this weighted page set.
func (wp WeightedPages) Pages() Pages <span class="cov0" title="0">{
        pages := make(Pages, len(wp))
        for i := range wp </span><span class="cov0" title="0">{
                pages[i] = wp[i].Page
        }</span>
        <span class="cov0" title="0">return pages</span>
}

// Next returns the next Page relative to the given Page in
// this weighted page set.
func (wp WeightedPages) Next(cur Page) Page <span class="cov8" title="1">{
        for x, c := range wp </span><span class="cov8" title="1">{
                if c.Page.Eq(cur) </span><span class="cov8" title="1">{
                        if x == 0 </span><span class="cov8" title="1">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">return wp[x-1].Page</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

// Prev returns the previous Page relative to the given Page in
// this weighted page set.
func (wp WeightedPages) Prev(cur Page) Page <span class="cov8" title="1">{
        for x, c := range wp </span><span class="cov8" title="1">{
                if c.Page.Eq(cur) </span><span class="cov8" title="1">{
                        if x &lt; len(wp)-1 </span><span class="cov8" title="1">{
                                return wp[x+1].Page
                        }</span>
                        <span class="cov8" title="1">return nil</span>
                }
        }
        <span class="cov0" title="0">return nil</span>
}

func (wp WeightedPages) Len() int      <span class="cov8" title="1">{ return len(wp) }</span>
func (wp WeightedPages) Swap(i, j int) <span class="cov8" title="1">{ wp[i], wp[j] = wp[j], wp[i] }</span>

// Sort stable sorts this weighted page set.
func (wp WeightedPages) Sort() <span class="cov8" title="1">{ sort.Stable(wp) }</span>

// Count returns the number of pages in this weighted page set.
func (wp WeightedPages) Count() int <span class="cov0" title="0">{ return len(wp) }</span>

func (wp WeightedPages) Less(i, j int) bool <span class="cov8" title="1">{
        if wp[i].Weight == wp[j].Weight </span><span class="cov0" title="0">{
                return DefaultPageSort(wp[i].Page, wp[j].Page)
        }</span>
        <span class="cov8" title="1">return wp[i].Weight &lt; wp[j].Weight</span>
}
</pre>
		
		<pre class="file" id="file239" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// This file is autogenerated.

package page

import (
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/source"
)

// ZeroFile represents a zero value of source.File with warnings if invoked.
type zeroFile struct {
        log loggers.Logger
}

func NewZeroFile(log loggers.Logger) source.File <span class="cov0" title="0">{
        return zeroFile{log: log}
}</span>

func (zeroFile) IsZero() bool <span class="cov0" title="0">{
        return true
}</span>

func (z zeroFile) Path() (o0 string) <span class="cov0" title="0">{
        z.log.Warnln(".File.Path on zero object. Wrap it in if or with: {{ with .File }}{{ .Path }}{{ end }}")
        return
}</span>
func (z zeroFile) Section() (o0 string) <span class="cov0" title="0">{
        z.log.Warnln(".File.Section on zero object. Wrap it in if or with: {{ with .File }}{{ .Section }}{{ end }}")
        return
}</span>
func (z zeroFile) Lang() (o0 string) <span class="cov0" title="0">{
        z.log.Warnln(".File.Lang on zero object. Wrap it in if or with: {{ with .File }}{{ .Lang }}{{ end }}")
        return
}</span>
func (z zeroFile) Filename() (o0 string) <span class="cov0" title="0">{
        z.log.Warnln(".File.Filename on zero object. Wrap it in if or with: {{ with .File }}{{ .Filename }}{{ end }}")
        return
}</span>
func (z zeroFile) Dir() (o0 string) <span class="cov0" title="0">{
        z.log.Warnln(".File.Dir on zero object. Wrap it in if or with: {{ with .File }}{{ .Dir }}{{ end }}")
        return
}</span>
func (z zeroFile) Extension() (o0 string) <span class="cov0" title="0">{
        z.log.Warnln(".File.Extension on zero object. Wrap it in if or with: {{ with .File }}{{ .Extension }}{{ end }}")
        return
}</span>
func (z zeroFile) Ext() (o0 string) <span class="cov0" title="0">{
        z.log.Warnln(".File.Ext on zero object. Wrap it in if or with: {{ with .File }}{{ .Ext }}{{ end }}")
        return
}</span>
func (z zeroFile) LogicalName() (o0 string) <span class="cov0" title="0">{
        z.log.Warnln(".File.LogicalName on zero object. Wrap it in if or with: {{ with .File }}{{ .LogicalName }}{{ end }}")
        return
}</span>
func (z zeroFile) BaseFileName() (o0 string) <span class="cov0" title="0">{
        z.log.Warnln(".File.BaseFileName on zero object. Wrap it in if or with: {{ with .File }}{{ .BaseFileName }}{{ end }}")
        return
}</span>
func (z zeroFile) TranslationBaseName() (o0 string) <span class="cov0" title="0">{
        z.log.Warnln(".File.TranslationBaseName on zero object. Wrap it in if or with: {{ with .File }}{{ .TranslationBaseName }}{{ end }}")
        return
}</span>
func (z zeroFile) ContentBaseName() (o0 string) <span class="cov0" title="0">{
        z.log.Warnln(".File.ContentBaseName on zero object. Wrap it in if or with: {{ with .File }}{{ .ContentBaseName }}{{ end }}")
        return
}</span>
func (z zeroFile) UniqueID() (o0 string) <span class="cov0" title="0">{
        z.log.Warnln(".File.UniqueID on zero object. Wrap it in if or with: {{ with .File }}{{ .UniqueID }}{{ end }}")
        return
}</span>
func (z zeroFile) FileInfo() (o0 hugofs.FileMetaInfo) <span class="cov0" title="0">{
        z.log.Warnln(".File.FileInfo on zero object. Wrap it in if or with: {{ with .File }}{{ .FileInfo }}{{ end }}")
        return
}</span>
</pre>
		
		<pre class="file" id="file240" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "github.com/gohugoio/hugo/resources/postpub"
        "github.com/gohugoio/hugo/resources/resource"
)

type transformationKeyer interface {
        TransformationKey() string
}

// PostProcess wraps the given Resource for later processing.
func (spec *Spec) PostProcess(r resource.Resource) (postpub.PostPublishedResource, error) <span class="cov0" title="0">{
        key := r.(transformationKeyer).TransformationKey()
        spec.postProcessMu.RLock()
        result, found := spec.PostProcessResources[key]
        spec.postProcessMu.RUnlock()
        if found </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">spec.postProcessMu.Lock()
        defer spec.postProcessMu.Unlock()

        // Double check
        result, found = spec.PostProcessResources[key]
        if found </span><span class="cov0" title="0">{
                return result, nil
        }</span>

        <span class="cov0" title="0">result = postpub.NewPostPublishResource(spec.incr.Incr(), r)
        if result == nil </span><span class="cov0" title="0">{
                panic("got nil result")</span>
        }
        <span class="cov0" title="0">spec.PostProcessResources[key] = result

        return result, nil</span>
}
</pre>
		
		<pre class="file" id="file241" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package postpub

import (
        "reflect"
)

const (
        FieldNotSupported = "__field_not_supported"
)

func structToMapWithPlaceholders(root string, in interface{}, createPlaceholder func(s string) string) map[string]interface{} <span class="cov0" title="0">{
        m := structToMap(in)
        insertFieldPlaceholders(root, m, createPlaceholder)
        return m
}</span>

func structToMap(s interface{}) map[string]interface{} <span class="cov8" title="1">{
        m := make(map[string]interface{})
        t := reflect.TypeOf(s)

        for i := 0; i &lt; t.NumMethod(); i++ </span><span class="cov8" title="1">{
                method := t.Method(i)
                if method.PkgPath != "" </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if method.Type.NumIn() == 1 </span><span class="cov8" title="1">{
                        m[method.Name] = ""
                }</span>
        }

        <span class="cov8" title="1">for i := 0; i &lt; t.NumField(); i++ </span><span class="cov8" title="1">{
                field := t.Field(i)
                if field.PkgPath != "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">m[field.Name] = ""</span>
        }
        <span class="cov8" title="1">return m</span>
}

// insert placeholder for the templates. Do it very shallow for now.
func insertFieldPlaceholders(root string, m map[string]interface{}, createPlaceholder func(s string) string) <span class="cov8" title="1">{
        for k := range m </span><span class="cov8" title="1">{
                m[k] = createPlaceholder(root + "." + k)
        }</span>
}
</pre>
		
		<pre class="file" id="file242" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package postpub

import (
        "fmt"
        "reflect"
        "strconv"
        "strings"

        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/resources/resource"
)

type PostPublishedResource interface {
        resource.ResourceTypeProvider
        resource.ResourceLinksProvider
        resource.ResourceMetaProvider
        resource.ResourceParamsProvider
        resource.ResourceDataProvider
        resource.OriginProvider

        MediaType() map[string]interface{}
}

const (
        PostProcessPrefix = "__h_pp_l1"

        // The suffix has an '=' in it to prevent the minifier to remove any enclosing
        // quoutes around the attribute values.
        // See issue #8884.
        PostProcessSuffix = "__e="
)

func NewPostPublishResource(id int, r resource.Resource) PostPublishedResource <span class="cov0" title="0">{
        return &amp;PostPublishResource{
                prefix:   PostProcessPrefix + "_" + strconv.Itoa(id) + "_",
                delegate: r,
        }
}</span>

// postPublishResource holds a Resource to be transformed post publishing.
type PostPublishResource struct {
        prefix   string
        delegate resource.Resource
}

func (r *PostPublishResource) field(name string) string <span class="cov0" title="0">{
        return r.prefix + name + PostProcessSuffix
}</span>

func (r *PostPublishResource) Permalink() string <span class="cov0" title="0">{
        return r.field("Permalink")
}</span>

func (r *PostPublishResource) RelPermalink() string <span class="cov0" title="0">{
        return r.field("RelPermalink")
}</span>

func (r *PostPublishResource) Origin() resource.Resource <span class="cov0" title="0">{
        return r.delegate
}</span>

func (r *PostPublishResource) GetFieldString(pattern string) (string, bool) <span class="cov0" title="0">{
        if r == nil </span><span class="cov0" title="0">{
                panic("resource is nil")</span>
        }
        <span class="cov0" title="0">prefixIdx := strings.Index(pattern, r.prefix)
        if prefixIdx == -1 </span><span class="cov0" title="0">{
                // Not a method on this resource.
                return "", false
        }</span>

        <span class="cov0" title="0">fieldAccessor := pattern[prefixIdx+len(r.prefix) : strings.Index(pattern, PostProcessSuffix)]

        d := r.delegate
        switch </span>{
        case fieldAccessor == "RelPermalink":<span class="cov0" title="0">
                return d.RelPermalink(), true</span>
        case fieldAccessor == "Permalink":<span class="cov0" title="0">
                return d.Permalink(), true</span>
        case fieldAccessor == "Name":<span class="cov0" title="0">
                return d.Name(), true</span>
        case fieldAccessor == "Title":<span class="cov0" title="0">
                return d.Title(), true</span>
        case fieldAccessor == "ResourceType":<span class="cov0" title="0">
                return d.ResourceType(), true</span>
        case fieldAccessor == "Content":<span class="cov0" title="0">
                content, err := d.(resource.ContentProvider).Content()
                if err != nil </span><span class="cov0" title="0">{
                        return "", true
                }</span>
                <span class="cov0" title="0">return cast.ToString(content), true</span>
        case strings.HasPrefix(fieldAccessor, "MediaType"):<span class="cov0" title="0">
                return r.fieldToString(d.MediaType(), fieldAccessor), true</span>
        case fieldAccessor == "Data.Integrity":<span class="cov0" title="0">
                return cast.ToString((d.Data().(map[string]interface{})["Integrity"])), true</span>
        default:<span class="cov0" title="0">
                panic(fmt.Sprintf("unknown field accessor %q", fieldAccessor))</span>
        }
}

func (r *PostPublishResource) fieldToString(receiver interface{}, path string) string <span class="cov0" title="0">{
        fieldname := strings.Split(path, ".")[1]

        receiverv := reflect.ValueOf(receiver)
        switch receiverv.Kind() </span>{
        case reflect.Map:<span class="cov0" title="0">
                v := receiverv.MapIndex(reflect.ValueOf(fieldname))
                return cast.ToString(v.Interface())</span>
        default:<span class="cov0" title="0">
                v := receiverv.FieldByName(fieldname)
                if !v.IsValid() </span><span class="cov0" title="0">{
                        method := receiverv.MethodByName(fieldname)
                        if method.IsValid() </span><span class="cov0" title="0">{
                                vals := method.Call(nil)
                                if len(vals) &gt; 0 </span><span class="cov0" title="0">{
                                        v = vals[0]
                                }</span>

                        }
                }

                <span class="cov0" title="0">if v.IsValid() </span><span class="cov0" title="0">{
                        return cast.ToString(v.Interface())
                }</span>
                <span class="cov0" title="0">return ""</span>
        }
}

func (r *PostPublishResource) Data() interface{} <span class="cov0" title="0">{
        m := map[string]interface{}{
                "Integrity": "",
        }
        insertFieldPlaceholders("Data", m, r.field)
        return m
}</span>

func (r *PostPublishResource) MediaType() map[string]interface{} <span class="cov0" title="0">{
        m := structToMapWithPlaceholders("MediaType", media.Type{}, r.field)
        return m
}</span>

func (r *PostPublishResource) ResourceType() string <span class="cov0" title="0">{
        return r.field("ResourceType")
}</span>

func (r *PostPublishResource) Name() string <span class="cov0" title="0">{
        return r.field("Name")
}</span>

func (r *PostPublishResource) Title() string <span class="cov0" title="0">{
        return r.field("Title")
}</span>

func (r *PostPublishResource) Params() maps.Params <span class="cov0" title="0">{
        panic(r.fieldNotSupported("Params"))</span>
}

func (r *PostPublishResource) Content() (interface{}, error) <span class="cov0" title="0">{
        return r.field("Content"), nil
}</span>

func (r *PostPublishResource) fieldNotSupported(name string) string <span class="cov0" title="0">{
        return fmt.Sprintf("method .%s is currently not supported in post-publish transformations.", name)
}</span>
</pre>
		
		<pre class="file" id="file243" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "fmt"
        "io"
        "io/ioutil"
        "os"
        "path"
        "path/filepath"
        "sync"

        "github.com/gohugoio/hugo/resources/internal"

        "github.com/gohugoio/hugo/common/herrors"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/source"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/hugio"
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/helpers"
)

var (
        _ resource.ContentResource         = (*genericResource)(nil)
        _ resource.ReadSeekCloserResource  = (*genericResource)(nil)
        _ resource.Resource                = (*genericResource)(nil)
        _ resource.Source                  = (*genericResource)(nil)
        _ resource.Cloner                  = (*genericResource)(nil)
        _ resource.ResourcesLanguageMerger = (*resource.Resources)(nil)
        _ permalinker                      = (*genericResource)(nil)
        _ resource.Identifier              = (*genericResource)(nil)
        _ fileInfo                         = (*genericResource)(nil)
)

type ResourceSourceDescriptor struct {
        // TargetPaths is a callback to fetch paths's relative to its owner.
        TargetPaths func() page.TargetPaths

        // Need one of these to load the resource content.
        SourceFile         source.File
        OpenReadSeekCloser resource.OpenReadSeekCloser

        FileInfo os.FileInfo

        // If OpenReadSeekerCloser is not set, we use this to open the file.
        SourceFilename string

        Fs afero.Fs

        // Set when its known up front, else it's resolved from the target filename.
        MediaType media.Type

        // The relative target filename without any language code.
        RelTargetFilename string

        // Any base paths prepended to the target path. This will also typically be the
        // language code, but setting it here means that it should not have any effect on
        // the permalink.
        // This may be several values. In multihost mode we may publish the same resources to
        // multiple targets.
        TargetBasePaths []string

        // Delay publishing until either Permalink or RelPermalink is called. Maybe never.
        LazyPublish bool
}

func (r ResourceSourceDescriptor) Filename() string <span class="cov8" title="1">{
        if r.SourceFile != nil </span><span class="cov0" title="0">{
                return r.SourceFile.Filename()
        }</span>
        <span class="cov8" title="1">return r.SourceFilename</span>
}

type ResourceTransformer interface {
        resource.Resource
        Transformer
}

type Transformer interface {
        Transform(...ResourceTransformation) (ResourceTransformer, error)
}

func NewFeatureNotAvailableTransformer(key string, elements ...interface{}) ResourceTransformation <span class="cov0" title="0">{
        return transformerNotAvailable{
                key: internal.NewResourceTransformationKey(key, elements...),
        }
}</span>

type transformerNotAvailable struct {
        key internal.ResourceTransformationKey
}

func (t transformerNotAvailable) Transform(ctx *ResourceTransformationCtx) error <span class="cov0" title="0">{
        return herrors.ErrFeatureNotAvailable
}</span>

func (t transformerNotAvailable) Key() internal.ResourceTransformationKey <span class="cov0" title="0">{
        return t.key
}</span>

type baseResourceResource interface {
        resource.Cloner
        resource.ContentProvider
        resource.Resource
        resource.Identifier
}

type baseResourceInternal interface {
        resource.Source

        fileInfo
        metaAssigner
        targetPather

        ReadSeekCloser() (hugio.ReadSeekCloser, error)

        // Internal
        cloneWithUpdates(*transformationUpdate) (baseResource, error)
        tryTransformedFileCache(key string, u *transformationUpdate) io.ReadCloser

        specProvider
        getResourcePaths() *resourcePathDescriptor
        getTargetFilenames() []string
        openDestinationsForWriting() (io.WriteCloser, error)
        openPublishFileForWriting(relTargetPath string) (io.WriteCloser, error)

        relTargetPathForRel(rel string, addBaseTargetPath, isAbs, isURL bool) string
}

type specProvider interface {
        getSpec() *Spec
}

type baseResource interface {
        baseResourceResource
        baseResourceInternal
}

type commonResource struct {
}

// Slice is not meant to be used externally. It's a bridge function
// for the template functions. See collections.Slice.
func (commonResource) Slice(in interface{}) (interface{}, error) <span class="cov0" title="0">{
        switch items := in.(type) </span>{
        case resource.Resources:<span class="cov0" title="0">
                return items, nil</span>
        case []interface{}:<span class="cov0" title="0">
                groups := make(resource.Resources, len(items))
                for i, v := range items </span><span class="cov0" title="0">{
                        g, ok := v.(resource.Resource)
                        if !ok </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("type %T is not a Resource", v)
                        }</span>
                        <span class="cov0" title="0">groups[i] = g
                        </span>{<span class="cov0" title="0">
                        }</span>
                }
                <span class="cov0" title="0">return groups, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("invalid slice type %T", items)</span>
        }
}

type dirFile struct {
        // This is the directory component with Unix-style slashes.
        dir string
        // This is the file component.
        file string
}

func (d dirFile) path() string <span class="cov8" title="1">{
        return path.Join(d.dir, d.file)
}</span>

type fileInfo interface {
        getSourceFilename() string
        setSourceFilename(string)
        setSourceFs(afero.Fs)
        getFileInfo() hugofs.FileMetaInfo
        hash() (string, error)
        size() int
}

// genericResource represents a generic linkable resource.
type genericResource struct {
        *resourcePathDescriptor
        *resourceFileInfo
        *resourceContent

        spec *Spec

        title  string
        name   string
        params map[string]interface{}
        data   map[string]interface{}

        resourceType string
        mediaType    media.Type
}

func (l *genericResource) Clone() resource.Resource <span class="cov8" title="1">{
        return l.clone()
}</span>

func (l *genericResource) Content() (interface{}, error) <span class="cov8" title="1">{
        if err := l.initContent(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return l.content, nil</span>
}

func (r *genericResource) Err() error <span class="cov0" title="0">{
        return nil
}</span>

func (l *genericResource) Data() interface{} <span class="cov8" title="1">{
        return l.data
}</span>

func (l *genericResource) Key() string <span class="cov8" title="1">{
        return l.RelPermalink()
}</span>

func (l *genericResource) MediaType() media.Type <span class="cov8" title="1">{
        return l.mediaType
}</span>

func (l *genericResource) setMediaType(mediaType media.Type) <span class="cov8" title="1">{
        l.mediaType = mediaType
}</span>

func (l *genericResource) Name() string <span class="cov8" title="1">{
        return l.name
}</span>

func (l *genericResource) Params() maps.Params <span class="cov8" title="1">{
        return l.params
}</span>

func (l *genericResource) Permalink() string <span class="cov8" title="1">{
        return l.spec.PermalinkForBaseURL(l.relPermalinkForRel(l.relTargetDirFile.path(), true), l.spec.BaseURL.HostURL())
}</span>

func (l *genericResource) Publish() error <span class="cov8" title="1">{
        var err error
        l.publishInit.Do(func() </span><span class="cov8" title="1">{
                var fr hugio.ReadSeekCloser
                fr, err = l.ReadSeekCloser()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">defer fr.Close()

                var fw io.WriteCloser
                fw, err = helpers.OpenFilesForWriting(l.spec.BaseFs.PublishFs, l.getTargetFilenames()...)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">defer fw.Close()

                _, err = io.Copy(fw, fr)</span>
        })

        <span class="cov8" title="1">return err</span>
}

func (l *genericResource) RelPermalink() string <span class="cov8" title="1">{
        return l.relPermalinkFor(l.relTargetDirFile.path())
}</span>

func (l *genericResource) ResourceType() string <span class="cov8" title="1">{
        return l.resourceType
}</span>

func (l *genericResource) String() string <span class="cov0" title="0">{
        return fmt.Sprintf("Resource(%s: %s)", l.resourceType, l.name)
}</span>

// Path is stored with Unix style slashes.
func (l *genericResource) TargetPath() string <span class="cov8" title="1">{
        return l.relTargetDirFile.path()
}</span>

func (l *genericResource) Title() string <span class="cov8" title="1">{
        return l.title
}</span>

func (l *genericResource) createBasePath(rel string, isURL bool) string <span class="cov8" title="1">{
        if l.targetPathBuilder == nil </span><span class="cov8" title="1">{
                return rel
        }</span>
        <span class="cov8" title="1">tp := l.targetPathBuilder()

        if isURL </span><span class="cov8" title="1">{
                return path.Join(tp.SubResourceBaseLink, rel)
        }</span>

        // TODO(bep) path
        <span class="cov8" title="1">return path.Join(filepath.ToSlash(tp.SubResourceBaseTarget), rel)</span>
}

func (l *genericResource) initContent() error <span class="cov8" title="1">{
        var err error
        l.contentInit.Do(func() </span><span class="cov8" title="1">{
                var r hugio.ReadSeekCloser
                r, err = l.ReadSeekCloser()
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">defer r.Close()

                var b []byte
                b, err = ioutil.ReadAll(r)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">l.content = string(b)</span>
        })

        <span class="cov8" title="1">return err</span>
}

func (l *genericResource) setName(name string) <span class="cov8" title="1">{
        l.name = name
}</span>

func (l *genericResource) getResourcePaths() *resourcePathDescriptor <span class="cov8" title="1">{
        return l.resourcePathDescriptor
}</span>

func (l *genericResource) getSpec() *Spec <span class="cov8" title="1">{
        return l.spec
}</span>

func (l *genericResource) getTargetFilenames() []string <span class="cov8" title="1">{
        paths := l.relTargetPaths()
        for i, p := range paths </span><span class="cov8" title="1">{
                paths[i] = filepath.Clean(p)
        }</span>
        <span class="cov8" title="1">return paths</span>
}

func (l *genericResource) setTitle(title string) <span class="cov8" title="1">{
        l.title = title
}</span>

func (r *genericResource) tryTransformedFileCache(key string, u *transformationUpdate) io.ReadCloser <span class="cov8" title="1">{
        fi, f, meta, found := r.spec.ResourceCache.getFromFile(key)
        if !found </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">u.sourceFilename = &amp;fi.Name
        mt, _ := r.spec.MediaTypes.GetByType(meta.MediaTypeV)
        u.mediaType = mt
        u.data = meta.MetaData
        u.targetPath = meta.Target
        return f</span>
}

func (r *genericResource) mergeData(in map[string]interface{}) <span class="cov8" title="1">{
        if len(in) == 0 </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if r.data == nil </span><span class="cov8" title="1">{
                r.data = make(map[string]interface{})
        }</span>
        <span class="cov8" title="1">for k, v := range in </span><span class="cov8" title="1">{
                if _, found := r.data[k]; !found </span><span class="cov8" title="1">{
                        r.data[k] = v
                }</span>
        }
}

func (rc *genericResource) cloneWithUpdates(u *transformationUpdate) (baseResource, error) <span class="cov8" title="1">{
        r := rc.clone()

        if u.content != nil </span><span class="cov8" title="1">{
                r.contentInit.Do(func() </span><span class="cov8" title="1">{
                        r.content = *u.content
                        r.openReadSeekerCloser = func() (hugio.ReadSeekCloser, error) </span><span class="cov8" title="1">{
                                return hugio.NewReadSeekerNoOpCloserFromString(r.content), nil
                        }</span>
                })
        }

        <span class="cov8" title="1">r.mediaType = u.mediaType

        if u.sourceFilename != nil </span><span class="cov8" title="1">{
                r.setSourceFilename(*u.sourceFilename)
        }</span>

        <span class="cov8" title="1">if u.sourceFs != nil </span><span class="cov8" title="1">{
                r.setSourceFs(u.sourceFs)
        }</span>

        <span class="cov8" title="1">if u.targetPath == "" </span><span class="cov0" title="0">{
                return nil, errors.New("missing targetPath")
        }</span>

        <span class="cov8" title="1">fpath, fname := path.Split(u.targetPath)
        r.resourcePathDescriptor.relTargetDirFile = dirFile{dir: fpath, file: fname}

        r.mergeData(u.data)

        return r, nil</span>
}

func (l genericResource) clone() *genericResource <span class="cov8" title="1">{
        gi := *l.resourceFileInfo
        rp := *l.resourcePathDescriptor
        l.resourceFileInfo = &amp;gi
        l.resourcePathDescriptor = &amp;rp
        l.resourceContent = &amp;resourceContent{}
        return &amp;l
}</span>

// returns an opened file or nil if nothing to write (it may already be published).
func (l *genericResource) openDestinationsForWriting() (w io.WriteCloser, err error) <span class="cov8" title="1">{
        l.publishInit.Do(func() </span><span class="cov8" title="1">{
                targetFilenames := l.getTargetFilenames()
                var changedFilenames []string

                // Fast path:
                // This is a processed version of the original;
                // check if it already exists at the destination.
                for _, targetFilename := range targetFilenames </span><span class="cov8" title="1">{
                        if _, err := l.getSpec().BaseFs.PublishFs.Stat(targetFilename); err == nil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">changedFilenames = append(changedFilenames, targetFilename)</span>
                }

                <span class="cov8" title="1">if len(changedFilenames) == 0 </span><span class="cov0" title="0">{
                        return
                }</span>

                <span class="cov8" title="1">w, err = helpers.OpenFilesForWriting(l.getSpec().BaseFs.PublishFs, changedFilenames...)</span>
        })

        <span class="cov8" title="1">return</span>
}

func (r *genericResource) openPublishFileForWriting(relTargetPath string) (io.WriteCloser, error) <span class="cov8" title="1">{
        return helpers.OpenFilesForWriting(r.spec.BaseFs.PublishFs, r.relTargetPathsFor(relTargetPath)...)
}</span>

func (l *genericResource) permalinkFor(target string) string <span class="cov0" title="0">{
        return l.spec.PermalinkForBaseURL(l.relPermalinkForRel(target, true), l.spec.BaseURL.HostURL())
}</span>

func (l *genericResource) relPermalinkFor(target string) string <span class="cov8" title="1">{
        return l.relPermalinkForRel(target, false)
}</span>

func (l *genericResource) relPermalinkForRel(rel string, isAbs bool) string <span class="cov8" title="1">{
        return l.spec.PathSpec.URLizeFilename(l.relTargetPathForRel(rel, false, isAbs, true))
}</span>

func (l *genericResource) relTargetPathForRel(rel string, addBaseTargetPath, isAbs, isURL bool) string <span class="cov8" title="1">{
        if addBaseTargetPath &amp;&amp; len(l.baseTargetPathDirs) &gt; 1 </span><span class="cov0" title="0">{
                panic("multiple baseTargetPathDirs")</span>
        }
        <span class="cov8" title="1">var basePath string
        if addBaseTargetPath &amp;&amp; len(l.baseTargetPathDirs) &gt; 0 </span><span class="cov0" title="0">{
                basePath = l.baseTargetPathDirs[0]
        }</span>

        <span class="cov8" title="1">return l.relTargetPathForRelAndBasePath(rel, basePath, isAbs, isURL)</span>
}

func (l *genericResource) relTargetPathForRelAndBasePath(rel, basePath string, isAbs, isURL bool) string <span class="cov8" title="1">{
        rel = l.createBasePath(rel, isURL)

        if basePath != "" </span><span class="cov0" title="0">{
                rel = path.Join(basePath, rel)
        }</span>

        <span class="cov8" title="1">if l.baseOffset != "" </span><span class="cov0" title="0">{
                rel = path.Join(l.baseOffset, rel)
        }</span>

        <span class="cov8" title="1">if isURL </span><span class="cov8" title="1">{
                bp := l.spec.PathSpec.GetBasePath(!isAbs)
                if bp != "" </span><span class="cov8" title="1">{
                        rel = path.Join(bp, rel)
                }</span>
        }

        <span class="cov8" title="1">if len(rel) == 0 || rel[0] != '/' </span><span class="cov8" title="1">{
                rel = "/" + rel
        }</span>

        <span class="cov8" title="1">return rel</span>
}

func (l *genericResource) relTargetPaths() []string <span class="cov8" title="1">{
        return l.relTargetPathsForRel(l.TargetPath())
}</span>

func (l *genericResource) relTargetPathsFor(target string) []string <span class="cov8" title="1">{
        return l.relTargetPathsForRel(target)
}</span>

func (l *genericResource) relTargetPathsForRel(rel string) []string <span class="cov8" title="1">{
        if len(l.baseTargetPathDirs) == 0 </span><span class="cov8" title="1">{
                return []string{l.relTargetPathForRelAndBasePath(rel, "", false, false)}
        }</span>

        <span class="cov0" title="0">targetPaths := make([]string, len(l.baseTargetPathDirs))
        for i, dir := range l.baseTargetPathDirs </span><span class="cov0" title="0">{
                targetPaths[i] = l.relTargetPathForRelAndBasePath(rel, dir, false, false)
        }</span>
        <span class="cov0" title="0">return targetPaths</span>
}

func (l *genericResource) updateParams(params map[string]interface{}) <span class="cov8" title="1">{
        if l.params == nil </span><span class="cov0" title="0">{
                l.params = params
                return
        }</span>

        // Sets the params not already set
        <span class="cov8" title="1">for k, v := range params </span><span class="cov8" title="1">{
                if _, found := l.params[k]; !found </span><span class="cov8" title="1">{
                        l.params[k] = v
                }</span>
        }
}

type targetPather interface {
        TargetPath() string
}

type permalinker interface {
        targetPather
        permalinkFor(target string) string
        relPermalinkFor(target string) string
        relTargetPaths() []string
        relTargetPathsFor(target string) []string
}

type resourceContent struct {
        content     string
        contentInit sync.Once

        publishInit sync.Once
}

type resourceFileInfo struct {
        // Will be set if this resource is backed by something other than a file.
        openReadSeekerCloser resource.OpenReadSeekCloser

        // This may be set to tell us to look in another filesystem for this resource.
        // We, by default, use the sourceFs filesystem in the spec below.
        sourceFs afero.Fs

        // Absolute filename to the source, including any content folder path.
        // Note that this is absolute in relation to the filesystem it is stored in.
        // It can be a base path filesystem, and then this filename will not match
        // the path to the file on the real filesystem.
        sourceFilename string

        fi hugofs.FileMetaInfo

        // A hash of the source content. Is only calculated in caching situations.
        h *resourceHash
}

func (fi *resourceFileInfo) ReadSeekCloser() (hugio.ReadSeekCloser, error) <span class="cov8" title="1">{
        if fi.openReadSeekerCloser != nil </span><span class="cov8" title="1">{
                return fi.openReadSeekerCloser()
        }</span>

        <span class="cov8" title="1">f, err := fi.getSourceFs().Open(fi.getSourceFilename())
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return f, nil</span>
}

func (fi *resourceFileInfo) getFileInfo() hugofs.FileMetaInfo <span class="cov8" title="1">{
        return fi.fi
}</span>

func (fi *resourceFileInfo) getSourceFilename() string <span class="cov8" title="1">{
        return fi.sourceFilename
}</span>

func (fi *resourceFileInfo) setSourceFilename(s string) <span class="cov8" title="1">{
        // Make sure it's always loaded by sourceFilename.
        fi.openReadSeekerCloser = nil
        fi.sourceFilename = s
}</span>

func (fi *resourceFileInfo) getSourceFs() afero.Fs <span class="cov8" title="1">{
        return fi.sourceFs
}</span>

func (fi *resourceFileInfo) setSourceFs(fs afero.Fs) <span class="cov8" title="1">{
        fi.sourceFs = fs
}</span>

func (fi *resourceFileInfo) hash() (string, error) <span class="cov8" title="1">{
        var err error
        fi.h.init.Do(func() </span><span class="cov8" title="1">{
                var hash string
                var f hugio.ReadSeekCloser
                f, err = fi.ReadSeekCloser()
                if err != nil </span><span class="cov0" title="0">{
                        err = errors.Wrap(err, "failed to open source file")
                        return
                }</span>
                <span class="cov8" title="1">defer f.Close()

                hash, err = helpers.MD5FromFileFast(f)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
                <span class="cov8" title="1">fi.h.value = hash</span>
        })

        <span class="cov8" title="1">return fi.h.value, err</span>
}

func (fi *resourceFileInfo) size() int <span class="cov8" title="1">{
        if fi.fi == nil </span><span class="cov0" title="0">{
                return 0
        }</span>

        <span class="cov8" title="1">return int(fi.fi.Size())</span>
}

type resourceHash struct {
        value string
        init  sync.Once
}

type resourcePathDescriptor struct {
        // The relative target directory and filename.
        relTargetDirFile dirFile

        // Callback used to construct a target path relative to its owner.
        targetPathBuilder func() page.TargetPaths

        // This will normally be the same as above, but this will only apply to publishing
        // of resources. It may be multiple values when in multihost mode.
        baseTargetPathDirs []string

        // baseOffset is set when the output format's path has a offset, e.g. for AMP.
        baseOffset string
}
</pre>
		
		<pre class="file" id="file244" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "encoding/json"
        "io"
        "path"
        "path/filepath"
        "regexp"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/gohugoio/hugo/resources/resource"

        "github.com/gohugoio/hugo/cache/filecache"

        "github.com/BurntSushi/locker"
)

const (
        CACHE_CLEAR_ALL = "clear_all"
        CACHE_OTHER     = "other"
)

type ResourceCache struct {
        rs *Spec

        sync.RWMutex

        // Either resource.Resource or resource.Resources.
        cache map[string]interface{}

        fileCache *filecache.Cache

        // Provides named resource locks.
        nlocker *locker.Locker
}

// ResourceCacheKey converts the filename into the format used in the resource
// cache.
func ResourceCacheKey(filename string) string <span class="cov8" title="1">{
        filename = filepath.ToSlash(filename)
        return path.Join(resourceKeyPartition(filename), filename)
}</span>

func resourceKeyPartition(filename string) string <span class="cov8" title="1">{
        ext := strings.TrimPrefix(path.Ext(filepath.ToSlash(filename)), ".")
        if ext == "" </span><span class="cov0" title="0">{
                ext = CACHE_OTHER
        }</span>
        <span class="cov8" title="1">return ext</span>
}

// Commonly used aliases and directory names used for some types.
var extAliasKeywords = map[string][]string{
        "sass": {"scss"},
        "scss": {"sass"},
}

// ResourceKeyPartitions resolves a ordered slice of partitions that is
// used to do resource cache invalidations.
//
// We use the first directory path element and the extension, so:
//     a/b.json =&gt; "a", "json"
//     b.json =&gt; "json"
//
// For some of the extensions we will also map to closely related types,
// e.g. "scss" will also return "sass".
//
func ResourceKeyPartitions(filename string) []string <span class="cov8" title="1">{
        var partitions []string
        filename = glob.NormalizePath(filename)
        dir, name := path.Split(filename)
        ext := strings.TrimPrefix(path.Ext(filepath.ToSlash(name)), ".")

        if dir != "" </span><span class="cov8" title="1">{
                partitions = append(partitions, strings.Split(dir, "/")[0])
        }</span>

        <span class="cov8" title="1">if ext != "" </span><span class="cov8" title="1">{
                partitions = append(partitions, ext)
        }</span>

        <span class="cov8" title="1">if aliases, found := extAliasKeywords[ext]; found </span><span class="cov8" title="1">{
                partitions = append(partitions, aliases...)
        }</span>

        <span class="cov8" title="1">if len(partitions) == 0 </span><span class="cov0" title="0">{
                partitions = []string{CACHE_OTHER}
        }</span>

        <span class="cov8" title="1">return helpers.UniqueStringsSorted(partitions)</span>
}

// ResourceKeyContainsAny returns whether the key is a member of any of the
// given partitions.
//
// This is used for resource cache invalidation.
func ResourceKeyContainsAny(key string, partitions []string) bool <span class="cov8" title="1">{
        parts := strings.Split(key, "/")
        for _, p1 := range partitions </span><span class="cov8" title="1">{
                for _, p2 := range parts </span><span class="cov8" title="1">{
                        if p1 == p2 </span><span class="cov8" title="1">{
                                return true
                        }</span>
                }
        }
        <span class="cov8" title="1">return false</span>
}

func newResourceCache(rs *Spec) *ResourceCache <span class="cov8" title="1">{
        return &amp;ResourceCache{
                rs:        rs,
                fileCache: rs.FileCaches.AssetsCache(),
                cache:     make(map[string]interface{}),
                nlocker:   locker.NewLocker(),
        }
}</span>

func (c *ResourceCache) clear() <span class="cov0" title="0">{
        c.Lock()
        defer c.Unlock()

        c.cache = make(map[string]interface{})
        c.nlocker = locker.NewLocker()
}</span>

func (c *ResourceCache) Contains(key string) bool <span class="cov0" title="0">{
        key = c.cleanKey(filepath.ToSlash(key))
        _, found := c.get(key)
        return found
}</span>

func (c *ResourceCache) cleanKey(key string) string <span class="cov8" title="1">{
        return strings.TrimPrefix(path.Clean(strings.ToLower(key)), "/")
}</span>

func (c *ResourceCache) get(key string) (interface{}, bool) <span class="cov8" title="1">{
        c.RLock()
        defer c.RUnlock()
        r, found := c.cache[key]
        return r, found
}</span>

func (c *ResourceCache) GetOrCreate(key string, f func() (resource.Resource, error)) (resource.Resource, error) <span class="cov0" title="0">{
        r, err := c.getOrCreate(key, func() (interface{}, error) </span><span class="cov0" title="0">{ return f() }</span>)
        <span class="cov0" title="0">if r == nil || err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.(resource.Resource), nil</span>
}

func (c *ResourceCache) GetOrCreateResources(key string, f func() (resource.Resources, error)) (resource.Resources, error) <span class="cov0" title="0">{
        r, err := c.getOrCreate(key, func() (interface{}, error) </span><span class="cov0" title="0">{ return f() }</span>)
        <span class="cov0" title="0">if r == nil || err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return r.(resource.Resources), nil</span>
}

func (c *ResourceCache) getOrCreate(key string, f func() (interface{}, error)) (interface{}, error) <span class="cov0" title="0">{
        key = c.cleanKey(key)
        // First check in-memory cache.
        r, found := c.get(key)
        if found </span><span class="cov0" title="0">{
                return r, nil
        }</span>
        // This is a potentially long running operation, so get a named lock.
        <span class="cov0" title="0">c.nlocker.Lock(key)

        // Double check in-memory cache.
        r, found = c.get(key)
        if found </span><span class="cov0" title="0">{
                c.nlocker.Unlock(key)
                return r, nil
        }</span>

        <span class="cov0" title="0">defer c.nlocker.Unlock(key)

        r, err := f()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">c.set(key, r)

        return r, nil</span>
}

func (c *ResourceCache) getFilenames(key string) (string, string) <span class="cov8" title="1">{
        filenameMeta := key + ".json"
        filenameContent := key + ".content"

        return filenameMeta, filenameContent
}</span>

func (c *ResourceCache) getFromFile(key string) (filecache.ItemInfo, io.ReadCloser, transformedResourceMetadata, bool) <span class="cov8" title="1">{
        c.RLock()
        defer c.RUnlock()

        var meta transformedResourceMetadata
        filenameMeta, filenameContent := c.getFilenames(key)

        _, jsonContent, _ := c.fileCache.GetBytes(filenameMeta)
        if jsonContent == nil </span><span class="cov0" title="0">{
                return filecache.ItemInfo{}, nil, meta, false
        }</span>

        <span class="cov8" title="1">if err := json.Unmarshal(jsonContent, &amp;meta); err != nil </span><span class="cov0" title="0">{
                return filecache.ItemInfo{}, nil, meta, false
        }</span>

        <span class="cov8" title="1">fi, rc, _ := c.fileCache.Get(filenameContent)

        return fi, rc, meta, rc != nil</span>
}

// writeMeta writes the metadata to file and returns a writer for the content part.
func (c *ResourceCache) writeMeta(key string, meta transformedResourceMetadata) (filecache.ItemInfo, io.WriteCloser, error) <span class="cov8" title="1">{
        filenameMeta, filenameContent := c.getFilenames(key)
        raw, err := json.Marshal(meta)
        if err != nil </span><span class="cov0" title="0">{
                return filecache.ItemInfo{}, nil, err
        }</span>

        <span class="cov8" title="1">_, fm, err := c.fileCache.WriteCloser(filenameMeta)
        if err != nil </span><span class="cov0" title="0">{
                return filecache.ItemInfo{}, nil, err
        }</span>
        <span class="cov8" title="1">defer fm.Close()

        if _, err := fm.Write(raw); err != nil </span><span class="cov0" title="0">{
                return filecache.ItemInfo{}, nil, err
        }</span>

        <span class="cov8" title="1">fi, fc, err := c.fileCache.WriteCloser(filenameContent)

        return fi, fc, err</span>
}

func (c *ResourceCache) set(key string, r interface{}) <span class="cov8" title="1">{
        c.Lock()
        defer c.Unlock()
        c.cache[key] = r
}</span>

func (c *ResourceCache) DeletePartitions(partitions ...string) <span class="cov0" title="0">{
        partitionsSet := map[string]bool{
                // Always clear out the resources not matching any partition.
                "other": true,
        }
        for _, p := range partitions </span><span class="cov0" title="0">{
                partitionsSet[p] = true
        }</span>

        <span class="cov0" title="0">if partitionsSet[CACHE_CLEAR_ALL] </span><span class="cov0" title="0">{
                c.clear()
                return
        }</span>

        <span class="cov0" title="0">c.Lock()
        defer c.Unlock()

        for k := range c.cache </span><span class="cov0" title="0">{
                clear := false
                for p := range partitionsSet </span><span class="cov0" title="0">{
                        if strings.Contains(k, p) </span><span class="cov0" title="0">{
                                // There will be some false positive, but that's fine.
                                clear = true
                                break</span>
                        }
                }

                <span class="cov0" title="0">if clear </span><span class="cov0" title="0">{
                        delete(c.cache, k)
                }</span>
        }
}

func (c *ResourceCache) DeleteMatches(re *regexp.Regexp) <span class="cov0" title="0">{
        c.Lock()
        defer c.Unlock()

        for k := range c.cache </span><span class="cov0" title="0">{
                if re.MatchString(k) </span><span class="cov0" title="0">{
                        delete(c.cache, k)
                }</span>
        }
}
</pre>
		
		<pre class="file" id="file245" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package bundler contains functions for concatenation etc. of Resource objects.
package bundler

import (
        "fmt"
        "io"
        "path"
        "path/filepath"

        "github.com/gohugoio/hugo/common/hugio"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
)

// Client contains methods perform concatenation and other bundling related
// tasks to Resource objects.
type Client struct {
        rs *resources.Spec
}

// New creates a new Client with the given specification.
func New(rs *resources.Spec) *Client <span class="cov0" title="0">{
        return &amp;Client{rs: rs}
}</span>

type multiReadSeekCloser struct {
        mr      io.Reader
        sources []hugio.ReadSeekCloser
}

func toReaders(sources []hugio.ReadSeekCloser) []io.Reader <span class="cov8" title="1">{
        readers := make([]io.Reader, len(sources))
        for i, r := range sources </span><span class="cov8" title="1">{
                readers[i] = r
        }</span>
        <span class="cov8" title="1">return readers</span>
}

func newMultiReadSeekCloser(sources ...hugio.ReadSeekCloser) *multiReadSeekCloser <span class="cov8" title="1">{
        mr := io.MultiReader(toReaders(sources)...)
        return &amp;multiReadSeekCloser{mr, sources}
}</span>

func (r *multiReadSeekCloser) Read(p []byte) (n int, err error) <span class="cov8" title="1">{
        return r.mr.Read(p)
}</span>

func (r *multiReadSeekCloser) Seek(offset int64, whence int) (newOffset int64, err error) <span class="cov8" title="1">{
        for _, s := range r.sources </span><span class="cov8" title="1">{
                newOffset, err = s.Seek(offset, whence)
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">r.mr = io.MultiReader(toReaders(r.sources)...)

        return</span>
}

func (r *multiReadSeekCloser) Close() error <span class="cov0" title="0">{
        for _, s := range r.sources </span><span class="cov0" title="0">{
                s.Close()
        }</span>
        <span class="cov0" title="0">return nil</span>
}

// Concat concatenates the list of Resource objects.
func (c *Client) Concat(targetPath string, r resource.Resources) (resource.Resource, error) <span class="cov0" title="0">{
        // The CACHE_OTHER will make sure this will be re-created and published on rebuilds.
        return c.rs.ResourceCache.GetOrCreate(path.Join(resources.CACHE_OTHER, targetPath), func() (resource.Resource, error) </span><span class="cov0" title="0">{
                var resolvedm media.Type

                // The given set of resources must be of the same Media Type.
                // We may improve on that in the future, but then we need to know more.
                for i, r := range r </span><span class="cov0" title="0">{
                        if i &gt; 0 &amp;&amp; r.MediaType().Type() != resolvedm.Type() </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("resources in Concat must be of the same Media Type, got %q and %q", r.MediaType().Type(), resolvedm.Type())
                        }</span>
                        <span class="cov0" title="0">resolvedm = r.MediaType()</span>
                }

                <span class="cov0" title="0">concatr := func() (hugio.ReadSeekCloser, error) </span><span class="cov0" title="0">{
                        var rcsources []hugio.ReadSeekCloser
                        for _, s := range r </span><span class="cov0" title="0">{
                                rcr, ok := s.(resource.ReadSeekCloserResource)
                                if !ok </span><span class="cov0" title="0">{
                                        return nil, fmt.Errorf("resource %T does not implement resource.ReadSeekerCloserResource", s)
                                }</span>
                                <span class="cov0" title="0">rc, err := rcr.ReadSeekCloser()
                                if err != nil </span><span class="cov0" title="0">{
                                        // Close the already opened.
                                        for _, rcs := range rcsources </span><span class="cov0" title="0">{
                                                rcs.Close()
                                        }</span>
                                        <span class="cov0" title="0">return nil, err</span>
                                }

                                <span class="cov0" title="0">rcsources = append(rcsources, rc)</span>
                        }

                        // Arbitrary JavaScript files require a barrier between them to be safely concatenated together.
                        // Without this, the last line of one file can affect the first line of the next file and change how both files are interpreted.
                        <span class="cov0" title="0">if resolvedm.MainType == media.JavascriptType.MainType &amp;&amp; resolvedm.SubType == media.JavascriptType.SubType </span><span class="cov0" title="0">{
                                readers := make([]hugio.ReadSeekCloser, 2*len(rcsources)-1)
                                j := 0
                                for i := 0; i &lt; len(rcsources); i++ </span><span class="cov0" title="0">{
                                        if i &gt; 0 </span><span class="cov0" title="0">{
                                                readers[j] = hugio.NewReadSeekerNoOpCloserFromString("\n;\n")
                                                j++
                                        }</span>
                                        <span class="cov0" title="0">readers[j] = rcsources[i]
                                        j++</span>
                                }
                                <span class="cov0" title="0">return newMultiReadSeekCloser(readers...), nil</span>
                        }

                        <span class="cov0" title="0">return newMultiReadSeekCloser(rcsources...), nil</span>
                }

                <span class="cov0" title="0">composite, err := c.rs.New(
                        resources.ResourceSourceDescriptor{
                                Fs:                 c.rs.FileCaches.AssetsCache().Fs,
                                LazyPublish:        true,
                                OpenReadSeekCloser: concatr,
                                RelTargetFilename:  filepath.Clean(targetPath),
                        })
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return composite, nil</span>
        })
}
</pre>
		
		<pre class="file" id="file246" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package create contains functions for to create Resource objects. This will
// typically non-files.
package create

import (
        "net/http"
        "path"
        "path/filepath"
        "strings"
        "time"

        "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/cache/filecache"
        "github.com/gohugoio/hugo/common/hugio"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
)

// Client contains methods to create Resource objects.
// tasks to Resource objects.
type Client struct {
        rs               *resources.Spec
        httpClient       *http.Client
        cacheGetResource *filecache.Cache
}

// New creates a new Client with the given specification.
func New(rs *resources.Spec) *Client <span class="cov0" title="0">{
        return &amp;Client{
                rs: rs,
                httpClient: &amp;http.Client{
                        Timeout: 10 * time.Second,
                },
                cacheGetResource: rs.FileCaches.GetResourceCache(),
        }
}</span>

// Get creates a new Resource by opening the given filename in the assets filesystem.
func (c *Client) Get(filename string) (resource.Resource, error) <span class="cov0" title="0">{
        filename = filepath.Clean(filename)
        return c.rs.ResourceCache.GetOrCreate(resources.ResourceCacheKey(filename), func() (resource.Resource, error) </span><span class="cov0" title="0">{
                return c.rs.New(resources.ResourceSourceDescriptor{
                        Fs:             c.rs.BaseFs.Assets.Fs,
                        LazyPublish:    true,
                        SourceFilename: filename,
                })
        }</span>)
}

// Match gets the resources matching the given pattern from the assets filesystem.
func (c *Client) Match(pattern string) (resource.Resources, error) <span class="cov0" title="0">{
        return c.match(pattern, false)
}</span>

// GetMatch gets first resource matching the given pattern from the assets filesystem.
func (c *Client) GetMatch(pattern string) (resource.Resource, error) <span class="cov0" title="0">{
        res, err := c.match(pattern, true)
        if err != nil || len(res) == 0 </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return res[0], err</span>
}

func (c *Client) match(pattern string, firstOnly bool) (resource.Resources, error) <span class="cov0" title="0">{
        var name string
        if firstOnly </span><span class="cov0" title="0">{
                name = "__get-match"
        }</span> else<span class="cov0" title="0"> {
                name = "__match"
        }</span>

        <span class="cov0" title="0">pattern = glob.NormalizePath(pattern)
        partitions := glob.FilterGlobParts(strings.Split(pattern, "/"))
        if len(partitions) == 0 </span><span class="cov0" title="0">{
                partitions = []string{resources.CACHE_OTHER}
        }</span>
        <span class="cov0" title="0">key := path.Join(name, path.Join(partitions...))
        key = path.Join(key, pattern)

        return c.rs.ResourceCache.GetOrCreateResources(key, func() (resource.Resources, error) </span><span class="cov0" title="0">{
                var res resource.Resources

                handle := func(info hugofs.FileMetaInfo) (bool, error) </span><span class="cov0" title="0">{
                        meta := info.Meta()
                        r, err := c.rs.New(resources.ResourceSourceDescriptor{
                                LazyPublish: true,
                                FileInfo:    info,
                                OpenReadSeekCloser: func() (hugio.ReadSeekCloser, error) </span><span class="cov0" title="0">{
                                        return meta.Open()
                                }</span>,
                                RelTargetFilename: meta.Path,
                        })
                        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                                return true, err
                        }</span>

                        <span class="cov0" title="0">res = append(res, r)

                        return firstOnly, nil</span>
                }

                <span class="cov0" title="0">if err := hugofs.Glob(c.rs.BaseFs.Assets.Fs, pattern, handle); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return res, nil</span>
        })
}

// FromString creates a new Resource from a string with the given relative target path.
func (c *Client) FromString(targetPath, content string) (resource.Resource, error) <span class="cov0" title="0">{
        return c.rs.ResourceCache.GetOrCreate(path.Join(resources.CACHE_OTHER, targetPath), func() (resource.Resource, error) </span><span class="cov0" title="0">{
                return c.rs.New(
                        resources.ResourceSourceDescriptor{
                                Fs:          c.rs.FileCaches.AssetsCache().Fs,
                                LazyPublish: true,
                                OpenReadSeekCloser: func() (hugio.ReadSeekCloser, error) </span><span class="cov0" title="0">{
                                        return hugio.NewReadSeekerNoOpCloserFromString(content), nil
                                }</span>,
                                RelTargetFilename: filepath.Clean(targetPath),
                        })
        })
}
</pre>
		
		<pre class="file" id="file247" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package create

import (
        "bufio"
        "bytes"
        "io"
        "io/ioutil"
        "mime"
        "net/http"
        "net/http/httputil"
        "net/url"
        "path"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/hugio"
        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"
)

// FromRemote expects one or n-parts of a URL to a resource
// If you provide multiple parts they will be joined together to the final URL.
func (c *Client) FromRemote(uri string, optionsm map[string]interface{}) (resource.Resource, error) <span class="cov0" title="0">{
        rURL, err := url.Parse(uri)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to parse URL for resource %s", uri)
        }</span>

        <span class="cov0" title="0">resourceID := helpers.HashString(uri, optionsm)

        _, httpResponse, err := c.cacheGetResource.GetOrCreate(resourceID, func() (io.ReadCloser, error) </span><span class="cov0" title="0">{
                options, err := decodeRemoteOptions(optionsm)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to decode options for resource %s", uri)
                }</span>
                <span class="cov0" title="0">if err := c.validateFromRemoteArgs(uri, options); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">req, err := http.NewRequest(options.Method, uri, options.BodyReader())
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.Wrapf(err, "failed to create request for resource %s", uri)
                }</span>
                <span class="cov0" title="0">addDefaultHeaders(req)

                if options.Headers != nil </span><span class="cov0" title="0">{
                        addUserProvidedHeaders(options.Headers, req)
                }</span>

                <span class="cov0" title="0">res, err := c.httpClient.Do(req)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">if res.StatusCode != http.StatusNotFound </span><span class="cov0" title="0">{
                        if res.StatusCode &lt; 200 || res.StatusCode &gt; 299 </span><span class="cov0" title="0">{
                                return nil, errors.Errorf("failed to fetch remote resource: %s", http.StatusText(res.StatusCode))
                        }</span>
                }

                <span class="cov0" title="0">httpResponse, err := httputil.DumpResponse(res, true)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">return hugio.ToReadCloser(bytes.NewReader(httpResponse)), nil</span>
        })
        <span class="cov0" title="0">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">defer httpResponse.Close()

        res, err := http.ReadResponse(bufio.NewReader(httpResponse), nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">if res.StatusCode == http.StatusNotFound </span><span class="cov0" title="0">{
                // Not found. This matches how looksup for local resources work.
                return nil, nil
        }</span>

        <span class="cov0" title="0">body, err := ioutil.ReadAll(res.Body)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrapf(err, "failed to read remote resource %q", uri)
        }</span>

        <span class="cov0" title="0">filename := path.Base(rURL.Path)
        if _, params, _ := mime.ParseMediaType(res.Header.Get("Content-Disposition")); params != nil </span><span class="cov0" title="0">{
                if _, ok := params["filename"]; ok </span><span class="cov0" title="0">{
                        filename = params["filename"]
                }</span>
        }

        <span class="cov0" title="0">var extensionHints []string

        contentType := res.Header.Get("Content-Type")

        // mime.ExtensionsByType gives a long list of extensions for text/plain,
        // just use ".txt".
        if strings.HasPrefix(contentType, "text/plain") </span><span class="cov0" title="0">{
                extensionHints = []string{".txt"}
        }</span> else<span class="cov0" title="0"> {
                exts, _ := mime.ExtensionsByType(contentType)
                if exts != nil </span><span class="cov0" title="0">{
                        extensionHints = exts
                }</span>
        }

        // Look for a file extention. If it's .txt, look for a more specific.
        <span class="cov0" title="0">if extensionHints == nil || extensionHints[0] == ".txt" </span><span class="cov0" title="0">{
                if ext := path.Ext(filename); ext != "" </span><span class="cov0" title="0">{
                        extensionHints = []string{ext}
                }</span>
        }

        // Now resolve the media type primarily using the content.
        <span class="cov0" title="0">mediaType := media.FromContent(c.rs.MediaTypes, extensionHints, body)
        if mediaType.IsZero() </span><span class="cov0" title="0">{
                return nil, errors.Errorf("failed to resolve media type for remote resource %q", uri)
        }</span>

        <span class="cov0" title="0">resourceID = filename[:len(filename)-len(path.Ext(filename))] + "_" + resourceID + mediaType.FirstSuffix.FullSuffix

        return c.rs.New(
                resources.ResourceSourceDescriptor{
                        MediaType:   mediaType,
                        LazyPublish: true,
                        OpenReadSeekCloser: func() (hugio.ReadSeekCloser, error) </span><span class="cov0" title="0">{
                                return hugio.NewReadSeekerNoOpCloser(bytes.NewReader(body)), nil
                        }</span>,
                        RelTargetFilename: filepath.Clean(resourceID),
                })
}

func (c *Client) validateFromRemoteArgs(uri string, options fromRemoteOptions) error <span class="cov0" title="0">{
        if err := c.rs.ExecHelper.Sec().CheckAllowedHTTPURL(uri); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if err := c.rs.ExecHelper.Sec().CheckAllowedHTTPMethod(options.Method); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">return nil</span>
}

func addDefaultHeaders(req *http.Request, accepts ...string) <span class="cov0" title="0">{
        for _, accept := range accepts </span><span class="cov0" title="0">{
                if !hasHeaderValue(req.Header, "Accept", accept) </span><span class="cov0" title="0">{
                        req.Header.Add("Accept", accept)
                }</span>
        }
        <span class="cov0" title="0">if !hasHeaderKey(req.Header, "User-Agent") </span><span class="cov0" title="0">{
                req.Header.Add("User-Agent", "Hugo Static Site Generator")
        }</span>
}

func addUserProvidedHeaders(headers map[string]interface{}, req *http.Request) <span class="cov0" title="0">{
        if headers == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">for key, val := range headers </span><span class="cov0" title="0">{
                vals := types.ToStringSlicePreserveString(val)
                for _, s := range vals </span><span class="cov0" title="0">{
                        req.Header.Add(key, s)
                }</span>
        }
}

func hasHeaderValue(m http.Header, key, value string) bool <span class="cov0" title="0">{
        var s []string
        var ok bool

        if s, ok = m[key]; !ok </span><span class="cov0" title="0">{
                return false
        }</span>

        <span class="cov0" title="0">for _, v := range s </span><span class="cov0" title="0">{
                if v == value </span><span class="cov0" title="0">{
                        return true
                }</span>
        }
        <span class="cov0" title="0">return false</span>
}

func hasHeaderKey(m http.Header, key string) bool <span class="cov0" title="0">{
        _, ok := m[key]
        return ok
}</span>

type fromRemoteOptions struct {
        Method  string
        Headers map[string]interface{}
        Body    []byte
}

func (o fromRemoteOptions) BodyReader() io.Reader <span class="cov0" title="0">{
        if o.Body == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return bytes.NewBuffer(o.Body)</span>
}

func decodeRemoteOptions(optionsm map[string]interface{}) (fromRemoteOptions, error) <span class="cov8" title="1">{
        options := fromRemoteOptions{
                Method: "GET",
        }

        err := mapstructure.WeakDecode(optionsm, &amp;options)
        if err != nil </span><span class="cov0" title="0">{
                return options, err
        }</span>
        <span class="cov8" title="1">options.Method = strings.ToUpper(options.Method)

        return options, nil</span>
}
</pre>
		
		<pre class="file" id="file248" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "fmt"
        "strconv"
        "strings"

        "github.com/gohugoio/hugo/hugofs/glob"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/resources/resource"

        "github.com/pkg/errors"
        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/common/maps"
)

var (
        _ metaAssigner         = (*genericResource)(nil)
        _ metaAssigner         = (*imageResource)(nil)
        _ metaAssignerProvider = (*resourceAdapter)(nil)
)

type metaAssignerProvider interface {
        getMetaAssigner() metaAssigner
}

// metaAssigner allows updating metadata in resources that supports it.
type metaAssigner interface {
        setTitle(title string)
        setName(name string)
        setMediaType(mediaType media.Type)
        updateParams(params map[string]interface{})
}

const counterPlaceHolder = ":counter"

// AssignMetadata assigns the given metadata to those resources that supports updates
// and matching by wildcard given in `src` using `filepath.Match` with lower cased values.
// This assignment is additive, but the most specific match needs to be first.
// The `name` and `title` metadata field support shell-matched collection it got a match in.
// See https://golang.org/pkg/path/#Match
func AssignMetadata(metadata []map[string]interface{}, resources ...resource.Resource) error <span class="cov8" title="1">{
        counters := make(map[string]int)

        for _, r := range resources </span><span class="cov8" title="1">{
                var ma metaAssigner
                mp, ok := r.(metaAssignerProvider)
                if ok </span><span class="cov8" title="1">{
                        ma = mp.getMetaAssigner()
                }</span> else<span class="cov8" title="1"> {
                        ma, ok = r.(metaAssigner)
                        if !ok </span><span class="cov0" title="0">{
                                continue</span>
                        }
                }

                <span class="cov8" title="1">var (
                        nameSet, titleSet                   bool
                        nameCounter, titleCounter           = 0, 0
                        nameCounterFound, titleCounterFound bool
                        resourceSrcKey                      = strings.ToLower(r.Name())
                )

                for _, meta := range metadata </span><span class="cov8" title="1">{
                        src, found := meta["src"]
                        if !found </span><span class="cov8" title="1">{
                                return fmt.Errorf("missing 'src' in metadata for resource")
                        }</span>

                        <span class="cov8" title="1">srcKey := strings.ToLower(cast.ToString(src))

                        glob, err := glob.GetGlob(srcKey)
                        if err != nil </span><span class="cov8" title="1">{
                                return errors.Wrap(err, "failed to match resource with metadata")
                        }</span>

                        <span class="cov8" title="1">match := glob.Match(resourceSrcKey)

                        if match </span><span class="cov8" title="1">{
                                if !nameSet </span><span class="cov8" title="1">{
                                        name, found := meta["name"]
                                        if found </span><span class="cov8" title="1">{
                                                name := cast.ToString(name)
                                                if !nameCounterFound </span><span class="cov8" title="1">{
                                                        nameCounterFound = strings.Contains(name, counterPlaceHolder)
                                                }</span>
                                                <span class="cov8" title="1">if nameCounterFound &amp;&amp; nameCounter == 0 </span><span class="cov8" title="1">{
                                                        counterKey := "name_" + srcKey
                                                        nameCounter = counters[counterKey] + 1
                                                        counters[counterKey] = nameCounter
                                                }</span>

                                                <span class="cov8" title="1">ma.setName(replaceResourcePlaceholders(name, nameCounter))
                                                nameSet = true</span>
                                        }
                                }

                                <span class="cov8" title="1">if !titleSet </span><span class="cov8" title="1">{
                                        title, found := meta["title"]
                                        if found </span><span class="cov8" title="1">{
                                                title := cast.ToString(title)
                                                if !titleCounterFound </span><span class="cov8" title="1">{
                                                        titleCounterFound = strings.Contains(title, counterPlaceHolder)
                                                }</span>
                                                <span class="cov8" title="1">if titleCounterFound &amp;&amp; titleCounter == 0 </span><span class="cov8" title="1">{
                                                        counterKey := "title_" + srcKey
                                                        titleCounter = counters[counterKey] + 1
                                                        counters[counterKey] = titleCounter
                                                }</span>
                                                <span class="cov8" title="1">ma.setTitle((replaceResourcePlaceholders(title, titleCounter)))
                                                titleSet = true</span>
                                        }
                                }

                                <span class="cov8" title="1">params, found := meta["params"]
                                if found </span><span class="cov8" title="1">{
                                        m := maps.ToStringMap(params)
                                        // Needed for case insensitive fetching of params values
                                        maps.PrepareParams(m)
                                        ma.updateParams(m)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return nil</span>
}

func replaceResourcePlaceholders(in string, counter int) string <span class="cov8" title="1">{
        return strings.Replace(in, counterPlaceHolder, strconv.Itoa(counter), -1)
}</span>
</pre>
		
		<pre class="file" id="file249" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "errors"
        "fmt"
        "mime"
        "os"
        "path"
        "path/filepath"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/resources/jsconfig"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/hexec"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/identity"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/resources/postpub"

        "github.com/gohugoio/hugo/cache/filecache"
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/output"
        "github.com/gohugoio/hugo/resources/images"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/gohugoio/hugo/tpl"
        "github.com/spf13/afero"
)

func NewSpec(
        s *helpers.PathSpec,
        fileCaches filecache.Caches,
        incr identity.Incrementer,
        logger loggers.Logger,
        errorHandler herrors.ErrorSender,
        execHelper *hexec.Exec,
        outputFormats output.Formats,
        mimeTypes media.Types) (*Spec, error) <span class="cov8" title="1">{
        imgConfig, err := images.DecodeConfig(s.Cfg.GetStringMap("imaging"))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">imaging, err := images.NewImageProcessor(imgConfig)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if incr == nil </span><span class="cov8" title="1">{
                incr = &amp;identity.IncrementByOne{}
        }</span>

        <span class="cov8" title="1">if logger == nil </span><span class="cov8" title="1">{
                logger = loggers.NewErrorLogger()
        }</span>

        <span class="cov8" title="1">permalinks, err := page.NewPermalinkExpander(s)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">rs := &amp;Spec{
                PathSpec:      s,
                Logger:        logger,
                ErrorSender:   errorHandler,
                imaging:       imaging,
                ExecHelper:    execHelper,
                incr:          incr,
                MediaTypes:    mimeTypes,
                OutputFormats: outputFormats,
                Permalinks:    permalinks,
                BuildConfig:   config.DecodeBuild(s.Cfg),
                FileCaches:    fileCaches,
                PostBuildAssets: &amp;PostBuildAssets{
                        PostProcessResources: make(map[string]postpub.PostPublishedResource),
                        JSConfigBuilder:      jsconfig.NewBuilder(),
                },
                imageCache: newImageCache(
                        fileCaches.ImageCache(),

                        s,
                ),
        }

        rs.ResourceCache = newResourceCache(rs)

        return rs, nil</span>
}

type Spec struct {
        *helpers.PathSpec

        MediaTypes    media.Types
        OutputFormats output.Formats

        Logger      loggers.Logger
        ErrorSender herrors.ErrorSender

        TextTemplates tpl.TemplateParseFinder

        Permalinks  page.PermalinkExpander
        BuildConfig config.Build

        // Holds default filter settings etc.
        imaging *images.ImageProcessor

        ExecHelper *hexec.Exec

        incr          identity.Incrementer
        imageCache    *imageCache
        ResourceCache *ResourceCache
        FileCaches    filecache.Caches

        // Assets used after the build is done.
        // This is shared between all sites.
        *PostBuildAssets
}

type PostBuildAssets struct {
        postProcessMu        sync.RWMutex
        PostProcessResources map[string]postpub.PostPublishedResource
        JSConfigBuilder      *jsconfig.Builder
}

func (r *Spec) New(fd ResourceSourceDescriptor) (resource.Resource, error) <span class="cov8" title="1">{
        return r.newResourceFor(fd)
}</span>

func (r *Spec) CacheStats() string <span class="cov0" title="0">{
        r.imageCache.mu.RLock()
        defer r.imageCache.mu.RUnlock()

        s := fmt.Sprintf("Cache entries: %d", len(r.imageCache.store))

        count := 0
        for k := range r.imageCache.store </span><span class="cov0" title="0">{
                if count &gt; 5 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov0" title="0">s += "\n" + k
                count++</span>
        }

        <span class="cov0" title="0">return s</span>
}

func (r *Spec) ClearCaches() <span class="cov0" title="0">{
        r.imageCache.clear()
        r.ResourceCache.clear()
}</span>

func (r *Spec) DeleteBySubstring(s string) <span class="cov0" title="0">{
        r.imageCache.deleteIfContains(s)
}</span>

func (s *Spec) String() string <span class="cov0" title="0">{
        return "spec"
}</span>

// TODO(bep) clean up below
func (r *Spec) newGenericResource(sourceFs afero.Fs,
        targetPathBuilder func() page.TargetPaths,
        osFileInfo os.FileInfo,
        sourceFilename,
        baseFilename string,
        mediaType media.Type) *genericResource <span class="cov8" title="1">{
        return r.newGenericResourceWithBase(
                sourceFs,
                nil,
                nil,
                targetPathBuilder,
                osFileInfo,
                sourceFilename,
                baseFilename,
                mediaType,
        )
}</span>

func (r *Spec) newGenericResourceWithBase(
        sourceFs afero.Fs,
        openReadSeekerCloser resource.OpenReadSeekCloser,
        targetPathBaseDirs []string,
        targetPathBuilder func() page.TargetPaths,
        osFileInfo os.FileInfo,
        sourceFilename,
        baseFilename string,
        mediaType media.Type) *genericResource <span class="cov8" title="1">{
        if osFileInfo != nil &amp;&amp; osFileInfo.IsDir() </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("dirs not supported resource types: %v", osFileInfo))</span>
        }

        // This value is used both to construct URLs and file paths, but start
        // with a Unix-styled path.
        <span class="cov8" title="1">baseFilename = helpers.ToSlashTrimLeading(baseFilename)
        fpath, fname := path.Split(baseFilename)

        resourceType := mediaType.MainType

        pathDescriptor := &amp;resourcePathDescriptor{
                baseTargetPathDirs: helpers.UniqueStringsReuse(targetPathBaseDirs),
                targetPathBuilder:  targetPathBuilder,
                relTargetDirFile:   dirFile{dir: fpath, file: fname},
        }

        var fim hugofs.FileMetaInfo
        if osFileInfo != nil </span><span class="cov8" title="1">{
                fim = osFileInfo.(hugofs.FileMetaInfo)
        }</span>

        <span class="cov8" title="1">gfi := &amp;resourceFileInfo{
                fi:                   fim,
                openReadSeekerCloser: openReadSeekerCloser,
                sourceFs:             sourceFs,
                sourceFilename:       sourceFilename,
                h:                    &amp;resourceHash{},
        }

        g := &amp;genericResource{
                resourceFileInfo:       gfi,
                resourcePathDescriptor: pathDescriptor,
                mediaType:              mediaType,
                resourceType:           resourceType,
                spec:                   r,
                params:                 make(map[string]interface{}),
                name:                   baseFilename,
                title:                  baseFilename,
                resourceContent:        &amp;resourceContent{},
        }

        return g</span>
}

func (r *Spec) newResource(sourceFs afero.Fs, fd ResourceSourceDescriptor) (resource.Resource, error) <span class="cov8" title="1">{
        fi := fd.FileInfo
        var sourceFilename string

        if fd.OpenReadSeekCloser != nil </span>{<span class="cov0" title="0">
        }</span> else<span class="cov8" title="1"> if fd.SourceFilename != "" </span><span class="cov8" title="1">{
                var err error
                fi, err = sourceFs.Stat(fd.SourceFilename)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return nil, nil
                        }</span>
                        <span class="cov0" title="0">return nil, err</span>
                }
                <span class="cov8" title="1">sourceFilename = fd.SourceFilename</span>
        } else<span class="cov0" title="0"> {
                sourceFilename = fd.SourceFile.Filename()
        }</span>

        <span class="cov8" title="1">if fd.RelTargetFilename == "" </span><span class="cov0" title="0">{
                fd.RelTargetFilename = sourceFilename
        }</span>

        <span class="cov8" title="1">mimeType := fd.MediaType
        if mimeType.IsZero() </span><span class="cov8" title="1">{
                ext := strings.ToLower(filepath.Ext(fd.RelTargetFilename))
                var (
                        found      bool
                        suffixInfo media.SuffixInfo
                )
                mimeType, suffixInfo, found = r.MediaTypes.GetFirstBySuffix(strings.TrimPrefix(ext, "."))
                // TODO(bep) we need to handle these ambiguous types better, but in this context
                // we most likely want the application/xml type.
                if suffixInfo.Suffix == "xml" &amp;&amp; mimeType.SubType == "rss" </span><span class="cov0" title="0">{
                        mimeType, found = r.MediaTypes.GetByType("application/xml")
                }</span>

                <span class="cov8" title="1">if !found </span><span class="cov0" title="0">{
                        // A fallback. Note that mime.TypeByExtension is slow by Hugo standards,
                        // so we should configure media types to avoid this lookup for most
                        // situations.
                        mimeStr := mime.TypeByExtension(ext)
                        if mimeStr != "" </span><span class="cov0" title="0">{
                                mimeType, _ = media.FromStringAndExt(mimeStr, ext)
                        }</span>
                }
        }

        <span class="cov8" title="1">gr := r.newGenericResourceWithBase(
                sourceFs,
                fd.OpenReadSeekCloser,
                fd.TargetBasePaths,
                fd.TargetPaths,
                fi,
                sourceFilename,
                fd.RelTargetFilename,
                mimeType)

        if mimeType.MainType == "image" </span><span class="cov8" title="1">{
                imgFormat, ok := images.ImageFormatFromMediaSubType(mimeType.SubType)
                if ok </span><span class="cov8" title="1">{
                        ir := &amp;imageResource{
                                Image:        images.NewImage(imgFormat, r.imaging, nil, gr),
                                baseResource: gr,
                        }
                        ir.root = ir
                        return newResourceAdapter(gr.spec, fd.LazyPublish, ir), nil
                }</span>

        }

        <span class="cov8" title="1">return newResourceAdapter(gr.spec, fd.LazyPublish, gr), nil</span>
}

func (r *Spec) newResourceFor(fd ResourceSourceDescriptor) (resource.Resource, error) <span class="cov8" title="1">{
        if fd.OpenReadSeekCloser == nil </span><span class="cov8" title="1">{
                if fd.SourceFile != nil &amp;&amp; fd.SourceFilename != "" </span><span class="cov0" title="0">{
                        return nil, errors.New("both SourceFile and AbsSourceFilename provided")
                }</span> else<span class="cov8" title="1"> if fd.SourceFile == nil &amp;&amp; fd.SourceFilename == "" </span><span class="cov0" title="0">{
                        return nil, errors.New("either SourceFile or AbsSourceFilename must be provided")
                }</span>
        }

        <span class="cov8" title="1">if fd.RelTargetFilename == "" </span><span class="cov8" title="1">{
                fd.RelTargetFilename = fd.Filename()
        }</span>

        <span class="cov8" title="1">if len(fd.TargetBasePaths) == 0 </span><span class="cov8" title="1">{
                // If not set, we publish the same resource to all hosts.
                fd.TargetBasePaths = r.MultihostTargetBasePaths
        }</span>

        <span class="cov8" title="1">return r.newResource(fd.Fs, fd)</span>
}
</pre>
		
		<pre class="file" id="file250" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package babel

import (
        "bytes"
        "io"
        "io/ioutil"
        "os"
        "path"
        "path/filepath"
        "regexp"
        "strconv"

        "github.com/gohugoio/hugo/common/hexec"
        "github.com/gohugoio/hugo/common/loggers"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/resources/internal"

        "github.com/mitchellh/mapstructure"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/pkg/errors"
)

// Options from https://babeljs.io/docs/en/options
type Options struct {
        Config string // Custom path to config file

        Minified   bool
        NoComments bool
        Compact    *bool
        Verbose    bool
        NoBabelrc  bool
        SourceMap  string
}

// DecodeOptions decodes options to and generates command flags
func DecodeOptions(m map[string]interface{}) (opts Options, err error) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">err = mapstructure.WeakDecode(m, &amp;opts)
        return</span>
}

func (opts Options) toArgs() []interface{} <span class="cov0" title="0">{
        var args []interface{}

        // external is not a known constant on the babel command line
        // .sourceMaps must be a boolean, "inline", "both", or undefined
        switch opts.SourceMap </span>{
        case "external":<span class="cov0" title="0">
                args = append(args, "--source-maps")</span>
        case "inline":<span class="cov0" title="0">
                args = append(args, "--source-maps=inline")</span>
        }
        <span class="cov0" title="0">if opts.Minified </span><span class="cov0" title="0">{
                args = append(args, "--minified")
        }</span>
        <span class="cov0" title="0">if opts.NoComments </span><span class="cov0" title="0">{
                args = append(args, "--no-comments")
        }</span>
        <span class="cov0" title="0">if opts.Compact != nil </span><span class="cov0" title="0">{
                args = append(args, "--compact="+strconv.FormatBool(*opts.Compact))
        }</span>
        <span class="cov0" title="0">if opts.Verbose </span><span class="cov0" title="0">{
                args = append(args, "--verbose")
        }</span>
        <span class="cov0" title="0">if opts.NoBabelrc </span><span class="cov0" title="0">{
                args = append(args, "--no-babelrc")
        }</span>
        <span class="cov0" title="0">return args</span>
}

// Client is the client used to do Babel transformations.
type Client struct {
        rs *resources.Spec
}

// New creates a new Client with the given specification.
func New(rs *resources.Spec) *Client <span class="cov0" title="0">{
        return &amp;Client{rs: rs}
}</span>

type babelTransformation struct {
        options Options
        rs      *resources.Spec
}

func (t *babelTransformation) Key() internal.ResourceTransformationKey <span class="cov0" title="0">{
        return internal.NewResourceTransformationKey("babel", t.options)
}</span>

// Transform shells out to babel-cli to do the heavy lifting.
// For this to work, you need some additional tools. To install them globally:
// npm install -g @babel/core @babel/cli
// If you want to use presets or plugins such as @babel/preset-env
// Then you should install those globally as well. e.g:
// npm install -g @babel/preset-env
// Instead of installing globally, you can also install everything as a dev-dependency (--save-dev instead of -g)
func (t *babelTransformation) Transform(ctx *resources.ResourceTransformationCtx) error <span class="cov0" title="0">{
        const binaryName = "babel"

        ex := t.rs.ExecHelper

        if err := ex.Sec().CheckAllowedExec(binaryName); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">var configFile string
        logger := t.rs.Logger

        var errBuf bytes.Buffer
        infoW := loggers.LoggerToWriterWithPrefix(logger.Info(), "babel")

        if t.options.Config != "" </span><span class="cov0" title="0">{
                configFile = t.options.Config
        }</span> else<span class="cov0" title="0"> {
                configFile = "babel.config.js"
        }</span>

        <span class="cov0" title="0">configFile = filepath.Clean(configFile)

        // We need an absolute filename to the config file.
        if !filepath.IsAbs(configFile) </span><span class="cov0" title="0">{
                configFile = t.rs.BaseFs.ResolveJSConfigFile(configFile)
                if configFile == "" &amp;&amp; t.options.Config != "" </span><span class="cov0" title="0">{
                        // Only fail if the user specified config file is not found.
                        return errors.Errorf("babel config %q not found:", configFile)
                }</span>
        }

        <span class="cov0" title="0">ctx.ReplaceOutPathExtension(".js")

        var cmdArgs []interface{}

        if configFile != "" </span><span class="cov0" title="0">{
                logger.Infoln("babel: use config file", configFile)
                cmdArgs = []interface{}{"--config-file", configFile}
        }</span>

        <span class="cov0" title="0">if optArgs := t.options.toArgs(); len(optArgs) &gt; 0 </span><span class="cov0" title="0">{
                cmdArgs = append(cmdArgs, optArgs...)
        }</span>
        <span class="cov0" title="0">cmdArgs = append(cmdArgs, "--filename="+ctx.SourcePath)

        // Create compile into a real temp file:
        // 1. separate stdout/stderr messages from babel (https://github.com/gohugoio/hugo/issues/8136)
        // 2. allow generation and retrieval of external source map.
        compileOutput, err := ioutil.TempFile("", "compileOut-*.js")
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">cmdArgs = append(cmdArgs, "--out-file="+compileOutput.Name())
        stderr := io.MultiWriter(infoW, &amp;errBuf)
        cmdArgs = append(cmdArgs, hexec.WithStderr(stderr))
        cmdArgs = append(cmdArgs, hexec.WithStdout(stderr))
        cmdArgs = append(cmdArgs, hexec.WithEnviron(hugo.GetExecEnviron(t.rs.WorkingDir, t.rs.Cfg, t.rs.BaseFs.Assets.Fs)))

        defer os.Remove(compileOutput.Name())

        // ARGA [--no-install babel --config-file /private/var/folders/_g/j3j21hts4fn7__h04w2x8gb40000gn/T/hugo-test-babel812882892/babel.config.js --source-maps --filename=js/main2.js --out-file=/var/folders/_g/j3j21hts4fn7__h04w2x8gb40000gn/T/compileOut-2237820197.js]
        //      [--no-install babel --config-file /private/var/folders/_g/j3j21hts4fn7__h04w2x8gb40000gn/T/hugo-test-babel332846848/babel.config.js --filename=js/main.js --out-file=/var/folders/_g/j3j21hts4fn7__h04w2x8gb40000gn/T/compileOut-1451390834.js 0x10304ee60 0x10304ed60 0x10304f060]
        cmd, err := ex.Npx(binaryName, cmdArgs...)

        if err != nil </span><span class="cov0" title="0">{
                if hexec.IsNotFound(err) </span><span class="cov0" title="0">{
                        // This may be on a CI server etc. Will fall back to pre-built assets.
                        return herrors.ErrFeatureNotAvailable
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">stdin, err := cmd.StdinPipe()

        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer stdin.Close()
                io.Copy(stdin, ctx.From)
        }</span>()

        <span class="cov0" title="0">err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                if hexec.IsNotFound(err) </span><span class="cov0" title="0">{
                        return herrors.ErrFeatureNotAvailable
                }</span>
                <span class="cov0" title="0">return errors.Wrap(err, errBuf.String())</span>
        }

        <span class="cov0" title="0">content, err := ioutil.ReadAll(compileOutput)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">mapFile := compileOutput.Name() + ".map"
        if _, err := os.Stat(mapFile); err == nil </span><span class="cov0" title="0">{
                defer os.Remove(mapFile)
                sourceMap, err := ioutil.ReadFile(mapFile)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">if err = ctx.PublishSourceMap(string(sourceMap)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">targetPath := path.Base(ctx.OutPath) + ".map"
                re := regexp.MustCompile(`//# sourceMappingURL=.*\n?`)
                content = []byte(re.ReplaceAllString(string(content), "//# sourceMappingURL="+targetPath+"\n"))</span>
        }

        <span class="cov0" title="0">ctx.To.Write(content)

        return nil</span>
}

// Process transforms the given Resource with the Babel processor.
func (c *Client) Process(res resources.ResourceTransformer, options Options) (resource.Resource, error) <span class="cov0" title="0">{
        return res.Transform(
                &amp;babelTransformation{rs: c.rs, options: options},
        )
}</span>
</pre>
		
		<pre class="file" id="file251" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package integrity

import (
        "crypto/md5"
        "crypto/sha256"
        "crypto/sha512"
        "encoding/base64"
        "encoding/hex"
        "hash"
        "html/template"
        "io"

        "github.com/gohugoio/hugo/resources/internal"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
)

const defaultHashAlgo = "sha256"

// Client contains methods to fingerprint (cachebusting) and other integrity-related
// methods.
type Client struct {
        rs *resources.Spec
}

// New creates a new Client with the given specification.
func New(rs *resources.Spec) *Client <span class="cov8" title="1">{
        return &amp;Client{rs: rs}
}</span>

type fingerprintTransformation struct {
        algo string
}

func (t *fingerprintTransformation) Key() internal.ResourceTransformationKey <span class="cov8" title="1">{
        return internal.NewResourceTransformationKey("fingerprint", t.algo)
}</span>

// Transform creates a MD5 hash of the Resource content and inserts that hash before
// the extension in the filename.
func (t *fingerprintTransformation) Transform(ctx *resources.ResourceTransformationCtx) error <span class="cov8" title="1">{
        h, err := newHash(t.algo)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">var w io.Writer
        if rc, ok := ctx.From.(io.ReadSeeker); ok </span><span class="cov8" title="1">{
                // This transformation does not change the content, so try to
                // avoid writing to To if we can.
                defer rc.Seek(0, 0)
                w = h
        }</span> else<span class="cov0" title="0"> {
                w = io.MultiWriter(h, ctx.To)
        }</span>

        <span class="cov8" title="1">io.Copy(w, ctx.From)
        d, err := digest(h)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">ctx.Data["Integrity"] = integrity(t.algo, d)
        ctx.AddOutPathIdentifier("." + hex.EncodeToString(d[:]))
        return nil</span>
}

func newHash(algo string) (hash.Hash, error) <span class="cov8" title="1">{
        switch algo </span>{
        case "md5":<span class="cov8" title="1">
                return md5.New(), nil</span>
        case "sha256":<span class="cov8" title="1">
                return sha256.New(), nil</span>
        case "sha384":<span class="cov8" title="1">
                return sha512.New384(), nil</span>
        case "sha512":<span class="cov8" title="1">
                return sha512.New(), nil</span>
        default:<span class="cov8" title="1">
                return nil, errors.Errorf("unsupported crypto algo: %q, use either md5, sha256, sha384 or sha512", algo)</span>
        }
}

// Fingerprint applies fingerprinting of the given resource and hash algorithm.
// It defaults to sha256 if none given, and the options are md5, sha256 or sha512.
// The same algo is used for both the fingerprinting part (aka cache busting) and
// the base64-encoded Subresource Integrity hash, so you will have to stay away from
// md5 if you plan to use both.
// See https://developer.mozilla.org/en-US/docs/Web/Security/Subresource_Integrity
func (c *Client) Fingerprint(res resources.ResourceTransformer, algo string) (resource.Resource, error) <span class="cov8" title="1">{
        if algo == "" </span><span class="cov8" title="1">{
                algo = defaultHashAlgo
        }</span>

        <span class="cov8" title="1">return res.Transform(&amp;fingerprintTransformation{algo: algo})</span>
}

func integrity(algo string, sum []byte) template.HTMLAttr <span class="cov8" title="1">{
        encoded := base64.StdEncoding.EncodeToString(sum)
        return template.HTMLAttr(algo + "-" + encoded)
}</span>

func digest(h hash.Hash) ([]byte, error) <span class="cov8" title="1">{
        sum := h.Sum(nil)
        return sum, nil
}</span>
</pre>
		
		<pre class="file" id="file252" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package js

import (
        "fmt"
        "io/ioutil"
        "os"
        "path"
        "path/filepath"
        "regexp"
        "strings"

        "github.com/pkg/errors"

        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/common/herrors"

        "github.com/gohugoio/hugo/hugolib/filesystems"
        "github.com/gohugoio/hugo/media"
        "github.com/gohugoio/hugo/resources/internal"

        "github.com/evanw/esbuild/pkg/api"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
)

// Client context for ESBuild.
type Client struct {
        rs  *resources.Spec
        sfs *filesystems.SourceFilesystem
}

// New creates a new client context.
func New(fs *filesystems.SourceFilesystem, rs *resources.Spec) *Client <span class="cov8" title="1">{
        return &amp;Client{
                rs:  rs,
                sfs: fs,
        }
}</span>

type buildTransformation struct {
        optsm map[string]interface{}
        c     *Client
}

func (t *buildTransformation) Key() internal.ResourceTransformationKey <span class="cov8" title="1">{
        return internal.NewResourceTransformationKey("jsbuild", t.optsm)
}</span>

func (t *buildTransformation) Transform(ctx *resources.ResourceTransformationCtx) error <span class="cov8" title="1">{
        ctx.OutMediaType = media.JavascriptType

        opts, err := decodeOptions(t.optsm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if opts.TargetPath != "" </span><span class="cov0" title="0">{
                ctx.OutPath = opts.TargetPath
        }</span> else<span class="cov8" title="1"> {
                ctx.ReplaceOutPathExtension(".js")
        }</span>

        <span class="cov8" title="1">src, err := ioutil.ReadAll(ctx.From)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">opts.sourceDir = filepath.FromSlash(path.Dir(ctx.SourcePath))
        opts.resolveDir = t.c.rs.WorkingDir // where node_modules gets resolved
        opts.contents = string(src)
        opts.mediaType = ctx.InMediaType

        buildOptions, err := toBuildOptions(opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">buildOptions.Plugins, err = createBuildPlugins(t.c, opts)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if buildOptions.Sourcemap == api.SourceMapExternal &amp;&amp; buildOptions.Outdir == "" </span><span class="cov0" title="0">{
                buildOptions.Outdir, err = ioutil.TempDir(os.TempDir(), "compileOutput")
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">defer os.Remove(buildOptions.Outdir)</span>
        }

        <span class="cov8" title="1">if opts.Inject != nil </span><span class="cov0" title="0">{
                // Resolve the absolute filenames.
                for i, ext := range opts.Inject </span><span class="cov0" title="0">{
                        impPath := filepath.FromSlash(ext)
                        if filepath.IsAbs(impPath) </span><span class="cov0" title="0">{
                                return errors.Errorf("inject: absolute paths not supported, must be relative to /assets")
                        }</span>

                        <span class="cov0" title="0">m := resolveComponentInAssets(t.c.rs.Assets.Fs, impPath)

                        if m == nil </span><span class="cov0" title="0">{
                                return errors.Errorf("inject: file %q not found", ext)
                        }</span>

                        <span class="cov0" title="0">opts.Inject[i] = m.Filename</span>

                }

                <span class="cov0" title="0">buildOptions.Inject = opts.Inject</span>

        }

        <span class="cov8" title="1">result := api.Build(buildOptions)

        if len(result.Errors) &gt; 0 </span><span class="cov0" title="0">{

                createErr := func(msg api.Message) error </span><span class="cov0" title="0">{
                        loc := msg.Location
                        if loc == nil </span><span class="cov0" title="0">{
                                return errors.New(msg.Text)
                        }</span>
                        <span class="cov0" title="0">path := loc.File

                        var (
                                f   afero.File
                                err error
                        )

                        if strings.HasPrefix(path, nsImportHugo) </span><span class="cov0" title="0">{
                                path = strings.TrimPrefix(path, nsImportHugo+":")
                                f, err = hugofs.Os.Open(path)
                        }</span> else<span class="cov0" title="0"> {
                                var fi os.FileInfo
                                fi, err = t.c.sfs.Fs.Stat(path)
                                if err == nil </span><span class="cov0" title="0">{
                                        m := fi.(hugofs.FileMetaInfo).Meta()
                                        path = m.Filename
                                        f, err = m.Open()
                                }</span>

                        }

                        <span class="cov0" title="0">if err == nil </span><span class="cov0" title="0">{
                                fe := herrors.NewFileError("js", 0, loc.Line, loc.Column, errors.New(msg.Text))
                                err, _ := herrors.WithFileContext(fe, path, f, herrors.SimpleLineMatcher)
                                f.Close()
                                return err
                        }</span>

                        <span class="cov0" title="0">return fmt.Errorf("%s", msg.Text)</span>
                }

                <span class="cov0" title="0">var errors []error

                for _, msg := range result.Errors </span><span class="cov0" title="0">{
                        errors = append(errors, createErr(msg))
                }</span>

                // Return 1, log the rest.
                <span class="cov0" title="0">for i, err := range errors </span><span class="cov0" title="0">{
                        if i &gt; 0 </span><span class="cov0" title="0">{
                                t.c.rs.Logger.Errorf("js.Build failed: %s", err)
                        }</span>
                }

                <span class="cov0" title="0">return errors[0]</span>
        }

        <span class="cov8" title="1">if buildOptions.Sourcemap == api.SourceMapExternal </span><span class="cov0" title="0">{
                content := string(result.OutputFiles[1].Contents)
                symPath := path.Base(ctx.OutPath) + ".map"
                re := regexp.MustCompile(`//# sourceMappingURL=.*\n?`)
                content = re.ReplaceAllString(content, "//# sourceMappingURL="+symPath+"\n")

                if err = ctx.PublishSourceMap(string(result.OutputFiles[0].Contents)); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_, err := ctx.To.Write([]byte(content))
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> {
                _, err := ctx.To.Write(result.OutputFiles[0].Contents)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// Process process esbuild transform
func (c *Client) Process(res resources.ResourceTransformer, opts map[string]interface{}) (resource.Resource, error) <span class="cov8" title="1">{
        return res.Transform(
                &amp;buildTransformation{c: c, optsm: opts},
        )
}</span>
</pre>
		
		<pre class="file" id="file253" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package js

import (
        "encoding/json"
        "fmt"
        "io/ioutil"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/pkg/errors"
        "github.com/spf13/afero"

        "github.com/evanw/esbuild/pkg/api"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/media"
        "github.com/mitchellh/mapstructure"
)

const (
        nsImportHugo = "ns-hugo"
        nsParams     = "ns-params"

        stdinImporter = "&lt;stdin&gt;"
)

// Options esbuild configuration
type Options struct {
        // If not set, the source path will be used as the base target path.
        // Note that the target path's extension may change if the target MIME type
        // is different, e.g. when the source is TypeScript.
        TargetPath string

        // Whether to minify to output.
        Minify bool

        // Whether to write mapfiles
        SourceMap string

        // The language target.
        // One of: es2015, es2016, es2017, es2018, es2019, es2020 or esnext.
        // Default is esnext.
        Target string

        // The output format.
        // One of: iife, cjs, esm
        // Default is to esm.
        Format string

        // External dependencies, e.g. "react".
        Externals []string

        // This option allows you to automatically replace a global variable with an import from another file.
        // The filenames must be relative to /assets.
        // See https://esbuild.github.io/api/#inject
        Inject []string

        // User defined symbols.
        Defines map[string]interface{}

        // Maps a component import to another.
        Shims map[string]string

        // User defined params. Will be marshaled to JSON and available as "@params", e.g.
        //     import * as params from '@params';
        Params interface{}

        // What to use instead of React.createElement.
        JSXFactory string

        // What to use instead of React.Fragment.
        JSXFragment string

        // There is/was a bug in WebKit with severe performance issue with the tracking
        // of TDZ checks in JavaScriptCore.
        //
        // Enabling this flag removes the TDZ and `const` assignment checks and
        // may improve performance of larger JS codebases until the WebKit fix
        // is in widespread use.
        //
        // See https://bugs.webkit.org/show_bug.cgi?id=199866
        // Deprecated: This no longer have any effect and will be removed.
        // TODO(bep) remove. See https://github.com/evanw/esbuild/commit/869e8117b499ca1dbfc5b3021938a53ffe934dba
        AvoidTDZ bool

        mediaType  media.Type
        outDir     string
        contents   string
        sourceDir  string
        resolveDir string
        tsConfig   string
}

func decodeOptions(m map[string]interface{}) (Options, error) <span class="cov8" title="1">{
        var opts Options

        if err := mapstructure.WeakDecode(m, &amp;opts); err != nil </span><span class="cov0" title="0">{
                return opts, err
        }</span>

        <span class="cov8" title="1">if opts.TargetPath != "" </span><span class="cov0" title="0">{
                opts.TargetPath = helpers.ToSlashTrimLeading(opts.TargetPath)
        }</span>

        <span class="cov8" title="1">opts.Target = strings.ToLower(opts.Target)
        opts.Format = strings.ToLower(opts.Format)

        return opts, nil</span>
}

var extensionToLoaderMap = map[string]api.Loader{
        ".js":   api.LoaderJS,
        ".mjs":  api.LoaderJS,
        ".cjs":  api.LoaderJS,
        ".jsx":  api.LoaderJSX,
        ".ts":   api.LoaderTS,
        ".tsx":  api.LoaderTSX,
        ".css":  api.LoaderCSS,
        ".json": api.LoaderJSON,
        ".txt":  api.LoaderText,
}

func loaderFromFilename(filename string) api.Loader <span class="cov8" title="1">{
        l, found := extensionToLoaderMap[filepath.Ext(filename)]
        if found </span><span class="cov8" title="1">{
                return l
        }</span>
        <span class="cov0" title="0">return api.LoaderJS</span>
}

func resolveComponentInAssets(fs afero.Fs, impPath string) *hugofs.FileMeta <span class="cov8" title="1">{
        findFirst := func(base string) *hugofs.FileMeta </span><span class="cov8" title="1">{
                // This is the most common sub-set of ESBuild's default extensions.
                // We assume that imports of JSON, CSS etc. will be using their full
                // name with extension.
                for _, ext := range []string{".js", ".ts", ".tsx", ".jsx"} </span><span class="cov8" title="1">{
                        if strings.HasSuffix(impPath, ext) </span><span class="cov8" title="1">{
                                // Import of foo.js.js need the full name.
                                return nil
                        }</span>
                        <span class="cov8" title="1">if fi, err := fs.Stat(base + ext); err == nil </span><span class="cov8" title="1">{
                                return fi.(hugofs.FileMetaInfo).Meta()
                        }</span>
                }

                // Not found.
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">var m *hugofs.FileMeta

        // See issue #8949.
        // We need to check if this is a regular file imported without an extension.
        // There may be ambigous situations where both foo.js and foo/index.js exists.
        // This import order is in line with both how Node and ESBuild's native
        // import resolver works.
        // This was fixed in Hugo 0.88.

        // It may be a regular file imported without an extension, e.g.
        // foo or foo/index.
        m = findFirst(impPath)
        if m != nil </span><span class="cov8" title="1">{
                return m
        }</span>

        // Finally check the path as is.
        <span class="cov8" title="1">fi, err := fs.Stat(impPath)

        if err == nil </span><span class="cov8" title="1">{
                if fi.IsDir() </span><span class="cov8" title="1">{
                        m = findFirst(filepath.Join(impPath, "index"))
                }</span> else<span class="cov8" title="1"> {
                        m = fi.(hugofs.FileMetaInfo).Meta()
                }</span>
        }

        <span class="cov8" title="1">return m</span>
}

func createBuildPlugins(c *Client, opts Options) ([]api.Plugin, error) <span class="cov8" title="1">{
        fs := c.rs.Assets

        resolveImport := func(args api.OnResolveArgs) (api.OnResolveResult, error) </span><span class="cov8" title="1">{
                impPath := args.Path
                if opts.Shims != nil </span><span class="cov0" title="0">{
                        override, found := opts.Shims[impPath]
                        if found </span><span class="cov0" title="0">{
                                impPath = override
                        }</span>
                }
                <span class="cov8" title="1">isStdin := args.Importer == stdinImporter
                var relDir string
                if !isStdin </span><span class="cov8" title="1">{
                        rel, found := fs.MakePathRelative(args.Importer)
                        if !found </span><span class="cov0" title="0">{
                                // Not in any of the /assets folders.
                                // This is an import from a node_modules, let
                                // ESBuild resolve this.
                                return api.OnResolveResult{}, nil
                        }</span>
                        <span class="cov8" title="1">relDir = filepath.Dir(rel)</span>
                } else<span class="cov8" title="1"> {
                        relDir = opts.sourceDir
                }</span>

                // Imports not starting with a "." is assumed to live relative to /assets.
                // Hugo makes no assumptions about the directory structure below /assets.
                <span class="cov8" title="1">if relDir != "" &amp;&amp; strings.HasPrefix(impPath, ".") </span><span class="cov8" title="1">{
                        impPath = filepath.Join(relDir, impPath)
                }</span>

                <span class="cov8" title="1">m := resolveComponentInAssets(fs.Fs, impPath)

                if m != nil </span><span class="cov8" title="1">{
                        // Store the source root so we can create a jsconfig.json
                        // to help intellisense when the build is done.
                        // This should be a small number of elements, and when
                        // in server mode, we may get stale entries on renames etc.,
                        // but that shouldn't matter too much.
                        c.rs.JSConfigBuilder.AddSourceRoot(m.SourceRoot)
                        return api.OnResolveResult{Path: m.Filename, Namespace: nsImportHugo}, nil
                }</span>

                // Fall back to ESBuild's resolve.
                <span class="cov0" title="0">return api.OnResolveResult{}, nil</span>
        }

        <span class="cov8" title="1">importResolver := api.Plugin{
                Name: "hugo-import-resolver",
                Setup: func(build api.PluginBuild) </span><span class="cov8" title="1">{
                        build.OnResolve(api.OnResolveOptions{Filter: `.*`},
                                func(args api.OnResolveArgs) (api.OnResolveResult, error) </span><span class="cov8" title="1">{
                                        return resolveImport(args)
                                }</span>)
                        <span class="cov8" title="1">build.OnLoad(api.OnLoadOptions{Filter: `.*`, Namespace: nsImportHugo},
                                func(args api.OnLoadArgs) (api.OnLoadResult, error) </span><span class="cov8" title="1">{
                                        b, err := ioutil.ReadFile(args.Path)
                                        if err != nil </span><span class="cov0" title="0">{
                                                return api.OnLoadResult{}, errors.Wrapf(err, "failed to read %q", args.Path)
                                        }</span>
                                        <span class="cov8" title="1">c := string(b)
                                        return api.OnLoadResult{
                                                // See https://github.com/evanw/esbuild/issues/502
                                                // This allows all modules to resolve dependencies
                                                // in the main project's node_modules.
                                                ResolveDir: opts.resolveDir,
                                                Contents:   &amp;c,
                                                Loader:     loaderFromFilename(args.Path),
                                        }, nil</span>
                                })
                },
        }

        <span class="cov8" title="1">params := opts.Params
        if params == nil </span><span class="cov8" title="1">{
                // This way @params will always resolve to something.
                params = make(map[string]interface{})
        }</span>

        <span class="cov8" title="1">b, err := json.Marshal(params)
        if err != nil </span><span class="cov0" title="0">{
                return nil, errors.Wrap(err, "failed to marshal params")
        }</span>
        <span class="cov8" title="1">bs := string(b)
        paramsPlugin := api.Plugin{
                Name: "hugo-params-plugin",
                Setup: func(build api.PluginBuild) </span><span class="cov8" title="1">{
                        build.OnResolve(api.OnResolveOptions{Filter: `^@params$`},
                                func(args api.OnResolveArgs) (api.OnResolveResult, error) </span><span class="cov0" title="0">{
                                        return api.OnResolveResult{
                                                Path:      args.Path,
                                                Namespace: nsParams,
                                        }, nil
                                }</span>)
                        <span class="cov8" title="1">build.OnLoad(api.OnLoadOptions{Filter: `.*`, Namespace: nsParams},
                                func(args api.OnLoadArgs) (api.OnLoadResult, error) </span><span class="cov0" title="0">{
                                        return api.OnLoadResult{
                                                Contents: &amp;bs,
                                                Loader:   api.LoaderJSON,
                                        }, nil
                                }</span>)
                },
        }

        <span class="cov8" title="1">return []api.Plugin{importResolver, paramsPlugin}, nil</span>
}

func toBuildOptions(opts Options) (buildOptions api.BuildOptions, err error) <span class="cov8" title="1">{
        var target api.Target
        switch opts.Target </span>{
        case "", "esnext":<span class="cov8" title="1">
                target = api.ESNext</span>
        case "es5":<span class="cov0" title="0">
                target = api.ES5</span>
        case "es6", "es2015":<span class="cov0" title="0">
                target = api.ES2015</span>
        case "es2016":<span class="cov0" title="0">
                target = api.ES2016</span>
        case "es2017":<span class="cov0" title="0">
                target = api.ES2017</span>
        case "es2018":<span class="cov8" title="1">
                target = api.ES2018</span>
        case "es2019":<span class="cov0" title="0">
                target = api.ES2019</span>
        case "es2020":<span class="cov0" title="0">
                target = api.ES2020</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("invalid target: %q", opts.Target)
                return</span>
        }

        <span class="cov8" title="1">mediaType := opts.mediaType
        if mediaType.IsZero() </span><span class="cov0" title="0">{
                mediaType = media.JavascriptType
        }</span>

        <span class="cov8" title="1">var loader api.Loader
        switch mediaType.SubType </span>{
        // TODO(bep) ESBuild support a set of other loaders, but I currently fail
        // to see the relevance. That may change as we start using this.
        case media.JavascriptType.SubType:<span class="cov8" title="1">
                loader = api.LoaderJS</span>
        case media.TypeScriptType.SubType:<span class="cov0" title="0">
                loader = api.LoaderTS</span>
        case media.TSXType.SubType:<span class="cov0" title="0">
                loader = api.LoaderTSX</span>
        case media.JSXType.SubType:<span class="cov0" title="0">
                loader = api.LoaderJSX</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported Media Type: %q", opts.mediaType)
                return</span>
        }

        <span class="cov8" title="1">var format api.Format
        // One of: iife, cjs, esm
        switch opts.Format </span>{
        case "", "iife":<span class="cov8" title="1">
                format = api.FormatIIFE</span>
        case "esm":<span class="cov0" title="0">
                format = api.FormatESModule</span>
        case "cjs":<span class="cov8" title="1">
                format = api.FormatCommonJS</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported script output format: %q", opts.Format)
                return</span>
        }

        <span class="cov8" title="1">var defines map[string]string
        if opts.Defines != nil </span><span class="cov0" title="0">{
                defines = maps.ToStringMapString(opts.Defines)
        }</span>

        // By default we only need to specify outDir and no outFile
        <span class="cov8" title="1">outDir := opts.outDir
        outFile := ""
        var sourceMap api.SourceMap
        switch opts.SourceMap </span>{
        case "inline":<span class="cov8" title="1">
                sourceMap = api.SourceMapInline</span>
        case "external":<span class="cov8" title="1">
                sourceMap = api.SourceMapExternal</span>
        case "":<span class="cov8" title="1">
                sourceMap = api.SourceMapNone</span>
        default:<span class="cov0" title="0">
                err = fmt.Errorf("unsupported sourcemap type: %q", opts.SourceMap)
                return</span>
        }

        <span class="cov8" title="1">buildOptions = api.BuildOptions{
                Outfile: outFile,
                Bundle:  true,

                Target:    target,
                Format:    format,
                Sourcemap: sourceMap,

                MinifyWhitespace:  opts.Minify,
                MinifyIdentifiers: opts.Minify,
                MinifySyntax:      opts.Minify,

                Outdir: outDir,
                Define: defines,

                External: opts.Externals,

                JSXFactory:  opts.JSXFactory,
                JSXFragment: opts.JSXFragment,

                Tsconfig: opts.tsConfig,

                // Note: We're not passing Sourcefile to ESBuild.
                // This makes ESBuild pass `stdin` as the Importer to the import
                // resolver, which is what we need/expect.
                Stdin: &amp;api.StdinOptions{
                        Contents:   opts.contents,
                        ResolveDir: opts.resolveDir,
                        Loader:     loader,
                },
        }
        return</span>
}
</pre>
		
		<pre class="file" id="file254" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package minifier

import (
        "github.com/gohugoio/hugo/minifiers"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/internal"
        "github.com/gohugoio/hugo/resources/resource"
)

// Client for minification of Resource objects. Supported minifiers are:
// css, html, js, json, svg and xml.
type Client struct {
        rs *resources.Spec
        m  minifiers.Client
}

// New creates a new Client given a specification. Note that it is the media types
// configured for the site that is used to match files to the correct minifier.
func New(rs *resources.Spec) (*Client, error) <span class="cov8" title="1">{
        m, err := minifiers.New(rs.MediaTypes, rs.OutputFormats, rs.Cfg)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">return &amp;Client{rs: rs, m: m}, nil</span>
}

type minifyTransformation struct {
        rs *resources.Spec
        m  minifiers.Client
}

func (t *minifyTransformation) Key() internal.ResourceTransformationKey <span class="cov8" title="1">{
        return internal.NewResourceTransformationKey("minify")
}</span>

func (t *minifyTransformation) Transform(ctx *resources.ResourceTransformationCtx) error <span class="cov8" title="1">{
        ctx.AddOutPathIdentifier(".min")
        return t.m.Minify(ctx.InMediaType, ctx.To, ctx.From)
}</span>

func (c *Client) Minify(res resources.ResourceTransformer) (resource.Resource, error) <span class="cov8" title="1">{
        return res.Transform(&amp;minifyTransformation{
                rs: c.rs,
                m:  c.m,
        })
}</span>
</pre>
		
		<pre class="file" id="file255" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package postcss

import (
        "bytes"
        "crypto/sha256"
        "encoding/hex"
        "io"
        "io/ioutil"
        "path"
        "path/filepath"
        "regexp"
        "strconv"
        "strings"

        "github.com/gohugoio/hugo/common/collections"
        "github.com/gohugoio/hugo/common/hexec"

        "github.com/gohugoio/hugo/common/hugo"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/gohugoio/hugo/resources/internal"
        "github.com/spf13/afero"
        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/hugofs"
        "github.com/pkg/errors"

        "github.com/mitchellh/mapstructure"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
)

const importIdentifier = "@import"

var cssSyntaxErrorRe = regexp.MustCompile(`&gt; (\d+) \|`)

var shouldImportRe = regexp.MustCompile(`^@import ["'].*["'];?\s*(/\*.*\*/)?$`)

// New creates a new Client with the given specification.
func New(rs *resources.Spec) *Client <span class="cov8" title="1">{
        return &amp;Client{rs: rs}
}</span>

func DecodeOptions(m map[string]interface{}) (opts Options, err error) <span class="cov8" title="1">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">err = mapstructure.WeakDecode(m, &amp;opts)

        if !opts.NoMap </span><span class="cov8" title="1">{
                // There was for a long time a discrepancy between documentation and
                // implementation for the noMap property, so we need to support both
                // camel and snake case.
                opts.NoMap = cast.ToBool(m["no-map"])
        }</span>

        <span class="cov8" title="1">return</span>
}

// Client is the client used to do PostCSS transformations.
type Client struct {
        rs *resources.Spec
}

// Process transforms the given Resource with the PostCSS processor.
func (c *Client) Process(res resources.ResourceTransformer, options Options) (resource.Resource, error) <span class="cov0" title="0">{
        return res.Transform(&amp;postcssTransformation{rs: c.rs, options: options})
}</span>

// Some of the options from https://github.com/postcss/postcss-cli
type Options struct {

        // Set a custom path to look for a config file.
        Config string

        NoMap bool // Disable the default inline sourcemaps

        // Enable inlining of @import statements.
        // Does so recursively, but currently once only per file;
        // that is, it's not possible to import the same file in
        // different scopes (root, media query...)
        // Note that this import routine does not care about the CSS spec,
        // so you can have @import anywhere in the file.
        InlineImports bool

        // Options for when not using a config file
        Use         string // List of postcss plugins to use
        Parser      string //  Custom postcss parser
        Stringifier string // Custom postcss stringifier
        Syntax      string // Custom postcss syntax
}

func (opts Options) toArgs() []string <span class="cov0" title="0">{
        var args []string
        if opts.NoMap </span><span class="cov0" title="0">{
                args = append(args, "--no-map")
        }</span>
        <span class="cov0" title="0">if opts.Use != "" </span><span class="cov0" title="0">{
                args = append(args, "--use")
                args = append(args, strings.Fields(opts.Use)...)
        }</span>
        <span class="cov0" title="0">if opts.Parser != "" </span><span class="cov0" title="0">{
                args = append(args, "--parser", opts.Parser)
        }</span>
        <span class="cov0" title="0">if opts.Stringifier != "" </span><span class="cov0" title="0">{
                args = append(args, "--stringifier", opts.Stringifier)
        }</span>
        <span class="cov0" title="0">if opts.Syntax != "" </span><span class="cov0" title="0">{
                args = append(args, "--syntax", opts.Syntax)
        }</span>
        <span class="cov0" title="0">return args</span>
}

type postcssTransformation struct {
        options Options
        rs      *resources.Spec
}

func (t *postcssTransformation) Key() internal.ResourceTransformationKey <span class="cov0" title="0">{
        return internal.NewResourceTransformationKey("postcss", t.options)
}</span>

// Transform shells out to postcss-cli to do the heavy lifting.
// For this to work, you need some additional tools. To install them globally:
// npm install -g postcss-cli
// npm install -g autoprefixer
func (t *postcssTransformation) Transform(ctx *resources.ResourceTransformationCtx) error <span class="cov0" title="0">{
        const binaryName = "postcss"

        ex := t.rs.ExecHelper

        var configFile string
        logger := t.rs.Logger

        if t.options.Config != "" </span><span class="cov0" title="0">{
                configFile = t.options.Config
        }</span> else<span class="cov0" title="0"> {
                configFile = "postcss.config.js"
        }</span>

        <span class="cov0" title="0">configFile = filepath.Clean(configFile)

        // We need an absolute filename to the config file.
        if !filepath.IsAbs(configFile) </span><span class="cov0" title="0">{
                configFile = t.rs.BaseFs.ResolveJSConfigFile(configFile)
                if configFile == "" &amp;&amp; t.options.Config != "" </span><span class="cov0" title="0">{
                        // Only fail if the user specified config file is not found.
                        return errors.Errorf("postcss config %q not found:", configFile)
                }</span>
        }

        <span class="cov0" title="0">var cmdArgs []interface{}

        if configFile != "" </span><span class="cov0" title="0">{
                logger.Infoln("postcss: use config file", configFile)
                cmdArgs = []interface{}{"--config", configFile}
        }</span>

        <span class="cov0" title="0">if optArgs := t.options.toArgs(); len(optArgs) &gt; 0 </span><span class="cov0" title="0">{
                cmdArgs = append(cmdArgs, collections.StringSliceToInterfaceSlice(optArgs)...)
        }</span>

        <span class="cov0" title="0">var errBuf bytes.Buffer
        infoW := loggers.LoggerToWriterWithPrefix(logger.Info(), "postcss")

        stderr := io.MultiWriter(infoW, &amp;errBuf)
        cmdArgs = append(cmdArgs, hexec.WithStderr(stderr))
        cmdArgs = append(cmdArgs, hexec.WithStdout(ctx.To))
        cmdArgs = append(cmdArgs, hexec.WithEnviron(hugo.GetExecEnviron(t.rs.WorkingDir, t.rs.Cfg, t.rs.BaseFs.Assets.Fs)))

        cmd, err := ex.Npx(binaryName, cmdArgs...)
        if err != nil </span><span class="cov0" title="0">{
                if hexec.IsNotFound(err) </span><span class="cov0" title="0">{
                        // This may be on a CI server etc. Will fall back to pre-built assets.
                        return herrors.ErrFeatureNotAvailable
                }</span>
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">stdin, err := cmd.StdinPipe()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">src := ctx.From

        imp := newImportResolver(
                ctx.From,
                ctx.InPath,
                t.rs.Assets.Fs, t.rs.Logger,
        )

        if t.options.InlineImports </span><span class="cov0" title="0">{
                var err error
                src, err = imp.resolve()
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">go func() </span><span class="cov0" title="0">{
                defer stdin.Close()
                io.Copy(stdin, src)
        }</span>()

        <span class="cov0" title="0">err = cmd.Run()
        if err != nil </span><span class="cov0" title="0">{
                if hexec.IsNotFound(err) </span><span class="cov0" title="0">{
                        return herrors.ErrFeatureNotAvailable
                }</span>
                <span class="cov0" title="0">return imp.toFileError(errBuf.String())</span>
        }

        <span class="cov0" title="0">return nil</span>
}

type fileOffset struct {
        Filename string
        Offset   int
}

type importResolver struct {
        r      io.Reader
        inPath string

        contentSeen map[string]bool
        linemap     map[int]fileOffset
        fs          afero.Fs
        logger      loggers.Logger
}

func newImportResolver(r io.Reader, inPath string, fs afero.Fs, logger loggers.Logger) *importResolver <span class="cov8" title="1">{
        return &amp;importResolver{
                r:      r,
                inPath: inPath,
                fs:     fs, logger: logger,
                linemap: make(map[int]fileOffset), contentSeen: make(map[string]bool),
        }
}</span>

func (imp *importResolver) contentHash(filename string) ([]byte, string) <span class="cov8" title="1">{
        b, err := afero.ReadFile(imp.fs, filename)
        if err != nil </span><span class="cov8" title="1">{
                return nil, ""
        }</span>
        <span class="cov8" title="1">h := sha256.New()
        h.Write(b)
        return b, hex.EncodeToString(h.Sum(nil))</span>
}

func (imp *importResolver) importRecursive(
        lineNum int,
        content string,
        inPath string) (int, string, error) <span class="cov8" title="1">{
        basePath := path.Dir(inPath)

        var replacements []string
        lines := strings.Split(content, "\n")

        trackLine := func(i, offset int, line string) </span><span class="cov8" title="1">{
                // TODO(bep) this is not very efficient.
                imp.linemap[i+lineNum] = fileOffset{Filename: inPath, Offset: offset}
        }</span>

        <span class="cov8" title="1">i := 0
        for offset, line := range lines </span><span class="cov8" title="1">{
                i++
                line = strings.TrimSpace(line)

                if !imp.shouldImport(line) </span><span class="cov8" title="1">{
                        trackLine(i, offset, line)
                }</span> else<span class="cov8" title="1"> {
                        i--
                        path := strings.Trim(strings.TrimPrefix(line, importIdentifier), " \"';")
                        filename := filepath.Join(basePath, path)
                        importContent, hash := imp.contentHash(filename)
                        if importContent == nil </span><span class="cov8" title="1">{
                                trackLine(i, offset, "ERROR")
                                imp.logger.Warnf("postcss: Failed to resolve CSS @import in %q for path %q", inPath, filename)
                                continue</span>
                        }

                        <span class="cov8" title="1">if imp.contentSeen[hash] </span><span class="cov8" title="1">{
                                i++
                                // Just replace the line with an empty string.
                                replacements = append(replacements, []string{line, ""}...)
                                trackLine(i, offset, "IMPORT")
                                continue</span>
                        }

                        <span class="cov8" title="1">imp.contentSeen[hash] = true

                        // Handle recursive imports.
                        l, nested, err := imp.importRecursive(i+lineNum, string(importContent), filepath.ToSlash(filename))
                        if err != nil </span><span class="cov0" title="0">{
                                return 0, "", err
                        }</span>

                        <span class="cov8" title="1">trackLine(i, offset, line)

                        i += l

                        importContent = []byte(nested)

                        replacements = append(replacements, []string{line, string(importContent)}...)</span>
                }
        }

        <span class="cov8" title="1">if len(replacements) &gt; 0 </span><span class="cov8" title="1">{
                repl := strings.NewReplacer(replacements...)
                content = repl.Replace(content)
        }</span>

        <span class="cov8" title="1">return i, content, nil</span>
}

func (imp *importResolver) resolve() (io.Reader, error) <span class="cov8" title="1">{
        const importIdentifier = "@import"

        content, err := ioutil.ReadAll(imp.r)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">contents := string(content)

        _, newContent, err := imp.importRecursive(0, contents, imp.inPath)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return strings.NewReader(newContent), nil</span>
}

// See https://www.w3schools.com/cssref/pr_import_rule.asp
// We currently only support simple file imports, no urls, no media queries.
// So this is OK:
//     @import "navigation.css";
// This is not:
//     @import url("navigation.css");
//     @import "mobstyle.css" screen and (max-width: 768px);
func (imp *importResolver) shouldImport(s string) bool <span class="cov8" title="1">{
        if !strings.HasPrefix(s, importIdentifier) </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">if strings.Contains(s, "url(") </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return shouldImportRe.MatchString(s)</span>
}

func (imp *importResolver) toFileError(output string) error <span class="cov0" title="0">{
        inErr := errors.New(strings.TrimSpace(output))

        match := cssSyntaxErrorRe.FindStringSubmatch(output)
        if match == nil </span><span class="cov0" title="0">{
                return inErr
        }</span>

        <span class="cov0" title="0">lineNum, err := strconv.Atoi(match[1])
        if err != nil </span><span class="cov0" title="0">{
                return inErr
        }</span>

        <span class="cov0" title="0">file, ok := imp.linemap[lineNum]
        if !ok </span><span class="cov0" title="0">{
                return inErr
        }</span>

        <span class="cov0" title="0">fi, err := imp.fs.Stat(file.Filename)
        if err != nil </span><span class="cov0" title="0">{
                return inErr
        }</span>
        <span class="cov0" title="0">realFilename := fi.(hugofs.FileMetaInfo).Meta().Filename

        ferr := herrors.NewFileError("css", -1, file.Offset+1, 1, inErr)

        werr, ok := herrors.WithFileContextForFile(ferr, realFilename, file.Filename, imp.fs, herrors.SimpleLineMatcher)

        if !ok </span><span class="cov0" title="0">{
                return ferr
        }</span>

        <span class="cov0" title="0">return werr</span>
}
</pre>
		
		<pre class="file" id="file256" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package templates contains functions for template processing of Resource objects.
package templates

import (
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/internal"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/gohugoio/hugo/tpl"
        "github.com/pkg/errors"
)

// Client contains methods to perform template processing of Resource objects.
type Client struct {
        rs *resources.Spec
        t  tpl.TemplatesProvider
}

// New creates a new Client with the given specification.
func New(rs *resources.Spec, t tpl.TemplatesProvider) *Client <span class="cov8" title="1">{
        if rs == nil </span><span class="cov0" title="0">{
                panic("must provice a resource Spec")</span>
        }
        <span class="cov8" title="1">if t == nil </span><span class="cov0" title="0">{
                panic("must provide a template provider")</span>
        }
        <span class="cov8" title="1">return &amp;Client{rs: rs, t: t}</span>
}

type executeAsTemplateTransform struct {
        rs         *resources.Spec
        t          tpl.TemplatesProvider
        targetPath string
        data       interface{}
}

func (t *executeAsTemplateTransform) Key() internal.ResourceTransformationKey <span class="cov8" title="1">{
        return internal.NewResourceTransformationKey("execute-as-template", t.targetPath)
}</span>

func (t *executeAsTemplateTransform) Transform(ctx *resources.ResourceTransformationCtx) error <span class="cov8" title="1">{
        tplStr := helpers.ReaderToString(ctx.From)
        templ, err := t.t.TextTmpl().Parse(ctx.InPath, tplStr)
        if err != nil </span><span class="cov0" title="0">{
                return errors.Wrapf(err, "failed to parse Resource %q as Template:", ctx.InPath)
        }</span>

        <span class="cov8" title="1">ctx.OutPath = t.targetPath

        return t.t.Tmpl().Execute(templ, ctx.To, t.data)</span>
}

func (c *Client) ExecuteAsTemplate(res resources.ResourceTransformer, targetPath string, data interface{}) (resource.Resource, error) <span class="cov8" title="1">{
        return res.Transform(&amp;executeAsTemplateTransform{
                rs:         c.rs,
                targetPath: helpers.ToSlashTrimLeading(targetPath),
                t:          c.t,
                data:       data,
        })
}</span>
</pre>
		
		<pre class="file" id="file257" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package godartsass integrates with the Dass Sass Embedded protocol to transpile
// SCSS/SASS.
package dartsass

import (
        "io"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugolib/filesystems"
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
        "github.com/spf13/afero"

        "github.com/bep/godartsass"
        "github.com/mitchellh/mapstructure"
)

// used as part of the cache key.
const transformationName = "tocss-dart"

func New(fs *filesystems.SourceFilesystem, rs *resources.Spec) (*Client, error) <span class="cov0" title="0">{
        if !Supports() </span><span class="cov0" title="0">{
                return &amp;Client{dartSassNotAvailable: true}, nil
        }</span>

        <span class="cov0" title="0">if err := rs.ExecHelper.Sec().CheckAllowedExec(dartSassEmbeddedBinaryName); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">transpiler, err := godartsass.Start(godartsass.Options{})
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;Client{sfs: fs, workFs: rs.BaseFs.Work, rs: rs, transpiler: transpiler}, nil</span>
}

type Client struct {
        dartSassNotAvailable bool
        rs                   *resources.Spec
        sfs                  *filesystems.SourceFilesystem
        workFs               afero.Fs
        transpiler           *godartsass.Transpiler
}

func (c *Client) ToCSS(res resources.ResourceTransformer, args map[string]interface{}) (resource.Resource, error) <span class="cov0" title="0">{
        if c.dartSassNotAvailable </span><span class="cov0" title="0">{
                return res.Transform(resources.NewFeatureNotAvailableTransformer(transformationName, args))
        }</span>
        <span class="cov0" title="0">return res.Transform(&amp;transform{c: c, optsm: args})</span>
}

func (c *Client) Close() error <span class="cov0" title="0">{
        if c.transpiler == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov0" title="0">return c.transpiler.Close()</span>
}

func (c *Client) toCSS(args godartsass.Args, src io.Reader) (godartsass.Result, error) <span class="cov0" title="0">{
        var res godartsass.Result

        in := helpers.ReaderToString(src)
        args.Source = in

        res, err := c.transpiler.Execute(args)
        if err != nil </span><span class="cov0" title="0">{
                return res, err
        }</span>

        <span class="cov0" title="0">return res, err</span>
}

type Options struct {

        // Hugo, will by default, just replace the extension of the source
        // to .css, e.g. "scss/main.scss" becomes "scss/main.css". You can
        // control this by setting this, e.g. "styles/main.css" will create
        // a Resource with that as a base for RelPermalink etc.
        TargetPath string

        // Hugo automatically adds the entry directories (where the main.scss lives)
        // for project and themes to the list of include paths sent to LibSASS.
        // Any paths set in this setting will be appended. Note that these will be
        // treated as relative to the working dir, i.e. no include paths outside the
        // project/themes.
        IncludePaths []string

        // Default is nested.
        // One of nested, expanded, compact, compressed.
        OutputStyle string

        // When enabled, Hugo will generate a source map.
        EnableSourceMap bool
}

func decodeOptions(m map[string]interface{}) (opts Options, err error) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">err = mapstructure.WeakDecode(m, &amp;opts)

        if opts.TargetPath != "" </span><span class="cov0" title="0">{
                opts.TargetPath = helpers.ToSlashTrimLeading(opts.TargetPath)
        }</span>

        <span class="cov0" title="0">return</span>
}
</pre>
		
		<pre class="file" id="file258" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package dartsass

import (
        "fmt"
        "io"
        "net/url"
        "path"
        "path/filepath"
        "strings"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/hexec"
        "github.com/gohugoio/hugo/htesting"
        "github.com/gohugoio/hugo/media"

        "github.com/gohugoio/hugo/resources"

        "github.com/gohugoio/hugo/resources/internal"

        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/bep/godartsass"
)

const (
        // See https://github.com/sass/dart-sass-embedded/issues/24
        stdinPlaceholder           = "HUGOSTDIN"
        dartSassEmbeddedBinaryName = "dart-sass-embedded"
)

// Supports returns whether dart-sass-embedded is found in $PATH.
func Supports() bool <span class="cov8" title="1">{
        if htesting.SupportsAll() </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov8" title="1">return hexec.InPath(dartSassEmbeddedBinaryName)</span>
}

type transform struct {
        optsm map[string]interface{}
        c     *Client
}

func (t *transform) Key() internal.ResourceTransformationKey <span class="cov0" title="0">{
        return internal.NewResourceTransformationKey(transformationName, t.optsm)
}</span>

func (t *transform) Transform(ctx *resources.ResourceTransformationCtx) error <span class="cov0" title="0">{
        ctx.OutMediaType = media.CSSType

        opts, err := decodeOptions(t.optsm)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if opts.TargetPath != "" </span><span class="cov0" title="0">{
                ctx.OutPath = opts.TargetPath
        }</span> else<span class="cov0" title="0"> {
                ctx.ReplaceOutPathExtension(".css")
        }</span>

        <span class="cov0" title="0">baseDir := path.Dir(ctx.SourcePath)

        args := godartsass.Args{
                URL:          stdinPlaceholder,
                IncludePaths: t.c.sfs.RealDirs(baseDir),
                ImportResolver: importResolver{
                        baseDir: baseDir,
                        c:       t.c,
                },
                OutputStyle:     godartsass.ParseOutputStyle(opts.OutputStyle),
                EnableSourceMap: opts.EnableSourceMap,
        }

        // Append any workDir relative include paths
        for _, ip := range opts.IncludePaths </span><span class="cov0" title="0">{
                info, err := t.c.workFs.Stat(filepath.Clean(ip))
                if err == nil </span><span class="cov0" title="0">{
                        filename := info.(hugofs.FileMetaInfo).Meta().Filename
                        args.IncludePaths = append(args.IncludePaths, filename)
                }</span>
        }

        <span class="cov0" title="0">if ctx.InMediaType.SubType == media.SASSType.SubType </span><span class="cov0" title="0">{
                args.SourceSyntax = godartsass.SourceSyntaxSASS
        }</span>

        <span class="cov0" title="0">res, err := t.c.toCSS(args, ctx.From)
        if err != nil </span><span class="cov0" title="0">{
                if sassErr, ok := err.(godartsass.SassError); ok </span><span class="cov0" title="0">{
                        start := sassErr.Span.Start
                        context := strings.TrimSpace(sassErr.Span.Context)
                        filename, _ := urlToFilename(sassErr.Span.Url)
                        if filename == stdinPlaceholder </span><span class="cov0" title="0">{
                                if ctx.SourcePath == "" </span><span class="cov0" title="0">{
                                        return sassErr
                                }</span>
                                <span class="cov0" title="0">filename = t.c.sfs.RealFilename(ctx.SourcePath)</span>
                        }

                        <span class="cov0" title="0">offsetMatcher := func(m herrors.LineMatcher) bool </span><span class="cov0" title="0">{
                                return m.Offset+len(m.Line) &gt;= start.Offset &amp;&amp; strings.Contains(m.Line, context)
                        }</span>

                        <span class="cov0" title="0">ferr, ok := herrors.WithFileContextForFile(
                                herrors.NewFileError("scss", -1, -1, start.Column, sassErr),
                                filename,
                                filename,
                                hugofs.Os,
                                offsetMatcher)

                        if !ok </span><span class="cov0" title="0">{
                                return sassErr
                        }</span>

                        <span class="cov0" title="0">return ferr</span>
                }
                <span class="cov0" title="0">return err</span>
        }

        <span class="cov0" title="0">out := res.CSS

        _, err = io.WriteString(ctx.To, out)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if opts.EnableSourceMap &amp;&amp; res.SourceMap != "" </span><span class="cov0" title="0">{
                if err := ctx.PublishSourceMap(res.SourceMap); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">_, err = fmt.Fprintf(ctx.To, "\n\n/*# sourceMappingURL=%s */", path.Base(ctx.OutPath)+".map")</span>
        }

        <span class="cov0" title="0">return err</span>
}

type importResolver struct {
        baseDir string
        c       *Client
}

func (t importResolver) CanonicalizeURL(url string) (string, error) <span class="cov0" title="0">{
        filePath, isURL := urlToFilename(url)
        var prevDir string
        var pathDir string
        if isURL </span><span class="cov0" title="0">{
                var found bool
                prevDir, found = t.c.sfs.MakePathRelative(filepath.Dir(filePath))

                if !found </span><span class="cov0" title="0">{
                        // Not a member of this filesystem, let Dart Sass handle it.
                        return "", nil
                }</span>
        } else<span class="cov0" title="0"> {
                prevDir = t.baseDir
                pathDir = path.Dir(url)
        }</span>

        <span class="cov0" title="0">basePath := filepath.Join(prevDir, pathDir)
        name := filepath.Base(filePath)

        // Pick the first match.
        var namePatterns []string
        if strings.Contains(name, ".") </span><span class="cov0" title="0">{
                namePatterns = []string{"_%s", "%s"}
        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(name, "_") </span><span class="cov0" title="0">{
                namePatterns = []string{"_%s.scss", "_%s.sass"}
        }</span> else<span class="cov0" title="0"> {
                namePatterns = []string{"_%s.scss", "%s.scss", "_%s.sass", "%s.sass"}
        }</span>

        <span class="cov0" title="0">name = strings.TrimPrefix(name, "_")

        for _, namePattern := range namePatterns </span><span class="cov0" title="0">{
                filenameToCheck := filepath.Join(basePath, fmt.Sprintf(namePattern, name))
                fi, err := t.c.sfs.Fs.Stat(filenameToCheck)
                if err == nil </span><span class="cov0" title="0">{
                        if fim, ok := fi.(hugofs.FileMetaInfo); ok </span><span class="cov0" title="0">{
                                return "file://" + filepath.ToSlash(fim.Meta().Filename), nil
                        }</span>
                }
        }

        // Not found, let Dart Dass handle it
        <span class="cov0" title="0">return "", nil</span>
}

func (t importResolver) Load(url string) (string, error) <span class="cov0" title="0">{
        filename, _ := urlToFilename(url)
        b, err := afero.ReadFile(hugofs.Os, filename)
        return string(b), err
}</span>

// TODO(bep) add tests
func urlToFilename(urls string) (string, bool) <span class="cov0" title="0">{
        u, err := url.ParseRequestURI(urls)
        if err != nil </span><span class="cov0" title="0">{
                return filepath.FromSlash(urls), false
        }</span>
        <span class="cov0" title="0">p := filepath.FromSlash(u.Path)

        if u.Host != "" </span><span class="cov0" title="0">{
                // C:\data\file.txt
                p = strings.ToUpper(u.Host) + ":" + p
        }</span>

        <span class="cov0" title="0">return p, true</span>
}
</pre>
		
		<pre class="file" id="file259" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package scss

import (
        "regexp"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/hugolib/filesystems"
        "github.com/gohugoio/hugo/resources"
        "github.com/spf13/afero"

        "github.com/mitchellh/mapstructure"
)

const transformationName = "tocss"

type Client struct {
        rs     *resources.Spec
        sfs    *filesystems.SourceFilesystem
        workFs afero.Fs
}

func New(fs *filesystems.SourceFilesystem, rs *resources.Spec) (*Client, error) <span class="cov0" title="0">{
        return &amp;Client{sfs: fs, workFs: rs.BaseFs.Work, rs: rs}, nil
}</span>

type Options struct {

        // Hugo, will by default, just replace the extension of the source
        // to .css, e.g. "scss/main.scss" becomes "scss/main.css". You can
        // control this by setting this, e.g. "styles/main.css" will create
        // a Resource with that as a base for RelPermalink etc.
        TargetPath string

        // Hugo automatically adds the entry directories (where the main.scss lives)
        // for project and themes to the list of include paths sent to LibSASS.
        // Any paths set in this setting will be appended. Note that these will be
        // treated as relative to the working dir, i.e. no include paths outside the
        // project/themes.
        IncludePaths []string

        // Default is nested.
        // One of nested, expanded, compact, compressed.
        OutputStyle string

        // Precision of floating point math.
        Precision int

        // When enabled, Hugo will generate a source map.
        EnableSourceMap bool
}

func DecodeOptions(m map[string]interface{}) (opts Options, err error) <span class="cov0" title="0">{
        if m == nil </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov0" title="0">err = mapstructure.WeakDecode(m, &amp;opts)

        if opts.TargetPath != "" </span><span class="cov0" title="0">{
                opts.TargetPath = helpers.ToSlashTrimLeading(opts.TargetPath)
        }</span>

        <span class="cov0" title="0">return</span>
}

var (
        regularCSSImportTo   = regexp.MustCompile(`.*(@import "(.*\.css)";).*`)
        regularCSSImportFrom = regexp.MustCompile(`.*(\/\* HUGO_IMPORT_START (.*) HUGO_IMPORT_END \*\/).*`)
)

func replaceRegularImportsIn(s string) (string, bool) <span class="cov8" title="1">{
        replaced := regularCSSImportTo.ReplaceAllString(s, "/* HUGO_IMPORT_START $2 HUGO_IMPORT_END */")
        return replaced, s != replaced
}</span>

func replaceRegularImportsOut(s string) string <span class="cov8" title="1">{
        return regularCSSImportFrom.ReplaceAllString(s, "@import \"$2\";")
}</span>
</pre>
		
		<pre class="file" id="file260" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// +build !extended

package scss

import (
        "github.com/gohugoio/hugo/resources"
        "github.com/gohugoio/hugo/resources/resource"
)

func (c *Client) ToCSS(res resources.ResourceTransformer, opts Options) (resource.Resource, error) <span class="cov0" title="0">{
        return res.Transform(resources.NewFeatureNotAvailableTransformer(transformationName, opts))
}</span>

// Used in tests.
func Supports() bool <span class="cov8" title="1">{
        return false
}</span>
</pre>
		
		<pre class="file" id="file261" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package resources

import (
        "bytes"
        "fmt"
        "image"
        "io"
        "path"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/common/paths"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/resources/images/exif"
        "github.com/spf13/afero"

        bp "github.com/gohugoio/hugo/bufferpool"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/common/hugio"
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/resources/internal"
        "github.com/gohugoio/hugo/resources/resource"

        "github.com/gohugoio/hugo/media"
)

var (
        _ resource.ContentResource        = (*resourceAdapter)(nil)
        _ resource.ReadSeekCloserResource = (*resourceAdapter)(nil)
        _ resource.Resource               = (*resourceAdapter)(nil)
        _ resource.Source                 = (*resourceAdapter)(nil)
        _ resource.Identifier             = (*resourceAdapter)(nil)
        _ resource.ResourceMetaProvider   = (*resourceAdapter)(nil)
)

// These are transformations that need special support in Hugo that may not
// be available when building the theme/site so we write the transformation
// result to disk and reuse if needed for these,
// TODO(bep) it's a little fragile having these constants redefined here.
var transformationsToCacheOnDisk = map[string]bool{
        "postcss":    true,
        "tocss":      true,
        "tocss-dart": true,
}

func newResourceAdapter(spec *Spec, lazyPublish bool, target transformableResource) *resourceAdapter <span class="cov8" title="1">{
        var po *publishOnce
        if lazyPublish </span><span class="cov8" title="1">{
                po = &amp;publishOnce{}
        }</span>
        <span class="cov8" title="1">return &amp;resourceAdapter{
                resourceTransformations: &amp;resourceTransformations{},
                resourceAdapterInner: &amp;resourceAdapterInner{
                        spec:        spec,
                        publishOnce: po,
                        target:      target,
                },
        }</span>
}

// ResourceTransformation is the interface that a resource transformation step
// needs to implement.
type ResourceTransformation interface {
        Key() internal.ResourceTransformationKey
        Transform(ctx *ResourceTransformationCtx) error
}

type ResourceTransformationCtx struct {
        // The content to transform.
        From io.Reader

        // The target of content transformation.
        // The current implementation requires that r is written to w
        // even if no transformation is performed.
        To io.Writer

        // This is the relative path to the original source. Unix styled slashes.
        SourcePath string

        // This is the relative target path to the resource. Unix styled slashes.
        InPath string

        // The relative target path to the transformed resource. Unix styled slashes.
        OutPath string

        // The input media type
        InMediaType media.Type

        // The media type of the transformed resource.
        OutMediaType media.Type

        // Data data can be set on the transformed Resource. Not that this need
        // to be simple types, as it needs to be serialized to JSON and back.
        Data map[string]interface{}

        // This is used to publish additional artifacts, e.g. source maps.
        // We may improve this.
        OpenResourcePublisher func(relTargetPath string) (io.WriteCloser, error)
}

// AddOutPathIdentifier transforming InPath to OutPath adding an identifier,
// eg '.min' before any extension.
func (ctx *ResourceTransformationCtx) AddOutPathIdentifier(identifier string) <span class="cov8" title="1">{
        ctx.OutPath = ctx.addPathIdentifier(ctx.InPath, identifier)
}</span>

// PublishSourceMap writes the content to the target folder of the main resource
// with the ".map" extension added.
func (ctx *ResourceTransformationCtx) PublishSourceMap(content string) error <span class="cov0" title="0">{
        target := ctx.OutPath + ".map"
        f, err := ctx.OpenResourcePublisher(target)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov0" title="0">defer f.Close()
        _, err = f.Write([]byte(content))
        return err</span>
}

// ReplaceOutPathExtension transforming InPath to OutPath replacing the file
// extension, e.g. ".scss"
func (ctx *ResourceTransformationCtx) ReplaceOutPathExtension(newExt string) <span class="cov8" title="1">{
        dir, file := path.Split(ctx.InPath)
        base, _ := paths.PathAndExt(file)
        ctx.OutPath = path.Join(dir, (base + newExt))
}</span>

func (ctx *ResourceTransformationCtx) addPathIdentifier(inPath, identifier string) string <span class="cov8" title="1">{
        dir, file := path.Split(inPath)
        base, ext := paths.PathAndExt(file)
        return path.Join(dir, (base + identifier + ext))
}</span>

type publishOnce struct {
        publisherInit sync.Once
        publisherErr  error
}

type resourceAdapter struct {
        commonResource
        *resourceTransformations
        *resourceAdapterInner
}

func (r *resourceAdapter) Content() (interface{}, error) <span class="cov8" title="1">{
        r.init(false, true)
        if r.transformationsErr != nil </span><span class="cov0" title="0">{
                return nil, r.transformationsErr
        }</span>
        <span class="cov8" title="1">return r.target.Content()</span>
}

func (r *resourceAdapter) Err() error <span class="cov0" title="0">{
        return nil
}</span>

func (r *resourceAdapter) Data() interface{} <span class="cov8" title="1">{
        r.init(false, false)
        return r.target.Data()
}</span>

func (r *resourceAdapter) Fill(spec string) (resource.Image, error) <span class="cov8" title="1">{
        return r.getImageOps().Fill(spec)
}</span>

func (r *resourceAdapter) Fit(spec string) (resource.Image, error) <span class="cov8" title="1">{
        return r.getImageOps().Fit(spec)
}</span>

func (r *resourceAdapter) Filter(filters ...interface{}) (resource.Image, error) <span class="cov8" title="1">{
        return r.getImageOps().Filter(filters...)
}</span>

func (r *resourceAdapter) Height() int <span class="cov8" title="1">{
        return r.getImageOps().Height()
}</span>

func (r *resourceAdapter) Exif() *exif.Exif <span class="cov8" title="1">{
        return r.getImageOps().Exif()
}</span>

func (r *resourceAdapter) Key() string <span class="cov8" title="1">{
        r.init(false, false)
        return r.target.(resource.Identifier).Key()
}</span>

func (r *resourceAdapter) MediaType() media.Type <span class="cov8" title="1">{
        r.init(false, false)
        return r.target.MediaType()
}</span>

func (r *resourceAdapter) Name() string <span class="cov8" title="1">{
        r.init(false, false)
        return r.target.Name()
}</span>

func (r *resourceAdapter) Params() maps.Params <span class="cov0" title="0">{
        r.init(false, false)
        return r.target.Params()
}</span>

func (r *resourceAdapter) Permalink() string <span class="cov8" title="1">{
        r.init(true, false)
        return r.target.Permalink()
}</span>

func (r *resourceAdapter) Publish() error <span class="cov0" title="0">{
        r.init(false, false)

        return r.target.Publish()
}</span>

func (r *resourceAdapter) ReadSeekCloser() (hugio.ReadSeekCloser, error) <span class="cov0" title="0">{
        r.init(false, false)
        return r.target.ReadSeekCloser()
}</span>

func (r *resourceAdapter) RelPermalink() string <span class="cov8" title="1">{
        r.init(true, false)
        return r.target.RelPermalink()
}</span>

func (r *resourceAdapter) Resize(spec string) (resource.Image, error) <span class="cov8" title="1">{
        return r.getImageOps().Resize(spec)
}</span>

func (r *resourceAdapter) ResourceType() string <span class="cov8" title="1">{
        r.init(false, false)
        return r.target.ResourceType()
}</span>

func (r *resourceAdapter) String() string <span class="cov8" title="1">{
        return r.Name()
}</span>

func (r *resourceAdapter) Title() string <span class="cov0" title="0">{
        r.init(false, false)
        return r.target.Title()
}</span>

func (r resourceAdapter) Transform(t ...ResourceTransformation) (ResourceTransformer, error) <span class="cov8" title="1">{
        r.resourceTransformations = &amp;resourceTransformations{
                transformations: append(r.transformations, t...),
        }

        r.resourceAdapterInner = &amp;resourceAdapterInner{
                spec:        r.spec,
                publishOnce: &amp;publishOnce{},
                target:      r.target,
        }

        return &amp;r, nil
}</span>

func (r *resourceAdapter) Width() int <span class="cov8" title="1">{
        return r.getImageOps().Width()
}</span>

func (r *resourceAdapter) DecodeImage() (image.Image, error) <span class="cov8" title="1">{
        return r.getImageOps().DecodeImage()
}</span>

func (r *resourceAdapter) getImageOps() resource.ImageOps <span class="cov8" title="1">{
        img, ok := r.target.(resource.ImageOps)
        if !ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("%T is not an image", r.target))</span>
        }
        <span class="cov8" title="1">r.init(false, false)
        return img</span>
}

func (r *resourceAdapter) getMetaAssigner() metaAssigner <span class="cov8" title="1">{
        return r.target
}</span>

func (r *resourceAdapter) getSpec() *Spec <span class="cov8" title="1">{
        return r.spec
}</span>

func (r *resourceAdapter) publish() <span class="cov8" title="1">{
        if r.publishOnce == nil </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">r.publisherInit.Do(func() </span><span class="cov8" title="1">{
                r.publisherErr = r.target.Publish()

                if r.publisherErr != nil </span><span class="cov0" title="0">{
                        r.spec.Logger.Errorf("Failed to publish Resource: %s", r.publisherErr)
                }</span>
        })
}

func (r *resourceAdapter) TransformationKey() string <span class="cov8" title="1">{
        // Files with a suffix will be stored in cache (both on disk and in memory)
        // partitioned by their suffix.
        var key string
        for _, tr := range r.transformations </span><span class="cov8" title="1">{
                key = key + "_" + tr.Key().Value()
        }</span>

        <span class="cov8" title="1">base := ResourceCacheKey(r.target.Key())
        return r.spec.ResourceCache.cleanKey(base) + "_" + helpers.MD5String(key)</span>
}

func (r *resourceAdapter) transform(publish, setContent bool) error <span class="cov8" title="1">{
        cache := r.spec.ResourceCache

        key := r.TransformationKey()

        cached, found := cache.get(key)

        if found </span><span class="cov8" title="1">{
                r.resourceAdapterInner = cached.(*resourceAdapterInner)
                return nil
        }</span>

        // Acquire a write lock for the named transformation.
        <span class="cov8" title="1">cache.nlocker.Lock(key)
        // Check the cache again.
        cached, found = cache.get(key)
        if found </span><span class="cov8" title="1">{
                r.resourceAdapterInner = cached.(*resourceAdapterInner)
                cache.nlocker.Unlock(key)
                return nil
        }</span>

        <span class="cov8" title="1">defer cache.nlocker.Unlock(key)
        defer cache.set(key, r.resourceAdapterInner)

        b1 := bp.GetBuffer()
        b2 := bp.GetBuffer()
        defer bp.PutBuffer(b1)
        defer bp.PutBuffer(b2)

        tctx := &amp;ResourceTransformationCtx{
                Data:                  make(map[string]interface{}),
                OpenResourcePublisher: r.target.openPublishFileForWriting,
        }

        tctx.InMediaType = r.target.MediaType()
        tctx.OutMediaType = r.target.MediaType()

        startCtx := *tctx
        updates := &amp;transformationUpdate{startCtx: startCtx}

        var contentrc hugio.ReadSeekCloser

        contentrc, err := contentReadSeekerCloser(r.target)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">defer contentrc.Close()

        tctx.From = contentrc
        tctx.To = b1

        tctx.InPath = r.target.TargetPath()
        tctx.SourcePath = tctx.InPath

        counter := 0
        writeToFileCache := false

        var transformedContentr io.Reader

        for i, tr := range r.transformations </span><span class="cov8" title="1">{
                if i != 0 </span><span class="cov8" title="1">{
                        tctx.InMediaType = tctx.OutMediaType
                }</span>

                <span class="cov8" title="1">mayBeCachedOnDisk := transformationsToCacheOnDisk[tr.Key().Name]
                if !writeToFileCache </span><span class="cov8" title="1">{
                        writeToFileCache = mayBeCachedOnDisk
                }</span>

                <span class="cov8" title="1">if i &gt; 0 </span><span class="cov8" title="1">{
                        hasWrites := tctx.To.(*bytes.Buffer).Len() &gt; 0
                        if hasWrites </span><span class="cov8" title="1">{
                                counter++
                                // Switch the buffers
                                if counter%2 == 0 </span><span class="cov8" title="1">{
                                        tctx.From = b2
                                        b1.Reset()
                                        tctx.To = b1
                                }</span> else<span class="cov8" title="1"> {
                                        tctx.From = b1
                                        b2.Reset()
                                        tctx.To = b2
                                }</span>
                        }
                }

                <span class="cov8" title="1">newErr := func(err error) error </span><span class="cov0" title="0">{
                        msg := fmt.Sprintf("%s: failed to transform %q (%s)", strings.ToUpper(tr.Key().Name), tctx.InPath, tctx.InMediaType.Type())

                        if err == herrors.ErrFeatureNotAvailable </span><span class="cov0" title="0">{
                                var errMsg string
                                if tr.Key().Name == "postcss" </span><span class="cov0" title="0">{
                                        // This transformation is not available in this
                                        // Most likely because PostCSS is not installed.
                                        errMsg = ". Check your PostCSS installation; install with \"npm install postcss-cli\". See https://gohugo.io/hugo-pipes/postcss/"
                                }</span> else<span class="cov0" title="0"> if tr.Key().Name == "tocss" </span><span class="cov0" title="0">{
                                        errMsg = ". Check your Hugo installation; you need the extended version to build SCSS/SASS."
                                }</span> else<span class="cov0" title="0"> if tr.Key().Name == "tocss-dart" </span><span class="cov0" title="0">{
                                        errMsg = ". You need dart-sass-embedded in your system $PATH."

                                }</span> else<span class="cov0" title="0"> if tr.Key().Name == "babel" </span><span class="cov0" title="0">{
                                        errMsg = ". You need to install Babel, see https://gohugo.io/hugo-pipes/babel/"
                                }</span>

                                <span class="cov0" title="0">return errors.Wrap(err, msg+errMsg)</span>
                        }

                        <span class="cov0" title="0">return errors.Wrap(err, msg)</span>
                }

                <span class="cov8" title="1">var tryFileCache bool

                if mayBeCachedOnDisk &amp;&amp; r.spec.BuildConfig.UseResourceCache(nil) </span><span class="cov0" title="0">{
                        tryFileCache = true
                }</span> else<span class="cov8" title="1"> {
                        err = tr.Transform(tctx)
                        if err != nil &amp;&amp; err != herrors.ErrFeatureNotAvailable </span><span class="cov0" title="0">{
                                return newErr(err)
                        }</span>

                        <span class="cov8" title="1">if mayBeCachedOnDisk </span><span class="cov8" title="1">{
                                tryFileCache = r.spec.BuildConfig.UseResourceCache(err)
                        }</span>
                        <span class="cov8" title="1">if err != nil &amp;&amp; !tryFileCache </span><span class="cov0" title="0">{
                                return newErr(err)
                        }</span>
                }

                <span class="cov8" title="1">if tryFileCache </span><span class="cov8" title="1">{
                        f := r.target.tryTransformedFileCache(key, updates)
                        if f == nil </span><span class="cov0" title="0">{
                                if err != nil </span><span class="cov0" title="0">{
                                        return newErr(err)
                                }</span>
                                <span class="cov0" title="0">return newErr(errors.Errorf("resource %q not found in file cache", key))</span>
                        }
                        <span class="cov8" title="1">transformedContentr = f
                        updates.sourceFs = cache.fileCache.Fs
                        defer f.Close()

                        // The reader above is all we need.
                        break</span>
                }

                <span class="cov8" title="1">if tctx.OutPath != "" </span><span class="cov8" title="1">{
                        tctx.InPath = tctx.OutPath
                        tctx.OutPath = ""
                }</span>
        }

        <span class="cov8" title="1">if transformedContentr == nil </span><span class="cov8" title="1">{
                updates.updateFromCtx(tctx)
        }</span>

        <span class="cov8" title="1">var publishwriters []io.WriteCloser

        if publish </span><span class="cov8" title="1">{
                publicw, err := r.target.openPublishFileForWriting(updates.targetPath)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">publishwriters = append(publishwriters, publicw)</span>
        }

        <span class="cov8" title="1">if transformedContentr == nil </span><span class="cov8" title="1">{
                if writeToFileCache </span><span class="cov8" title="1">{
                        // Also write it to the cache
                        fi, metaw, err := cache.writeMeta(key, updates.toTransformedResourceMetadata())
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                        <span class="cov8" title="1">updates.sourceFilename = &amp;fi.Name
                        updates.sourceFs = cache.fileCache.Fs
                        publishwriters = append(publishwriters, metaw)</span>
                }

                // Any transformations reading from From must also write to To.
                // This means that if the target buffer is empty, we can just reuse
                // the original reader.
                <span class="cov8" title="1">if b, ok := tctx.To.(*bytes.Buffer); ok &amp;&amp; b.Len() &gt; 0 </span><span class="cov8" title="1">{
                        transformedContentr = tctx.To.(*bytes.Buffer)
                }</span> else<span class="cov8" title="1"> {
                        transformedContentr = contentrc
                }</span>
        }

        // Also write it to memory
        <span class="cov8" title="1">var contentmemw *bytes.Buffer

        setContent = setContent || !writeToFileCache

        if setContent </span><span class="cov8" title="1">{
                contentmemw = bp.GetBuffer()
                defer bp.PutBuffer(contentmemw)
                publishwriters = append(publishwriters, hugio.ToWriteCloser(contentmemw))
        }</span>

        <span class="cov8" title="1">publishw := hugio.NewMultiWriteCloser(publishwriters...)
        _, err = io.Copy(publishw, transformedContentr)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">publishw.Close()

        if setContent </span><span class="cov8" title="1">{
                s := contentmemw.String()
                updates.content = &amp;s
        }</span>

        <span class="cov8" title="1">newTarget, err := r.target.cloneWithUpdates(updates)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">r.target = newTarget

        return nil</span>
}

func (r *resourceAdapter) init(publish, setContent bool) <span class="cov8" title="1">{
        r.initTransform(publish, setContent)
}</span>

func (r *resourceAdapter) initTransform(publish, setContent bool) <span class="cov8" title="1">{
        r.transformationsInit.Do(func() </span><span class="cov8" title="1">{
                if len(r.transformations) == 0 </span><span class="cov8" title="1">{
                        // Nothing to do.
                        return
                }</span>

                <span class="cov8" title="1">if publish </span><span class="cov8" title="1">{
                        // The transformation will write the content directly to
                        // the destination.
                        r.publishOnce = nil
                }</span>

                <span class="cov8" title="1">r.transformationsErr = r.transform(publish, setContent)
                if r.transformationsErr != nil </span><span class="cov0" title="0">{
                        if r.spec.ErrorSender != nil </span><span class="cov0" title="0">{
                                r.spec.ErrorSender.SendError(r.transformationsErr)
                        }</span> else<span class="cov0" title="0"> {
                                r.spec.Logger.Errorf("Transformation failed: %s", r.transformationsErr)
                        }</span>
                }
        })

        <span class="cov8" title="1">if publish &amp;&amp; r.publishOnce != nil </span><span class="cov8" title="1">{
                r.publish()
        }</span>
}

type resourceAdapterInner struct {
        target transformableResource

        spec *Spec

        // Handles publishing (to /public) if needed.
        *publishOnce
}

type resourceTransformations struct {
        transformationsInit sync.Once
        transformationsErr  error
        transformations     []ResourceTransformation
}

type transformableResource interface {
        baseResourceInternal

        resource.ContentProvider
        resource.Resource
        resource.Identifier
}

type transformationUpdate struct {
        content        *string
        sourceFilename *string
        sourceFs       afero.Fs
        targetPath     string
        mediaType      media.Type
        data           map[string]interface{}

        startCtx ResourceTransformationCtx
}

func (u *transformationUpdate) isContentChanged() bool <span class="cov8" title="1">{
        return u.content != nil || u.sourceFilename != nil
}</span>

func (u *transformationUpdate) toTransformedResourceMetadata() transformedResourceMetadata <span class="cov8" title="1">{
        return transformedResourceMetadata{
                MediaTypeV: u.mediaType.Type(),
                Target:     u.targetPath,
                MetaData:   u.data,
        }
}</span>

func (u *transformationUpdate) updateFromCtx(ctx *ResourceTransformationCtx) <span class="cov8" title="1">{
        u.targetPath = ctx.OutPath
        u.mediaType = ctx.OutMediaType
        u.data = ctx.Data
        u.targetPath = ctx.InPath
}</span>

// We will persist this information to disk.
type transformedResourceMetadata struct {
        Target     string                 `json:"Target"`
        MediaTypeV string                 `json:"MediaType"`
        MetaData   map[string]interface{} `json:"Data"`
}

// contentReadSeekerCloser returns a ReadSeekerCloser if possible for a given Resource.
func contentReadSeekerCloser(r resource.Resource) (hugio.ReadSeekCloser, error) <span class="cov8" title="1">{
        switch rr := r.(type) </span>{
        case resource.ReadSeekCloserResource:<span class="cov8" title="1">
                rc, err := rr.ReadSeekCloser()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">return rc, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("cannot transform content of Resource of type %T", r)</span>

        }
}
</pre>
		
		<pre class="file" id="file262" style="display: none">// Copyright 2021 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package source

import (
        "path/filepath"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/common/paths"

        "github.com/gohugoio/hugo/hugofs/files"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/common/hugio"

        "github.com/gohugoio/hugo/hugofs"

        "github.com/gohugoio/hugo/helpers"
)

// fileInfo implements the File interface.
var (
        _ File = (*FileInfo)(nil)
)

// File represents a source file.
// This is a temporary construct until we resolve page.Page conflicts.
// TODO(bep) remove this construct once we have resolved page deprecations
type File interface {
        fileOverlap
        FileWithoutOverlap
}

// Temporary to solve duplicate/deprecated names in page.Page
type fileOverlap interface {
        // Path gets the relative path including file name and extension.
        // The directory is relative to the content root.
        Path() string

        // Section is first directory below the content root.
        // For page bundles in root, the Section will be empty.
        Section() string

        // Lang is the language code for this page. It will be the
        // same as the site's language code.
        Lang() string

        IsZero() bool
}

type FileWithoutOverlap interface {

        // Filename gets the full path and filename to the file.
        Filename() string

        // Dir gets the name of the directory that contains this file.
        // The directory is relative to the content root.
        Dir() string

        // Extension gets the file extension, i.e "myblogpost.md" will return "md".
        Extension() string

        // Ext is an alias for Extension.
        Ext() string // Hmm... Deprecate Extension

        // LogicalName is filename and extension of the file.
        LogicalName() string

        // BaseFileName is a filename without extension.
        BaseFileName() string

        // TranslationBaseName is a filename with no extension,
        // not even the optional language extension part.
        TranslationBaseName() string

        // ContentBaseName is a either TranslationBaseName or name of containing folder
        // if file is a leaf bundle.
        ContentBaseName() string

        // UniqueID is the MD5 hash of the file's path and is for most practical applications,
        // Hugo content files being one of them, considered to be unique.
        UniqueID() string

        FileInfo() hugofs.FileMetaInfo
}

// FileInfo describes a source file.
type FileInfo struct {

        // Absolute filename to the file on disk.
        filename string

        sp *SourceSpec

        fi hugofs.FileMetaInfo

        // Derived from filename
        ext  string // Extension without any "."
        lang string

        name string

        dir                 string
        relDir              string
        relPath             string
        baseName            string
        translationBaseName string
        contentBaseName     string
        section             string
        classifier          files.ContentClass

        uniqueID string

        lazyInit sync.Once
}

// Filename returns a file's absolute path and filename on disk.
func (fi *FileInfo) Filename() string <span class="cov8" title="1">{ return fi.filename }</span>

// Path gets the relative path including file name and extension.  The directory
// is relative to the content root.
func (fi *FileInfo) Path() string <span class="cov8" title="1">{ return fi.relPath }</span>

// Dir gets the name of the directory that contains this file.  The directory is
// relative to the content root.
func (fi *FileInfo) Dir() string <span class="cov8" title="1">{ return fi.relDir }</span>

// Extension is an alias to Ext().
func (fi *FileInfo) Extension() string <span class="cov0" title="0">{ return fi.Ext() }</span>

// Ext returns a file's extension without the leading period (ie. "md").
func (fi *FileInfo) Ext() string <span class="cov0" title="0">{ return fi.ext }</span>

// Lang returns a file's language (ie. "sv").
func (fi *FileInfo) Lang() string <span class="cov0" title="0">{ return fi.lang }</span>

// LogicalName returns a file's name and extension (ie. "page.sv.md").
func (fi *FileInfo) LogicalName() string <span class="cov0" title="0">{ return fi.name }</span>

// BaseFileName returns a file's name without extension (ie. "page.sv").
func (fi *FileInfo) BaseFileName() string <span class="cov8" title="1">{ return fi.baseName }</span>

// TranslationBaseName returns a file's translation base name without the
// language segment (ie. "page").
func (fi *FileInfo) TranslationBaseName() string <span class="cov8" title="1">{ return fi.translationBaseName }</span>

// ContentBaseName is a either TranslationBaseName or name of containing folder
// if file is a leaf bundle.
func (fi *FileInfo) ContentBaseName() string <span class="cov0" title="0">{
        fi.init()
        return fi.contentBaseName
}</span>

// Section returns a file's section.
func (fi *FileInfo) Section() string <span class="cov8" title="1">{
        fi.init()
        return fi.section
}</span>

// UniqueID returns a file's unique, MD5 hash identifier.
func (fi *FileInfo) UniqueID() string <span class="cov0" title="0">{
        fi.init()
        return fi.uniqueID
}</span>

// FileInfo returns a file's underlying os.FileInfo.
func (fi *FileInfo) FileInfo() hugofs.FileMetaInfo <span class="cov0" title="0">{ return fi.fi }</span>

func (fi *FileInfo) String() string <span class="cov0" title="0">{ return fi.BaseFileName() }</span>

// Open implements ReadableFile.
func (fi *FileInfo) Open() (hugio.ReadSeekCloser, error) <span class="cov0" title="0">{
        f, err := fi.fi.Meta().Open()

        return f, err
}</span>

func (fi *FileInfo) IsZero() bool <span class="cov0" title="0">{
        return fi == nil
}</span>

// We create a lot of these FileInfo objects, but there are parts of it used only
// in some cases that is slightly expensive to construct.
func (fi *FileInfo) init() <span class="cov8" title="1">{
        fi.lazyInit.Do(func() </span><span class="cov8" title="1">{
                relDir := strings.Trim(fi.relDir, helpers.FilePathSeparator)
                parts := strings.Split(relDir, helpers.FilePathSeparator)
                var section string
                if (fi.classifier != files.ContentClassLeaf &amp;&amp; len(parts) == 1) || len(parts) &gt; 1 </span><span class="cov8" title="1">{
                        section = parts[0]
                }</span>
                <span class="cov8" title="1">fi.section = section

                if fi.classifier.IsBundle() &amp;&amp; len(parts) &gt; 0 </span><span class="cov0" title="0">{
                        fi.contentBaseName = parts[len(parts)-1]
                }</span> else<span class="cov8" title="1"> {
                        fi.contentBaseName = fi.translationBaseName
                }</span>

                <span class="cov8" title="1">fi.uniqueID = helpers.MD5String(filepath.ToSlash(fi.relPath))</span>
        })
}

// NewTestFile creates a partially filled File used in unit tests.
// TODO(bep) improve this package
func NewTestFile(filename string) *FileInfo <span class="cov0" title="0">{
        base := filepath.Base(filepath.Dir(filename))
        return &amp;FileInfo{
                filename:            filename,
                translationBaseName: base,
        }
}</span>

func (sp *SourceSpec) NewFileInfoFrom(path, filename string) (*FileInfo, error) <span class="cov8" title="1">{
        meta := &amp;hugofs.FileMeta{
                Filename: filename,
                Path:     path,
        }

        return sp.NewFileInfo(hugofs.NewFileMetaInfo(nil, meta))
}</span>

func (sp *SourceSpec) NewFileInfo(fi hugofs.FileMetaInfo) (*FileInfo, error) <span class="cov8" title="1">{
        m := fi.Meta()

        filename := m.Filename
        relPath := m.Path

        if relPath == "" </span><span class="cov0" title="0">{
                return nil, errors.Errorf("no Path provided by %v (%T)", m, m.Fs)
        }</span>

        <span class="cov8" title="1">if filename == "" </span><span class="cov0" title="0">{
                return nil, errors.Errorf("no Filename provided by %v (%T)", m, m.Fs)
        }</span>

        <span class="cov8" title="1">relDir := filepath.Dir(relPath)
        if relDir == "." </span><span class="cov0" title="0">{
                relDir = ""
        }</span>
        <span class="cov8" title="1">if !strings.HasSuffix(relDir, helpers.FilePathSeparator) </span><span class="cov8" title="1">{
                relDir = relDir + helpers.FilePathSeparator
        }</span>

        <span class="cov8" title="1">lang := m.Lang
        translationBaseName := m.TranslationBaseName

        dir, name := filepath.Split(relPath)
        if !strings.HasSuffix(dir, helpers.FilePathSeparator) </span><span class="cov0" title="0">{
                dir = dir + helpers.FilePathSeparator
        }</span>

        <span class="cov8" title="1">ext := strings.ToLower(strings.TrimPrefix(filepath.Ext(name), "."))
        baseName := paths.Filename(name)

        if translationBaseName == "" </span><span class="cov8" title="1">{
                // This is usually provided by the filesystem. But this FileInfo is also
                // created in a standalone context when doing "hugo new". This is
                // an approximate implementation, which is "good enough" in that case.
                fileLangExt := filepath.Ext(baseName)
                translationBaseName = strings.TrimSuffix(baseName, fileLangExt)
        }</span>

        <span class="cov8" title="1">f := &amp;FileInfo{
                sp:                  sp,
                filename:            filename,
                fi:                  fi,
                lang:                lang,
                ext:                 ext,
                dir:                 dir,
                relDir:              relDir,  // Dir()
                relPath:             relPath, // Path()
                name:                name,
                baseName:            baseName, // BaseFileName()
                translationBaseName: translationBaseName,
                classifier:          m.Classifier,
        }

        return f, nil</span>
}
</pre>
		
		<pre class="file" id="file263" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package source

import (
        "path/filepath"
        "sync"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/hugofs"
)

// Filesystem represents a source filesystem.
type Filesystem struct {
        files        []File
        filesInit    sync.Once
        filesInitErr error

        Base string

        fi hugofs.FileMetaInfo

        SourceSpec
}

// NewFilesystem returns a new filesytem for a given source spec.
func (sp SourceSpec) NewFilesystem(base string) *Filesystem <span class="cov8" title="1">{
        return &amp;Filesystem{SourceSpec: sp, Base: base}
}</span>

func (sp SourceSpec) NewFilesystemFromFileMetaInfo(fi hugofs.FileMetaInfo) *Filesystem <span class="cov0" title="0">{
        return &amp;Filesystem{SourceSpec: sp, fi: fi}
}</span>

// Files returns a slice of readable files.
func (f *Filesystem) Files() ([]File, error) <span class="cov8" title="1">{
        f.filesInit.Do(func() </span><span class="cov8" title="1">{
                err := f.captureFiles()
                if err != nil </span><span class="cov0" title="0">{
                        f.filesInitErr = errors.Wrap(err, "capture files")
                }</span>
        })
        <span class="cov8" title="1">return f.files, f.filesInitErr</span>
}

// add populates a file in the Filesystem.files
func (f *Filesystem) add(name string, fi hugofs.FileMetaInfo) (err error) <span class="cov0" title="0">{
        var file File

        file, err = f.SourceSpec.NewFileInfo(fi)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">f.files = append(f.files, file)

        return err</span>
}

func (f *Filesystem) captureFiles() error <span class="cov8" title="1">{
        walker := func(path string, fi hugofs.FileMetaInfo, err error) error </span><span class="cov8" title="1">{
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if fi.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov0" title="0">meta := fi.Meta()
                filename := meta.Filename

                b, err := f.shouldRead(filename, fi)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if b </span><span class="cov0" title="0">{
                        err = f.add(filename, fi)
                }</span>

                <span class="cov0" title="0">return err</span>
        }

        <span class="cov8" title="1">w := hugofs.NewWalkway(hugofs.WalkwayConfig{
                Fs:     f.SourceFs,
                Info:   f.fi,
                Root:   f.Base,
                WalkFn: walker,
        })

        return w.Walk()</span>
}

func (f *Filesystem) shouldRead(filename string, fi hugofs.FileMetaInfo) (bool, error) <span class="cov0" title="0">{
        ignore := f.SourceSpec.IgnoreFile(fi.Meta().Filename)

        if fi.IsDir() </span><span class="cov0" title="0">{
                if ignore </span><span class="cov0" title="0">{
                        return false, filepath.SkipDir
                }</span>
                <span class="cov0" title="0">return false, nil</span>
        }

        <span class="cov0" title="0">if ignore </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file264" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package source

import (
        "os"
        "path/filepath"
        "regexp"
        "runtime"

        "github.com/gohugoio/hugo/hugofs/glob"

        "github.com/gohugoio/hugo/langs"
        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/cast"
)

// SourceSpec abstracts language-specific file creation.
// TODO(bep) rename to Spec
type SourceSpec struct {
        *helpers.PathSpec

        SourceFs afero.Fs

        shouldInclude func(filename string) bool

        Languages              map[string]interface{}
        DefaultContentLanguage string
        DisabledLanguages      map[string]bool
}

// NewSourceSpec initializes SourceSpec using languages the given filesystem and PathSpec.
func NewSourceSpec(ps *helpers.PathSpec, inclusionFilter *glob.FilenameFilter, fs afero.Fs) *SourceSpec <span class="cov8" title="1">{
        cfg := ps.Cfg
        defaultLang := cfg.GetString("defaultContentLanguage")
        languages := cfg.GetStringMap("languages")

        disabledLangsSet := make(map[string]bool)

        for _, disabledLang := range cfg.GetStringSlice("disableLanguages") </span><span class="cov0" title="0">{
                disabledLangsSet[disabledLang] = true
        }</span>

        <span class="cov8" title="1">if len(languages) == 0 </span><span class="cov8" title="1">{
                l := langs.NewDefaultLanguage(cfg)
                languages[l.Lang] = l
                defaultLang = l.Lang
        }</span>

        <span class="cov8" title="1">ignoreFiles := cast.ToStringSlice(cfg.Get("ignoreFiles"))
        var regexps []*regexp.Regexp
        if len(ignoreFiles) &gt; 0 </span><span class="cov8" title="1">{
                for _, ignorePattern := range ignoreFiles </span><span class="cov8" title="1">{
                        re, err := regexp.Compile(ignorePattern)
                        if err != nil </span><span class="cov8" title="1">{
                                helpers.DistinctErrorLog.Printf("Invalid regexp %q in ignoreFiles: %s", ignorePattern, err)
                        }</span> else<span class="cov8" title="1"> {
                                regexps = append(regexps, re)
                        }</span>

                }
        }
        <span class="cov8" title="1">shouldInclude := func(filename string) bool </span><span class="cov8" title="1">{
                if !inclusionFilter.Match(filename, false) </span><span class="cov0" title="0">{
                        return false
                }</span>
                <span class="cov8" title="1">for _, r := range regexps </span><span class="cov8" title="1">{
                        if r.MatchString(filename) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        }

        <span class="cov8" title="1">return &amp;SourceSpec{shouldInclude: shouldInclude, PathSpec: ps, SourceFs: fs, Languages: languages, DefaultContentLanguage: defaultLang, DisabledLanguages: disabledLangsSet}</span>
}

// IgnoreFile returns whether a given file should be ignored.
func (s *SourceSpec) IgnoreFile(filename string) bool <span class="cov8" title="1">{
        if filename == "" </span><span class="cov0" title="0">{
                if _, ok := s.SourceFs.(*afero.OsFs); ok </span><span class="cov0" title="0">{
                        return true
                }</span>
                <span class="cov0" title="0">return false</span>
        }

        <span class="cov8" title="1">base := filepath.Base(filename)

        if len(base) &gt; 0 </span><span class="cov8" title="1">{
                first := base[0]
                last := base[len(base)-1]
                if first == '.' ||
                        first == '#' ||
                        last == '~' </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">if !s.shouldInclude(filename) </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if runtime.GOOS == "windows" </span><span class="cov0" title="0">{
                // Also check the forward slash variant if different.
                unixFilename := filepath.ToSlash(filename)
                if unixFilename != filename </span><span class="cov0" title="0">{
                        if !s.shouldInclude(unixFilename) </span><span class="cov0" title="0">{
                                return true
                        }</span>
                }
        }

        <span class="cov8" title="1">return false</span>
}

// IsRegularSourceFile returns whether filename represents a regular file in the
// source filesystem.
func (s *SourceSpec) IsRegularSourceFile(filename string) (bool, error) <span class="cov0" title="0">{
        fi, err := helpers.LstatIfPossible(s.SourceFs, filename)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                return false, nil
        }</span>

        <span class="cov0" title="0">if fi.Mode()&amp;os.ModeSymlink == os.ModeSymlink </span><span class="cov0" title="0">{
                link, err := filepath.EvalSymlinks(filename)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">fi, err = helpers.LstatIfPossible(s.SourceFs, link)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov0" title="0">if fi.IsDir() </span><span class="cov0" title="0">{
                        return false, nil
                }</span>
        }

        <span class="cov0" title="0">return true, nil</span>
}
</pre>
		
		<pre class="file" id="file265" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package cast provides template functions for data type conversions.
package cast

import (
        "html/template"

        _cast "github.com/spf13/cast"
)

// New returns a new instance of the cast-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "cast" namespace.
type Namespace struct {
}

// ToInt converts the given value to an int.
func (ns *Namespace) ToInt(v interface{}) (int, error) <span class="cov8" title="1">{
        v = convertTemplateToString(v)
        return _cast.ToIntE(v)
}</span>

// ToString converts the given value to a string.
func (ns *Namespace) ToString(v interface{}) (string, error) <span class="cov8" title="1">{
        return _cast.ToStringE(v)
}</span>

// ToFloat converts the given value to a float.
func (ns *Namespace) ToFloat(v interface{}) (float64, error) <span class="cov8" title="1">{
        v = convertTemplateToString(v)
        return _cast.ToFloat64E(v)
}</span>

func convertTemplateToString(v interface{}) interface{} <span class="cov8" title="1">{
        switch vv := v.(type) </span>{
        case template.HTML:<span class="cov8" title="1">
                v = string(vv)</span>
        case template.CSS:<span class="cov8" title="1">
                v = string(vv)</span>
        case template.HTMLAttr:<span class="cov8" title="1">
                v = string(vv)</span>
        case template.JS:<span class="cov8" title="1">
                v = string(vv)</span>
        case template.JSStr:<span class="cov8" title="1">
                v = string(vv)</span>
        }
        <span class="cov8" title="1">return v</span>
}
</pre>
		
		<pre class="file" id="file266" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cast

import (
        "github.com/gohugoio/hugo/common/loggers"
        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/docshelper"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/resources/page"
        "github.com/gohugoio/hugo/tpl/internal"
)

// This file provides documentation support and is randomly put into this package.
func init() <span class="cov8" title="1">{
        docsProvider := func() docshelper.DocProvider </span><span class="cov0" title="0">{
                cfg := config.New()
                d := &amp;deps.Deps{
                        Cfg:                 cfg,
                        Log:                 loggers.NewErrorLogger(),
                        BuildStartListeners: &amp;deps.Listeners{},
                        Language:            langs.NewDefaultLanguage(cfg),
                        Site:                page.NewDummyHugoSite(newTestConfig()),
                }

                var namespaces internal.TemplateFuncsNamespaces

                for _, nsf := range internal.TemplateFuncsNamespaceRegistry </span><span class="cov0" title="0">{
                        nf := nsf(d)
                        namespaces = append(namespaces, nf)

                }</span>

                <span class="cov0" title="0">return docshelper.DocProvider{"tpl": map[string]interface{}{"funcs": namespaces}}</span>
        }

        <span class="cov8" title="1">docshelper.AddDocProviderFunc(docsProvider)</span>
}

func newTestConfig() config.Provider <span class="cov0" title="0">{
        v := config.New()
        v.Set("contentDir", "content")
        return v
}</span>
</pre>
		
		<pre class="file" id="file267" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cast

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "cast"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.ToInt,
                        []string{"int"},
                        [][2]string{
                                {`{{ "1234" | int | printf "%T" }}`, `int`},
                        },
                )

                ns.AddMethodMapping(ctx.ToString,
                        []string{"string"},
                        [][2]string{
                                {`{{ 1234 | string | printf "%T" }}`, `string`},
                        },
                )

                ns.AddMethodMapping(ctx.ToFloat,
                        []string{"float"},
                        [][2]string{
                                {`{{ "1234" | float | printf "%T" }}`, `float64`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file268" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "errors"

        "github.com/gohugoio/hugo/common/collections"
)

// Append appends the arguments up to the last one to the slice in the last argument.
// This construct allows template constructs like this:
//     {{ $pages = $pages | append $p2 $p1 }}
// Note that with 2 arguments where both are slices of the same type,
// the first slice will be appended to the second:
//     {{ $pages = $pages | append .Site.RegularPages }}
func (ns *Namespace) Append(args ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(args) &lt; 2 </span><span class="cov8" title="1">{
                return nil, errors.New("need at least 2 arguments to append")
        }</span>

        <span class="cov8" title="1">to := args[len(args)-1]
        from := args[:len(args)-1]

        return collections.Append(to, from...)</span>
}
</pre>
		
		<pre class="file" id="file269" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "errors"
        "fmt"
        "reflect"
        "strings"

        "github.com/gohugoio/hugo/tpl"
)

// Apply takes a map, array, or slice and returns a new slice with the function fname applied over it.
func (ns *Namespace) Apply(seq interface{}, fname string, args ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        if seq == nil </span><span class="cov0" title="0">{
                return make([]interface{}, 0), nil
        }</span>

        <span class="cov8" title="1">if fname == "apply" </span><span class="cov8" title="1">{
                return nil, errors.New("can't apply myself (no turtles allowed)")
        }</span>

        <span class="cov8" title="1">seqv := reflect.ValueOf(seq)
        seqv, isNil := indirect(seqv)
        if isNil </span><span class="cov8" title="1">{
                return nil, errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov8" title="1">fnv, found := ns.lookupFunc(fname)
        if !found </span><span class="cov8" title="1">{
                return nil, errors.New("can't find function " + fname)
        }</span>

        // fnv := reflect.ValueOf(fn)

        <span class="cov8" title="1">switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                r := make([]interface{}, seqv.Len())
                for i := 0; i &lt; seqv.Len(); i++ </span><span class="cov8" title="1">{
                        vv := seqv.Index(i)

                        vvv, err := applyFnToThis(fnv, vv, args...)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">r[i] = vvv.Interface()</span>
                }

                <span class="cov8" title="1">return r, nil</span>
        default:<span class="cov0" title="0">
                return nil, fmt.Errorf("can't apply over %v", seq)</span>
        }
}

func applyFnToThis(fn, this reflect.Value, args ...interface{}) (reflect.Value, error) <span class="cov8" title="1">{
        n := make([]reflect.Value, len(args))
        for i, arg := range args </span><span class="cov8" title="1">{
                if arg == "." </span><span class="cov0" title="0">{
                        n[i] = this
                }</span> else<span class="cov8" title="1"> {
                        n[i] = reflect.ValueOf(arg)
                }</span>
        }

        <span class="cov8" title="1">num := fn.Type().NumIn()

        if fn.Type().IsVariadic() </span><span class="cov8" title="1">{
                num--
        }</span>

        // TODO(bep) see #1098 - also see template_tests.go
        /*if len(args) &lt; num {
                return reflect.ValueOf(nil), errors.New("Too few arguments")
        } else if len(args) &gt; num {
                return reflect.ValueOf(nil), errors.New("Too many arguments")
        }*/

        <span class="cov8" title="1">for i := 0; i &lt; num; i++ </span><span class="cov0" title="0">{
                // AssignableTo reports whether xt is assignable to type targ.
                if xt, targ := n[i].Type(), fn.Type().In(i); !xt.AssignableTo(targ) </span><span class="cov0" title="0">{
                        return reflect.ValueOf(nil), errors.New("called apply using " + xt.String() + " as type " + targ.String())
                }</span>
        }

        <span class="cov8" title="1">res := fn.Call(n)

        if len(res) == 1 || res[1].IsNil() </span><span class="cov8" title="1">{
                return res[0], nil
        }</span>
        <span class="cov0" title="0">return reflect.ValueOf(nil), res[1].Interface().(error)</span>
}

func (ns *Namespace) lookupFunc(fname string) (reflect.Value, bool) <span class="cov8" title="1">{
        if !strings.ContainsRune(fname, '.') </span><span class="cov8" title="1">{
                templ := ns.deps.Tmpl().(tpl.TemplateFuncGetter)
                return templ.GetFunc(fname)
        }</span>

        <span class="cov8" title="1">ss := strings.SplitN(fname, ".", 2)

        // Namespace
        nv, found := ns.lookupFunc(ss[0])
        if !found </span><span class="cov0" title="0">{
                return reflect.Value{}, false
        }</span>

        <span class="cov8" title="1">fn, ok := nv.Interface().(func(...interface{}) (interface{}, error))
        if !ok </span><span class="cov8" title="1">{
                return reflect.Value{}, false
        }</span>
        <span class="cov0" title="0">v, err := fn()
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov0" title="0">nv = reflect.ValueOf(v)

        // method
        m := nv.MethodByName(ss[1])

        if m.Kind() == reflect.Invalid </span><span class="cov0" title="0">{
                return reflect.Value{}, false
        }</span>
        <span class="cov0" title="0">return m, true</span>
}

// indirect is borrowed from the Go stdlib: 'text/template/exec.go'
func indirect(v reflect.Value) (rv reflect.Value, isNil bool) <span class="cov8" title="1">{
        for ; v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface; v = v.Elem() </span><span class="cov8" title="1">{
                if v.IsNil() </span><span class="cov8" title="1">{
                        return v, true
                }</span>
                <span class="cov8" title="1">if v.Kind() == reflect.Interface &amp;&amp; v.NumMethod() &gt; 0 </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return v, false</span>
}

func indirectInterface(v reflect.Value) (rv reflect.Value, isNil bool) <span class="cov8" title="1">{
        for ; v.Kind() == reflect.Interface; v = v.Elem() </span><span class="cov8" title="1">{
                if v.IsNil() </span><span class="cov8" title="1">{
                        return v, true
                }</span>
                <span class="cov8" title="1">if v.Kind() == reflect.Interface &amp;&amp; v.NumMethod() &gt; 0 </span><span class="cov0" title="0">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return v, false</span>
}
</pre>
		
		<pre class="file" id="file270" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package collections provides template functions for manipulating collections
// such as arrays, maps, and slices.
package collections

import (
        "fmt"
        "html/template"
        "math/rand"
        "net/url"
        "reflect"
        "strings"
        "time"

        "github.com/gohugoio/hugo/common/collections"
        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/common/types"
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/pkg/errors"
        "github.com/spf13/cast"
)

func init() <span class="cov8" title="1">{
        rand.Seed(time.Now().UTC().UnixNano())
}</span>

// New returns a new instance of the collections-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                deps: deps,
        }
}</span>

// Namespace provides template functions for the "collections" namespace.
type Namespace struct {
        deps *deps.Deps
}

// After returns all the items after the first N in a rangeable list.
func (ns *Namespace) After(index interface{}, seq interface{}) (interface{}, error) <span class="cov8" title="1">{
        if index == nil || seq == nil </span><span class="cov8" title="1">{
                return nil, errors.New("both limit and seq must be provided")
        }</span>

        <span class="cov8" title="1">indexv, err := cast.ToIntE(index)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if indexv &lt; 0 </span><span class="cov8" title="1">{
                return nil, errors.New("sequence bounds out of range [" + cast.ToString(indexv) + ":]")
        }</span>

        <span class="cov8" title="1">seqv := reflect.ValueOf(seq)
        seqv, isNil := indirect(seqv)
        if isNil </span><span class="cov8" title="1">{
                return nil, errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov8" title="1">switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice, reflect.String:<span class="cov8" title="1"></span>
                // okay
        default:<span class="cov8" title="1">
                return nil, errors.New("can't iterate over " + reflect.ValueOf(seq).Type().String())</span>
        }

        <span class="cov8" title="1">if indexv &gt;= seqv.Len() </span><span class="cov8" title="1">{
                return seqv.Slice(0, 0).Interface(), nil
        }</span>

        <span class="cov8" title="1">return seqv.Slice(indexv, seqv.Len()).Interface(), nil</span>
}

// Delimit takes a given sequence and returns a delimited HTML string.
// If last is passed to the function, it will be used as the final delimiter.
func (ns *Namespace) Delimit(seq, delimiter interface{}, last ...interface{}) (template.HTML, error) <span class="cov8" title="1">{
        d, err := cast.ToStringE(delimiter)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">var dLast *string
        if len(last) &gt; 0 </span><span class="cov8" title="1">{
                l := last[0]
                dStr, err := cast.ToStringE(l)
                if err != nil </span><span class="cov0" title="0">{
                        dLast = nil
                }</span> else<span class="cov8" title="1"> {
                        dLast = &amp;dStr
                }</span>
        }

        <span class="cov8" title="1">seqv := reflect.ValueOf(seq)
        seqv, isNil := indirect(seqv)
        if isNil </span><span class="cov0" title="0">{
                return "", errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov8" title="1">var str string
        switch seqv.Kind() </span>{
        case reflect.Map:<span class="cov8" title="1">
                sortSeq, err := ns.Sort(seq)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
                <span class="cov8" title="1">seqv = reflect.ValueOf(sortSeq)
                fallthrough</span>
        case reflect.Array, reflect.Slice, reflect.String:<span class="cov8" title="1">
                for i := 0; i &lt; seqv.Len(); i++ </span><span class="cov8" title="1">{
                        val := seqv.Index(i).Interface()
                        valStr, err := cast.ToStringE(val)
                        if err != nil </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov8" title="1">switch </span>{
                        case i == seqv.Len()-2 &amp;&amp; dLast != nil:<span class="cov8" title="1">
                                str += valStr + *dLast</span>
                        case i == seqv.Len()-1:<span class="cov8" title="1">
                                str += valStr</span>
                        default:<span class="cov8" title="1">
                                str += valStr + d</span>
                        }
                }

        default:<span class="cov0" title="0">
                return "", fmt.Errorf("can't iterate over %v", seq)</span>
        }

        <span class="cov8" title="1">return template.HTML(str), nil</span>
}

// Dictionary creates a map[string]interface{} from the given parameters by
// walking the parameters and treating them as key-value pairs.  The number
// of parameters must be even.
// The keys can be string slices, which will create the needed nested structure.
func (ns *Namespace) Dictionary(values ...interface{}) (map[string]interface{}, error) <span class="cov8" title="1">{
        if len(values)%2 != 0 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid dictionary call")
        }</span>

        <span class="cov8" title="1">root := make(map[string]interface{})

        for i := 0; i &lt; len(values); i += 2 </span><span class="cov8" title="1">{
                dict := root
                var key string
                switch v := values[i].(type) </span>{
                case string:<span class="cov8" title="1">
                        key = v</span>
                case []string:<span class="cov8" title="1">
                        for i := 0; i &lt; len(v)-1; i++ </span><span class="cov8" title="1">{
                                key = v[i]
                                var m map[string]interface{}
                                v, found := dict[key]
                                if found </span><span class="cov8" title="1">{
                                        m = v.(map[string]interface{})
                                }</span> else<span class="cov8" title="1"> {
                                        m = make(map[string]interface{})
                                        dict[key] = m
                                }</span>
                                <span class="cov8" title="1">dict = m</span>
                        }
                        <span class="cov8" title="1">key = v[len(v)-1]</span>
                default:<span class="cov8" title="1">
                        return nil, errors.New("invalid dictionary key")</span>
                }
                <span class="cov8" title="1">dict[key] = values[i+1]</span>
        }

        <span class="cov8" title="1">return root, nil</span>
}

// EchoParam returns a given value if it is set; otherwise, it returns an
// empty string.
func (ns *Namespace) EchoParam(a, key interface{}) interface{} <span class="cov8" title="1">{
        av, isNil := indirect(reflect.ValueOf(a))
        if isNil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">var avv reflect.Value
        switch av.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                index, ok := key.(int)
                if ok &amp;&amp; av.Len() &gt; index </span><span class="cov8" title="1">{
                        avv = av.Index(index)
                }</span>
        case reflect.Map:<span class="cov8" title="1">
                kv := reflect.ValueOf(key)
                if kv.Type().AssignableTo(av.Type().Key()) </span><span class="cov8" title="1">{
                        avv = av.MapIndex(kv)
                }</span>
        }

        <span class="cov8" title="1">avv, isNil = indirect(avv)

        if isNil </span><span class="cov8" title="1">{
                return ""
        }</span>

        <span class="cov8" title="1">if avv.IsValid() </span><span class="cov8" title="1">{
                switch avv.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                        return avv.Int()</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                        return avv.Uint()</span>
                case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                        return avv.Float()</span>
                case reflect.String:<span class="cov8" title="1">
                        return avv.String()</span>
                }
        }

        <span class="cov8" title="1">return ""</span>
}

// First returns the first N items in a rangeable list.
func (ns *Namespace) First(limit interface{}, seq interface{}) (interface{}, error) <span class="cov8" title="1">{
        if limit == nil || seq == nil </span><span class="cov8" title="1">{
                return nil, errors.New("both limit and seq must be provided")
        }</span>

        <span class="cov8" title="1">limitv, err := cast.ToIntE(limit)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if limitv &lt; 0 </span><span class="cov8" title="1">{
                return nil, errors.New("sequence length must be non-negative")
        }</span>

        <span class="cov8" title="1">seqv := reflect.ValueOf(seq)
        seqv, isNil := indirect(seqv)
        if isNil </span><span class="cov8" title="1">{
                return nil, errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov8" title="1">switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice, reflect.String:<span class="cov8" title="1"></span>
                // okay
        default:<span class="cov8" title="1">
                return nil, errors.New("can't iterate over " + reflect.ValueOf(seq).Type().String())</span>
        }

        <span class="cov8" title="1">if limitv &gt; seqv.Len() </span><span class="cov8" title="1">{
                limitv = seqv.Len()
        }</span>

        <span class="cov8" title="1">return seqv.Slice(0, limitv).Interface(), nil</span>
}

// In returns whether v is in the set l.  l may be an array or slice.
func (ns *Namespace) In(l interface{}, v interface{}) (bool, error) <span class="cov8" title="1">{
        if l == nil || v == nil </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">lv := reflect.ValueOf(l)
        vv := reflect.ValueOf(v)

        vvk := normalize(vv)

        switch lv.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                for i := 0; i &lt; lv.Len(); i++ </span><span class="cov8" title="1">{
                        lvv, isNil := indirectInterface(lv.Index(i))
                        if isNil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">lvvk := normalize(lvv)

                        if lvvk == vvk </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                }
        }
        <span class="cov8" title="1">ss, err := cast.ToStringE(l)
        if err != nil </span><span class="cov8" title="1">{
                return false, nil
        }</span>

        <span class="cov8" title="1">su, err := cast.ToStringE(v)
        if err != nil </span><span class="cov0" title="0">{
                return false, nil
        }</span>
        <span class="cov8" title="1">return strings.Contains(ss, su), nil</span>
}

// Intersect returns the common elements in the given sets, l1 and l2.  l1 and
// l2 must be of the same type and may be either arrays or slices.
func (ns *Namespace) Intersect(l1, l2 interface{}) (interface{}, error) <span class="cov8" title="1">{
        if l1 == nil || l2 == nil </span><span class="cov8" title="1">{
                return make([]interface{}, 0), nil
        }</span>

        <span class="cov8" title="1">var ins *intersector

        l1v := reflect.ValueOf(l1)
        l2v := reflect.ValueOf(l2)

        switch l1v.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                ins = &amp;intersector{r: reflect.MakeSlice(l1v.Type(), 0, 0), seen: make(map[interface{}]bool)}
                switch l2v.Kind() </span>{
                case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                        for i := 0; i &lt; l1v.Len(); i++ </span><span class="cov8" title="1">{
                                l1vv := l1v.Index(i)
                                if !l1vv.Type().Comparable() </span><span class="cov8" title="1">{
                                        return make([]interface{}, 0), errors.New("intersect does not support slices or arrays of uncomparable types")
                                }</span>

                                <span class="cov8" title="1">for j := 0; j &lt; l2v.Len(); j++ </span><span class="cov8" title="1">{
                                        l2vv := l2v.Index(j)
                                        if !l2vv.Type().Comparable() </span><span class="cov8" title="1">{
                                                return make([]interface{}, 0), errors.New("intersect does not support slices or arrays of uncomparable types")
                                        }</span>

                                        <span class="cov8" title="1">ins.handleValuePair(l1vv, l2vv)</span>
                                }
                        }
                        <span class="cov8" title="1">return ins.r.Interface(), nil</span>
                default:<span class="cov8" title="1">
                        return nil, errors.New("can't iterate over " + reflect.ValueOf(l2).Type().String())</span>
                }
        default:<span class="cov8" title="1">
                return nil, errors.New("can't iterate over " + reflect.ValueOf(l1).Type().String())</span>
        }
}

// Group groups a set of elements by the given key.
// This is currently only supported for Pages.
func (ns *Namespace) Group(key interface{}, items interface{}) (interface{}, error) <span class="cov8" title="1">{
        if key == nil </span><span class="cov8" title="1">{
                return nil, errors.New("nil is not a valid key to group by")
        }</span>

        <span class="cov8" title="1">if g, ok := items.(collections.Grouper); ok </span><span class="cov0" title="0">{
                return g.Group(key, items)
        }</span>

        <span class="cov8" title="1">in := newSliceElement(items)

        if g, ok := in.(collections.Grouper); ok </span><span class="cov8" title="1">{
                return g.Group(key, items)
        }</span>

        <span class="cov8" title="1">return nil, fmt.Errorf("grouping not supported for type %T %T", items, in)</span>
}

// IsSet returns whether a given array, channel, slice, or map has a key
// defined.
func (ns *Namespace) IsSet(a interface{}, key interface{}) (bool, error) <span class="cov8" title="1">{
        av := reflect.ValueOf(a)
        kv := reflect.ValueOf(key)

        switch av.Kind() </span>{
        case reflect.Array, reflect.Chan, reflect.Slice:<span class="cov8" title="1">
                k, err := cast.ToIntE(key)
                if err != nil </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("isset unable to use key of type %T as index", key)
                }</span>
                <span class="cov8" title="1">if av.Len() &gt; k </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        case reflect.Map:<span class="cov8" title="1">
                if kv.Type() == av.Type().Key() </span><span class="cov8" title="1">{
                        return av.MapIndex(kv).IsValid(), nil
                }</span>
        default:<span class="cov8" title="1">
                helpers.DistinctErrorLog.Printf("WARNING: calling IsSet with unsupported type %q (%T) will always return false.\n", av.Kind(), a)</span>
        }

        <span class="cov8" title="1">return false, nil</span>
}

// Last returns the last N items in a rangeable list.
func (ns *Namespace) Last(limit interface{}, seq interface{}) (interface{}, error) <span class="cov8" title="1">{
        if limit == nil || seq == nil </span><span class="cov8" title="1">{
                return nil, errors.New("both limit and seq must be provided")
        }</span>

        <span class="cov8" title="1">limitv, err := cast.ToIntE(limit)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if limitv &lt; 0 </span><span class="cov8" title="1">{
                return nil, errors.New("sequence length must be non-negative")
        }</span>

        <span class="cov8" title="1">seqv := reflect.ValueOf(seq)
        seqv, isNil := indirect(seqv)
        if isNil </span><span class="cov8" title="1">{
                return nil, errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov8" title="1">switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice, reflect.String:<span class="cov8" title="1"></span>
                // okay
        default:<span class="cov8" title="1">
                return nil, errors.New("can't iterate over " + reflect.ValueOf(seq).Type().String())</span>
        }

        <span class="cov8" title="1">if limitv &gt; seqv.Len() </span><span class="cov8" title="1">{
                limitv = seqv.Len()
        }</span>

        <span class="cov8" title="1">return seqv.Slice(seqv.Len()-limitv, seqv.Len()).Interface(), nil</span>
}

// Querify encodes the given parameters in URL-encoded form ("bar=baz&amp;foo=quux") sorted by key.
func (ns *Namespace) Querify(params ...interface{}) (string, error) <span class="cov8" title="1">{
        qs := url.Values{}

        if len(params) == 1 </span><span class="cov8" title="1">{
                switch v := params[0].(type) </span>{
                case []string:<span class="cov8" title="1">
                        if len(v)%2 != 0 </span><span class="cov8" title="1">{
                                return "", errors.New("invalid query")
                        }</span>

                        <span class="cov8" title="1">for i := 0; i &lt; len(v); i += 2 </span><span class="cov8" title="1">{
                                qs.Add(v[i], v[i+1])
                        }</span>

                        <span class="cov8" title="1">return qs.Encode(), nil</span>

                case []interface{}:<span class="cov8" title="1">
                        params = v</span>

                default:<span class="cov0" title="0">
                        return "", errors.New("query keys must be strings")</span>
                }
        }

        <span class="cov8" title="1">if len(params)%2 != 0 </span><span class="cov8" title="1">{
                return "", errors.New("invalid query")
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(params); i += 2 </span><span class="cov8" title="1">{
                switch v := params[i].(type) </span>{
                case string:<span class="cov8" title="1">
                        qs.Add(v, fmt.Sprintf("%v", params[i+1]))</span>
                default:<span class="cov8" title="1">
                        return "", errors.New("query keys must be strings")</span>
                }
        }

        <span class="cov8" title="1">return qs.Encode(), nil</span>
}

// Reverse creates a copy of slice and reverses it.
func (ns *Namespace) Reverse(slice interface{}) (interface{}, error) <span class="cov8" title="1">{
        if slice == nil </span><span class="cov8" title="1">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">v := reflect.ValueOf(slice)

        switch v.Kind() </span>{
        case reflect.Slice:<span class="cov8" title="1"></span>
        default:<span class="cov8" title="1">
                return nil, errors.New("argument must be a slice")</span>
        }

        <span class="cov8" title="1">sliceCopy := reflect.MakeSlice(v.Type(), v.Len(), v.Len())

        for i := v.Len() - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                element := sliceCopy.Index(i)
                element.Set(v.Index(v.Len() - 1 - i))
        }</span>

        <span class="cov8" title="1">return sliceCopy.Interface(), nil</span>
}

// Seq creates a sequence of integers.  It's named and used as GNU's seq.
//
// Examples:
//     3 =&gt; 1, 2, 3
//     1 2 4 =&gt; 1, 3
//     -3 =&gt; -1, -2, -3
//     1 4 =&gt; 1, 2, 3, 4
//     1 -2 =&gt; 1, 0, -1, -2
func (ns *Namespace) Seq(args ...interface{}) ([]int, error) <span class="cov8" title="1">{
        if len(args) &lt; 1 || len(args) &gt; 3 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid number of arguments to Seq")
        }</span>

        <span class="cov8" title="1">intArgs := cast.ToIntSlice(args)
        if len(intArgs) &lt; 1 || len(intArgs) &gt; 3 </span><span class="cov8" title="1">{
                return nil, errors.New("invalid arguments to Seq")
        }</span>

        <span class="cov8" title="1">inc := 1
        var last int
        first := intArgs[0]

        if len(intArgs) == 1 </span><span class="cov8" title="1">{
                last = first
                if last == 0 </span><span class="cov8" title="1">{
                        return []int{}, nil
                }</span> else<span class="cov8" title="1"> if last &gt; 0 </span><span class="cov8" title="1">{
                        first = 1
                }</span> else<span class="cov8" title="1"> {
                        first = -1
                        inc = -1
                }</span>
        } else<span class="cov8" title="1"> if len(intArgs) == 2 </span><span class="cov8" title="1">{
                last = intArgs[1]
                if last &lt; first </span><span class="cov8" title="1">{
                        inc = -1
                }</span>
        } else<span class="cov8" title="1"> {
                inc = intArgs[1]
                last = intArgs[2]
                if inc == 0 </span><span class="cov8" title="1">{
                        return nil, errors.New("'increment' must not be 0")
                }</span>
                <span class="cov8" title="1">if first &lt; last &amp;&amp; inc &lt; 0 </span><span class="cov8" title="1">{
                        return nil, errors.New("'increment' must be &gt; 0")
                }</span>
                <span class="cov8" title="1">if first &gt; last &amp;&amp; inc &gt; 0 </span><span class="cov8" title="1">{
                        return nil, errors.New("'increment' must be &lt; 0")
                }</span>
        }

        // sanity check
        <span class="cov8" title="1">if last &lt; -100000 </span><span class="cov8" title="1">{
                return nil, errors.New("size of result exceeds limit")
        }</span>
        <span class="cov8" title="1">size := ((last - first) / inc) + 1

        // sanity check
        if size &lt;= 0 || size &gt; 2000 </span><span class="cov8" title="1">{
                return nil, errors.New("size of result exceeds limit")
        }</span>

        <span class="cov8" title="1">seq := make([]int, size)
        val := first
        for i := 0; ; i++ </span><span class="cov8" title="1">{
                seq[i] = val
                val += inc
                if (inc &lt; 0 &amp;&amp; val &lt; last) || (inc &gt; 0 &amp;&amp; val &gt; last) </span><span class="cov8" title="1">{
                        break</span>
                }
        }

        <span class="cov8" title="1">return seq, nil</span>
}

// Shuffle returns the given rangeable list in a randomised order.
func (ns *Namespace) Shuffle(seq interface{}) (interface{}, error) <span class="cov8" title="1">{
        if seq == nil </span><span class="cov8" title="1">{
                return nil, errors.New("both count and seq must be provided")
        }</span>

        <span class="cov8" title="1">seqv := reflect.ValueOf(seq)
        seqv, isNil := indirect(seqv)
        if isNil </span><span class="cov8" title="1">{
                return nil, errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov8" title="1">switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice, reflect.String:<span class="cov8" title="1"></span>
                // okay
        default:<span class="cov8" title="1">
                return nil, errors.New("can't iterate over " + reflect.ValueOf(seq).Type().String())</span>
        }

        <span class="cov8" title="1">shuffled := reflect.MakeSlice(reflect.TypeOf(seq), seqv.Len(), seqv.Len())

        randomIndices := rand.Perm(seqv.Len())

        for index, value := range randomIndices </span><span class="cov8" title="1">{
                shuffled.Index(value).Set(seqv.Index(index))
        }</span>

        <span class="cov8" title="1">return shuffled.Interface(), nil</span>
}

// Slice returns a slice of all passed arguments.
func (ns *Namespace) Slice(args ...interface{}) interface{} <span class="cov8" title="1">{
        if len(args) == 0 </span><span class="cov8" title="1">{
                return args
        }</span>

        <span class="cov8" title="1">return collections.Slice(args...)</span>
}

type intersector struct {
        r    reflect.Value
        seen map[interface{}]bool
}

func (i *intersector) appendIfNotSeen(v reflect.Value) <span class="cov8" title="1">{
        vi := v.Interface()
        if !i.seen[vi] </span><span class="cov8" title="1">{
                i.r = reflect.Append(i.r, v)
                i.seen[vi] = true
        }</span>
}

func (i *intersector) handleValuePair(l1vv, l2vv reflect.Value) <span class="cov8" title="1">{
        switch kind := l1vv.Kind(); </span>{
        case kind == reflect.String:<span class="cov8" title="1">
                l2t, err := toString(l2vv)
                if err == nil &amp;&amp; l1vv.String() == l2t </span><span class="cov8" title="1">{
                        i.appendIfNotSeen(l1vv)
                }</span>
        case isNumber(kind):<span class="cov8" title="1">
                f1, err1 := numberToFloat(l1vv)
                f2, err2 := numberToFloat(l2vv)
                if err1 == nil &amp;&amp; err2 == nil &amp;&amp; f1 == f2 </span><span class="cov8" title="1">{
                        i.appendIfNotSeen(l1vv)
                }</span>
        case kind == reflect.Ptr, kind == reflect.Struct:<span class="cov8" title="1">
                if l1vv.Interface() == l2vv.Interface() </span><span class="cov8" title="1">{
                        i.appendIfNotSeen(l1vv)
                }</span>
        case kind == reflect.Interface:<span class="cov8" title="1">
                i.handleValuePair(reflect.ValueOf(l1vv.Interface()), l2vv)</span>
        }
}

// Union returns the union of the given sets, l1 and l2. l1 and
// l2 must be of the same type and may be either arrays or slices.
// If l1 and l2 aren't of the same type then l1 will be returned.
// If either l1 or l2 is nil then the non-nil list will be returned.
func (ns *Namespace) Union(l1, l2 interface{}) (interface{}, error) <span class="cov8" title="1">{
        if l1 == nil &amp;&amp; l2 == nil </span><span class="cov8" title="1">{
                return []interface{}{}, nil
        }</span> else<span class="cov8" title="1"> if l1 == nil &amp;&amp; l2 != nil </span><span class="cov8" title="1">{
                return l2, nil
        }</span> else<span class="cov8" title="1"> if l1 != nil &amp;&amp; l2 == nil </span><span class="cov8" title="1">{
                return l1, nil
        }</span>

        <span class="cov8" title="1">l1v := reflect.ValueOf(l1)
        l2v := reflect.ValueOf(l2)

        var ins *intersector

        switch l1v.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                switch l2v.Kind() </span>{
                case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                        ins = &amp;intersector{r: reflect.MakeSlice(l1v.Type(), 0, 0), seen: make(map[interface{}]bool)}

                        if l1v.Type() != l2v.Type() &amp;&amp;
                                l1v.Type().Elem().Kind() != reflect.Interface &amp;&amp;
                                l2v.Type().Elem().Kind() != reflect.Interface </span><span class="cov8" title="1">{
                                return ins.r.Interface(), nil
                        }</span>

                        <span class="cov8" title="1">var (
                                l1vv  reflect.Value
                                isNil bool
                        )

                        for i := 0; i &lt; l1v.Len(); i++ </span><span class="cov8" title="1">{
                                l1vv, isNil = indirectInterface(l1v.Index(i))

                                if !l1vv.Type().Comparable() </span><span class="cov8" title="1">{
                                        return []interface{}{}, errors.New("union does not support slices or arrays of uncomparable types")
                                }</span>

                                <span class="cov8" title="1">if !isNil </span><span class="cov8" title="1">{
                                        ins.appendIfNotSeen(l1vv)
                                }</span>
                        }

                        <span class="cov8" title="1">if !l1vv.IsValid() </span><span class="cov8" title="1">{
                                // The first slice may be empty. Pick the first value of the second
                                // to use as a prototype.
                                if l2v.Len() &gt; 0 </span><span class="cov8" title="1">{
                                        l1vv = l2v.Index(0)
                                }</span>
                        }

                        <span class="cov8" title="1">for j := 0; j &lt; l2v.Len(); j++ </span><span class="cov8" title="1">{
                                l2vv := l2v.Index(j)

                                switch kind := l1vv.Kind(); </span>{
                                case kind == reflect.String:<span class="cov8" title="1">
                                        l2t, err := toString(l2vv)
                                        if err == nil </span><span class="cov8" title="1">{
                                                ins.appendIfNotSeen(reflect.ValueOf(l2t))
                                        }</span>
                                case isNumber(kind):<span class="cov8" title="1">
                                        var err error
                                        l2vv, err = convertNumber(l2vv, kind)
                                        if err == nil </span><span class="cov8" title="1">{
                                                ins.appendIfNotSeen(l2vv)
                                        }</span>
                                case kind == reflect.Interface, kind == reflect.Struct, kind == reflect.Ptr:<span class="cov8" title="1">
                                        ins.appendIfNotSeen(l2vv)</span>

                                }
                        }

                        <span class="cov8" title="1">return ins.r.Interface(), nil</span>
                default:<span class="cov8" title="1">
                        return nil, errors.New("can't iterate over " + reflect.ValueOf(l2).Type().String())</span>
                }
        default:<span class="cov8" title="1">
                return nil, errors.New("can't iterate over " + reflect.ValueOf(l1).Type().String())</span>
        }
}

// Uniq takes in a slice or array and returns a slice with subsequent
// duplicate elements removed.
func (ns *Namespace) Uniq(seq interface{}) (interface{}, error) <span class="cov8" title="1">{
        if seq == nil </span><span class="cov8" title="1">{
                return make([]interface{}, 0), nil
        }</span>

        <span class="cov8" title="1">v := reflect.ValueOf(seq)
        var slice reflect.Value

        switch v.Kind() </span>{
        case reflect.Slice:<span class="cov8" title="1">
                slice = reflect.MakeSlice(v.Type(), 0, 0)</span>

        case reflect.Array:<span class="cov8" title="1">
                slice = reflect.MakeSlice(reflect.SliceOf(v.Type().Elem()), 0, 0)</span>
        default:<span class="cov8" title="1">
                return nil, errors.Errorf("type %T not supported", seq)</span>
        }

        <span class="cov8" title="1">seen := make(map[interface{}]bool)

        for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                ev, _ := indirectInterface(v.Index(i))

                key := normalize(ev)

                if _, found := seen[key]; !found </span><span class="cov8" title="1">{
                        slice = reflect.Append(slice, ev)
                        seen[key] = true
                }</span>
        }

        <span class="cov8" title="1">return slice.Interface(), nil</span>
}

// KeyVals creates a key and values wrapper.
func (ns *Namespace) KeyVals(key interface{}, vals ...interface{}) (types.KeyValues, error) <span class="cov0" title="0">{
        return types.KeyValues{Key: key, Values: vals}, nil
}</span>

// NewScratch creates a new Scratch which can be used to store values in a
// thread safe way.
func (ns *Namespace) NewScratch() *maps.Scratch <span class="cov0" title="0">{
        return maps.NewScratch()
}</span>
</pre>
		
		<pre class="file" id="file271" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "errors"
        "fmt"
        "reflect"
)

// Complement gives the elements in the last element of seqs that are not in
// any of the others.
// All elements of seqs must be slices or arrays of comparable types.
//
// The reasoning behind this rather clumsy API is so we can do this in the templates:
//    {{ $c := .Pages | complement $last4 }}
func (ns *Namespace) Complement(seqs ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(seqs) &lt; 2 </span><span class="cov8" title="1">{
                return nil, errors.New("complement needs at least two arguments")
        }</span>

        <span class="cov8" title="1">universe := seqs[len(seqs)-1]
        as := seqs[:len(seqs)-1]

        aset, err := collectIdentities(as...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">v := reflect.ValueOf(universe)
        switch v.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                sl := reflect.MakeSlice(v.Type(), 0, 0)
                for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                        ev, _ := indirectInterface(v.Index(i))
                        if _, found := aset[normalize(ev)]; !found </span><span class="cov8" title="1">{
                                sl = reflect.Append(sl, ev)
                        }</span>
                }
                <span class="cov8" title="1">return sl.Interface(), nil</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("arguments to complement must be slices or arrays")</span>
        }
}
</pre>
		
		<pre class="file" id="file272" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "errors"
        "fmt"
        "reflect"

        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/common/maps"
)

// Index returns the result of indexing its first argument by the following
// arguments. Thus "index x 1 2 3" is, in Go syntax, x[1][2][3]. Each
// indexed item must be a map, slice, or array.
//
// Copied from Go stdlib src/text/template/funcs.go.
//
// We deviate from the stdlib due to https://github.com/golang/go/issues/14751.
//
// TODO(moorereason): merge upstream changes.
func (ns *Namespace) Index(item interface{}, args ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        v := reflect.ValueOf(item)
        if !v.IsValid() </span><span class="cov8" title="1">{
                return nil, errors.New("index of untyped nil")
        }</span>

        <span class="cov8" title="1">lowerm, ok := item.(maps.Params)
        if ok </span><span class="cov8" title="1">{
                return lowerm.Get(cast.ToStringSlice(args)...), nil
        }</span>

        <span class="cov8" title="1">var indices []interface{}

        if len(args) == 1 </span><span class="cov8" title="1">{
                v := reflect.ValueOf(args[0])
                if v.Kind() == reflect.Slice </span><span class="cov8" title="1">{
                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                                indices = append(indices, v.Index(i).Interface())
                        }</span>
                }
        }

        <span class="cov8" title="1">if indices == nil </span><span class="cov8" title="1">{
                indices = args
        }</span>

        <span class="cov8" title="1">for _, i := range indices </span><span class="cov8" title="1">{
                index := reflect.ValueOf(i)
                var isNil bool
                if v, isNil = indirect(v); isNil </span><span class="cov0" title="0">{
                        return nil, errors.New("index of nil pointer")
                }</span>
                <span class="cov8" title="1">switch v.Kind() </span>{
                case reflect.Array, reflect.Slice, reflect.String:<span class="cov8" title="1">
                        var x int64
                        switch index.Kind() </span>{
                        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                                x = index.Int()</span>
                        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                                x = int64(index.Uint())</span>
                        case reflect.Invalid:<span class="cov8" title="1">
                                return nil, errors.New("cannot index slice/array with nil")</span>
                        default:<span class="cov8" title="1">
                                return nil, fmt.Errorf("cannot index slice/array with type %s", index.Type())</span>
                        }
                        <span class="cov8" title="1">if x &lt; 0 || x &gt;= int64(v.Len()) </span><span class="cov8" title="1">{
                                // We deviate from stdlib here.  Don't return an error if the
                                // index is out of range.
                                return nil, nil
                        }</span>
                        <span class="cov8" title="1">v = v.Index(int(x))</span>
                case reflect.Map:<span class="cov8" title="1">
                        index, err := prepareArg(index, v.Type().Key())
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">if x := v.MapIndex(index); x.IsValid() </span><span class="cov8" title="1">{
                                v = x
                        }</span> else<span class="cov8" title="1"> {
                                v = reflect.Zero(v.Type().Elem())
                        }</span>
                case reflect.Invalid:<span class="cov0" title="0">
                        // the loop holds invariant: v.IsValid()
                        panic("unreachable")</span>
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("can't index item of type %s", v.Type())</span>
                }
        }
        <span class="cov8" title="1">return v.Interface(), nil</span>
}

// prepareArg checks if value can be used as an argument of type argType, and
// converts an invalid value to appropriate zero if possible.
//
// Copied from Go stdlib src/text/template/funcs.go.
func prepareArg(value reflect.Value, argType reflect.Type) (reflect.Value, error) <span class="cov8" title="1">{
        if !value.IsValid() </span><span class="cov0" title="0">{
                if !canBeNil(argType) </span><span class="cov0" title="0">{
                        return reflect.Value{}, fmt.Errorf("value is nil; should be of type %s", argType)
                }</span>
                <span class="cov0" title="0">value = reflect.Zero(argType)</span>
        }
        <span class="cov8" title="1">if !value.Type().AssignableTo(argType) </span><span class="cov0" title="0">{
                return reflect.Value{}, fmt.Errorf("value has type %s; should be %s", value.Type(), argType)
        }</span>
        <span class="cov8" title="1">return value, nil</span>
}

// canBeNil reports whether an untyped nil can be assigned to the type. See reflect.Zero.
//
// Copied from Go stdlib src/text/template/exec.go.
func canBeNil(typ reflect.Type) bool <span class="cov0" title="0">{
        switch typ.Kind() </span>{
        case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:<span class="cov0" title="0">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}
</pre>
		
		<pre class="file" id="file273" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "collections"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.After,
                        []string{"after"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Apply,
                        []string{"apply"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Complement,
                        []string{"complement"},
                        [][2]string{
                                {`{{ slice "a" "b" "c" "d" "e" "f" | complement (slice "b" "c") (slice "d" "e")  }}`, `[a f]`},
                        },
                )

                ns.AddMethodMapping(ctx.SymDiff,
                        []string{"symdiff"},
                        [][2]string{
                                {`{{ slice 1 2 3 | symdiff (slice 3 4) }}`, `[1 2 4]`},
                        },
                )

                ns.AddMethodMapping(ctx.Delimit,
                        []string{"delimit"},
                        [][2]string{
                                {`{{ delimit (slice "A" "B" "C") ", " " and " }}`, `A, B and C`},
                        },
                )

                ns.AddMethodMapping(ctx.Dictionary,
                        []string{"dict"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.EchoParam,
                        []string{"echoParam"},
                        [][2]string{
                                {`{{ echoParam .Params "langCode" }}`, `en`},
                        },
                )

                ns.AddMethodMapping(ctx.First,
                        []string{"first"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.KeyVals,
                        []string{"keyVals"},
                        [][2]string{
                                {`{{ keyVals "key" "a" "b" }}`, `key: [a b]`},
                        },
                )

                ns.AddMethodMapping(ctx.In,
                        []string{"in"},
                        [][2]string{
                                {`{{ if in "this string contains a substring" "substring" }}Substring found!{{ end }}`, `Substring found!`},
                        },
                )

                ns.AddMethodMapping(ctx.Index,
                        []string{"index"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Intersect,
                        []string{"intersect"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.IsSet,
                        []string{"isSet", "isset"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Last,
                        []string{"last"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Querify,
                        []string{"querify"},
                        [][2]string{
                                {
                                        `{{ (querify "foo" 1 "bar" 2 "baz" "with spaces" "qux" "this&amp;that=those") | safeHTML }}`,
                                        `bar=2&amp;baz=with+spaces&amp;foo=1&amp;qux=this%26that%3Dthose`,
                                },
                                {
                                        `&lt;a href="https://www.google.com?{{ (querify "q" "test" "page" 3) | safeURL }}"&gt;Search&lt;/a&gt;`,
                                        `&lt;a href="https://www.google.com?page=3&amp;amp;q=test"&gt;Search&lt;/a&gt;`,
                                },
                                {
                                        `{{ slice "foo" 1 "bar" 2 | querify | safeHTML }}`,
                                        `bar=2&amp;foo=1`,
                                },
                        },
                )

                ns.AddMethodMapping(ctx.Shuffle,
                        []string{"shuffle"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Slice,
                        []string{"slice"},
                        [][2]string{
                                {`{{ slice "B" "C" "A" | sort }}`, `[A B C]`},
                        },
                )

                ns.AddMethodMapping(ctx.Sort,
                        []string{"sort"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Union,
                        []string{"union"},
                        [][2]string{
                                {`{{ union (slice 1 2 3) (slice 3 4 5) }}`, `[1 2 3 4 5]`},
                        },
                )

                ns.AddMethodMapping(ctx.Where,
                        []string{"where"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Append,
                        []string{"append"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Group,
                        []string{"group"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Seq,
                        []string{"seq"},
                        [][2]string{
                                {`{{ seq 3 }}`, `[1 2 3]`},
                        },
                )

                ns.AddMethodMapping(ctx.NewScratch,
                        []string{"newScratch"},
                        [][2]string{
                                {`{{ $scratch := newScratch }}{{ $scratch.Add "b" 2 }}{{ $scratch.Add "b" 2 }}{{ $scratch.Get "b" }}`, `4`},
                        },
                )

                ns.AddMethodMapping(ctx.Uniq,
                        []string{"uniq"},
                        [][2]string{
                                {`{{ slice 1 2 3 2 | uniq }}`, `[1 2 3]`},
                        },
                )

                ns.AddMethodMapping(ctx.Merge,
                        []string{"merge"},
                        [][2]string{
                                {
                                        `{{ dict "title" "Hugo Rocks!" | collections.Merge (dict "title" "Default Title" "description" "Yes, Hugo Rocks!") | sort }}`,
                                        `[Yes, Hugo Rocks! Hugo Rocks!]`,
                                },
                                {
                                        `{{  merge (dict "title" "Default Title" "description" "Yes, Hugo Rocks!") (dict "title" "Hugo Rocks!") | sort }}`,
                                        `[Yes, Hugo Rocks! Hugo Rocks!]`,
                                },
                                {
                                        `{{  merge (dict "title" "Default Title" "description" "Yes, Hugo Rocks!") (dict "title" "Hugo Rocks!") (dict "extra" "For reals!") | sort }}`,
                                        `[Yes, Hugo Rocks! For reals! Hugo Rocks!]`,
                                },
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file274" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "reflect"
        "strings"

        "github.com/gohugoio/hugo/common/hreflect"
        "github.com/gohugoio/hugo/common/maps"

        "github.com/pkg/errors"
)

// Merge creates a copy of the final parameter and merges the preceding
// parameters into it in reverse order.
// Currently only maps are supported. Key handling is case insensitive.
func (ns *Namespace) Merge(params ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(params) &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("merge requires at least two parameters")
        }</span>

        <span class="cov8" title="1">var err error
        result := params[len(params)-1]

        for i := len(params) - 2; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                result, err = ns.merge(params[i], result)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return result, nil</span>
}

// merge creates a copy of dst and merges src into it.
func (ns *Namespace) merge(src, dst interface{}) (interface{}, error) <span class="cov8" title="1">{
        vdst, vsrc := reflect.ValueOf(dst), reflect.ValueOf(src)

        if vdst.Kind() != reflect.Map </span><span class="cov8" title="1">{
                return nil, errors.Errorf("destination must be a map, got %T", dst)
        }</span>

        <span class="cov8" title="1">if !hreflect.IsTruthfulValue(vsrc) </span><span class="cov8" title="1">{
                return dst, nil
        }</span>

        <span class="cov8" title="1">if vsrc.Kind() != reflect.Map </span><span class="cov8" title="1">{
                return nil, errors.Errorf("source must be a map, got %T", src)
        }</span>

        <span class="cov8" title="1">if vsrc.Type().Key() != vdst.Type().Key() </span><span class="cov8" title="1">{
                return nil, errors.Errorf("incompatible map types, got %T to %T", src, dst)
        }</span>

        <span class="cov8" title="1">return mergeMap(vdst, vsrc).Interface(), nil</span>
}

func caseInsensitiveLookup(m, k reflect.Value) (reflect.Value, bool) <span class="cov8" title="1">{
        if m.Type().Key().Kind() != reflect.String || k.Kind() != reflect.String </span><span class="cov8" title="1">{
                // Fall back to direct lookup.
                v := m.MapIndex(k)
                return v, hreflect.IsTruthfulValue(v)
        }</span>

        <span class="cov8" title="1">for _, key := range m.MapKeys() </span><span class="cov8" title="1">{
                if strings.EqualFold(k.String(), key.String()) </span><span class="cov8" title="1">{
                        return m.MapIndex(key), true
                }</span>
        }

        <span class="cov8" title="1">return reflect.Value{}, false</span>
}

func mergeMap(dst, src reflect.Value) reflect.Value <span class="cov8" title="1">{
        out := reflect.MakeMap(dst.Type())

        // If the destination is Params, we must lower case all keys.
        _, lowerCase := dst.Interface().(maps.Params)

        // Copy the destination map.
        for _, key := range dst.MapKeys() </span><span class="cov8" title="1">{
                v := dst.MapIndex(key)
                out.SetMapIndex(key, v)
        }</span>

        // Add all keys in src not already in destination.
        // Maps of the same type will be merged.
        <span class="cov8" title="1">for _, key := range src.MapKeys() </span><span class="cov8" title="1">{
                sv := src.MapIndex(key)
                dv, found := caseInsensitiveLookup(dst, key)

                if found </span><span class="cov8" title="1">{
                        // If both are the same map key type, merge.
                        dve := dv.Elem()
                        if dve.Kind() == reflect.Map </span><span class="cov8" title="1">{
                                sve := sv.Elem()
                                if sve.Kind() != reflect.Map </span><span class="cov8" title="1">{
                                        continue</span>
                                }

                                <span class="cov8" title="1">if dve.Type().Key() == sve.Type().Key() </span><span class="cov8" title="1">{
                                        out.SetMapIndex(key, mergeMap(dve, sve))
                                }</span>
                        }
                } else<span class="cov8" title="1"> {
                        if lowerCase &amp;&amp; key.Kind() == reflect.String </span><span class="cov8" title="1">{
                                key = reflect.ValueOf(strings.ToLower(key.String()))
                        }</span>
                        <span class="cov8" title="1">out.SetMapIndex(key, sv)</span>
                }
        }

        <span class="cov8" title="1">return out</span>
}
</pre>
		
		<pre class="file" id="file275" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "fmt"
        "reflect"
        "time"

        "github.com/mitchellh/hashstructure"
        "github.com/pkg/errors"
)

var (
        zero      reflect.Value
        errorType = reflect.TypeOf((*error)(nil)).Elem()
        timeType  = reflect.TypeOf((*time.Time)(nil)).Elem()
)

func numberToFloat(v reflect.Value) (float64, error) <span class="cov8" title="1">{
        switch kind := v.Kind(); </span>{
        case isFloat(kind):<span class="cov8" title="1">
                return v.Float(), nil</span>
        case isInt(kind):<span class="cov8" title="1">
                return float64(v.Int()), nil</span>
        case isUint(kind):<span class="cov8" title="1">
                return float64(v.Uint()), nil</span>
        case kind == reflect.Interface:<span class="cov8" title="1">
                return numberToFloat(v.Elem())</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("invalid kind %s in numberToFloat", kind)</span>
        }
}

// normalizes different numeric types if isNumber
// or get the hash values if not Comparable (such as map or struct)
// to make them comparable
func normalize(v reflect.Value) interface{} <span class="cov8" title="1">{
        k := v.Kind()

        switch </span>{
        case !v.Type().Comparable():<span class="cov8" title="1">
                h, err := hashstructure.Hash(v.Interface(), nil)
                if err != nil </span><span class="cov0" title="0">{
                        panic(err)</span>
                }
                <span class="cov8" title="1">return h</span>
        case isNumber(k):<span class="cov8" title="1">
                f, err := numberToFloat(v)
                if err == nil </span><span class="cov8" title="1">{
                        return f
                }</span>
        }
        <span class="cov8" title="1">return v.Interface()</span>
}

// collects identities from the slices in seqs into a set. Numeric values are normalized,
// pointers unwrapped.
func collectIdentities(seqs ...interface{}) (map[interface{}]bool, error) <span class="cov8" title="1">{
        seen := make(map[interface{}]bool)
        for _, seq := range seqs </span><span class="cov8" title="1">{
                v := reflect.ValueOf(seq)
                switch v.Kind() </span>{
                case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                        for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                                ev, _ := indirectInterface(v.Index(i))

                                if !ev.Type().Comparable() </span><span class="cov8" title="1">{
                                        return nil, errors.New("elements must be comparable")
                                }</span>

                                <span class="cov8" title="1">seen[normalize(ev)] = true</span>
                        }
                default:<span class="cov8" title="1">
                        return nil, fmt.Errorf("arguments must be slices or arrays")</span>
                }
        }

        <span class="cov8" title="1">return seen, nil</span>
}

// We have some different numeric and string types that we try to behave like
// they were the same.
func convertValue(v reflect.Value, to reflect.Type) (reflect.Value, error) <span class="cov8" title="1">{
        if v.Type().AssignableTo(to) </span><span class="cov8" title="1">{
                return v, nil
        }</span>
        <span class="cov8" title="1">switch kind := to.Kind(); </span>{
        case kind == reflect.String:<span class="cov0" title="0">
                s, err := toString(v)
                return reflect.ValueOf(s), err</span>
        case isNumber(kind):<span class="cov8" title="1">
                return convertNumber(v, kind)</span>
        default:<span class="cov0" title="0">
                return reflect.Value{}, errors.Errorf("%s is not assignable to %s", v.Type(), to)</span>
        }
}

// There are potential overflows in this function, but the downconversion of
// int64 etc. into int8 etc. is coming from the synthetic unit tests for Union etc.
// TODO(bep) We should consider normalizing the slices to int64 etc.
func convertNumber(v reflect.Value, to reflect.Kind) (reflect.Value, error) <span class="cov8" title="1">{
        var n reflect.Value
        if isFloat(to) </span><span class="cov8" title="1">{
                f, err := toFloat(v)
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
                <span class="cov8" title="1">switch to </span>{
                case reflect.Float32:<span class="cov8" title="1">
                        n = reflect.ValueOf(float32(f))</span>
                default:<span class="cov8" title="1">
                        n = reflect.ValueOf(float64(f))</span>
                }
        } else<span class="cov8" title="1"> if isInt(to) </span><span class="cov8" title="1">{
                i, err := toInt(v)
                if err != nil </span><span class="cov8" title="1">{
                        return n, err
                }</span>
                <span class="cov8" title="1">switch to </span>{
                case reflect.Int:<span class="cov8" title="1">
                        n = reflect.ValueOf(int(i))</span>
                case reflect.Int8:<span class="cov8" title="1">
                        n = reflect.ValueOf(int8(i))</span>
                case reflect.Int16:<span class="cov8" title="1">
                        n = reflect.ValueOf(int16(i))</span>
                case reflect.Int32:<span class="cov8" title="1">
                        n = reflect.ValueOf(int32(i))</span>
                case reflect.Int64:<span class="cov8" title="1">
                        n = reflect.ValueOf(int64(i))</span>
                }
        } else<span class="cov8" title="1"> if isUint(to) </span><span class="cov8" title="1">{
                i, err := toUint(v)
                if err != nil </span><span class="cov0" title="0">{
                        return n, err
                }</span>
                <span class="cov8" title="1">switch to </span>{
                case reflect.Uint:<span class="cov8" title="1">
                        n = reflect.ValueOf(uint(i))</span>
                case reflect.Uint8:<span class="cov0" title="0">
                        n = reflect.ValueOf(uint8(i))</span>
                case reflect.Uint16:<span class="cov0" title="0">
                        n = reflect.ValueOf(uint16(i))</span>
                case reflect.Uint32:<span class="cov0" title="0">
                        n = reflect.ValueOf(uint32(i))</span>
                case reflect.Uint64:<span class="cov0" title="0">
                        n = reflect.ValueOf(uint64(i))</span>
                }

        }

        <span class="cov8" title="1">if !n.IsValid() </span><span class="cov0" title="0">{
                return n, errors.New("invalid values")
        }</span>

        <span class="cov8" title="1">return n, nil</span>
}

func newSliceElement(items interface{}) interface{} <span class="cov8" title="1">{
        tp := reflect.TypeOf(items)
        if tp == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">switch tp.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                tp = tp.Elem()
                if tp.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                        tp = tp.Elem()
                }</span>

                <span class="cov8" title="1">return reflect.New(tp).Interface()</span>
        }
        <span class="cov8" title="1">return nil</span>
}

func isNumber(kind reflect.Kind) bool <span class="cov8" title="1">{
        return isInt(kind) || isUint(kind) || isFloat(kind)
}</span>

func isInt(kind reflect.Kind) bool <span class="cov8" title="1">{
        switch kind </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func isUint(kind reflect.Kind) bool <span class="cov8" title="1">{
        switch kind </span>{
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}

func isFloat(kind reflect.Kind) bool <span class="cov8" title="1">{
        switch kind </span>{
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file276" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "errors"
        "reflect"
        "sort"
        "strings"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/tpl/compare"
        "github.com/spf13/cast"
)

var sortComp = compare.New(true)

// Sort returns a sorted sequence.
func (ns *Namespace) Sort(seq interface{}, args ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        if seq == nil </span><span class="cov8" title="1">{
                return nil, errors.New("sequence must be provided")
        }</span>

        <span class="cov8" title="1">seqv, isNil := indirect(reflect.ValueOf(seq))
        if isNil </span><span class="cov8" title="1">{
                return nil, errors.New("can't iterate over a nil value")
        }</span>

        <span class="cov8" title="1">var sliceType reflect.Type
        switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                sliceType = seqv.Type()</span>
        case reflect.Map:<span class="cov8" title="1">
                sliceType = reflect.SliceOf(seqv.Type().Elem())</span>
        default:<span class="cov8" title="1">
                return nil, errors.New("can't sort " + reflect.ValueOf(seq).Type().String())</span>
        }

        // Create a list of pairs that will be used to do the sort
        <span class="cov8" title="1">p := pairList{SortAsc: true, SliceType: sliceType}
        p.Pairs = make([]pair, seqv.Len())

        var sortByField string
        for i, l := range args </span><span class="cov8" title="1">{
                dStr, err := cast.ToStringE(l)
                switch </span>{
                case i == 0 &amp;&amp; err != nil:<span class="cov8" title="1">
                        sortByField = ""</span>
                case i == 0 &amp;&amp; err == nil:<span class="cov8" title="1">
                        sortByField = dStr</span>
                case i == 1 &amp;&amp; err == nil &amp;&amp; dStr == "desc":<span class="cov8" title="1">
                        p.SortAsc = false</span>
                case i == 1:<span class="cov8" title="1">
                        p.SortAsc = true</span>
                }
        }
        <span class="cov8" title="1">path := strings.Split(strings.Trim(sortByField, "."), ".")

        switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                for i := 0; i &lt; seqv.Len(); i++ </span><span class="cov8" title="1">{
                        p.Pairs[i].Value = seqv.Index(i)
                        if sortByField == "" || sortByField == "value" </span><span class="cov8" title="1">{
                                p.Pairs[i].Key = p.Pairs[i].Value
                        }</span> else<span class="cov8" title="1"> {
                                v := p.Pairs[i].Value
                                var err error
                                for i, elemName := range path </span><span class="cov8" title="1">{
                                        v, err = evaluateSubElem(v, elemName)
                                        if err != nil </span><span class="cov8" title="1">{
                                                return nil, err
                                        }</span>
                                        <span class="cov8" title="1">if !v.IsValid() </span><span class="cov8" title="1">{
                                                continue</span>
                                        }
                                        // Special handling of lower cased maps.
                                        <span class="cov8" title="1">if params, ok := v.Interface().(maps.Params); ok </span><span class="cov8" title="1">{
                                                v = reflect.ValueOf(params.Get(path[i+1:]...))
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">p.Pairs[i].Key = v</span>
                        }
                }

        case reflect.Map:<span class="cov8" title="1">
                keys := seqv.MapKeys()
                for i := 0; i &lt; seqv.Len(); i++ </span><span class="cov8" title="1">{
                        p.Pairs[i].Value = seqv.MapIndex(keys[i])

                        if sortByField == "" </span><span class="cov8" title="1">{
                                p.Pairs[i].Key = keys[i]
                        }</span> else<span class="cov8" title="1"> if sortByField == "value" </span><span class="cov8" title="1">{
                                p.Pairs[i].Key = p.Pairs[i].Value
                        }</span> else<span class="cov8" title="1"> {
                                v := p.Pairs[i].Value
                                var err error
                                for i, elemName := range path </span><span class="cov8" title="1">{
                                        v, err = evaluateSubElem(v, elemName)
                                        if err != nil </span><span class="cov8" title="1">{
                                                return nil, err
                                        }</span>
                                        <span class="cov8" title="1">if !v.IsValid() </span><span class="cov0" title="0">{
                                                continue</span>
                                        }
                                        // Special handling of lower cased maps.
                                        <span class="cov8" title="1">if params, ok := v.Interface().(maps.Params); ok </span><span class="cov8" title="1">{
                                                v = reflect.ValueOf(params.Get(path[i+1:]...))
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">p.Pairs[i].Key = v</span>
                        }
                }
        }
        <span class="cov8" title="1">return p.sort(), nil</span>
}

// Credit for pair sorting method goes to Andrew Gerrand
// https://groups.google.com/forum/#!topic/golang-nuts/FT7cjmcL7gw
// A data structure to hold a key/value pair.
type pair struct {
        Key   reflect.Value
        Value reflect.Value
}

// A slice of pairs that implements sort.Interface to sort by Value.
type pairList struct {
        Pairs     []pair
        SortAsc   bool
        SliceType reflect.Type
}

func (p pairList) Swap(i, j int) <span class="cov8" title="1">{ p.Pairs[i], p.Pairs[j] = p.Pairs[j], p.Pairs[i] }</span>
func (p pairList) Len() int      <span class="cov8" title="1">{ return len(p.Pairs) }</span>
func (p pairList) Less(i, j int) bool <span class="cov8" title="1">{
        iv := p.Pairs[i].Key
        jv := p.Pairs[j].Key

        if iv.IsValid() </span><span class="cov8" title="1">{
                if jv.IsValid() </span><span class="cov8" title="1">{
                        // can only call Interface() on valid reflect Values
                        return sortComp.Lt(iv.Interface(), jv.Interface())
                }</span>

                // if j is invalid, test i against i's zero value
                <span class="cov8" title="1">return sortComp.Lt(iv.Interface(), reflect.Zero(iv.Type()))</span>
        }

        <span class="cov8" title="1">if jv.IsValid() </span><span class="cov8" title="1">{
                // if i is invalid, test j against j's zero value
                return sortComp.Lt(reflect.Zero(jv.Type()), jv.Interface())
        }</span>

        <span class="cov0" title="0">return false</span>
}

// sorts a pairList and returns a slice of sorted values
func (p pairList) sort() interface{} <span class="cov8" title="1">{
        if p.SortAsc </span><span class="cov8" title="1">{
                sort.Sort(p)
        }</span> else<span class="cov8" title="1"> {
                sort.Sort(sort.Reverse(p))
        }</span>
        <span class="cov8" title="1">sorted := reflect.MakeSlice(p.SliceType, len(p.Pairs), len(p.Pairs))
        for i, v := range p.Pairs </span><span class="cov8" title="1">{
                sorted.Index(i).Set(v.Value)
        }</span>

        <span class="cov8" title="1">return sorted.Interface()</span>
}
</pre>
		
		<pre class="file" id="file277" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "fmt"
        "reflect"

        "github.com/pkg/errors"
)

// SymDiff returns the symmetric difference of s1 and s2.
// Arguments must be either a slice or an array of comparable types.
func (ns *Namespace) SymDiff(s2, s1 interface{}) (interface{}, error) <span class="cov8" title="1">{
        ids1, err := collectIdentities(s1)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ids2, err := collectIdentities(s2)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var slice reflect.Value
        var sliceElemType reflect.Type

        for i, s := range []interface{}{s1, s2} </span><span class="cov8" title="1">{
                v := reflect.ValueOf(s)

                switch v.Kind() </span>{
                case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                        if i == 0 </span><span class="cov8" title="1">{
                                sliceType := v.Type()
                                sliceElemType = sliceType.Elem()
                                slice = reflect.MakeSlice(sliceType, 0, 0)
                        }</span>

                        <span class="cov8" title="1">for i := 0; i &lt; v.Len(); i++ </span><span class="cov8" title="1">{
                                ev, _ := indirectInterface(v.Index(i))
                                key := normalize(ev)

                                // Append if the key is not in their intersection.
                                if ids1[key] != ids2[key] </span><span class="cov8" title="1">{
                                        v, err := convertValue(ev, sliceElemType)
                                        if err != nil </span><span class="cov8" title="1">{
                                                return nil, errors.WithMessage(err, "symdiff: failed to convert value")
                                        }</span>
                                        <span class="cov8" title="1">slice = reflect.Append(slice, v)</span>
                                }
                        }
                default:<span class="cov0" title="0">
                        return nil, fmt.Errorf("arguments to symdiff must be slices or arrays")</span>
                }
        }

        <span class="cov8" title="1">return slice.Interface(), nil</span>
}
</pre>
		
		<pre class="file" id="file278" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package collections

import (
        "errors"
        "fmt"
        "reflect"
        "strings"

        "github.com/gohugoio/hugo/common/maps"
)

// Where returns a filtered subset of a given data type.
func (ns *Namespace) Where(seq, key interface{}, args ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        seqv, isNil := indirect(reflect.ValueOf(seq))
        if isNil </span><span class="cov8" title="1">{
                return nil, errors.New("can't iterate over a nil value of type " + reflect.ValueOf(seq).Type().String())
        }</span>

        <span class="cov8" title="1">mv, op, err := parseWhereArgs(args...)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var path []string
        kv := reflect.ValueOf(key)
        if kv.Kind() == reflect.String </span><span class="cov8" title="1">{
                path = strings.Split(strings.Trim(kv.String(), "."), ".")
        }</span>

        <span class="cov8" title="1">switch seqv.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                return ns.checkWhereArray(seqv, kv, mv, path, op)</span>
        case reflect.Map:<span class="cov8" title="1">
                return ns.checkWhereMap(seqv, kv, mv, path, op)</span>
        default:<span class="cov8" title="1">
                return nil, fmt.Errorf("can't iterate over %v", seq)</span>
        }
}

func (ns *Namespace) checkCondition(v, mv reflect.Value, op string) (bool, error) <span class="cov8" title="1">{
        v, vIsNil := indirect(v)
        if !v.IsValid() </span><span class="cov8" title="1">{
                vIsNil = true
        }</span>

        <span class="cov8" title="1">mv, mvIsNil := indirect(mv)
        if !mv.IsValid() </span><span class="cov8" title="1">{
                mvIsNil = true
        }</span>
        <span class="cov8" title="1">if vIsNil || mvIsNil </span><span class="cov8" title="1">{
                switch op </span>{
                case "", "=", "==", "eq":<span class="cov8" title="1">
                        return vIsNil == mvIsNil, nil</span>
                case "!=", "&lt;&gt;", "ne":<span class="cov8" title="1">
                        return vIsNil != mvIsNil, nil</span>
                }
                <span class="cov8" title="1">return false, nil</span>
        }

        <span class="cov8" title="1">if v.Kind() == reflect.Bool &amp;&amp; mv.Kind() == reflect.Bool </span><span class="cov8" title="1">{
                switch op </span>{
                case "", "=", "==", "eq":<span class="cov8" title="1">
                        return v.Bool() == mv.Bool(), nil</span>
                case "!=", "&lt;&gt;", "ne":<span class="cov8" title="1">
                        return v.Bool() != mv.Bool(), nil</span>
                }
                <span class="cov8" title="1">return false, nil</span>
        }

        <span class="cov8" title="1">var ivp, imvp *int64
        var fvp, fmvp *float64
        var svp, smvp *string
        var slv, slmv interface{}
        var ima []int64
        var fma []float64
        var sma []string

        if mv.Kind() == v.Kind() </span><span class="cov8" title="1">{
                switch v.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                        iv := v.Int()
                        ivp = &amp;iv
                        imv := mv.Int()
                        imvp = &amp;imv</span>
                case reflect.String:<span class="cov8" title="1">
                        sv := v.String()
                        svp = &amp;sv
                        smv := mv.String()
                        smvp = &amp;smv</span>
                case reflect.Float64:<span class="cov8" title="1">
                        fv := v.Float()
                        fvp = &amp;fv
                        fmv := mv.Float()
                        fmvp = &amp;fmv</span>
                case reflect.Struct:<span class="cov8" title="1">
                        switch v.Type() </span>{
                        case timeType:<span class="cov8" title="1">
                                iv := toTimeUnix(v)
                                ivp = &amp;iv
                                imv := toTimeUnix(mv)
                                imvp = &amp;imv</span>
                        }
                case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                        slv = v.Interface()
                        slmv = mv.Interface()</span>
                }
        } else<span class="cov8" title="1"> if isNumber(v.Kind()) &amp;&amp; isNumber(mv.Kind()) </span><span class="cov8" title="1">{
                fv, err := toFloat(v)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">fvp = &amp;fv
                fmv, err := toFloat(mv)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>
                <span class="cov8" title="1">fmvp = &amp;fmv</span>
        } else<span class="cov8" title="1"> {
                if mv.Kind() != reflect.Array &amp;&amp; mv.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">if mv.Len() == 0 </span><span class="cov8" title="1">{
                        return false, nil
                }</span>

                <span class="cov8" title="1">if v.Kind() != reflect.Interface &amp;&amp; mv.Type().Elem().Kind() != reflect.Interface &amp;&amp; mv.Type().Elem() != v.Type() &amp;&amp; v.Kind() != reflect.Array &amp;&amp; v.Kind() != reflect.Slice </span><span class="cov8" title="1">{
                        return false, nil
                }</span>
                <span class="cov8" title="1">switch v.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                        iv := v.Int()
                        ivp = &amp;iv
                        for i := 0; i &lt; mv.Len(); i++ </span><span class="cov8" title="1">{
                                if anInt, err := toInt(mv.Index(i)); err == nil </span><span class="cov8" title="1">{
                                        ima = append(ima, anInt)
                                }</span>
                        }
                case reflect.String:<span class="cov8" title="1">
                        sv := v.String()
                        svp = &amp;sv
                        for i := 0; i &lt; mv.Len(); i++ </span><span class="cov8" title="1">{
                                if aString, err := toString(mv.Index(i)); err == nil </span><span class="cov8" title="1">{
                                        sma = append(sma, aString)
                                }</span>
                        }
                case reflect.Float64:<span class="cov8" title="1">
                        fv := v.Float()
                        fvp = &amp;fv
                        for i := 0; i &lt; mv.Len(); i++ </span><span class="cov8" title="1">{
                                if aFloat, err := toFloat(mv.Index(i)); err == nil </span><span class="cov8" title="1">{
                                        fma = append(fma, aFloat)
                                }</span>
                        }
                case reflect.Struct:<span class="cov8" title="1">
                        switch v.Type() </span>{
                        case timeType:<span class="cov8" title="1">
                                iv := toTimeUnix(v)
                                ivp = &amp;iv
                                for i := 0; i &lt; mv.Len(); i++ </span><span class="cov8" title="1">{
                                        ima = append(ima, toTimeUnix(mv.Index(i)))
                                }</span>
                        }
                case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                        slv = v.Interface()
                        slmv = mv.Interface()</span>
                }
        }

        <span class="cov8" title="1">switch op </span>{
        case "", "=", "==", "eq":<span class="cov8" title="1">
                switch </span>{
                case ivp != nil &amp;&amp; imvp != nil:<span class="cov8" title="1">
                        return *ivp == *imvp, nil</span>
                case svp != nil &amp;&amp; smvp != nil:<span class="cov8" title="1">
                        return *svp == *smvp, nil</span>
                case fvp != nil &amp;&amp; fmvp != nil:<span class="cov8" title="1">
                        return *fvp == *fmvp, nil</span>
                }
        case "!=", "&lt;&gt;", "ne":<span class="cov8" title="1">
                switch </span>{
                case ivp != nil &amp;&amp; imvp != nil:<span class="cov8" title="1">
                        return *ivp != *imvp, nil</span>
                case svp != nil &amp;&amp; smvp != nil:<span class="cov8" title="1">
                        return *svp != *smvp, nil</span>
                case fvp != nil &amp;&amp; fmvp != nil:<span class="cov8" title="1">
                        return *fvp != *fmvp, nil</span>
                }
        case "&gt;=", "ge":<span class="cov8" title="1">
                switch </span>{
                case ivp != nil &amp;&amp; imvp != nil:<span class="cov8" title="1">
                        return *ivp &gt;= *imvp, nil</span>
                case svp != nil &amp;&amp; smvp != nil:<span class="cov8" title="1">
                        return *svp &gt;= *smvp, nil</span>
                case fvp != nil &amp;&amp; fmvp != nil:<span class="cov8" title="1">
                        return *fvp &gt;= *fmvp, nil</span>
                }
        case "&gt;", "gt":<span class="cov8" title="1">
                switch </span>{
                case ivp != nil &amp;&amp; imvp != nil:<span class="cov8" title="1">
                        return *ivp &gt; *imvp, nil</span>
                case svp != nil &amp;&amp; smvp != nil:<span class="cov8" title="1">
                        return *svp &gt; *smvp, nil</span>
                case fvp != nil &amp;&amp; fmvp != nil:<span class="cov8" title="1">
                        return *fvp &gt; *fmvp, nil</span>
                }
        case "&lt;=", "le":<span class="cov8" title="1">
                switch </span>{
                case ivp != nil &amp;&amp; imvp != nil:<span class="cov8" title="1">
                        return *ivp &lt;= *imvp, nil</span>
                case svp != nil &amp;&amp; smvp != nil:<span class="cov8" title="1">
                        return *svp &lt;= *smvp, nil</span>
                case fvp != nil &amp;&amp; fmvp != nil:<span class="cov8" title="1">
                        return *fvp &lt;= *fmvp, nil</span>
                }
        case "&lt;", "lt":<span class="cov8" title="1">
                switch </span>{
                case ivp != nil &amp;&amp; imvp != nil:<span class="cov8" title="1">
                        return *ivp &lt; *imvp, nil</span>
                case svp != nil &amp;&amp; smvp != nil:<span class="cov8" title="1">
                        return *svp &lt; *smvp, nil</span>
                case fvp != nil &amp;&amp; fmvp != nil:<span class="cov8" title="1">
                        return *fvp &lt; *fmvp, nil</span>
                }
        case "in", "not in":<span class="cov8" title="1">
                var r bool
                switch </span>{
                case ivp != nil &amp;&amp; len(ima) &gt; 0:<span class="cov8" title="1">
                        r, _ = ns.In(ima, *ivp)</span>
                case fvp != nil &amp;&amp; len(fma) &gt; 0:<span class="cov8" title="1">
                        r, _ = ns.In(fma, *fvp)</span>
                case svp != nil:<span class="cov8" title="1">
                        if len(sma) &gt; 0 </span><span class="cov8" title="1">{
                                r, _ = ns.In(sma, *svp)
                        }</span> else<span class="cov8" title="1"> if smvp != nil </span><span class="cov8" title="1">{
                                r, _ = ns.In(*smvp, *svp)
                        }</span>
                default:<span class="cov0" title="0">
                        return false, nil</span>
                }
                <span class="cov8" title="1">if op == "not in" </span><span class="cov8" title="1">{
                        return !r, nil
                }</span>
                <span class="cov8" title="1">return r, nil</span>
        case "intersect":<span class="cov8" title="1">
                r, err := ns.Intersect(slv, slmv)
                if err != nil </span><span class="cov0" title="0">{
                        return false, err
                }</span>

                <span class="cov8" title="1">if reflect.TypeOf(r).Kind() == reflect.Slice </span><span class="cov8" title="1">{
                        s := reflect.ValueOf(r)

                        if s.Len() &gt; 0 </span><span class="cov8" title="1">{
                                return true, nil
                        }</span>
                        <span class="cov8" title="1">return false, nil</span>
                }
                <span class="cov0" title="0">return false, errors.New("invalid intersect values")</span>
        default:<span class="cov8" title="1">
                return false, errors.New("no such operator")</span>
        }
        <span class="cov0" title="0">return false, nil</span>
}

func evaluateSubElem(obj reflect.Value, elemName string) (reflect.Value, error) <span class="cov8" title="1">{
        if !obj.IsValid() </span><span class="cov8" title="1">{
                return zero, errors.New("can't evaluate an invalid value")
        }</span>

        <span class="cov8" title="1">typ := obj.Type()
        obj, isNil := indirect(obj)

        if obj.Kind() == reflect.Interface </span><span class="cov8" title="1">{
                // If obj is an interface, we need to inspect the value it contains
                // to see the full set of methods and fields.
                // Indirect returns the value that it points to, which is what's needed
                // below to be able to reflect on its fields.
                obj = reflect.Indirect(obj.Elem())
        }</span>

        // first, check whether obj has a method. In this case, obj is
        // a struct or its pointer. If obj is a struct,
        // to check all T and *T method, use obj pointer type Value
        <span class="cov8" title="1">objPtr := obj
        if objPtr.Kind() != reflect.Interface &amp;&amp; objPtr.CanAddr() </span><span class="cov8" title="1">{
                objPtr = objPtr.Addr()
        }</span>

        <span class="cov8" title="1">mt, ok := objPtr.Type().MethodByName(elemName)
        if ok </span><span class="cov8" title="1">{
                switch </span>{
                case mt.PkgPath != "":<span class="cov0" title="0">
                        return zero, fmt.Errorf("%s is an unexported method of type %s", elemName, typ)</span>
                case mt.Type.NumIn() &gt; 1:<span class="cov8" title="1">
                        return zero, fmt.Errorf("%s is a method of type %s but requires more than 1 parameter", elemName, typ)</span>
                case mt.Type.NumOut() == 0:<span class="cov8" title="1">
                        return zero, fmt.Errorf("%s is a method of type %s but returns no output", elemName, typ)</span>
                case mt.Type.NumOut() &gt; 2:<span class="cov0" title="0">
                        return zero, fmt.Errorf("%s is a method of type %s but returns more than 2 outputs", elemName, typ)</span>
                case mt.Type.NumOut() == 1 &amp;&amp; mt.Type.Out(0).Implements(errorType):<span class="cov8" title="1">
                        return zero, fmt.Errorf("%s is a method of type %s but only returns an error type", elemName, typ)</span>
                case mt.Type.NumOut() == 2 &amp;&amp; !mt.Type.Out(1).Implements(errorType):<span class="cov8" title="1">
                        return zero, fmt.Errorf("%s is a method of type %s returning two values but the second value is not an error type", elemName, typ)</span>
                }
                <span class="cov8" title="1">res := objPtr.Method(mt.Index).Call([]reflect.Value{})
                if len(res) == 2 &amp;&amp; !res[1].IsNil() </span><span class="cov8" title="1">{
                        return zero, fmt.Errorf("error at calling a method %s of type %s: %s", elemName, typ, res[1].Interface().(error))
                }</span>
                <span class="cov8" title="1">return res[0], nil</span>
        }

        // elemName isn't a method so next start to check whether it is
        // a struct field or a map value. In both cases, it mustn't be
        // a nil value
        <span class="cov8" title="1">if isNil </span><span class="cov8" title="1">{
                return zero, fmt.Errorf("can't evaluate a nil pointer of type %s by a struct field or map key name %s", typ, elemName)
        }</span>
        <span class="cov8" title="1">switch obj.Kind() </span>{
        case reflect.Struct:<span class="cov8" title="1">
                ft, ok := obj.Type().FieldByName(elemName)
                if ok </span><span class="cov8" title="1">{
                        if ft.PkgPath != "" &amp;&amp; !ft.Anonymous </span><span class="cov8" title="1">{
                                return zero, fmt.Errorf("%s is an unexported field of struct type %s", elemName, typ)
                        }</span>
                        <span class="cov8" title="1">return obj.FieldByIndex(ft.Index), nil</span>
                }
                <span class="cov8" title="1">return zero, fmt.Errorf("%s isn't a field of struct type %s", elemName, typ)</span>
        case reflect.Map:<span class="cov8" title="1">
                kv := reflect.ValueOf(elemName)
                if kv.Type().AssignableTo(obj.Type().Key()) </span><span class="cov8" title="1">{
                        return obj.MapIndex(kv), nil
                }</span>
                <span class="cov8" title="1">return zero, fmt.Errorf("%s isn't a key of map type %s", elemName, typ)</span>
        }
        <span class="cov8" title="1">return zero, fmt.Errorf("%s is neither a struct field, a method nor a map element of type %s", elemName, typ)</span>
}

// parseWhereArgs parses the end arguments to the where function.  Return a
// match value and an operator, if one is defined.
func parseWhereArgs(args ...interface{}) (mv reflect.Value, op string, err error) <span class="cov8" title="1">{
        switch len(args) </span>{
        case 1:<span class="cov8" title="1">
                mv = reflect.ValueOf(args[0])</span>
        case 2:<span class="cov8" title="1">
                var ok bool
                if op, ok = args[0].(string); !ok </span><span class="cov8" title="1">{
                        err = errors.New("operator argument must be string type")
                        return
                }</span>
                <span class="cov8" title="1">op = strings.TrimSpace(strings.ToLower(op))
                mv = reflect.ValueOf(args[1])</span>
        default:<span class="cov8" title="1">
                err = errors.New("can't evaluate the array by no match argument or more than or equal to two arguments")</span>
        }
        <span class="cov8" title="1">return</span>
}

// checkWhereArray handles the where-matching logic when the seqv value is an
// Array or Slice.
func (ns *Namespace) checkWhereArray(seqv, kv, mv reflect.Value, path []string, op string) (interface{}, error) <span class="cov8" title="1">{
        rv := reflect.MakeSlice(seqv.Type(), 0, 0)

        for i := 0; i &lt; seqv.Len(); i++ </span><span class="cov8" title="1">{
                var vvv reflect.Value
                rvv := seqv.Index(i)

                if kv.Kind() == reflect.String </span><span class="cov8" title="1">{
                        if params, ok := rvv.Interface().(maps.Params); ok </span><span class="cov8" title="1">{
                                vvv = reflect.ValueOf(params.Get(path...))
                        }</span> else<span class="cov8" title="1"> {
                                vvv = rvv
                                for i, elemName := range path </span><span class="cov8" title="1">{
                                        var err error
                                        vvv, err = evaluateSubElem(vvv, elemName)

                                        if err != nil </span><span class="cov8" title="1">{
                                                continue</span>
                                        }

                                        <span class="cov8" title="1">if i &lt; len(path)-1 &amp;&amp; vvv.IsValid() </span><span class="cov8" title="1">{
                                                if params, ok := vvv.Interface().(maps.Params); ok </span><span class="cov8" title="1">{
                                                        // The current path element is the map itself, .Params.
                                                        vvv = reflect.ValueOf(params.Get(path[i+1:]...))
                                                        break</span>
                                                }
                                        }
                                }
                        }
                } else<span class="cov8" title="1"> {
                        vv, _ := indirect(rvv)
                        if vv.Kind() == reflect.Map &amp;&amp; kv.Type().AssignableTo(vv.Type().Key()) </span><span class="cov8" title="1">{
                                vvv = vv.MapIndex(kv)
                        }</span>
                }

                <span class="cov8" title="1">if ok, err := ns.checkCondition(vvv, mv, op); ok </span><span class="cov8" title="1">{
                        rv = reflect.Append(rv, rvv)
                }</span> else<span class="cov8" title="1"> if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return rv.Interface(), nil</span>
}

// checkWhereMap handles the where-matching logic when the seqv value is a Map.
func (ns *Namespace) checkWhereMap(seqv, kv, mv reflect.Value, path []string, op string) (interface{}, error) <span class="cov8" title="1">{
        rv := reflect.MakeMap(seqv.Type())
        keys := seqv.MapKeys()
        for _, k := range keys </span><span class="cov8" title="1">{
                elemv := seqv.MapIndex(k)
                switch elemv.Kind() </span>{
                case reflect.Array, reflect.Slice:<span class="cov0" title="0">
                        r, err := ns.checkWhereArray(elemv, kv, mv, path, op)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov0" title="0">switch rr := reflect.ValueOf(r); rr.Kind() </span>{
                        case reflect.Slice:<span class="cov0" title="0">
                                if rr.Len() &gt; 0 </span><span class="cov0" title="0">{
                                        rv.SetMapIndex(k, elemv)
                                }</span>
                        }
                case reflect.Interface:<span class="cov8" title="1">
                        elemvv, isNil := indirect(elemv)
                        if isNil </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov8" title="1">switch elemvv.Kind() </span>{
                        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                                r, err := ns.checkWhereArray(elemvv, kv, mv, path, op)
                                if err != nil </span><span class="cov0" title="0">{
                                        return nil, err
                                }</span>

                                <span class="cov8" title="1">switch rr := reflect.ValueOf(r); rr.Kind() </span>{
                                case reflect.Slice:<span class="cov8" title="1">
                                        if rr.Len() &gt; 0 </span><span class="cov8" title="1">{
                                                rv.SetMapIndex(k, elemv)
                                        }</span>
                                }
                        }
                }
        }
        <span class="cov8" title="1">return rv.Interface(), nil</span>
}

// toFloat returns the float value if possible.
func toFloat(v reflect.Value) (float64, error) <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return v.Float(), nil</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return v.Convert(reflect.TypeOf(float64(0))).Float(), nil</span>
        case reflect.Interface:<span class="cov8" title="1">
                return toFloat(v.Elem())</span>
        }
        <span class="cov0" title="0">return -1, errors.New("unable to convert value to float")</span>
}

// toInt returns the int value if possible, -1 if not.
// TODO(bep) consolidate all these reflect funcs.
func toInt(v reflect.Value) (int64, error) <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return v.Int(), nil</span>
        case reflect.Interface:<span class="cov8" title="1">
                return toInt(v.Elem())</span>
        }
        <span class="cov8" title="1">return -1, errors.New("unable to convert value to int")</span>
}

func toUint(v reflect.Value) (uint64, error) <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                return v.Uint(), nil</span>
        case reflect.Interface:<span class="cov0" title="0">
                return toUint(v.Elem())</span>
        }
        <span class="cov0" title="0">return 0, errors.New("unable to convert value to uint")</span>
}

// toString returns the string value if possible, "" if not.
func toString(v reflect.Value) (string, error) <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                return v.String(), nil</span>
        case reflect.Interface:<span class="cov8" title="1">
                return toString(v.Elem())</span>
        }
        <span class="cov8" title="1">return "", errors.New("unable to convert value to string")</span>
}

func toTimeUnix(v reflect.Value) int64 <span class="cov8" title="1">{
        if v.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                return toTimeUnix(v.Elem())
        }</span>
        <span class="cov8" title="1">if v.Type() != timeType </span><span class="cov0" title="0">{
                panic("coding error: argument must be time.Time type reflect Value")</span>
        }
        <span class="cov8" title="1">return v.MethodByName("Unix").Call([]reflect.Value{})[0].Int()</span>
}
</pre>
		
		<pre class="file" id="file279" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package compare provides template functions for comparing values.
package compare

import (
        "fmt"
        "reflect"
        "strconv"
        "time"

        "github.com/gohugoio/hugo/compare"

        "github.com/gohugoio/hugo/common/types"
)

// New returns a new instance of the compare-namespaced template functions.
func New(caseInsensitive bool) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{caseInsensitive: caseInsensitive}
}</span>

// Namespace provides template functions for the "compare" namespace.
type Namespace struct {
        // Enable to do case insensitive string compares.
        caseInsensitive bool
}

// Default checks whether a given value is set and returns a default value if it
// is not.  "Set" in this context means non-zero for numeric types and times;
// non-zero length for strings, arrays, slices, and maps;
// any boolean or struct value; or non-nil for any other types.
func (*Namespace) Default(dflt interface{}, given ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        // given is variadic because the following construct will not pass a piped
        // argument when the key is missing:  {{ index . "key" | default "foo" }}
        // The Go template will complain that we got 1 argument when we expected 2.

        if len(given) == 0 </span><span class="cov0" title="0">{
                return dflt, nil
        }</span>
        <span class="cov8" title="1">if len(given) != 1 </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("wrong number of args for default: want 2 got %d", len(given)+1)
        }</span>

        <span class="cov8" title="1">g := reflect.ValueOf(given[0])
        if !g.IsValid() </span><span class="cov8" title="1">{
                return dflt, nil
        }</span>

        <span class="cov8" title="1">set := false

        switch g.Kind() </span>{
        case reflect.Bool:<span class="cov8" title="1">
                set = true</span>
        case reflect.String, reflect.Array, reflect.Slice, reflect.Map:<span class="cov8" title="1">
                set = g.Len() != 0</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                set = g.Int() != 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                set = g.Uint() != 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                set = g.Float() != 0</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov8" title="1">
                set = g.Complex() != 0</span>
        case reflect.Struct:<span class="cov8" title="1">
                switch actual := given[0].(type) </span>{
                case time.Time:<span class="cov8" title="1">
                        set = !actual.IsZero()</span>
                default:<span class="cov8" title="1">
                        set = true</span>
                }
        default:<span class="cov0" title="0">
                set = !g.IsNil()</span>
        }

        <span class="cov8" title="1">if set </span><span class="cov8" title="1">{
                return given[0], nil
        }</span>

        <span class="cov8" title="1">return dflt, nil</span>
}

// Eq returns the boolean truth of arg1 == arg2 || arg1 == arg3 || arg1 == arg4.
func (n *Namespace) Eq(first interface{}, others ...interface{}) bool <span class="cov8" title="1">{
        if n.caseInsensitive </span><span class="cov0" title="0">{
                panic("caseInsensitive not implemented for Eq")</span>
        }
        <span class="cov8" title="1">n.checkComparisonArgCount(1, others...)
        normalize := func(v interface{}) interface{} </span><span class="cov8" title="1">{
                if types.IsNil(v) </span><span class="cov8" title="1">{
                        return nil
                }</span>
                <span class="cov8" title="1">vv := reflect.ValueOf(v)
                switch vv.Kind() </span>{
                case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                        return vv.Int()</span>
                case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                        return vv.Float()</span>
                case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:<span class="cov8" title="1">
                        return vv.Uint()</span>
                case reflect.String:<span class="cov8" title="1">
                        return vv.String()</span>
                default:<span class="cov8" title="1">
                        return v</span>
                }
        }

        <span class="cov8" title="1">normFirst := normalize(first)
        for _, other := range others </span><span class="cov8" title="1">{
                if e, ok := first.(compare.Eqer); ok </span><span class="cov8" title="1">{
                        if e.Eq(other) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">if e, ok := other.(compare.Eqer); ok </span><span class="cov8" title="1">{
                        if e.Eq(first) </span><span class="cov8" title="1">{
                                return true
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">other = normalize(other)
                if reflect.DeepEqual(normFirst, other) </span><span class="cov8" title="1">{
                        return true
                }</span>
        }

        <span class="cov8" title="1">return false</span>
}

// Ne returns the boolean truth of arg1 != arg2 &amp;&amp; arg1 != arg3 &amp;&amp; arg1 != arg4.
func (n *Namespace) Ne(first interface{}, others ...interface{}) bool <span class="cov8" title="1">{
        n.checkComparisonArgCount(1, others...)
        for _, other := range others </span><span class="cov8" title="1">{
                if n.Eq(first, other) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Ge returns the boolean truth of arg1 &gt;= arg2 &amp;&amp; arg1 &gt;= arg3 &amp;&amp; arg1 &gt;= arg4.
func (n *Namespace) Ge(first interface{}, others ...interface{}) bool <span class="cov8" title="1">{
        n.checkComparisonArgCount(1, others...)
        for _, other := range others </span><span class="cov8" title="1">{
                left, right := n.compareGet(first, other)
                if !(left &gt;= right) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Gt returns the boolean truth of arg1 &gt; arg2 &amp;&amp; arg1 &gt; arg3 &amp;&amp; arg1 &gt; arg4.
func (n *Namespace) Gt(first interface{}, others ...interface{}) bool <span class="cov8" title="1">{
        n.checkComparisonArgCount(1, others...)
        for _, other := range others </span><span class="cov8" title="1">{
                left, right := n.compareGet(first, other)
                if !(left &gt; right) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Le returns the boolean truth of arg1 &lt;= arg2 &amp;&amp; arg1 &lt;= arg3 &amp;&amp; arg1 &lt;= arg4.
func (n *Namespace) Le(first interface{}, others ...interface{}) bool <span class="cov8" title="1">{
        n.checkComparisonArgCount(1, others...)
        for _, other := range others </span><span class="cov8" title="1">{
                left, right := n.compareGet(first, other)
                if !(left &lt;= right) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Lt returns the boolean truth of arg1 &lt; arg2 &amp;&amp; arg1 &lt; arg3 &amp;&amp; arg1 &lt; arg4.
func (n *Namespace) Lt(first interface{}, others ...interface{}) bool <span class="cov8" title="1">{
        n.checkComparisonArgCount(1, others...)
        for _, other := range others </span><span class="cov8" title="1">{
                left, right := n.compareGet(first, other)
                if !(left &lt; right) </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

func (n *Namespace) checkComparisonArgCount(min int, others ...interface{}) bool <span class="cov8" title="1">{
        if len(others) &lt; min </span><span class="cov8" title="1">{
                panic("missing arguments for comparison")</span>
        }
        <span class="cov8" title="1">return true</span>
}

// Conditional can be used as a ternary operator.
// It returns a if condition, else b.
func (n *Namespace) Conditional(condition bool, a, b interface{}) interface{} <span class="cov8" title="1">{
        if condition </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">return b</span>
}

func (ns *Namespace) compareGet(a interface{}, b interface{}) (float64, float64) <span class="cov8" title="1">{
        if ac, ok := a.(compare.Comparer); ok </span><span class="cov8" title="1">{
                c := ac.Compare(b)
                if c &lt; 0 </span><span class="cov8" title="1">{
                        return 1, 0
                }</span> else<span class="cov8" title="1"> if c == 0 </span><span class="cov8" title="1">{
                        return 0, 0
                }</span> else<span class="cov8" title="1"> {
                        return 0, 1
                }</span>
        }

        <span class="cov8" title="1">if bc, ok := b.(compare.Comparer); ok </span><span class="cov8" title="1">{
                c := bc.Compare(a)
                if c &lt; 0 </span><span class="cov8" title="1">{
                        return 0, 1
                }</span> else<span class="cov8" title="1"> if c == 0 </span><span class="cov8" title="1">{
                        return 0, 0
                }</span> else<span class="cov8" title="1"> {
                        return 1, 0
                }</span>
        }

        <span class="cov8" title="1">var left, right float64
        var leftStr, rightStr *string
        av := reflect.ValueOf(a)

        switch av.Kind() </span>{
        case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:<span class="cov8" title="1">
                left = float64(av.Len())</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                left = float64(av.Int())</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                left = av.Float()</span>
        case reflect.String:<span class="cov8" title="1">
                var err error
                left, err = strconv.ParseFloat(av.String(), 64)
                if err != nil </span><span class="cov8" title="1">{
                        str := av.String()
                        leftStr = &amp;str
                }</span>
        case reflect.Struct:<span class="cov8" title="1">
                switch av.Type() </span>{
                case timeType:<span class="cov8" title="1">
                        left = float64(toTimeUnix(av))</span>
                }
        case reflect.Bool:<span class="cov0" title="0">
                left = 0
                if av.Bool() </span><span class="cov0" title="0">{
                        left = 1
                }</span>
        }

        <span class="cov8" title="1">bv := reflect.ValueOf(b)

        switch bv.Kind() </span>{
        case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice:<span class="cov8" title="1">
                right = float64(bv.Len())</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                right = float64(bv.Int())</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                right = bv.Float()</span>
        case reflect.String:<span class="cov8" title="1">
                var err error
                right, err = strconv.ParseFloat(bv.String(), 64)
                if err != nil </span><span class="cov8" title="1">{
                        str := bv.String()
                        rightStr = &amp;str
                }</span>
        case reflect.Struct:<span class="cov8" title="1">
                switch bv.Type() </span>{
                case timeType:<span class="cov8" title="1">
                        right = float64(toTimeUnix(bv))</span>
                }
        case reflect.Bool:<span class="cov0" title="0">
                right = 0
                if bv.Bool() </span><span class="cov0" title="0">{
                        right = 1
                }</span>
        }

        <span class="cov8" title="1">if ns.caseInsensitive &amp;&amp; leftStr != nil &amp;&amp; rightStr != nil </span><span class="cov8" title="1">{
                c := compare.Strings(*leftStr, *rightStr)
                if c &lt; 0 </span><span class="cov8" title="1">{
                        return 0, 1
                }</span> else<span class="cov8" title="1"> if c &gt; 0 </span><span class="cov8" title="1">{
                        return 1, 0
                }</span> else<span class="cov0" title="0"> {
                        return 0, 0
                }</span>
        }

        <span class="cov8" title="1">switch </span>{
        case leftStr == nil || rightStr == nil:<span class="cov8" title="1"></span>
        case *leftStr &lt; *rightStr:<span class="cov8" title="1">
                return 0, 1</span>
        case *leftStr &gt; *rightStr:<span class="cov8" title="1">
                return 1, 0</span>
        default:<span class="cov8" title="1">
                return 0, 0</span>
        }

        <span class="cov8" title="1">return left, right</span>
}

var timeType = reflect.TypeOf((*time.Time)(nil)).Elem()

func toTimeUnix(v reflect.Value) int64 <span class="cov8" title="1">{
        if v.Kind() == reflect.Interface </span><span class="cov0" title="0">{
                return toTimeUnix(v.Elem())
        }</span>
        <span class="cov8" title="1">if v.Type() != timeType </span><span class="cov8" title="1">{
                panic("coding error: argument must be time.Time type reflect Value")</span>
        }
        <span class="cov8" title="1">return v.MethodByName("Unix").Call([]reflect.Value{})[0].Int()</span>
}
</pre>
		
		<pre class="file" id="file280" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package compare

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "compare"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(false)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Default,
                        []string{"default"},
                        [][2]string{
                                {`{{ "Hugo Rocks!" | default "Hugo Rules!" }}`, `Hugo Rocks!`},
                                {`{{ "" | default "Hugo Rules!" }}`, `Hugo Rules!`},
                        },
                )

                ns.AddMethodMapping(ctx.Eq,
                        []string{"eq"},
                        [][2]string{
                                {`{{ if eq .Section "blog" }}current{{ end }}`, `current`},
                        },
                )

                ns.AddMethodMapping(ctx.Ge,
                        []string{"ge"},
                        [][2]string{
                                {`{{ if ge .Hugo.Version "0.36" }}Reasonable new Hugo version!{{ end }}`, `Reasonable new Hugo version!`},
                        },
                )

                ns.AddMethodMapping(ctx.Gt,
                        []string{"gt"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Le,
                        []string{"le"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Lt,
                        []string{"lt"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Ne,
                        []string{"ne"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Conditional,
                        []string{"cond"},
                        [][2]string{
                                {`{{ cond (eq (add 2 2) 4) "2+2 is 4" "what?" | safeHTML }}`, `2+2 is 4`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file281" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package crypto provides template functions for cryptographic operations.
package crypto

import (
        "crypto/hmac"
        "crypto/md5"
        "crypto/sha1"
        "crypto/sha256"
        "crypto/sha512"
        "encoding/hex"
        "fmt"
        "hash"

        "github.com/spf13/cast"
)

// New returns a new instance of the crypto-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "crypto" namespace.
type Namespace struct{}

// MD5 hashes the given input and returns its MD5 checksum.
func (ns *Namespace) MD5(in interface{}) (string, error) <span class="cov8" title="1">{
        conv, err := cast.ToStringE(in)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">hash := md5.Sum([]byte(conv))
        return hex.EncodeToString(hash[:]), nil</span>
}

// SHA1 hashes the given input and returns its SHA1 checksum.
func (ns *Namespace) SHA1(in interface{}) (string, error) <span class="cov8" title="1">{
        conv, err := cast.ToStringE(in)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">hash := sha1.Sum([]byte(conv))
        return hex.EncodeToString(hash[:]), nil</span>
}

// SHA256 hashes the given input and returns its SHA256 checksum.
func (ns *Namespace) SHA256(in interface{}) (string, error) <span class="cov8" title="1">{
        conv, err := cast.ToStringE(in)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">hash := sha256.Sum256([]byte(conv))
        return hex.EncodeToString(hash[:]), nil</span>
}

// HMAC returns a cryptographic hash that uses a key to sign a message.
func (ns *Namespace) HMAC(h interface{}, k interface{}, m interface{}) (string, error) <span class="cov8" title="1">{
        ha, err := cast.ToStringE(h)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">var hash func() hash.Hash
        switch ha </span>{
        case "md5":<span class="cov8" title="1">
                hash = md5.New</span>
        case "sha1":<span class="cov8" title="1">
                hash = sha1.New</span>
        case "sha256":<span class="cov8" title="1">
                hash = sha256.New</span>
        case "sha512":<span class="cov8" title="1">
                hash = sha512.New</span>
        default:<span class="cov8" title="1">
                return "", fmt.Errorf("hmac: %s is not a supported hash function", ha)</span>
        }

        <span class="cov8" title="1">msg, err := cast.ToStringE(m)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">key, err := cast.ToStringE(k)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">mac := hmac.New(hash, []byte(key))
        _, err = mac.Write([]byte(msg))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return hex.EncodeToString(mac.Sum(nil)[:]), nil</span>
}
</pre>
		
		<pre class="file" id="file282" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package crypto

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "crypto"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.MD5,
                        []string{"md5"},
                        [][2]string{
                                {`{{ md5 "Hello world, gophers!" }}`, `b3029f756f98f79e7f1b7f1d1f0dd53b`},
                                {`{{ crypto.MD5 "Hello world, gophers!" }}`, `b3029f756f98f79e7f1b7f1d1f0dd53b`},
                        },
                )

                ns.AddMethodMapping(ctx.SHA1,
                        []string{"sha1"},
                        [][2]string{
                                {`{{ sha1 "Hello world, gophers!" }}`, `c8b5b0e33d408246e30f53e32b8f7627a7a649d4`},
                        },
                )

                ns.AddMethodMapping(ctx.SHA256,
                        []string{"sha256"},
                        [][2]string{
                                {`{{ sha256 "Hello world, gophers!" }}`, `6ec43b78da9669f50e4e422575c54bf87536954ccd58280219c393f2ce352b46`},
                        },
                )

                ns.AddMethodMapping(ctx.HMAC,
                        []string{"hmac"},
                        [][2]string{
                                {`{{ hmac "sha256" "Secret key" "Hello world, gophers!" }}`, `b6d11b6c53830b9d87036272ca9fe9d19306b8f9d8aa07b15da27d89e6e34f40`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file283" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package data provides template functions for working with external data
// sources.
package data

import (
        "bytes"
        "encoding/csv"
        "encoding/json"
        "errors"
        "net/http"
        "strings"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/config/security"

        "github.com/gohugoio/hugo/common/types"

        "github.com/gohugoio/hugo/common/constants"
        "github.com/gohugoio/hugo/common/loggers"

        "github.com/spf13/cast"

        "github.com/gohugoio/hugo/cache/filecache"
        "github.com/gohugoio/hugo/deps"
        _errors "github.com/pkg/errors"
)

// New returns a new instance of the data-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                deps:         deps,
                cacheGetCSV:  deps.FileCaches.GetCSVCache(),
                cacheGetJSON: deps.FileCaches.GetJSONCache(),
                client:       http.DefaultClient,
        }
}</span>

// Namespace provides template functions for the "data" namespace.
type Namespace struct {
        deps *deps.Deps

        cacheGetJSON *filecache.Cache
        cacheGetCSV  *filecache.Cache

        client *http.Client
}

// GetCSV expects a data separator and one or n-parts of a URL to a resource which
// can either be a local or a remote one.
// The data separator can be a comma, semi-colon, pipe, etc, but only one character.
// If you provide multiple parts for the URL they will be joined together to the final URL.
// GetCSV returns nil or a slice slice to use in a short code.
func (ns *Namespace) GetCSV(sep string, args ...interface{}) (d [][]string, err error) <span class="cov8" title="1">{
        url, headers := toURLAndHeaders(args)
        cache := ns.cacheGetCSV

        unmarshal := func(b []byte) (bool, error) </span><span class="cov8" title="1">{
                if d, err = parseCSV(b, sep); err != nil </span><span class="cov8" title="1">{
                        err = _errors.Wrapf(err, "failed to parse CSV file %s", url)

                        return true, err
                }</span>

                <span class="cov8" title="1">return false, nil</span>
        }

        <span class="cov8" title="1">var req *http.Request
        req, err = http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, _errors.Wrapf(err, "failed to create request for getCSV for resource %s", url)
        }</span>

        // Add custom user headers.
        <span class="cov8" title="1">addUserProvidedHeaders(headers, req)
        addDefaultHeaders(req, "text/csv", "text/plain")

        err = ns.getResource(cache, unmarshal, req)
        if err != nil </span><span class="cov8" title="1">{
                if security.IsAccessDenied(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ns.deps.Log.(loggers.IgnorableLogger).Errorsf(constants.ErrRemoteGetCSV, "Failed to get CSV resource %q: %s", url, err)
                return nil, nil</span>
        }

        <span class="cov8" title="1">return</span>
}

// GetJSON expects one or n-parts of a URL to a resource which can either be a local or a remote one.
// If you provide multiple parts they will be joined together to the final URL.
// GetJSON returns nil or parsed JSON to use in a short code.
func (ns *Namespace) GetJSON(args ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        var v interface{}
        url, headers := toURLAndHeaders(args)
        cache := ns.cacheGetJSON

        req, err := http.NewRequest("GET", url, nil)
        if err != nil </span><span class="cov0" title="0">{
                return nil, _errors.Wrapf(err, "Failed to create request for getJSON resource %s", url)
        }</span>

        <span class="cov8" title="1">unmarshal := func(b []byte) (bool, error) </span><span class="cov8" title="1">{
                err := json.Unmarshal(b, &amp;v)
                if err != nil </span><span class="cov8" title="1">{
                        return true, err
                }</span>
                <span class="cov8" title="1">return false, nil</span>
        }

        <span class="cov8" title="1">addUserProvidedHeaders(headers, req)
        addDefaultHeaders(req, "application/json")

        err = ns.getResource(cache, unmarshal, req)
        if err != nil </span><span class="cov8" title="1">{
                if security.IsAccessDenied(err) </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">ns.deps.Log.(loggers.IgnorableLogger).Errorsf(constants.ErrRemoteGetJSON, "Failed to get JSON resource %q: %s", url, err)
                return nil, nil</span>
        }

        <span class="cov8" title="1">return v, nil</span>
}

func addDefaultHeaders(req *http.Request, accepts ...string) <span class="cov8" title="1">{
        for _, accept := range accepts </span><span class="cov8" title="1">{
                if !hasHeaderValue(req.Header, "Accept", accept) </span><span class="cov8" title="1">{
                        req.Header.Add("Accept", accept)
                }</span>
        }
        <span class="cov8" title="1">if !hasHeaderKey(req.Header, "User-Agent") </span><span class="cov8" title="1">{
                req.Header.Add("User-Agent", "Hugo Static Site Generator")
        }</span>
}

func addUserProvidedHeaders(headers map[string]interface{}, req *http.Request) <span class="cov8" title="1">{
        if headers == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">for key, val := range headers </span><span class="cov8" title="1">{
                vals := types.ToStringSlicePreserveString(val)
                for _, s := range vals </span><span class="cov8" title="1">{
                        req.Header.Add(key, s)
                }</span>
        }
}

func hasHeaderValue(m http.Header, key, value string) bool <span class="cov8" title="1">{
        var s []string
        var ok bool

        if s, ok = m[key]; !ok </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">for _, v := range s </span><span class="cov8" title="1">{
                if v == value </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

func hasHeaderKey(m http.Header, key string) bool <span class="cov8" title="1">{
        _, ok := m[key]
        return ok
}</span>

func toURLAndHeaders(urlParts []interface{}) (string, map[string]interface{}) <span class="cov8" title="1">{
        if len(urlParts) == 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        // The last argument may be a map.
        <span class="cov8" title="1">headers, err := maps.ToStringMapE(urlParts[len(urlParts)-1])
        if err == nil </span><span class="cov8" title="1">{
                urlParts = urlParts[:len(urlParts)-1]
        }</span> else<span class="cov8" title="1"> {
                headers = nil
        }</span>

        <span class="cov8" title="1">return strings.Join(cast.ToStringSlice(urlParts), ""), headers</span>
}

// parseCSV parses bytes of CSV data into a slice slice string or an error
func parseCSV(c []byte, sep string) ([][]string, error) <span class="cov8" title="1">{
        if len(sep) != 1 </span><span class="cov8" title="1">{
                return nil, errors.New("Incorrect length of CSV separator: " + sep)
        }</span>
        <span class="cov8" title="1">b := bytes.NewReader(c)
        r := csv.NewReader(b)
        rSep := []rune(sep)
        r.Comma = rSep[0]
        r.FieldsPerRecord = 0
        return r.ReadAll()</span>
}
</pre>
		
		<pre class="file" id="file284" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package data

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "data"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.GetCSV,
                        []string{"getCSV"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.GetJSON,
                        []string{"getJSON"},
                        [][2]string{},
                )
                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file285" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package data

import (
        "bytes"
        "io/ioutil"
        "net/http"
        "net/url"
        "path/filepath"
        "time"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/cache/filecache"

        "github.com/gohugoio/hugo/config"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/afero"
)

var (
        resSleep   = time.Second * 2 // if JSON decoding failed sleep for n seconds before retrying
        resRetries = 1               // number of retries to load the JSON from URL
)

// getRemote loads the content of a remote file. This method is thread safe.
func (ns *Namespace) getRemote(cache *filecache.Cache, unmarshal func([]byte) (bool, error), req *http.Request) error <span class="cov8" title="1">{
        url := req.URL.String()
        if err := ns.deps.ExecHelper.Sec().CheckAllowedHTTPURL(url); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if err := ns.deps.ExecHelper.Sec().CheckAllowedHTTPMethod("GET"); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        
        <span class="cov8" title="1">var headers bytes.Buffer
        req.Header.Write(&amp;headers)
        id := helpers.MD5String(url + headers.String())
        var handled bool
        var retry bool

        _, b, err := cache.GetOrCreateBytes(id, func() ([]byte, error) </span><span class="cov8" title="1">{
                var err error
                handled = true
                for i := 0; i &lt;= resRetries; i++ </span><span class="cov8" title="1">{
                        ns.deps.Log.Infof("Downloading: %s ...", url)
                        var res *http.Response
                        res, err = ns.client.Do(req)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">var b []byte
                        b, err = ioutil.ReadAll(res.Body)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">res.Body.Close()

                        if isHTTPError(res) </span><span class="cov8" title="1">{
                                return nil, errors.Errorf("Failed to retrieve remote file: %s, body: %q", http.StatusText(res.StatusCode), b)
                        }</span>

                        <span class="cov8" title="1">retry, err = unmarshal(b)

                        if err == nil </span><span class="cov8" title="1">{
                                // Return it so it can be cached.
                                return b, nil
                        }</span>

                        <span class="cov8" title="1">if !retry </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">ns.deps.Log.Infof("Cannot read remote resource %s: %s", url, err)
                        ns.deps.Log.Infof("Retry #%d for %s and sleeping for %s", i+1, url, resSleep)
                        time.Sleep(resSleep)</span>
                }

                <span class="cov8" title="1">return nil, err</span>
        })

        <span class="cov8" title="1">if !handled </span><span class="cov8" title="1">{
                // This is cached content and should be correct.
                _, err = unmarshal(b)
        }</span>

        <span class="cov8" title="1">return err</span>
}

// getLocal loads the content of a local file
func getLocal(url string, fs afero.Fs, cfg config.Provider) ([]byte, error) <span class="cov8" title="1">{
        filename := filepath.Join(cfg.GetString("workingDir"), url)
        return afero.ReadFile(fs, filename)
}</span>

// getResource loads the content of a local or remote file and returns its content and the
// cache ID used, if relevant.
func (ns *Namespace) getResource(cache *filecache.Cache, unmarshal func(b []byte) (bool, error), req *http.Request) error <span class="cov8" title="1">{
        switch req.URL.Scheme </span>{
        case "":<span class="cov8" title="1">
                url, err := url.QueryUnescape(req.URL.String())
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov8" title="1">b, err := getLocal(url, ns.deps.Fs.Source, ns.deps.Cfg)
                if err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
                <span class="cov8" title="1">_, err = unmarshal(b)
                return err</span>
        default:<span class="cov8" title="1">
                return ns.getRemote(cache, unmarshal, req)</span>
        }
}

func isHTTPError(res *http.Response) bool <span class="cov8" title="1">{
        return res.StatusCode &lt; 200 || res.StatusCode &gt; 299
}</span>
</pre>
		
		<pre class="file" id="file286" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package debug provides template functions to help debugging templates.
package debug

import (
        "github.com/sanity-io/litter"

        "github.com/gohugoio/hugo/deps"
)

// New returns a new instance of the debug-namespaced template functions.
func New(d *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "debug" namespace.
type Namespace struct {
}

// Dump returns a object dump of val as a string.
// Note that not every value passed to Dump will print so nicely, but
// we'll improve on that. We recommend using the "go" Chroma lexer to format the output
// nicely.
// Also note that the output from Dump may change from Hugo version to the next,
// so don't depend on a specific output.
func (ns *Namespace) Dump(val interface{}) string <span class="cov0" title="0">{
        return litter.Sdump(val)
}</span>
</pre>
		
		<pre class="file" id="file287" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package debug

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "debug"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Dump,
                        nil,
                        [][2]string{
                                {`{{- $m := newScratch -}}
{{- $m.Set "Hugo" "Rocks!" -}}
{{- $m.Values | debug.Dump | safeHTML -}}`, "map[string]interface {}{\n  \"Hugo\": \"Rocks!\",\n}"},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file288" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package encoding provides template functions for encoding content.
package encoding

import (
        "encoding/base64"
        "encoding/json"
        "errors"
        "html/template"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/spf13/cast"
)

// New returns a new instance of the encoding-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "encoding" namespace.
type Namespace struct{}

// Base64Decode returns the base64 decoding of the given content.
func (ns *Namespace) Base64Decode(content interface{}) (string, error) <span class="cov8" title="1">{
        conv, err := cast.ToStringE(content)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">dec, err := base64.StdEncoding.DecodeString(conv)
        return string(dec), err</span>
}

// Base64Encode returns the base64 encoding of the given content.
func (ns *Namespace) Base64Encode(content interface{}) (string, error) <span class="cov8" title="1">{
        conv, err := cast.ToStringE(content)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return base64.StdEncoding.EncodeToString([]byte(conv)), nil</span>
}

// Jsonify encodes a given object to JSON.  To pretty print the JSON, pass a map
// or dictionary of options as the first argument.  Supported options are
// "prefix" and "indent".  Each JSON element in the output will begin on a new
// line beginning with prefix followed by one or more copies of indent according
// to the indentation nesting.
func (ns *Namespace) Jsonify(args ...interface{}) (template.HTML, error) <span class="cov8" title="1">{
        var (
                b   []byte
                err error
        )

        switch len(args) </span>{
        case 0:<span class="cov0" title="0">
                return "", nil</span>
        case 1:<span class="cov8" title="1">
                b, err = json.Marshal(args[0])</span>
        case 2:<span class="cov8" title="1">
                var opts map[string]string

                opts, err = maps.ToStringMapStringE(args[0])
                if err != nil </span><span class="cov8" title="1">{
                        break</span>
                }

                <span class="cov8" title="1">b, err = json.MarshalIndent(args[1], opts["prefix"], opts["indent"])</span>
        default:<span class="cov0" title="0">
                err = errors.New("too many arguments to jsonify")</span>
        }

        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return template.HTML(b), nil</span>
}
</pre>
		
		<pre class="file" id="file289" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package encoding

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "encoding"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Base64Decode,
                        []string{"base64Decode"},
                        [][2]string{
                                {`{{ "SGVsbG8gd29ybGQ=" | base64Decode }}`, `Hello world`},
                                {`{{ 42 | base64Encode | base64Decode }}`, `42`},
                        },
                )

                ns.AddMethodMapping(ctx.Base64Encode,
                        []string{"base64Encode"},
                        [][2]string{
                                {`{{ "Hello world" | base64Encode }}`, `SGVsbG8gd29ybGQ=`},
                        },
                )

                ns.AddMethodMapping(ctx.Jsonify,
                        []string{"jsonify"},
                        [][2]string{
                                {`{{ (slice "A" "B" "C") | jsonify }}`, `["A","B","C"]`},
                                {`{{ (slice "A" "B" "C") | jsonify (dict "indent" "  ") }}`, "[\n  \"A\",\n  \"B\",\n  \"C\"\n]"},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file290" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package fmt provides template functions for formatting strings.
package fmt

import (
        _fmt "fmt"

        "github.com/gohugoio/hugo/common/loggers"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
)

// New returns a new instance of the fmt-namespaced template functions.
func New(d *deps.Deps) *Namespace <span class="cov8" title="1">{
        ignorableLogger, ok := d.Log.(loggers.IgnorableLogger)
        if !ok </span><span class="cov0" title="0">{
                ignorableLogger = loggers.NewIgnorableLogger(d.Log)
        }</span>

        <span class="cov8" title="1">distinctLogger := helpers.NewDistinctLogger(d.Log)
        ns := &amp;Namespace{
                distinctLogger: ignorableLogger.Apply(distinctLogger),
        }

        d.BuildStartListeners.Add(func() </span><span class="cov0" title="0">{
                ns.distinctLogger.Reset()
        }</span>)

        <span class="cov8" title="1">return ns</span>
}

// Namespace provides template functions for the "fmt" namespace.
type Namespace struct {
        distinctLogger loggers.IgnorableLogger
}

// Print returns string representation of the passed arguments.
func (ns *Namespace) Print(a ...interface{}) string <span class="cov0" title="0">{
        return _fmt.Sprint(a...)
}</span>

// Printf returns a formatted string representation of the passed arguments.
func (ns *Namespace) Printf(format string, a ...interface{}) string <span class="cov0" title="0">{
        return _fmt.Sprintf(format, a...)
}</span>

// Println returns string representation of the passed arguments ending with a newline.
func (ns *Namespace) Println(a ...interface{}) string <span class="cov0" title="0">{
        return _fmt.Sprintln(a...)
}</span>

// Errorf formats according to a format specifier and logs an ERROR.
// It returns an empty string.
func (ns *Namespace) Errorf(format string, a ...interface{}) string <span class="cov0" title="0">{
        ns.distinctLogger.Errorf(format, a...)
        return ""
}</span>

// Erroridf formats according to a format specifier and logs an ERROR and
// an information text that the error with the given ID can be suppressed in config.
// It returns an empty string.
func (ns *Namespace) Erroridf(id, format string, a ...interface{}) string <span class="cov0" title="0">{
        ns.distinctLogger.Errorsf(id, format, a...)
        return ""
}</span>

// Warnf formats according to a format specifier and logs a WARNING.
// It returns an empty string.
func (ns *Namespace) Warnf(format string, a ...interface{}) string <span class="cov0" title="0">{
        ns.distinctLogger.Warnf(format, a...)
        return ""
}</span>
</pre>
		
		<pre class="file" id="file291" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package fmt

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "fmt"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Print,
                        []string{"print"},
                        [][2]string{
                                {`{{ print "works!" }}`, `works!`},
                        },
                )

                ns.AddMethodMapping(ctx.Println,
                        []string{"println"},
                        [][2]string{
                                {`{{ println "works!" }}`, "works!\n"},
                        },
                )

                ns.AddMethodMapping(ctx.Printf,
                        []string{"printf"},
                        [][2]string{
                                {`{{ printf "%s!" "works" }}`, `works!`},
                        },
                )

                ns.AddMethodMapping(ctx.Errorf,
                        []string{"errorf"},
                        [][2]string{
                                {`{{ errorf "%s." "failed" }}`, ``},
                        },
                )

                ns.AddMethodMapping(ctx.Erroridf,
                        []string{"erroridf"},
                        [][2]string{
                                {`{{ erroridf "my-err-id" "%s." "failed" }}`, ``},
                        },
                )

                ns.AddMethodMapping(ctx.Warnf,
                        []string{"warnf"},
                        [][2]string{
                                {`{{ warnf "%s." "warning" }}`, ``},
                        },
                )
                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file292" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package hugo provides template functions for accessing the Site Hugo object.
package hugo

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "hugo"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                h := d.Site.Hugo()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return h, nil }</span>,
                }

                // We just add the Hugo struct as the namespace here. No method mappings.

                <span class="cov8" title="1">return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file293" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package images provides template functions for manipulating images.
package images

import (
        "image"
        "sync"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/resources/images"
        "github.com/gohugoio/hugo/resources/resource"

        // Importing image codecs for image.DecodeConfig
        _ "image/gif"
        _ "image/jpeg"
        _ "image/png"

        // Import webp codec
        _ "golang.org/x/image/webp"

        "github.com/gohugoio/hugo/deps"
        "github.com/spf13/cast"
)

// New returns a new instance of the images-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                Filters: &amp;images.Filters{},
                cache:   map[string]image.Config{},
                deps:    deps,
        }
}</span>

// Namespace provides template functions for the "images" namespace.
type Namespace struct {
        *images.Filters
        cacheMu sync.RWMutex
        cache   map[string]image.Config

        deps *deps.Deps
}

// Config returns the image.Config for the specified path relative to the
// working directory.
func (ns *Namespace) Config(path interface{}) (image.Config, error) <span class="cov8" title="1">{
        filename, err := cast.ToStringE(path)
        if err != nil </span><span class="cov8" title="1">{
                return image.Config{}, err
        }</span>

        <span class="cov8" title="1">if filename == "" </span><span class="cov8" title="1">{
                return image.Config{}, errors.New("config needs a filename")
        }</span>

        // Check cache for image config.
        <span class="cov8" title="1">ns.cacheMu.RLock()
        config, ok := ns.cache[filename]
        ns.cacheMu.RUnlock()

        if ok </span><span class="cov8" title="1">{
                return config, nil
        }</span>

        <span class="cov8" title="1">f, err := ns.deps.Fs.WorkingDir.Open(filename)
        if err != nil </span><span class="cov8" title="1">{
                return image.Config{}, err
        }</span>
        <span class="cov8" title="1">defer f.Close()

        config, _, err = image.DecodeConfig(f)
        if err != nil </span><span class="cov0" title="0">{
                return config, err
        }</span>

        <span class="cov8" title="1">ns.cacheMu.Lock()
        ns.cache[filename] = config
        ns.cacheMu.Unlock()

        return config, nil</span>
}

func (ns *Namespace) Filter(args ...interface{}) (resource.Image, error) <span class="cov0" title="0">{
        if len(args) &lt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("must provide an image and one or more filters")
        }</span>

        <span class="cov0" title="0">img := args[len(args)-1].(resource.Image)
        filtersv := args[:len(args)-1]

        return img.Filter(filtersv...)</span>
}
</pre>
		
		<pre class="file" id="file294" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package images

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "images"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Config,
                        []string{"imageConfig"},
                        [][2]string{},
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file295" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package inflect provides template functions for the inflection of words.
package inflect

import (
        "strconv"
        "strings"

        _inflect "github.com/gobuffalo/flect"
        "github.com/spf13/cast"
)

// New returns a new instance of the inflect-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "inflect" namespace.
type Namespace struct{}

// Humanize returns the humanized form of a single parameter.
//
// If the parameter is either an integer or a string containing an integer
// value, the behavior is to add the appropriate ordinal.
//
//     Example:  "my-first-post" -&gt; "My first post"
//     Example:  "103" -&gt; "103rd"
//     Example:  52 -&gt; "52nd"
func (ns *Namespace) Humanize(in interface{}) (string, error) <span class="cov8" title="1">{
        word, err := cast.ToStringE(in)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if word == "" </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">_, ok := in.(int)           // original param was literal int value
        _, err = strconv.Atoi(word) // original param was string containing an int value
        if ok || err == nil </span><span class="cov8" title="1">{
                return _inflect.Ordinalize(word), nil
        }</span>

        <span class="cov8" title="1">str := _inflect.Humanize(word)
        return _inflect.Humanize(strings.ToLower(str)), nil</span>
}

// Pluralize returns the plural form of a single word.
func (ns *Namespace) Pluralize(in interface{}) (string, error) <span class="cov8" title="1">{
        word, err := cast.ToStringE(in)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return _inflect.Pluralize(word), nil</span>
}

// Singularize returns the singular form of a single word.
func (ns *Namespace) Singularize(in interface{}) (string, error) <span class="cov8" title="1">{
        word, err := cast.ToStringE(in)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return _inflect.Singularize(word), nil</span>
}
</pre>
		
		<pre class="file" id="file296" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package inflect

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "inflect"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Humanize,
                        []string{"humanize"},
                        [][2]string{
                                {`{{ humanize "my-first-post" }}`, `My first post`},
                                {`{{ humanize "myCamelPost" }}`, `My camel post`},
                                {`{{ humanize "52" }}`, `52nd`},
                                {`{{ humanize 103 }}`, `103rd`},
                        },
                )

                ns.AddMethodMapping(ctx.Pluralize,
                        []string{"pluralize"},
                        [][2]string{
                                {`{{ "cat" | pluralize }}`, `cats`},
                        },
                )

                ns.AddMethodMapping(ctx.Singularize,
                        []string{"singularize"},
                        [][2]string{
                                {`{{ "cats" | singularize }}`, `cat`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file297" style="display: none">// Copyright 2018 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package fmtsort provides a general stable ordering mechanism
// for maps, on behalf of the fmt and text/template packages.
// It is not guaranteed to be efficient and works only for types
// that are valid map keys.
package fmtsort

import (
        "reflect"
        "sort"
)

// Note: Throughout this package we avoid calling reflect.Value.Interface as
// it is not always legal to do so and it's easier to avoid the issue than to face it.

// SortedMap represents a map's keys and values. The keys and values are
// aligned in index order: Value[i] is the value in the map corresponding to Key[i].
type SortedMap struct {
        Key   []reflect.Value
        Value []reflect.Value
}

func (o *SortedMap) Len() int           <span class="cov8" title="1">{ return len(o.Key) }</span>
func (o *SortedMap) Less(i, j int) bool <span class="cov8" title="1">{ return compare(o.Key[i], o.Key[j]) &lt; 0 }</span>
func (o *SortedMap) Swap(i, j int) <span class="cov8" title="1">{
        o.Key[i], o.Key[j] = o.Key[j], o.Key[i]
        o.Value[i], o.Value[j] = o.Value[j], o.Value[i]
}</span>

// Sort accepts a map and returns a SortedMap that has the same keys and
// values but in a stable sorted order according to the keys, modulo issues
// raised by unorderable key values such as NaNs.
//
// The ordering rules are more general than with Go's &lt; operator:
//
//  - when applicable, nil compares low
//  - ints, floats, and strings order by &lt;
//  - NaN compares less than non-NaN floats
//  - bool compares false before true
//  - complex compares real, then imag
//  - pointers compare by machine address
//  - channel values compare by machine address
//  - structs compare each field in turn
//  - arrays compare each element in turn.
//    Otherwise identical arrays compare by length.
//  - interface values compare first by reflect.Type describing the concrete type
//    and then by concrete value as described in the previous rules.
//
func Sort(mapValue reflect.Value) *SortedMap <span class="cov8" title="1">{
        if mapValue.Type().Kind() != reflect.Map </span><span class="cov0" title="0">{
                return nil
        }</span>
        // Note: this code is arranged to not panic even in the presence
        // of a concurrent map update. The runtime is responsible for
        // yelling loudly if that happens. See issue 33275.
        <span class="cov8" title="1">n := mapValue.Len()
        key := make([]reflect.Value, 0, n)
        value := make([]reflect.Value, 0, n)
        iter := mapValue.MapRange()
        for iter.Next() </span><span class="cov8" title="1">{
                key = append(key, iter.Key())
                value = append(value, iter.Value())
        }</span>
        <span class="cov8" title="1">sorted := &amp;SortedMap{
                Key:   key,
                Value: value,
        }
        sort.Stable(sorted)
        return sorted</span>
}

// compare compares two values of the same type. It returns -1, 0, 1
// according to whether a &gt; b (1), a == b (0), or a &lt; b (-1).
// If the types differ, it returns -1.
// See the comment on Sort for the comparison rules.
func compare(aVal, bVal reflect.Value) int <span class="cov8" title="1">{
        aType, bType := aVal.Type(), bVal.Type()
        if aType != bType </span><span class="cov0" title="0">{
                return -1 // No good answer possible, but don't return 0: they're not equal.
        }</span>
        <span class="cov8" title="1">switch aVal.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                a, b := aVal.Int(), bVal.Int()
                switch </span>{
                case a &lt; b:<span class="cov8" title="1">
                        return -1</span>
                case a &gt; b:<span class="cov8" title="1">
                        return 1</span>
                default:<span class="cov8" title="1">
                        return 0</span>
                }
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov8" title="1">
                a, b := aVal.Uint(), bVal.Uint()
                switch </span>{
                case a &lt; b:<span class="cov8" title="1">
                        return -1</span>
                case a &gt; b:<span class="cov8" title="1">
                        return 1</span>
                default:<span class="cov8" title="1">
                        return 0</span>
                }
        case reflect.String:<span class="cov8" title="1">
                a, b := aVal.String(), bVal.String()
                switch </span>{
                case a &lt; b:<span class="cov8" title="1">
                        return -1</span>
                case a &gt; b:<span class="cov8" title="1">
                        return 1</span>
                default:<span class="cov8" title="1">
                        return 0</span>
                }
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return floatCompare(aVal.Float(), bVal.Float())</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov8" title="1">
                a, b := aVal.Complex(), bVal.Complex()
                if c := floatCompare(real(a), real(b)); c != 0 </span><span class="cov8" title="1">{
                        return c
                }</span>
                <span class="cov8" title="1">return floatCompare(imag(a), imag(b))</span>
        case reflect.Bool:<span class="cov8" title="1">
                a, b := aVal.Bool(), bVal.Bool()
                switch </span>{
                case a == b:<span class="cov8" title="1">
                        return 0</span>
                case a:<span class="cov8" title="1">
                        return 1</span>
                default:<span class="cov8" title="1">
                        return -1</span>
                }
        case reflect.Ptr, reflect.UnsafePointer:<span class="cov8" title="1">
                a, b := aVal.Pointer(), bVal.Pointer()
                switch </span>{
                case a &lt; b:<span class="cov8" title="1">
                        return -1</span>
                case a &gt; b:<span class="cov8" title="1">
                        return 1</span>
                default:<span class="cov8" title="1">
                        return 0</span>
                }
        case reflect.Chan:<span class="cov8" title="1">
                if c, ok := nilCompare(aVal, bVal); ok </span><span class="cov0" title="0">{
                        return c
                }</span>
                <span class="cov8" title="1">ap, bp := aVal.Pointer(), bVal.Pointer()
                switch </span>{
                case ap &lt; bp:<span class="cov8" title="1">
                        return -1</span>
                case ap &gt; bp:<span class="cov8" title="1">
                        return 1</span>
                default:<span class="cov8" title="1">
                        return 0</span>
                }
        case reflect.Struct:<span class="cov8" title="1">
                for i := 0; i &lt; aVal.NumField(); i++ </span><span class="cov8" title="1">{
                        if c := compare(aVal.Field(i), bVal.Field(i)); c != 0 </span><span class="cov8" title="1">{
                                return c
                        }</span>
                }
                <span class="cov8" title="1">return 0</span>
        case reflect.Array:<span class="cov8" title="1">
                for i := 0; i &lt; aVal.Len(); i++ </span><span class="cov8" title="1">{
                        if c := compare(aVal.Index(i), bVal.Index(i)); c != 0 </span><span class="cov8" title="1">{
                                return c
                        }</span>
                }
                <span class="cov8" title="1">return 0</span>
        case reflect.Interface:<span class="cov8" title="1">
                if c, ok := nilCompare(aVal, bVal); ok </span><span class="cov0" title="0">{
                        return c
                }</span>
                <span class="cov8" title="1">c := compare(reflect.ValueOf(aVal.Elem().Type()), reflect.ValueOf(bVal.Elem().Type()))
                if c != 0 </span><span class="cov8" title="1">{
                        return c
                }</span>
                <span class="cov8" title="1">return compare(aVal.Elem(), bVal.Elem())</span>
        default:<span class="cov0" title="0">
                // Certain types cannot appear as keys (maps, funcs, slices), but be explicit.
                panic("bad type in compare: " + aType.String())</span>
        }
}

// nilCompare checks whether either value is nil. If not, the boolean is false.
// If either value is nil, the boolean is true and the integer is the comparison
// value. The comparison is defined to be 0 if both are nil, otherwise the one
// nil value compares low. Both arguments must represent a chan, func,
// interface, map, pointer, or slice.
func nilCompare(aVal, bVal reflect.Value) (int, bool) <span class="cov8" title="1">{
        if aVal.IsNil() </span><span class="cov0" title="0">{
                if bVal.IsNil() </span><span class="cov0" title="0">{
                        return 0, true
                }</span>
                <span class="cov0" title="0">return -1, true</span>
        }
        <span class="cov8" title="1">if bVal.IsNil() </span><span class="cov0" title="0">{
                return 1, true
        }</span>
        <span class="cov8" title="1">return 0, false</span>
}

// floatCompare compares two floating-point values. NaNs compare low.
func floatCompare(a, b float64) int <span class="cov8" title="1">{
        switch </span>{
        case isNaN(a):<span class="cov8" title="1">
                return -1</span> // No good answer if b is a NaN so don't bother checking.
        case isNaN(b):<span class="cov8" title="1">
                return 1</span>
        case a &lt; b:<span class="cov8" title="1">
                return -1</span>
        case a &gt; b:<span class="cov8" title="1">
                return 1</span>
        }
        <span class="cov8" title="1">return 0</span>
}

func isNaN(a float64) bool <span class="cov8" title="1">{
        return a != a
}</span>
</pre>
		
		<pre class="file" id="file298" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "strings"
)

// attrTypeMap[n] describes the value of the given attribute.
// If an attribute affects (or can mask) the encoding or interpretation of
// other content, or affects the contents, idempotency, or credentials of a
// network message, then the value in this map is contentTypeUnsafe.
// This map is derived from HTML5, specifically
// https://www.w3.org/TR/html5/Overview.html#attributes-1
// as well as "%URI"-typed attributes from
// https://www.w3.org/TR/html4/index/attributes.html
var attrTypeMap = map[string]contentType{
        "accept":          contentTypePlain,
        "accept-charset":  contentTypeUnsafe,
        "action":          contentTypeURL,
        "alt":             contentTypePlain,
        "archive":         contentTypeURL,
        "async":           contentTypeUnsafe,
        "autocomplete":    contentTypePlain,
        "autofocus":       contentTypePlain,
        "autoplay":        contentTypePlain,
        "background":      contentTypeURL,
        "border":          contentTypePlain,
        "checked":         contentTypePlain,
        "cite":            contentTypeURL,
        "challenge":       contentTypeUnsafe,
        "charset":         contentTypeUnsafe,
        "class":           contentTypePlain,
        "classid":         contentTypeURL,
        "codebase":        contentTypeURL,
        "cols":            contentTypePlain,
        "colspan":         contentTypePlain,
        "content":         contentTypeUnsafe,
        "contenteditable": contentTypePlain,
        "contextmenu":     contentTypePlain,
        "controls":        contentTypePlain,
        "coords":          contentTypePlain,
        "crossorigin":     contentTypeUnsafe,
        "data":            contentTypeURL,
        "datetime":        contentTypePlain,
        "default":         contentTypePlain,
        "defer":           contentTypeUnsafe,
        "dir":             contentTypePlain,
        "dirname":         contentTypePlain,
        "disabled":        contentTypePlain,
        "draggable":       contentTypePlain,
        "dropzone":        contentTypePlain,
        "enctype":         contentTypeUnsafe,
        "for":             contentTypePlain,
        "form":            contentTypeUnsafe,
        "formaction":      contentTypeURL,
        "formenctype":     contentTypeUnsafe,
        "formmethod":      contentTypeUnsafe,
        "formnovalidate":  contentTypeUnsafe,
        "formtarget":      contentTypePlain,
        "headers":         contentTypePlain,
        "height":          contentTypePlain,
        "hidden":          contentTypePlain,
        "high":            contentTypePlain,
        "href":            contentTypeURL,
        "hreflang":        contentTypePlain,
        "http-equiv":      contentTypeUnsafe,
        "icon":            contentTypeURL,
        "id":              contentTypePlain,
        "ismap":           contentTypePlain,
        "keytype":         contentTypeUnsafe,
        "kind":            contentTypePlain,
        "label":           contentTypePlain,
        "lang":            contentTypePlain,
        "language":        contentTypeUnsafe,
        "list":            contentTypePlain,
        "longdesc":        contentTypeURL,
        "loop":            contentTypePlain,
        "low":             contentTypePlain,
        "manifest":        contentTypeURL,
        "max":             contentTypePlain,
        "maxlength":       contentTypePlain,
        "media":           contentTypePlain,
        "mediagroup":      contentTypePlain,
        "method":          contentTypeUnsafe,
        "min":             contentTypePlain,
        "multiple":        contentTypePlain,
        "name":            contentTypePlain,
        "novalidate":      contentTypeUnsafe,
        // Skip handler names from
        // https://www.w3.org/TR/html5/webappapis.html#event-handlers-on-elements,-document-objects,-and-window-objects
        // since we have special handling in attrType.
        "open":        contentTypePlain,
        "optimum":     contentTypePlain,
        "pattern":     contentTypeUnsafe,
        "placeholder": contentTypePlain,
        "poster":      contentTypeURL,
        "profile":     contentTypeURL,
        "preload":     contentTypePlain,
        "pubdate":     contentTypePlain,
        "radiogroup":  contentTypePlain,
        "readonly":    contentTypePlain,
        "rel":         contentTypeUnsafe,
        "required":    contentTypePlain,
        "reversed":    contentTypePlain,
        "rows":        contentTypePlain,
        "rowspan":     contentTypePlain,
        "sandbox":     contentTypeUnsafe,
        "spellcheck":  contentTypePlain,
        "scope":       contentTypePlain,
        "scoped":      contentTypePlain,
        "seamless":    contentTypePlain,
        "selected":    contentTypePlain,
        "shape":       contentTypePlain,
        "size":        contentTypePlain,
        "sizes":       contentTypePlain,
        "span":        contentTypePlain,
        "src":         contentTypeURL,
        "srcdoc":      contentTypeHTML,
        "srclang":     contentTypePlain,
        "srcset":      contentTypeSrcset,
        "start":       contentTypePlain,
        "step":        contentTypePlain,
        "style":       contentTypeCSS,
        "tabindex":    contentTypePlain,
        "target":      contentTypePlain,
        "title":       contentTypePlain,
        "type":        contentTypeUnsafe,
        "usemap":      contentTypeURL,
        "value":       contentTypeUnsafe,
        "width":       contentTypePlain,
        "wrap":        contentTypePlain,
        "xmlns":       contentTypeURL,
}

// attrType returns a conservative (upper-bound on authority) guess at the
// type of the lowercase named attribute.
func attrType(name string) contentType <span class="cov8" title="1">{
        if strings.HasPrefix(name, "data-") </span><span class="cov8" title="1">{
                // Strip data- so that custom attribute heuristics below are
                // widely applied.
                // Treat data-action as URL below.
                name = name[5:]
        }</span> else<span class="cov8" title="1"> if colon := strings.IndexRune(name, ':'); colon != -1 </span><span class="cov8" title="1">{
                if name[:colon] == "xmlns" </span><span class="cov8" title="1">{
                        return contentTypeURL
                }</span>
                // Treat svg:href and xlink:href as href below.
                <span class="cov8" title="1">name = name[colon+1:]</span>
        }
        <span class="cov8" title="1">if t, ok := attrTypeMap[name]; ok </span><span class="cov8" title="1">{
                return t
        }</span>
        // Treat partial event handler names as script.
        <span class="cov8" title="1">if strings.HasPrefix(name, "on") </span><span class="cov8" title="1">{
                return contentTypeJS
        }</span>

        // Heuristics to prevent "javascript:..." injection in custom
        // data attributes and custom attributes like g:tweetUrl.
        // https://www.w3.org/TR/html5/dom.html#embedding-custom-non-visible-data-with-the-data-*-attributes
        // "Custom data attributes are intended to store custom data
        //  private to the page or application, for which there are no
        //  more appropriate attributes or elements."
        // Developers seem to store URL content in data URLs that start
        // or end with "URI" or "URL".
        <span class="cov8" title="1">if strings.Contains(name, "src") ||
                strings.Contains(name, "uri") ||
                strings.Contains(name, "url") </span><span class="cov8" title="1">{
                return contentTypeURL
        }</span>
        <span class="cov8" title="1">return contentTypePlain</span>
}
</pre>
		
		<pre class="file" id="file299" style="display: none">// Code generated by "stringer -type attr"; DO NOT EDIT.

package template

import "strconv"

const _attr_name = "attrNoneattrScriptattrScriptTypeattrStyleattrURLattrSrcset"

var _attr_index = [...]uint8{0, 8, 18, 32, 41, 48, 58}

func (i attr) String() string <span class="cov8" title="1">{
        if i &gt;= attr(len(_attr_index)-1) </span><span class="cov0" title="0">{
                return "attr(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov8" title="1">return _attr_name[_attr_index[i]:_attr_index[i+1]]</span>
}
</pre>
		
		<pre class="file" id="file300" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "fmt"
        htmltemplate "html/template"
        "reflect"
)

type contentType uint8

const (
        contentTypePlain contentType = iota
        contentTypeCSS
        contentTypeHTML
        contentTypeHTMLAttr
        contentTypeJS
        contentTypeJSStr
        contentTypeURL
        contentTypeSrcset
        // contentTypeUnsafe is used in attr.go for values that affect how
        // embedded content and network messages are formed, vetted,
        // or interpreted; or which credentials network messages carry.
        contentTypeUnsafe
)

// indirect returns the value, after dereferencing as many times
// as necessary to reach the base type (or nil).
func indirect(a interface{}) interface{} <span class="cov8" title="1">{
        if a == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if t := reflect.TypeOf(a); t.Kind() != reflect.Ptr </span><span class="cov8" title="1">{
                // Avoid creating a reflect.Value if it's not a pointer.
                return a
        }</span>
        <span class="cov8" title="1">v := reflect.ValueOf(a)
        for v.Kind() == reflect.Ptr &amp;&amp; !v.IsNil() </span><span class="cov8" title="1">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">return v.Interface()</span>
}

var (
        errorType       = reflect.TypeOf((*error)(nil)).Elem()
        fmtStringerType = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()
)

// indirectToStringerOrError returns the value, after dereferencing as many times
// as necessary to reach the base type (or nil) or an implementation of fmt.Stringer
// or error,
func indirectToStringerOrError(a interface{}) interface{} <span class="cov8" title="1">{
        if a == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">v := reflect.ValueOf(a)
        for !v.Type().Implements(fmtStringerType) &amp;&amp; !v.Type().Implements(errorType) &amp;&amp; v.Kind() == reflect.Ptr &amp;&amp; !v.IsNil() </span><span class="cov8" title="1">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">return v.Interface()</span>
}

// stringify converts its arguments to a string and the type of the content.
// All pointers are dereferenced, as in the text/template package.
func stringify(args ...interface{}) (string, contentType) <span class="cov8" title="1">{
        if len(args) == 1 </span><span class="cov8" title="1">{
                switch s := indirect(args[0]).(type) </span>{
                case string:<span class="cov8" title="1">
                        return s, contentTypePlain</span>
                case htmltemplate.CSS:<span class="cov8" title="1">
                        return string(s), contentTypeCSS</span>
                case htmltemplate.HTML:<span class="cov8" title="1">
                        return string(s), contentTypeHTML</span>
                case htmltemplate.HTMLAttr:<span class="cov8" title="1">
                        return string(s), contentTypeHTMLAttr</span>
                case htmltemplate.JS:<span class="cov8" title="1">
                        return string(s), contentTypeJS</span>
                case htmltemplate.JSStr:<span class="cov8" title="1">
                        return string(s), contentTypeJSStr</span>
                case htmltemplate.URL:<span class="cov8" title="1">
                        return string(s), contentTypeURL</span>
                case htmltemplate.Srcset:<span class="cov8" title="1">
                        return string(s), contentTypeSrcset</span>
                }
        }
        <span class="cov8" title="1">i := 0
        for _, arg := range args </span><span class="cov8" title="1">{
                // We skip untyped nil arguments for backward compatibility.
                // Without this they would be output as &lt;nil&gt;, escaped.
                // See issue 25875.
                if arg == nil </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">args[i] = indirectToStringerOrError(arg)
                i++</span>
        }
        <span class="cov8" title="1">return fmt.Sprint(args[:i]...), contentTypePlain</span>
}
</pre>
		
		<pre class="file" id="file301" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import "fmt"

// context describes the state an HTML parser must be in when it reaches the
// portion of HTML produced by evaluating a particular template node.
//
// The zero value of type context is the start context for a template that
// produces an HTML fragment as defined at
// https://www.w3.org/TR/html5/syntax.html#the-end
// where the context element is null.
type context struct {
        state   state
        delim   delim
        urlPart urlPart
        jsCtx   jsCtx
        attr    attr
        element element
        err     *Error
}

func (c context) String() string <span class="cov8" title="1">{
        var err error
        if c.err != nil </span><span class="cov0" title="0">{
                err = c.err
        }</span>
        <span class="cov8" title="1">return fmt.Sprintf("{%v %v %v %v %v %v %v}", c.state, c.delim, c.urlPart, c.jsCtx, c.attr, c.element, err)</span>
}

// eq reports whether two contexts are equal.
func (c context) eq(d context) bool <span class="cov8" title="1">{
        return c.state == d.state &amp;&amp;
                c.delim == d.delim &amp;&amp;
                c.urlPart == d.urlPart &amp;&amp;
                c.jsCtx == d.jsCtx &amp;&amp;
                c.attr == d.attr &amp;&amp;
                c.element == d.element &amp;&amp;
                c.err == d.err
}</span>

// mangle produces an identifier that includes a suffix that distinguishes it
// from template names mangled with different contexts.
func (c context) mangle(templateName string) string <span class="cov8" title="1">{
        // The mangled name for the default context is the input templateName.
        if c.state == stateText </span><span class="cov8" title="1">{
                return templateName
        }</span>
        <span class="cov8" title="1">s := templateName + "$htmltemplate_" + c.state.String()
        if c.delim != delimNone </span><span class="cov8" title="1">{
                s += "_" + c.delim.String()
        }</span>
        <span class="cov8" title="1">if c.urlPart != urlPartNone </span><span class="cov0" title="0">{
                s += "_" + c.urlPart.String()
        }</span>
        <span class="cov8" title="1">if c.jsCtx != jsCtxRegexp </span><span class="cov8" title="1">{
                s += "_" + c.jsCtx.String()
        }</span>
        <span class="cov8" title="1">if c.attr != attrNone </span><span class="cov8" title="1">{
                s += "_" + c.attr.String()
        }</span>
        <span class="cov8" title="1">if c.element != elementNone </span><span class="cov8" title="1">{
                s += "_" + c.element.String()
        }</span>
        <span class="cov8" title="1">return s</span>
}

// state describes a high-level HTML parser state.
//
// It bounds the top of the element stack, and by extension the HTML insertion
// mode, but also contains state that does not correspond to anything in the
// HTML5 parsing algorithm because a single token production in the HTML
// grammar may contain embedded actions in a template. For instance, the quoted
// HTML attribute produced by
//     &lt;div title="Hello {{.World}}"&gt;
// is a single token in HTML's grammar but in a template spans several nodes.
type state uint8

//go:generate stringer -type state

const (
        // stateText is parsed character data. An HTML parser is in
        // this state when its parse position is outside an HTML tag,
        // directive, comment, and special element body.
        stateText state = iota
        // stateTag occurs before an HTML attribute or the end of a tag.
        stateTag
        // stateAttrName occurs inside an attribute name.
        // It occurs between the ^'s in ` ^name^ = value`.
        stateAttrName
        // stateAfterName occurs after an attr name has ended but before any
        // equals sign. It occurs between the ^'s in ` name^ ^= value`.
        stateAfterName
        // stateBeforeValue occurs after the equals sign but before the value.
        // It occurs between the ^'s in ` name =^ ^value`.
        stateBeforeValue
        // stateHTMLCmt occurs inside an &lt;!-- HTML comment --&gt;.
        stateHTMLCmt
        // stateRCDATA occurs inside an RCDATA element (&lt;textarea&gt; or &lt;title&gt;)
        // as described at https://www.w3.org/TR/html5/syntax.html#elements-0
        stateRCDATA
        // stateAttr occurs inside an HTML attribute whose content is text.
        stateAttr
        // stateURL occurs inside an HTML attribute whose content is a URL.
        stateURL
        // stateSrcset occurs inside an HTML srcset attribute.
        stateSrcset
        // stateJS occurs inside an event handler or script element.
        stateJS
        // stateJSDqStr occurs inside a JavaScript double quoted string.
        stateJSDqStr
        // stateJSSqStr occurs inside a JavaScript single quoted string.
        stateJSSqStr
        // stateJSRegexp occurs inside a JavaScript regexp literal.
        stateJSRegexp
        // stateJSBlockCmt occurs inside a JavaScript /* block comment */.
        stateJSBlockCmt
        // stateJSLineCmt occurs inside a JavaScript // line comment.
        stateJSLineCmt
        // stateCSS occurs inside a &lt;style&gt; element or style attribute.
        stateCSS
        // stateCSSDqStr occurs inside a CSS double quoted string.
        stateCSSDqStr
        // stateCSSSqStr occurs inside a CSS single quoted string.
        stateCSSSqStr
        // stateCSSDqURL occurs inside a CSS double quoted url("...").
        stateCSSDqURL
        // stateCSSSqURL occurs inside a CSS single quoted url('...').
        stateCSSSqURL
        // stateCSSURL occurs inside a CSS unquoted url(...).
        stateCSSURL
        // stateCSSBlockCmt occurs inside a CSS /* block comment */.
        stateCSSBlockCmt
        // stateCSSLineCmt occurs inside a CSS // line comment.
        stateCSSLineCmt
        // stateError is an infectious error state outside any valid
        // HTML/CSS/JS construct.
        stateError
)

// isComment is true for any state that contains content meant for template
// authors &amp; maintainers, not for end-users or machines.
func isComment(s state) bool <span class="cov8" title="1">{
        switch s </span>{
        case stateHTMLCmt, stateJSBlockCmt, stateJSLineCmt, stateCSSBlockCmt, stateCSSLineCmt:<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isInTag return whether s occurs solely inside an HTML tag.
func isInTag(s state) bool <span class="cov8" title="1">{
        switch s </span>{
        case stateTag, stateAttrName, stateAfterName, stateBeforeValue, stateAttr:<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// delim is the delimiter that will end the current HTML attribute.
type delim uint8

//go:generate stringer -type delim

const (
        // delimNone occurs outside any attribute.
        delimNone delim = iota
        // delimDoubleQuote occurs when a double quote (") closes the attribute.
        delimDoubleQuote
        // delimSingleQuote occurs when a single quote (') closes the attribute.
        delimSingleQuote
        // delimSpaceOrTagEnd occurs when a space or right angle bracket (&gt;)
        // closes the attribute.
        delimSpaceOrTagEnd
)

// urlPart identifies a part in an RFC 3986 hierarchical URL to allow different
// encoding strategies.
type urlPart uint8

//go:generate stringer -type urlPart

const (
        // urlPartNone occurs when not in a URL, or possibly at the start:
        // ^ in "^http://auth/path?k=v#frag".
        urlPartNone urlPart = iota
        // urlPartPreQuery occurs in the scheme, authority, or path; between the
        // ^s in "h^ttp://auth/path^?k=v#frag".
        urlPartPreQuery
        // urlPartQueryOrFrag occurs in the query portion between the ^s in
        // "http://auth/path?^k=v#frag^".
        urlPartQueryOrFrag
        // urlPartUnknown occurs due to joining of contexts both before and
        // after the query separator.
        urlPartUnknown
)

// jsCtx determines whether a '/' starts a regular expression literal or a
// division operator.
type jsCtx uint8

//go:generate stringer -type jsCtx

const (
        // jsCtxRegexp occurs where a '/' would start a regexp literal.
        jsCtxRegexp jsCtx = iota
        // jsCtxDivOp occurs where a '/' would start a division operator.
        jsCtxDivOp
        // jsCtxUnknown occurs where a '/' is ambiguous due to context joining.
        jsCtxUnknown
)

// element identifies the HTML element when inside a start tag or special body.
// Certain HTML element (for example &lt;script&gt; and &lt;style&gt;) have bodies that are
// treated differently from stateText so the element type is necessary to
// transition into the correct context at the end of a tag and to identify the
// end delimiter for the body.
type element uint8

//go:generate stringer -type element

const (
        // elementNone occurs outside a special tag or special element body.
        elementNone element = iota
        // elementScript corresponds to the raw text &lt;script&gt; element
        // with JS MIME type or no type attribute.
        elementScript
        // elementStyle corresponds to the raw text &lt;style&gt; element.
        elementStyle
        // elementTextarea corresponds to the RCDATA &lt;textarea&gt; element.
        elementTextarea
        // elementTitle corresponds to the RCDATA &lt;title&gt; element.
        elementTitle
)

//go:generate stringer -type attr

// attr identifies the current HTML attribute when inside the attribute,
// that is, starting from stateAttrName until stateTag/stateText (exclusive).
type attr uint8

const (
        // attrNone corresponds to a normal attribute or no attribute.
        attrNone attr = iota
        // attrScript corresponds to an event handler attribute.
        attrScript
        // attrScriptType corresponds to the type attribute in script HTML element
        attrScriptType
        // attrStyle corresponds to the style attribute whose value is CSS.
        attrStyle
        // attrURL corresponds to an attribute whose value is a URL.
        attrURL
        // attrSrcset corresponds to a srcset attribute.
        attrSrcset
)
</pre>
		
		<pre class="file" id="file302" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "bytes"
        "fmt"
        "strings"
        "unicode"
        "unicode/utf8"
)

// endsWithCSSKeyword reports whether b ends with an ident that
// case-insensitively matches the lower-case kw.
func endsWithCSSKeyword(b []byte, kw string) bool <span class="cov8" title="1">{
        i := len(b) - len(kw)
        if i &lt; 0 </span><span class="cov8" title="1">{
                // Too short.
                return false
        }</span>
        <span class="cov8" title="1">if i != 0 </span><span class="cov8" title="1">{
                r, _ := utf8.DecodeLastRune(b[:i])
                if isCSSNmchar(r) </span><span class="cov8" title="1">{
                        // Too long.
                        return false
                }</span>
        }
        // Many CSS keywords, such as "!important" can have characters encoded,
        // but the URI production does not allow that according to
        // https://www.w3.org/TR/css3-syntax/#TOK-URI
        // This does not attempt to recognize encoded keywords. For example,
        // given "\75\72\6c" and "url" this return false.
        <span class="cov8" title="1">return string(bytes.ToLower(b[i:])) == kw</span>
}

// isCSSNmchar reports whether rune is allowed anywhere in a CSS identifier.
func isCSSNmchar(r rune) bool <span class="cov8" title="1">{
        // Based on the CSS3 nmchar production but ignores multi-rune escape
        // sequences.
        // https://www.w3.org/TR/css3-syntax/#SUBTOK-nmchar
        return 'a' &lt;= r &amp;&amp; r &lt;= 'z' ||
                'A' &lt;= r &amp;&amp; r &lt;= 'Z' ||
                '0' &lt;= r &amp;&amp; r &lt;= '9' ||
                r == '-' ||
                r == '_' ||
                // Non-ASCII cases below.
                0x80 &lt;= r &amp;&amp; r &lt;= 0xd7ff ||
                0xe000 &lt;= r &amp;&amp; r &lt;= 0xfffd ||
                0x10000 &lt;= r &amp;&amp; r &lt;= 0x10ffff
}</span>

// decodeCSS decodes CSS3 escapes given a sequence of stringchars.
// If there is no change, it returns the input, otherwise it returns a slice
// backed by a new array.
// https://www.w3.org/TR/css3-syntax/#SUBTOK-stringchar defines stringchar.
func decodeCSS(s []byte) []byte <span class="cov8" title="1">{
        i := bytes.IndexByte(s, '\\')
        if i == -1 </span><span class="cov8" title="1">{
                return s
        }</span>
        // The UTF-8 sequence for a codepoint is never longer than 1 + the
        // number hex digits need to represent that codepoint, so len(s) is an
        // upper bound on the output length.
        <span class="cov8" title="1">b := make([]byte, 0, len(s))
        for len(s) != 0 </span><span class="cov8" title="1">{
                i := bytes.IndexByte(s, '\\')
                if i == -1 </span><span class="cov8" title="1">{
                        i = len(s)
                }</span>
                <span class="cov8" title="1">b, s = append(b, s[:i]...), s[i:]
                if len(s) &lt; 2 </span><span class="cov8" title="1">{
                        break</span>
                }
                // https://www.w3.org/TR/css3-syntax/#SUBTOK-escape
                // escape ::= unicode | '\' [#x20-#x7E#x80-#xD7FF#xE000-#xFFFD#x10000-#x10FFFF]
                <span class="cov8" title="1">if isHex(s[1]) </span><span class="cov8" title="1">{
                        // https://www.w3.org/TR/css3-syntax/#SUBTOK-unicode
                        //   unicode ::= '\' [0-9a-fA-F]{1,6} wc?
                        j := 2
                        for j &lt; len(s) &amp;&amp; j &lt; 7 &amp;&amp; isHex(s[j]) </span><span class="cov8" title="1">{
                                j++
                        }</span>
                        <span class="cov8" title="1">r := hexDecode(s[1:j])
                        if r &gt; unicode.MaxRune </span><span class="cov0" title="0">{
                                r, j = r/16, j-1
                        }</span>
                        <span class="cov8" title="1">n := utf8.EncodeRune(b[len(b):cap(b)], r)
                        // The optional space at the end allows a hex
                        // sequence to be followed by a literal hex.
                        // string(decodeCSS([]byte(`\A B`))) == "\nB"
                        b, s = b[:len(b)+n], skipCSSSpace(s[j:])</span>
                } else<span class="cov8" title="1"> {
                        // `\\` decodes to `\` and `\"` to `"`.
                        _, n := utf8.DecodeRune(s[1:])
                        b, s = append(b, s[1:1+n]...), s[1+n:]
                }</span>
        }
        <span class="cov8" title="1">return b</span>
}

// isHex reports whether the given character is a hex digit.
func isHex(c byte) bool <span class="cov8" title="1">{
        return '0' &lt;= c &amp;&amp; c &lt;= '9' || 'a' &lt;= c &amp;&amp; c &lt;= 'f' || 'A' &lt;= c &amp;&amp; c &lt;= 'F'
}</span>

// hexDecode decodes a short hex digit sequence: "10" -&gt; 16.
func hexDecode(s []byte) rune <span class="cov8" title="1">{
        n := '\x00'
        for _, c := range s </span><span class="cov8" title="1">{
                n &lt;&lt;= 4
                switch </span>{
                case '0' &lt;= c &amp;&amp; c &lt;= '9':<span class="cov8" title="1">
                        n |= rune(c - '0')</span>
                case 'a' &lt;= c &amp;&amp; c &lt;= 'f':<span class="cov8" title="1">
                        n |= rune(c-'a') + 10</span>
                case 'A' &lt;= c &amp;&amp; c &lt;= 'F':<span class="cov8" title="1">
                        n |= rune(c-'A') + 10</span>
                default:<span class="cov0" title="0">
                        panic(fmt.Sprintf("Bad hex digit in %q", s))</span>
                }
        }
        <span class="cov8" title="1">return n</span>
}

// skipCSSSpace returns a suffix of c, skipping over a single space.
func skipCSSSpace(c []byte) []byte <span class="cov8" title="1">{
        if len(c) == 0 </span><span class="cov8" title="1">{
                return c
        }</span>
        // wc ::= #x9 | #xA | #xC | #xD | #x20
        <span class="cov8" title="1">switch c[0] </span>{
        case '\t', '\n', '\f', ' ':<span class="cov8" title="1">
                return c[1:]</span>
        case '\r':<span class="cov8" title="1">
                // This differs from CSS3's wc production because it contains a
                // probable spec error whereby wc contains all the single byte
                // sequences in nl (newline) but not CRLF.
                if len(c) &gt;= 2 &amp;&amp; c[1] == '\n' </span><span class="cov8" title="1">{
                        return c[2:]
                }</span>
                <span class="cov8" title="1">return c[1:]</span>
        }
        <span class="cov8" title="1">return c</span>
}

// isCSSSpace reports whether b is a CSS space char as defined in wc.
func isCSSSpace(b byte) bool <span class="cov8" title="1">{
        switch b </span>{
        case '\t', '\n', '\f', '\r', ' ':<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// cssEscaper escapes HTML and CSS special characters using \&lt;hex&gt;+ escapes.
func cssEscaper(args ...interface{}) string <span class="cov8" title="1">{
        s, _ := stringify(args...)
        var b strings.Builder
        r, w, written := rune(0), 0, 0
        for i := 0; i &lt; len(s); i += w </span><span class="cov8" title="1">{
                // See comment in htmlEscaper.
                r, w = utf8.DecodeRuneInString(s[i:])
                var repl string
                switch </span>{
                case int(r) &lt; len(cssReplacementTable) &amp;&amp; cssReplacementTable[r] != "":<span class="cov8" title="1">
                        repl = cssReplacementTable[r]</span>
                default:<span class="cov8" title="1">
                        continue</span>
                }
                <span class="cov8" title="1">if written == 0 </span><span class="cov8" title="1">{
                        b.Grow(len(s))
                }</span>
                <span class="cov8" title="1">b.WriteString(s[written:i])
                b.WriteString(repl)
                written = i + w
                if repl != `\\` &amp;&amp; (written == len(s) || isHex(s[written]) || isCSSSpace(s[written])) </span><span class="cov8" title="1">{
                        b.WriteByte(' ')
                }</span>
        }
        <span class="cov8" title="1">if written == 0 </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">b.WriteString(s[written:])
        return b.String()</span>
}

var cssReplacementTable = []string{
        0:    `\0`,
        '\t': `\9`,
        '\n': `\a`,
        '\f': `\c`,
        '\r': `\d`,
        // Encode HTML specials as hex so the output can be embedded
        // in HTML attributes without further encoding.
        '"':  `\22`,
        '&amp;':  `\26`,
        '\'': `\27`,
        '(':  `\28`,
        ')':  `\29`,
        '+':  `\2b`,
        '/':  `\2f`,
        ':':  `\3a`,
        ';':  `\3b`,
        '&lt;':  `\3c`,
        '&gt;':  `\3e`,
        '\\': `\\`,
        '{':  `\7b`,
        '}':  `\7d`,
}

var expressionBytes = []byte("expression")
var mozBindingBytes = []byte("mozbinding")

// cssValueFilter allows innocuous CSS values in the output including CSS
// quantities (10px or 25%), ID or class literals (#foo, .bar), keyword values
// (inherit, blue), and colors (#888).
// It filters out unsafe values, such as those that affect token boundaries,
// and anything that might execute scripts.
func cssValueFilter(args ...interface{}) string <span class="cov8" title="1">{
        s, t := stringify(args...)
        if t == contentTypeCSS </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">b, id := decodeCSS([]byte(s)), make([]byte, 0, 64)

        // CSS3 error handling is specified as honoring string boundaries per
        // https://www.w3.org/TR/css3-syntax/#error-handling :
        //     Malformed declarations. User agents must handle unexpected
        //     tokens encountered while parsing a declaration by reading until
        //     the end of the declaration, while observing the rules for
        //     matching pairs of (), [], {}, "", and '', and correctly handling
        //     escapes. For example, a malformed declaration may be missing a
        //     property, colon (:) or value.
        // So we need to make sure that values do not have mismatched bracket
        // or quote characters to prevent the browser from restarting parsing
        // inside a string that might embed JavaScript source.
        for i, c := range b </span><span class="cov8" title="1">{
                switch c </span>{
                case 0, '"', '\'', '(', ')', '/', ';', '@', '[', '\\', ']', '`', '{', '}':<span class="cov8" title="1">
                        return filterFailsafe</span>
                case '-':<span class="cov8" title="1">
                        // Disallow &lt;!-- or --&gt;.
                        // -- should not appear in valid identifiers.
                        if i != 0 &amp;&amp; b[i-1] == '-' </span><span class="cov8" title="1">{
                                return filterFailsafe
                        }</span>
                default:<span class="cov8" title="1">
                        if c &lt; utf8.RuneSelf &amp;&amp; isCSSNmchar(rune(c)) </span><span class="cov8" title="1">{
                                id = append(id, c)
                        }</span>
                }
        }
        <span class="cov8" title="1">id = bytes.ToLower(id)
        if bytes.Contains(id, expressionBytes) || bytes.Contains(id, mozBindingBytes) </span><span class="cov8" title="1">{
                return filterFailsafe
        }</span>
        <span class="cov8" title="1">return string(b)</span>
}
</pre>
		
		<pre class="file" id="file303" style="display: none">// Code generated by "stringer -type delim"; DO NOT EDIT.

package template

import "strconv"

const _delim_name = "delimNonedelimDoubleQuotedelimSingleQuotedelimSpaceOrTagEnd"

var _delim_index = [...]uint8{0, 9, 25, 41, 59}

func (i delim) String() string <span class="cov8" title="1">{
        if i &gt;= delim(len(_delim_index)-1) </span><span class="cov0" title="0">{
                return "delim(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov8" title="1">return _delim_name[_delim_index[i]:_delim_index[i+1]]</span>
}
</pre>
		
		<pre class="file" id="file304" style="display: none">// Code generated by "stringer -type element"; DO NOT EDIT.

package template

import "strconv"

const _element_name = "elementNoneelementScriptelementStyleelementTextareaelementTitle"

var _element_index = [...]uint8{0, 11, 24, 36, 51, 63}

func (i element) String() string <span class="cov8" title="1">{
        if i &gt;= element(len(_element_index)-1) </span><span class="cov0" title="0">{
                return "element(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov8" title="1">return _element_name[_element_index[i]:_element_index[i+1]]</span>
}
</pre>
		
		<pre class="file" id="file305" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "fmt"

        "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/parse"
)

// Error describes a problem encountered during template Escaping.
type Error struct {
        // ErrorCode describes the kind of error.
        ErrorCode ErrorCode
        // Node is the node that caused the problem, if known.
        // If not nil, it overrides Name and Line.
        Node parse.Node
        // Name is the name of the template in which the error was encountered.
        Name string
        // Line is the line number of the error in the template source or 0.
        Line int
        // Description is a human-readable description of the problem.
        Description string
}

// ErrorCode is a code for a kind of error.
type ErrorCode int

// We define codes for each error that manifests while escaping templates, but
// escaped templates may also fail at runtime.
//
// Output: "ZgotmplZ"
// Example:
//   &lt;img src="{{.X}}"&gt;
//   where {{.X}} evaluates to `javascript:...`
// Discussion:
//   "ZgotmplZ" is a special value that indicates that unsafe content reached a
//   CSS or URL context at runtime. The output of the example will be
//     &lt;img src="#ZgotmplZ"&gt;
//   If the data comes from a trusted source, use content types to exempt it
//   from filtering: URL(`javascript:...`).
const (
        // OK indicates the lack of an error.
        OK ErrorCode = iota

        // ErrAmbigContext: "... appears in an ambiguous context within a URL"
        // Example:
        //   &lt;a href="
        //      {{if .C}}
        //        /path/
        //      {{else}}
        //        /search?q=
        //      {{end}}
        //      {{.X}}
        //   "&gt;
        // Discussion:
        //   {{.X}} is in an ambiguous URL context since, depending on {{.C}},
        //  it may be either a URL suffix or a query parameter.
        //   Moving {{.X}} into the condition removes the ambiguity:
        //   &lt;a href="{{if .C}}/path/{{.X}}{{else}}/search?q={{.X}}"&gt;
        ErrAmbigContext

        // ErrBadHTML: "expected space, attr name, or end of tag, but got ...",
        //   "... in unquoted attr", "... in attribute name"
        // Example:
        //   &lt;a href = /search?q=foo&gt;
        //   &lt;href=foo&gt;
        //   &lt;form na&lt;e=...&gt;
        //   &lt;option selected&lt;
        // Discussion:
        //   This is often due to a typo in an HTML element, but some runes
        //   are banned in tag names, attribute names, and unquoted attribute
        //   values because they can tickle parser ambiguities.
        //   Quoting all attributes is the best policy.
        ErrBadHTML

        // ErrBranchEnd: "{{if}} branches end in different contexts"
        // Example:
        //   {{if .C}}&lt;a href="{{end}}{{.X}}
        // Discussion:
        //   Package html/template statically examines each path through an
        //   {{if}}, {{range}}, or {{with}} to escape any following pipelines.
        //   The example is ambiguous since {{.X}} might be an HTML text node,
        //   or a URL prefix in an HTML attribute. The context of {{.X}} is
        //   used to figure out how to escape it, but that context depends on
        //   the run-time value of {{.C}} which is not statically known.
        //
        //   The problem is usually something like missing quotes or angle
        //   brackets, or can be avoided by refactoring to put the two contexts
        //   into different branches of an if, range or with. If the problem
        //   is in a {{range}} over a collection that should never be empty,
        //   adding a dummy {{else}} can help.
        ErrBranchEnd

        // ErrEndContext: "... ends in a non-text context: ..."
        // Examples:
        //   &lt;div
        //   &lt;div title="no close quote&gt;
        //   &lt;script&gt;f()
        // Discussion:
        //   Executed templates should produce a DocumentFragment of HTML.
        //   Templates that end without closing tags will trigger this error.
        //   Templates that should not be used in an HTML context or that
        //   produce incomplete Fragments should not be executed directly.
        //
        //   {{define "main"}} &lt;script&gt;{{template "helper"}}&lt;/script&gt; {{end}}
        //   {{define "helper"}} document.write(' &lt;div title=" ') {{end}}
        //
        //   "helper" does not produce a valid document fragment, so should
        //   not be Executed directly.
        ErrEndContext

        // ErrNoSuchTemplate: "no such template ..."
        // Examples:
        //   {{define "main"}}&lt;div {{template "attrs"}}&gt;{{end}}
        //   {{define "attrs"}}href="{{.URL}}"{{end}}
        // Discussion:
        //   Package html/template looks through template calls to compute the
        //   context.
        //   Here the {{.URL}} in "attrs" must be treated as a URL when called
        //   from "main", but you will get this error if "attrs" is not defined
        //   when "main" is parsed.
        ErrNoSuchTemplate

        // ErrOutputContext: "cannot compute output context for template ..."
        // Examples:
        //   {{define "t"}}{{if .T}}{{template "t" .T}}{{end}}{{.H}}",{{end}}
        // Discussion:
        //   A recursive template does not end in the same context in which it
        //   starts, and a reliable output context cannot be computed.
        //   Look for typos in the named template.
        //   If the template should not be called in the named start context,
        //   look for calls to that template in unexpected contexts.
        //   Maybe refactor recursive templates to not be recursive.
        ErrOutputContext

        // ErrPartialCharset: "unfinished JS regexp charset in ..."
        // Example:
        //     &lt;script&gt;var pattern = /foo[{{.Chars}}]/&lt;/script&gt;
        // Discussion:
        //   Package html/template does not support interpolation into regular
        //   expression literal character sets.
        ErrPartialCharset

        // ErrPartialEscape: "unfinished escape sequence in ..."
        // Example:
        //   &lt;script&gt;alert("\{{.X}}")&lt;/script&gt;
        // Discussion:
        //   Package html/template does not support actions following a
        //   backslash.
        //   This is usually an error and there are better solutions; for
        //   example
        //     &lt;script&gt;alert("{{.X}}")&lt;/script&gt;
        //   should work, and if {{.X}} is a partial escape sequence such as
        //   "xA0", mark the whole sequence as safe content: JSStr(`\xA0`)
        ErrPartialEscape

        // ErrRangeLoopReentry: "on range loop re-entry: ..."
        // Example:
        //   &lt;script&gt;var x = [{{range .}}'{{.}},{{end}}]&lt;/script&gt;
        // Discussion:
        //   If an iteration through a range would cause it to end in a
        //   different context than an earlier pass, there is no single context.
        //   In the example, there is missing a quote, so it is not clear
        //   whether {{.}} is meant to be inside a JS string or in a JS value
        //   context. The second iteration would produce something like
        //
        //     &lt;script&gt;var x = ['firstValue,'secondValue]&lt;/script&gt;
        ErrRangeLoopReentry

        // ErrSlashAmbig: '/' could start a division or regexp.
        // Example:
        //   &lt;script&gt;
        //     {{if .C}}var x = 1{{end}}
        //     /-{{.N}}/i.test(x) ? doThis : doThat();
        //   &lt;/script&gt;
        // Discussion:
        //   The example above could produce `var x = 1/-2/i.test(s)...`
        //   in which the first '/' is a mathematical division operator or it
        //   could produce `/-2/i.test(s)` in which the first '/' starts a
        //   regexp literal.
        //   Look for missing semicolons inside branches, and maybe add
        //   parentheses to make it clear which interpretation you intend.
        ErrSlashAmbig

        // ErrPredefinedEscaper: "predefined escaper ... disallowed in template"
        // Example:
        //   &lt;div class={{. | html}}&gt;Hello&lt;div&gt;
        // Discussion:
        //   Package html/template already contextually escapes all pipelines to
        //   produce HTML output safe against code injection. Manually escaping
        //   pipeline output using the predefined escapers "html" or "urlquery" is
        //   unnecessary, and may affect the correctness or safety of the escaped
        //   pipeline output in Go 1.8 and earlier.
        //
        //   In most cases, such as the given example, this error can be resolved by
        //   simply removing the predefined escaper from the pipeline and letting the
        //   contextual autoescaper handle the escaping of the pipeline. In other
        //   instances, where the predefined escaper occurs in the middle of a
        //   pipeline where subsequent commands expect escaped input, e.g.
        //     {{.X | html | makeALink}}
        //   where makeALink does
        //     return `&lt;a href="`+input+`"&gt;link&lt;/a&gt;`
        //   consider refactoring the surrounding template to make use of the
        //   contextual autoescaper, i.e.
        //     &lt;a href="{{.X}}"&gt;link&lt;/a&gt;
        //
        //   To ease migration to Go 1.9 and beyond, "html" and "urlquery" will
        //   continue to be allowed as the last command in a pipeline. However, if the
        //   pipeline occurs in an unquoted attribute value context, "html" is
        //   disallowed. Avoid using "html" and "urlquery" entirely in new templates.
        ErrPredefinedEscaper
)

func (e *Error) Error() string <span class="cov8" title="1">{
        switch </span>{
        case e.Node != nil:<span class="cov8" title="1">
                loc, _ := (*parse.Tree)(nil).ErrorContext(e.Node)
                return fmt.Sprintf("html/template:%s: %s", loc, e.Description)</span>
        case e.Line != 0:<span class="cov8" title="1">
                return fmt.Sprintf("html/template:%s:%d: %s", e.Name, e.Line, e.Description)</span>
        case e.Name != "":<span class="cov8" title="1">
                return fmt.Sprintf("html/template:%s: %s", e.Name, e.Description)</span>
        }
        <span class="cov0" title="0">return "html/template: " + e.Description</span>
}

// errorf creates an error given a format string f and args.
// The template Name still needs to be supplied.
func errorf(k ErrorCode, node parse.Node, line int, f string, args ...interface{}) *Error <span class="cov8" title="1">{
        return &amp;Error{k, node, "", line, fmt.Sprintf(f, args...)}
}</span>
</pre>
		
		<pre class="file" id="file306" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "bytes"
        "fmt"
        "html"
        "io"

        template "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate"
        "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/parse"
)

// escapeTemplate rewrites the named template, which must be
// associated with t, to guarantee that the output of any of the named
// templates is properly escaped. If no error is returned, then the named templates have
// been modified. Otherwise the named templates have been rendered
// unusable.
func escapeTemplate(tmpl *Template, node parse.Node, name string) error <span class="cov8" title="1">{
        c, _ := tmpl.esc.escapeTree(context{}, node, name, 0)
        var err error
        if c.err != nil </span><span class="cov8" title="1">{
                err, c.err.Name = c.err, name
        }</span> else<span class="cov8" title="1"> if c.state != stateText </span><span class="cov8" title="1">{
                err = &amp;Error{ErrEndContext, nil, name, 0, fmt.Sprintf("ends in a non-text context: %v", c)}
        }</span>
        <span class="cov8" title="1">if err != nil </span><span class="cov8" title="1">{
                // Prevent execution of unsafe templates.
                if t := tmpl.set[name]; t != nil </span><span class="cov8" title="1">{
                        t.escapeErr = err
                        t.text.Tree = nil
                        t.Tree = nil
                }</span>
                <span class="cov8" title="1">return err</span>
        }
        <span class="cov8" title="1">tmpl.esc.commit()
        if t := tmpl.set[name]; t != nil </span><span class="cov8" title="1">{
                t.escapeErr = escapeOK
                t.Tree = t.text.Tree
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// evalArgs formats the list of arguments into a string. It is equivalent to
// fmt.Sprint(args...), except that it deferences all pointers.
func evalArgs(args ...interface{}) string <span class="cov8" title="1">{
        // Optimization for simple common case of a single string argument.
        if len(args) == 1 </span><span class="cov8" title="1">{
                if s, ok := args[0].(string); ok </span><span class="cov8" title="1">{
                        return s
                }</span>
        }
        <span class="cov8" title="1">for i, arg := range args </span><span class="cov8" title="1">{
                args[i] = indirectToStringerOrError(arg)
        }</span>
        <span class="cov8" title="1">return fmt.Sprint(args...)</span>
}

// funcMap maps command names to functions that render their inputs safe.
var funcMap = template.FuncMap{
        "_html_template_attrescaper":     attrEscaper,
        "_html_template_commentescaper":  commentEscaper,
        "_html_template_cssescaper":      cssEscaper,
        "_html_template_cssvaluefilter":  cssValueFilter,
        "_html_template_htmlnamefilter":  htmlNameFilter,
        "_html_template_htmlescaper":     htmlEscaper,
        "_html_template_jsregexpescaper": jsRegexpEscaper,
        "_html_template_jsstrescaper":    jsStrEscaper,
        "_html_template_jsvalescaper":    jsValEscaper,
        "_html_template_nospaceescaper":  htmlNospaceEscaper,
        "_html_template_rcdataescaper":   rcdataEscaper,
        "_html_template_srcsetescaper":   srcsetFilterAndEscaper,
        "_html_template_urlescaper":      urlEscaper,
        "_html_template_urlfilter":       urlFilter,
        "_html_template_urlnormalizer":   urlNormalizer,
        "_eval_args_":                    evalArgs,
}

// escaper collects type inferences about templates and changes needed to make
// templates injection safe.
type escaper struct {
        // ns is the nameSpace that this escaper is associated with.
        ns *nameSpace
        // output[templateName] is the output context for a templateName that
        // has been mangled to include its input context.
        output map[string]context
        // derived[c.mangle(name)] maps to a template derived from the template
        // named name templateName for the start context c.
        derived map[string]*template.Template
        // called[templateName] is a set of called mangled template names.
        called map[string]bool
        // xxxNodeEdits are the accumulated edits to apply during commit.
        // Such edits are not applied immediately in case a template set
        // executes a given template in different escaping contexts.
        actionNodeEdits   map[*parse.ActionNode][]string
        templateNodeEdits map[*parse.TemplateNode]string
        textNodeEdits     map[*parse.TextNode][]byte
}

// makeEscaper creates a blank escaper for the given set.
func makeEscaper(n *nameSpace) escaper <span class="cov8" title="1">{
        return escaper{
                n,
                map[string]context{},
                map[string]*template.Template{},
                map[string]bool{},
                map[*parse.ActionNode][]string{},
                map[*parse.TemplateNode]string{},
                map[*parse.TextNode][]byte{},
        }
}</span>

// filterFailsafe is an innocuous word that is emitted in place of unsafe values
// by sanitizer functions. It is not a keyword in any programming language,
// contains no special characters, is not empty, and when it appears in output
// it is distinct enough that a developer can find the source of the problem
// via a search engine.
const filterFailsafe = "ZgotmplZ"

// escape escapes a template node.
func (e *escaper) escape(c context, n parse.Node) context <span class="cov8" title="1">{
        switch n := n.(type) </span>{
        case *parse.ActionNode:<span class="cov8" title="1">
                return e.escapeAction(c, n)</span>
        case *parse.CommentNode:<span class="cov8" title="1">
                return c</span>
        case *parse.IfNode:<span class="cov8" title="1">
                return e.escapeBranch(c, &amp;n.BranchNode, "if")</span>
        case *parse.ListNode:<span class="cov0" title="0">
                return e.escapeList(c, n)</span>
        case *parse.RangeNode:<span class="cov8" title="1">
                return e.escapeBranch(c, &amp;n.BranchNode, "range")</span>
        case *parse.TemplateNode:<span class="cov8" title="1">
                return e.escapeTemplate(c, n)</span>
        case *parse.TextNode:<span class="cov8" title="1">
                return e.escapeText(c, n)</span>
        case *parse.WithNode:<span class="cov8" title="1">
                return e.escapeBranch(c, &amp;n.BranchNode, "with")</span>
        }
        <span class="cov0" title="0">panic("escaping " + n.String() + " is unimplemented")</span>
}

// escapeAction escapes an action template node.
func (e *escaper) escapeAction(c context, n *parse.ActionNode) context <span class="cov8" title="1">{
        if len(n.Pipe.Decl) != 0 </span><span class="cov8" title="1">{
                // A local variable assignment, not an interpolation.
                return c
        }</span>
        <span class="cov8" title="1">c = nudge(c)
        // Check for disallowed use of predefined escapers in the pipeline.
        for pos, idNode := range n.Pipe.Cmds </span><span class="cov8" title="1">{
                node, ok := idNode.Args[0].(*parse.IdentifierNode)
                if !ok </span><span class="cov8" title="1">{
                        // A predefined escaper "esc" will never be found as an identifier in a
                        // Chain or Field node, since:
                        // - "esc.x ..." is invalid, since predefined escapers return strings, and
                        //   strings do not have methods, keys or fields.
                        // - "... .esc" is invalid, since predefined escapers are global functions,
                        //   not methods or fields of any types.
                        // Therefore, it is safe to ignore these two node types.
                        continue</span>
                }
                <span class="cov8" title="1">ident := node.Ident
                if _, ok := predefinedEscapers[ident]; ok </span><span class="cov8" title="1">{
                        if pos &lt; len(n.Pipe.Cmds)-1 ||
                                c.state == stateAttr &amp;&amp; c.delim == delimSpaceOrTagEnd &amp;&amp; ident == "html" </span><span class="cov8" title="1">{
                                return context{
                                        state: stateError,
                                        err:   errorf(ErrPredefinedEscaper, n, n.Line, "predefined escaper %q disallowed in template", ident),
                                }
                        }</span>
                }
        }
        <span class="cov8" title="1">s := make([]string, 0, 3)
        switch c.state </span>{
        case stateError:<span class="cov8" title="1">
                return c</span>
        case stateURL, stateCSSDqStr, stateCSSSqStr, stateCSSDqURL, stateCSSSqURL, stateCSSURL:<span class="cov8" title="1">
                switch c.urlPart </span>{
                case urlPartNone:<span class="cov8" title="1">
                        s = append(s, "_html_template_urlfilter")
                        fallthrough</span>
                case urlPartPreQuery:<span class="cov8" title="1">
                        switch c.state </span>{
                        case stateCSSDqStr, stateCSSSqStr:<span class="cov8" title="1">
                                s = append(s, "_html_template_cssescaper")</span>
                        default:<span class="cov8" title="1">
                                s = append(s, "_html_template_urlnormalizer")</span>
                        }
                case urlPartQueryOrFrag:<span class="cov8" title="1">
                        s = append(s, "_html_template_urlescaper")</span>
                case urlPartUnknown:<span class="cov8" title="1">
                        return context{
                                state: stateError,
                                err:   errorf(ErrAmbigContext, n, n.Line, "%s appears in an ambiguous context within a URL", n),
                        }</span>
                default:<span class="cov0" title="0">
                        panic(c.urlPart.String())</span>
                }
        case stateJS:<span class="cov8" title="1">
                s = append(s, "_html_template_jsvalescaper")
                // A slash after a value starts a div operator.
                c.jsCtx = jsCtxDivOp</span>
        case stateJSDqStr, stateJSSqStr:<span class="cov8" title="1">
                s = append(s, "_html_template_jsstrescaper")</span>
        case stateJSRegexp:<span class="cov8" title="1">
                s = append(s, "_html_template_jsregexpescaper")</span>
        case stateCSS:<span class="cov8" title="1">
                s = append(s, "_html_template_cssvaluefilter")</span>
        case stateText:<span class="cov8" title="1">
                s = append(s, "_html_template_htmlescaper")</span>
        case stateRCDATA:<span class="cov8" title="1">
                s = append(s, "_html_template_rcdataescaper")</span>
        case stateAttr:<span class="cov8" title="1"></span>
                // Handled below in delim check.
        case stateAttrName, stateTag:<span class="cov8" title="1">
                c.state = stateAttrName
                s = append(s, "_html_template_htmlnamefilter")</span>
        case stateSrcset:<span class="cov8" title="1">
                s = append(s, "_html_template_srcsetescaper")</span>
        default:<span class="cov8" title="1">
                if isComment(c.state) </span><span class="cov8" title="1">{
                        s = append(s, "_html_template_commentescaper")
                }</span> else<span class="cov0" title="0"> {
                        panic("unexpected state " + c.state.String())</span>
                }
        }
        <span class="cov8" title="1">switch c.delim </span>{
        case delimNone:<span class="cov8" title="1"></span>
                // No extra-escaping needed for raw text content.
        case delimSpaceOrTagEnd:<span class="cov8" title="1">
                s = append(s, "_html_template_nospaceescaper")</span>
        default:<span class="cov8" title="1">
                s = append(s, "_html_template_attrescaper")</span>
        }
        <span class="cov8" title="1">e.editActionNode(n, s)
        return c</span>
}

// ensurePipelineContains ensures that the pipeline ends with the commands with
// the identifiers in s in order. If the pipeline ends with a predefined escaper
// (i.e. "html" or "urlquery"), merge it with the identifiers in s.
func ensurePipelineContains(p *parse.PipeNode, s []string) <span class="cov8" title="1">{
        if len(s) == 0 </span><span class="cov8" title="1">{
                // Do not rewrite pipeline if we have no escapers to insert.
                return
        }</span>
        // Precondition: p.Cmds contains at most one predefined escaper and the
        // escaper will be present at p.Cmds[len(p.Cmds)-1]. This precondition is
        // always true because of the checks in escapeAction.
        <span class="cov8" title="1">pipelineLen := len(p.Cmds)
        if pipelineLen &gt; 0 </span><span class="cov8" title="1">{
                lastCmd := p.Cmds[pipelineLen-1]
                if idNode, ok := lastCmd.Args[0].(*parse.IdentifierNode); ok </span><span class="cov8" title="1">{
                        if esc := idNode.Ident; predefinedEscapers[esc] </span><span class="cov8" title="1">{
                                // Pipeline ends with a predefined escaper.
                                if len(p.Cmds) == 1 &amp;&amp; len(lastCmd.Args) &gt; 1 </span><span class="cov8" title="1">{
                                        // Special case: pipeline is of the form {{ esc arg1 arg2 ... argN }},
                                        // where esc is the predefined escaper, and arg1...argN are its arguments.
                                        // Convert this into the equivalent form
                                        // {{ _eval_args_ arg1 arg2 ... argN | esc }}, so that esc can be easily
                                        // merged with the escapers in s.
                                        lastCmd.Args[0] = parse.NewIdentifier("_eval_args_").SetTree(nil).SetPos(lastCmd.Args[0].Position())
                                        p.Cmds = appendCmd(p.Cmds, newIdentCmd(esc, p.Position()))
                                        pipelineLen++
                                }</span>
                                // If any of the commands in s that we are about to insert is equivalent
                                // to the predefined escaper, use the predefined escaper instead.
                                <span class="cov8" title="1">dup := false
                                for i, escaper := range s </span><span class="cov8" title="1">{
                                        if escFnsEq(esc, escaper) </span><span class="cov8" title="1">{
                                                s[i] = idNode.Ident
                                                dup = true
                                        }</span>
                                }
                                <span class="cov8" title="1">if dup </span><span class="cov8" title="1">{
                                        // The predefined escaper will already be inserted along with the
                                        // escapers in s, so do not copy it to the rewritten pipeline.
                                        pipelineLen--
                                }</span>
                        }
                }
        }
        // Rewrite the pipeline, creating the escapers in s at the end of the pipeline.
        <span class="cov8" title="1">newCmds := make([]*parse.CommandNode, pipelineLen, pipelineLen+len(s))
        insertedIdents := make(map[string]bool)
        for i := 0; i &lt; pipelineLen; i++ </span><span class="cov8" title="1">{
                cmd := p.Cmds[i]
                newCmds[i] = cmd
                if idNode, ok := cmd.Args[0].(*parse.IdentifierNode); ok </span><span class="cov8" title="1">{
                        insertedIdents[normalizeEscFn(idNode.Ident)] = true
                }</span>
        }
        <span class="cov8" title="1">for _, name := range s </span><span class="cov8" title="1">{
                if !insertedIdents[normalizeEscFn(name)] </span><span class="cov8" title="1">{
                        // When two templates share an underlying parse tree via the use of
                        // AddParseTree and one template is executed after the other, this check
                        // ensures that escapers that were already inserted into the pipeline on
                        // the first escaping pass do not get inserted again.
                        newCmds = appendCmd(newCmds, newIdentCmd(name, p.Position()))
                }</span>
        }
        <span class="cov8" title="1">p.Cmds = newCmds</span>
}

// predefinedEscapers contains template predefined escapers that are equivalent
// to some contextual escapers. Keep in sync with equivEscapers.
var predefinedEscapers = map[string]bool{
        "html":     true,
        "urlquery": true,
}

// equivEscapers matches contextual escapers to equivalent predefined
// template escapers.
var equivEscapers = map[string]string{
        // The following pairs of HTML escapers provide equivalent security
        // guarantees, since they all escape '\000', '\'', '"', '&amp;', '&lt;', and '&gt;'.
        "_html_template_attrescaper":   "html",
        "_html_template_htmlescaper":   "html",
        "_html_template_rcdataescaper": "html",
        // These two URL escapers produce URLs safe for embedding in a URL query by
        // percent-encoding all the reserved characters specified in RFC 3986 Section
        // 2.2
        "_html_template_urlescaper": "urlquery",
        // These two functions are not actually equivalent; urlquery is stricter as it
        // escapes reserved characters (e.g. '#'), while _html_template_urlnormalizer
        // does not. It is therefore only safe to replace _html_template_urlnormalizer
        // with urlquery (this happens in ensurePipelineContains), but not the otherI've
        // way around. We keep this entry around to preserve the behavior of templates
        // written before Go 1.9, which might depend on this substitution taking place.
        "_html_template_urlnormalizer": "urlquery",
}

// escFnsEq reports whether the two escaping functions are equivalent.
func escFnsEq(a, b string) bool <span class="cov8" title="1">{
        return normalizeEscFn(a) == normalizeEscFn(b)
}</span>

// normalizeEscFn(a) is equal to normalizeEscFn(b) for any pair of names of
// escaper functions a and b that are equivalent.
func normalizeEscFn(e string) string <span class="cov8" title="1">{
        if norm := equivEscapers[e]; norm != "" </span><span class="cov8" title="1">{
                return norm
        }</span>
        <span class="cov8" title="1">return e</span>
}

// redundantFuncs[a][b] implies that funcMap[b](funcMap[a](x)) == funcMap[a](x)
// for all x.
var redundantFuncs = map[string]map[string]bool{
        "_html_template_commentescaper": {
                "_html_template_attrescaper":    true,
                "_html_template_nospaceescaper": true,
                "_html_template_htmlescaper":    true,
        },
        "_html_template_cssescaper": {
                "_html_template_attrescaper": true,
        },
        "_html_template_jsregexpescaper": {
                "_html_template_attrescaper": true,
        },
        "_html_template_jsstrescaper": {
                "_html_template_attrescaper": true,
        },
        "_html_template_urlescaper": {
                "_html_template_urlnormalizer": true,
        },
}

// appendCmd appends the given command to the end of the command pipeline
// unless it is redundant with the last command.
func appendCmd(cmds []*parse.CommandNode, cmd *parse.CommandNode) []*parse.CommandNode <span class="cov8" title="1">{
        if n := len(cmds); n != 0 </span><span class="cov8" title="1">{
                last, okLast := cmds[n-1].Args[0].(*parse.IdentifierNode)
                next, okNext := cmd.Args[0].(*parse.IdentifierNode)
                if okLast &amp;&amp; okNext &amp;&amp; redundantFuncs[last.Ident][next.Ident] </span><span class="cov8" title="1">{
                        return cmds
                }</span>
        }
        <span class="cov8" title="1">return append(cmds, cmd)</span>
}

// newIdentCmd produces a command containing a single identifier node.
func newIdentCmd(identifier string, pos parse.Pos) *parse.CommandNode <span class="cov8" title="1">{
        return &amp;parse.CommandNode{
                NodeType: parse.NodeCommand,
                Args:     []parse.Node{parse.NewIdentifier(identifier).SetTree(nil).SetPos(pos)}, // TODO: SetTree.
        }
}</span>

// nudge returns the context that would result from following empty string
// transitions from the input context.
// For example, parsing:
//     `&lt;a href=`
// will end in context{stateBeforeValue, attrURL}, but parsing one extra rune:
//     `&lt;a href=x`
// will end in context{stateURL, delimSpaceOrTagEnd, ...}.
// There are two transitions that happen when the 'x' is seen:
// (1) Transition from a before-value state to a start-of-value state without
//     consuming any character.
// (2) Consume 'x' and transition past the first value character.
// In this case, nudging produces the context after (1) happens.
func nudge(c context) context <span class="cov8" title="1">{
        switch c.state </span>{
        case stateTag:<span class="cov8" title="1">
                // In `&lt;foo {{.}}`, the action should emit an attribute.
                c.state = stateAttrName</span>
        case stateBeforeValue:<span class="cov8" title="1">
                // In `&lt;foo bar={{.}}`, the action is an undelimited value.
                c.state, c.delim, c.attr = attrStartStates[c.attr], delimSpaceOrTagEnd, attrNone</span>
        case stateAfterName:<span class="cov8" title="1">
                // In `&lt;foo bar {{.}}`, the action is an attribute name.
                c.state, c.attr = stateAttrName, attrNone</span>
        }
        <span class="cov8" title="1">return c</span>
}

// join joins the two contexts of a branch template node. The result is an
// error context if either of the input contexts are error contexts, or if the
// input contexts differ.
func join(a, b context, node parse.Node, nodeName string) context <span class="cov8" title="1">{
        if a.state == stateError </span><span class="cov8" title="1">{
                return a
        }</span>
        <span class="cov8" title="1">if b.state == stateError </span><span class="cov8" title="1">{
                return b
        }</span>
        <span class="cov8" title="1">if a.eq(b) </span><span class="cov8" title="1">{
                return a
        }</span>

        <span class="cov8" title="1">c := a
        c.urlPart = b.urlPart
        if c.eq(b) </span><span class="cov8" title="1">{
                // The contexts differ only by urlPart.
                c.urlPart = urlPartUnknown
                return c
        }</span>

        <span class="cov8" title="1">c = a
        c.jsCtx = b.jsCtx
        if c.eq(b) </span><span class="cov8" title="1">{
                // The contexts differ only by jsCtx.
                c.jsCtx = jsCtxUnknown
                return c
        }</span>

        // Allow a nudged context to join with an unnudged one.
        // This means that
        //   &lt;p title={{if .C}}{{.}}{{end}}
        // ends in an unquoted value state even though the else branch
        // ends in stateBeforeValue.
        <span class="cov8" title="1">if c, d := nudge(a), nudge(b); !(c.eq(a) &amp;&amp; d.eq(b)) </span><span class="cov8" title="1">{
                if e := join(c, d, node, nodeName); e.state != stateError </span><span class="cov8" title="1">{
                        return e
                }</span>
        }

        <span class="cov8" title="1">return context{
                state: stateError,
                err:   errorf(ErrBranchEnd, node, 0, "{{%s}} branches end in different contexts: %v, %v", nodeName, a, b),
        }</span>
}

// escapeBranch escapes a branch template node: "if", "range" and "with".
func (e *escaper) escapeBranch(c context, n *parse.BranchNode, nodeName string) context <span class="cov8" title="1">{
        c0 := e.escapeList(c, n.List)
        if nodeName == "range" &amp;&amp; c0.state != stateError </span><span class="cov8" title="1">{
                // The "true" branch of a "range" node can execute multiple times.
                // We check that executing n.List once results in the same context
                // as executing n.List twice.
                c1, _ := e.escapeListConditionally(c0, n.List, nil)
                c0 = join(c0, c1, n, nodeName)
                if c0.state == stateError </span><span class="cov8" title="1">{
                        // Make clear that this is a problem on loop re-entry
                        // since developers tend to overlook that branch when
                        // debugging templates.
                        c0.err.Line = n.Line
                        c0.err.Description = "on range loop re-entry: " + c0.err.Description
                        return c0
                }</span>
        }
        <span class="cov8" title="1">c1 := e.escapeList(c, n.ElseList)
        return join(c0, c1, n, nodeName)</span>
}

// escapeList escapes a list template node.
func (e *escaper) escapeList(c context, n *parse.ListNode) context <span class="cov8" title="1">{
        if n == nil </span><span class="cov8" title="1">{
                return c
        }</span>
        <span class="cov8" title="1">for _, m := range n.Nodes </span><span class="cov8" title="1">{
                c = e.escape(c, m)
        }</span>
        <span class="cov8" title="1">return c</span>
}

// escapeListConditionally escapes a list node but only preserves edits and
// inferences in e if the inferences and output context satisfy filter.
// It returns the best guess at an output context, and the result of the filter
// which is the same as whether e was updated.
func (e *escaper) escapeListConditionally(c context, n *parse.ListNode, filter func(*escaper, context) bool) (context, bool) <span class="cov8" title="1">{
        e1 := makeEscaper(e.ns)
        // Make type inferences available to f.
        for k, v := range e.output </span><span class="cov8" title="1">{
                e1.output[k] = v
        }</span>
        <span class="cov8" title="1">c = e1.escapeList(c, n)
        ok := filter != nil &amp;&amp; filter(&amp;e1, c)
        if ok </span><span class="cov8" title="1">{
                // Copy inferences and edits from e1 back into e.
                for k, v := range e1.output </span><span class="cov8" title="1">{
                        e.output[k] = v
                }</span>
                <span class="cov8" title="1">for k, v := range e1.derived </span><span class="cov8" title="1">{
                        e.derived[k] = v
                }</span>
                <span class="cov8" title="1">for k, v := range e1.called </span><span class="cov8" title="1">{
                        e.called[k] = v
                }</span>
                <span class="cov8" title="1">for k, v := range e1.actionNodeEdits </span><span class="cov8" title="1">{
                        e.editActionNode(k, v)
                }</span>
                <span class="cov8" title="1">for k, v := range e1.templateNodeEdits </span><span class="cov8" title="1">{
                        e.editTemplateNode(k, v)
                }</span>
                <span class="cov8" title="1">for k, v := range e1.textNodeEdits </span><span class="cov8" title="1">{
                        e.editTextNode(k, v)
                }</span>
        }
        <span class="cov8" title="1">return c, ok</span>
}

// escapeTemplate escapes a {{template}} call node.
func (e *escaper) escapeTemplate(c context, n *parse.TemplateNode) context <span class="cov8" title="1">{
        c, name := e.escapeTree(c, n, n.Name, n.Line)
        if name != n.Name </span><span class="cov8" title="1">{
                e.editTemplateNode(n, name)
        }</span>
        <span class="cov8" title="1">return c</span>
}

// escapeTree escapes the named template starting in the given context as
// necessary and returns its output context.
func (e *escaper) escapeTree(c context, node parse.Node, name string, line int) (context, string) <span class="cov8" title="1">{
        // Mangle the template name with the input context to produce a reliable
        // identifier.
        dname := c.mangle(name)
        e.called[dname] = true
        if out, ok := e.output[dname]; ok </span><span class="cov8" title="1">{
                // Already escaped.
                return out, dname
        }</span>
        <span class="cov8" title="1">t := e.template(name)
        if t == nil </span><span class="cov8" title="1">{
                // Two cases: The template exists but is empty, or has never been mentioned at
                // all. Distinguish the cases in the error messages.
                if e.ns.set[name] != nil </span><span class="cov0" title="0">{
                        return context{
                                state: stateError,
                                err:   errorf(ErrNoSuchTemplate, node, line, "%q is an incomplete or empty template", name),
                        }, dname
                }</span>
                <span class="cov8" title="1">return context{
                        state: stateError,
                        err:   errorf(ErrNoSuchTemplate, node, line, "no such template %q", name),
                }, dname</span>
        }
        <span class="cov8" title="1">if dname != name </span><span class="cov8" title="1">{
                // Use any template derived during an earlier call to escapeTemplate
                // with different top level templates, or clone if necessary.
                dt := e.template(dname)
                if dt == nil </span><span class="cov8" title="1">{
                        dt = template.New(dname)
                        dt.Tree = &amp;parse.Tree{Name: dname, Root: t.Root.CopyList()}
                        e.derived[dname] = dt
                }</span>
                <span class="cov8" title="1">t = dt</span>
        }
        <span class="cov8" title="1">return e.computeOutCtx(c, t), dname</span>
}

// computeOutCtx takes a template and its start context and computes the output
// context while storing any inferences in e.
func (e *escaper) computeOutCtx(c context, t *template.Template) context <span class="cov8" title="1">{
        // Propagate context over the body.
        c1, ok := e.escapeTemplateBody(c, t)
        if !ok </span><span class="cov8" title="1">{
                // Look for a fixed point by assuming c1 as the output context.
                if c2, ok2 := e.escapeTemplateBody(c1, t); ok2 </span><span class="cov8" title="1">{
                        c1, ok = c2, true
                }</span>
                // Use c1 as the error context if neither assumption worked.
        }
        <span class="cov8" title="1">if !ok &amp;&amp; c1.state != stateError </span><span class="cov8" title="1">{
                return context{
                        state: stateError,
                        err:   errorf(ErrOutputContext, t.Tree.Root, 0, "cannot compute output context for template %s", t.Name()),
                }
        }</span>
        <span class="cov8" title="1">return c1</span>
}

// escapeTemplateBody escapes the given template assuming the given output
// context, and returns the best guess at the output context and whether the
// assumption was correct.
func (e *escaper) escapeTemplateBody(c context, t *template.Template) (context, bool) <span class="cov8" title="1">{
        filter := func(e1 *escaper, c1 context) bool </span><span class="cov8" title="1">{
                if c1.state == stateError </span><span class="cov8" title="1">{
                        // Do not update the input escaper, e.
                        return false
                }</span>
                <span class="cov8" title="1">if !e1.called[t.Name()] </span><span class="cov8" title="1">{
                        // If t is not recursively called, then c1 is an
                        // accurate output context.
                        return true
                }</span>
                // c1 is accurate if it matches our assumed output context.
                <span class="cov8" title="1">return c.eq(c1)</span>
        }
        // We need to assume an output context so that recursive template calls
        // take the fast path out of escapeTree instead of infinitely recursing.
        // Naively assuming that the input context is the same as the output
        // works &gt;90% of the time.
        <span class="cov8" title="1">e.output[t.Name()] = c
        return e.escapeListConditionally(c, t.Tree.Root, filter)</span>
}

// delimEnds maps each delim to a string of characters that terminate it.
var delimEnds = [...]string{
        delimDoubleQuote: `"`,
        delimSingleQuote: "'",
        // Determined empirically by running the below in various browsers.
        // var div = document.createElement("DIV");
        // for (var i = 0; i &lt; 0x10000; ++i) {
        //   div.innerHTML = "&lt;span title=x" + String.fromCharCode(i) + "-bar&gt;";
        //   if (div.getElementsByTagName("SPAN")[0].title.indexOf("bar") &lt; 0)
        //     document.write("&lt;p&gt;U+" + i.toString(16));
        // }
        delimSpaceOrTagEnd: " \t\n\f\r&gt;",
}

var doctypeBytes = []byte("&lt;!DOCTYPE")

// escapeText escapes a text template node.
func (e *escaper) escapeText(c context, n *parse.TextNode) context <span class="cov8" title="1">{
        s, written, i, b := n.Text, 0, 0, new(bytes.Buffer)
        for i != len(s) </span><span class="cov8" title="1">{
                c1, nread := contextAfterText(c, s[i:])
                i1 := i + nread
                if c.state == stateText || c.state == stateRCDATA </span><span class="cov8" title="1">{
                        end := i1
                        if c1.state != c.state </span><span class="cov8" title="1">{
                                for j := end - 1; j &gt;= i; j-- </span><span class="cov8" title="1">{
                                        if s[j] == '&lt;' </span><span class="cov8" title="1">{
                                                end = j
                                                break</span>
                                        }
                                }
                        }
                        <span class="cov8" title="1">for j := i; j &lt; end; j++ </span><span class="cov8" title="1">{
                                if s[j] == '&lt;' &amp;&amp; !bytes.HasPrefix(bytes.ToUpper(s[j:]), doctypeBytes) </span><span class="cov8" title="1">{
                                        b.Write(s[written:j])
                                        b.WriteString("&amp;lt;")
                                        written = j + 1
                                }</span>
                        }
                } else<span class="cov8" title="1"> if isComment(c.state) &amp;&amp; c.delim == delimNone </span><span class="cov8" title="1">{
                        switch c.state </span>{
                        case stateJSBlockCmt:<span class="cov8" title="1">
                                // https://es5.github.com/#x7.4:
                                // "Comments behave like white space and are
                                // discarded except that, if a MultiLineComment
                                // contains a line terminator character, then
                                // the entire comment is considered to be a
                                // LineTerminator for purposes of parsing by
                                // the syntactic grammar."
                                if bytes.ContainsAny(s[written:i1], "\n\r\u2028\u2029") </span><span class="cov8" title="1">{
                                        b.WriteByte('\n')
                                }</span> else<span class="cov8" title="1"> {
                                        b.WriteByte(' ')
                                }</span>
                        case stateCSSBlockCmt:<span class="cov8" title="1">
                                b.WriteByte(' ')</span>
                        }
                        <span class="cov8" title="1">written = i1</span>
                }
                <span class="cov8" title="1">if c.state != c1.state &amp;&amp; isComment(c1.state) &amp;&amp; c1.delim == delimNone </span><span class="cov8" title="1">{
                        // Preserve the portion between written and the comment start.
                        cs := i1 - 2
                        if c1.state == stateHTMLCmt </span><span class="cov8" title="1">{
                                // "&lt;!--" instead of "/*" or "//"
                                cs -= 2
                        }</span>
                        <span class="cov8" title="1">b.Write(s[written:cs])
                        written = i1</span>
                }
                <span class="cov8" title="1">if i == i1 &amp;&amp; c.state == c1.state </span><span class="cov0" title="0">{
                        panic(fmt.Sprintf("infinite loop from %v to %v on %q..%q", c, c1, s[:i], s[i:]))</span>
                }
                <span class="cov8" title="1">c, i = c1, i1</span>
        }

        <span class="cov8" title="1">if written != 0 &amp;&amp; c.state != stateError </span><span class="cov8" title="1">{
                if !isComment(c.state) || c.delim != delimNone </span><span class="cov8" title="1">{
                        b.Write(n.Text[written:])
                }</span>
                <span class="cov8" title="1">e.editTextNode(n, b.Bytes())</span>
        }
        <span class="cov8" title="1">return c</span>
}

// contextAfterText starts in context c, consumes some tokens from the front of
// s, then returns the context after those tokens and the unprocessed suffix.
func contextAfterText(c context, s []byte) (context, int) <span class="cov8" title="1">{
        if c.delim == delimNone </span><span class="cov8" title="1">{
                c1, i := tSpecialTagEnd(c, s)
                if i == 0 </span><span class="cov8" title="1">{
                        // A special end tag (`&lt;/script&gt;`) has been seen and
                        // all content preceding it has been consumed.
                        return c1, 0
                }</span>
                // Consider all content up to any end tag.
                <span class="cov8" title="1">return transitionFunc[c.state](c, s[:i])</span>
        }

        // We are at the beginning of an attribute value.

        <span class="cov8" title="1">i := bytes.IndexAny(s, delimEnds[c.delim])
        if i == -1 </span><span class="cov8" title="1">{
                i = len(s)
        }</span>
        <span class="cov8" title="1">if c.delim == delimSpaceOrTagEnd </span><span class="cov8" title="1">{
                // https://www.w3.org/TR/html5/syntax.html#attribute-value-(unquoted)-state
                // lists the runes below as error characters.
                // Error out because HTML parsers may differ on whether
                // "&lt;a id= onclick=f("     ends inside id's or onclick's value,
                // "&lt;a class=`foo "        ends inside a value,
                // "&lt;a style=font:'Arial'" needs open-quote fixup.
                // IE treats '`' as a quotation character.
                if j := bytes.IndexAny(s[:i], "\"'&lt;=`"); j &gt;= 0 </span><span class="cov8" title="1">{
                        return context{
                                state: stateError,
                                err:   errorf(ErrBadHTML, nil, 0, "%q in unquoted attr: %q", s[j:j+1], s[:i]),
                        }, len(s)
                }</span>
        }
        <span class="cov8" title="1">if i == len(s) </span><span class="cov8" title="1">{
                // Remain inside the attribute.
                // Decode the value so non-HTML rules can easily handle
                //     &lt;button onclick="alert(&amp;quot;Hi!&amp;quot;)"&gt;
                // without having to entity decode token boundaries.
                for u := []byte(html.UnescapeString(string(s))); len(u) != 0; </span><span class="cov8" title="1">{
                        c1, i1 := transitionFunc[c.state](c, u)
                        c, u = c1, u[i1:]
                }</span>
                <span class="cov8" title="1">return c, len(s)</span>
        }

        <span class="cov8" title="1">element := c.element

        // If this is a non-JS "type" attribute inside "script" tag, do not treat the contents as JS.
        if c.state == stateAttr &amp;&amp; c.element == elementScript &amp;&amp; c.attr == attrScriptType &amp;&amp; !isJSType(string(s[:i])) </span><span class="cov8" title="1">{
                element = elementNone
        }</span>

        <span class="cov8" title="1">if c.delim != delimSpaceOrTagEnd </span><span class="cov8" title="1">{
                // Consume any quote.
                i++
        }</span>
        // On exiting an attribute, we discard all state information
        // except the state and element.
        <span class="cov8" title="1">return context{state: stateTag, element: element}, i</span>
}

// editActionNode records a change to an action pipeline for later commit.
func (e *escaper) editActionNode(n *parse.ActionNode, cmds []string) <span class="cov8" title="1">{
        if _, ok := e.actionNodeEdits[n]; ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("node %s shared between templates", n))</span>
        }
        <span class="cov8" title="1">e.actionNodeEdits[n] = cmds</span>
}

// editTemplateNode records a change to a {{template}} callee for later commit.
func (e *escaper) editTemplateNode(n *parse.TemplateNode, callee string) <span class="cov8" title="1">{
        if _, ok := e.templateNodeEdits[n]; ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("node %s shared between templates", n))</span>
        }
        <span class="cov8" title="1">e.templateNodeEdits[n] = callee</span>
}

// editTextNode records a change to a text node for later commit.
func (e *escaper) editTextNode(n *parse.TextNode, text []byte) <span class="cov8" title="1">{
        if _, ok := e.textNodeEdits[n]; ok </span><span class="cov0" title="0">{
                panic(fmt.Sprintf("node %s shared between templates", n))</span>
        }
        <span class="cov8" title="1">e.textNodeEdits[n] = text</span>
}

// commit applies changes to actions and template calls needed to contextually
// autoescape content and adds any derived templates to the set.
func (e *escaper) commit() <span class="cov8" title="1">{
        for name := range e.output </span><span class="cov8" title="1">{
                e.template(name).Funcs(funcMap)
        }</span>
        // Any template from the name space associated with this escaper can be used
        // to add derived templates to the underlying text/template name space.
        <span class="cov8" title="1">tmpl := e.arbitraryTemplate()
        for _, t := range e.derived </span><span class="cov8" title="1">{
                if _, err := tmpl.text.AddParseTree(t.Name(), t.Tree); err != nil </span><span class="cov0" title="0">{
                        panic("error adding derived template")</span>
                }
        }
        <span class="cov8" title="1">for n, s := range e.actionNodeEdits </span><span class="cov8" title="1">{
                ensurePipelineContains(n.Pipe, s)
        }</span>
        <span class="cov8" title="1">for n, name := range e.templateNodeEdits </span><span class="cov8" title="1">{
                n.Name = name
        }</span>
        <span class="cov8" title="1">for n, s := range e.textNodeEdits </span><span class="cov8" title="1">{
                n.Text = s
        }</span>
        // Reset state that is specific to this commit so that the same changes are
        // not re-applied to the template on subsequent calls to commit.
        <span class="cov8" title="1">e.called = make(map[string]bool)
        e.actionNodeEdits = make(map[*parse.ActionNode][]string)
        e.templateNodeEdits = make(map[*parse.TemplateNode]string)
        e.textNodeEdits = make(map[*parse.TextNode][]byte)</span>
}

// template returns the named template given a mangled template name.
func (e *escaper) template(name string) *template.Template <span class="cov8" title="1">{
        // Any template from the name space associated with this escaper can be used
        // to look up templates in the underlying text/template name space.
        t := e.arbitraryTemplate().text.Lookup(name)
        if t == nil </span><span class="cov8" title="1">{
                t = e.derived[name]
        }</span>
        <span class="cov8" title="1">return t</span>
}

// arbitraryTemplate returns an arbitrary template from the name space
// associated with e and panics if no templates are found.
func (e *escaper) arbitraryTemplate() *Template <span class="cov8" title="1">{
        for _, t := range e.ns.set </span><span class="cov8" title="1">{
                return t
        }</span>
        <span class="cov0" title="0">panic("no templates in name space")</span>
}

// Forwarding functions so that clients need only import this package
// to reach the general escaping functions of text/template.

// HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.
func HTMLEscape(w io.Writer, b []byte) <span class="cov8" title="1">{
        template.HTMLEscape(w, b)
}</span>

// HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.
func HTMLEscapeString(s string) string <span class="cov8" title="1">{
        return template.HTMLEscapeString(s)
}</span>

// HTMLEscaper returns the escaped HTML equivalent of the textual
// representation of its arguments.
func HTMLEscaper(args ...interface{}) string <span class="cov8" title="1">{
        return template.HTMLEscaper(args...)
}</span>

// JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.
func JSEscape(w io.Writer, b []byte) <span class="cov8" title="1">{
        template.JSEscape(w, b)
}</span>

// JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.
func JSEscapeString(s string) string <span class="cov8" title="1">{
        return template.JSEscapeString(s)
}</span>

// JSEscaper returns the escaped JavaScript equivalent of the textual
// representation of its arguments.
func JSEscaper(args ...interface{}) string <span class="cov8" title="1">{
        return template.JSEscaper(args...)
}</span>

// URLQueryEscaper returns the escaped value of the textual representation of
// its arguments in a form suitable for embedding in a URL query.
func URLQueryEscaper(args ...interface{}) string <span class="cov8" title="1">{
        return template.URLQueryEscaper(args...)
}</span>
</pre>
		
		<pre class="file" id="file307" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "bytes"
        "fmt"
        "strings"
        "unicode/utf8"
)

// htmlNospaceEscaper escapes for inclusion in unquoted attribute values.
func htmlNospaceEscaper(args ...interface{}) string <span class="cov8" title="1">{
        s, t := stringify(args...)
        if t == contentTypeHTML </span><span class="cov8" title="1">{
                return htmlReplacer(stripTags(s), htmlNospaceNormReplacementTable, false)
        }</span>
        <span class="cov8" title="1">return htmlReplacer(s, htmlNospaceReplacementTable, false)</span>
}

// attrEscaper escapes for inclusion in quoted attribute values.
func attrEscaper(args ...interface{}) string <span class="cov8" title="1">{
        s, t := stringify(args...)
        if t == contentTypeHTML </span><span class="cov8" title="1">{
                return htmlReplacer(stripTags(s), htmlNormReplacementTable, true)
        }</span>
        <span class="cov8" title="1">return htmlReplacer(s, htmlReplacementTable, true)</span>
}

// rcdataEscaper escapes for inclusion in an RCDATA element body.
func rcdataEscaper(args ...interface{}) string <span class="cov8" title="1">{
        s, t := stringify(args...)
        if t == contentTypeHTML </span><span class="cov8" title="1">{
                return htmlReplacer(s, htmlNormReplacementTable, true)
        }</span>
        <span class="cov8" title="1">return htmlReplacer(s, htmlReplacementTable, true)</span>
}

// htmlEscaper escapes for inclusion in HTML text.
func htmlEscaper(args ...interface{}) string <span class="cov8" title="1">{
        s, t := stringify(args...)
        if t == contentTypeHTML </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">return htmlReplacer(s, htmlReplacementTable, true)</span>
}

// htmlReplacementTable contains the runes that need to be escaped
// inside a quoted attribute value or in a text node.
var htmlReplacementTable = []string{
        // https://www.w3.org/TR/html5/syntax.html#attribute-value-(unquoted)-state
        // U+0000 NULL Parse error. Append a U+FFFD REPLACEMENT
        // CHARACTER character to the current attribute's value.
        // "
        // and similarly
        // https://www.w3.org/TR/html5/syntax.html#before-attribute-value-state
        0:    "\uFFFD",
        '"':  "&amp;#34;",
        '&amp;':  "&amp;amp;",
        '\'': "&amp;#39;",
        '+':  "&amp;#43;",
        '&lt;':  "&amp;lt;",
        '&gt;':  "&amp;gt;",
}

// htmlNormReplacementTable is like htmlReplacementTable but without '&amp;' to
// avoid over-encoding existing entities.
var htmlNormReplacementTable = []string{
        0:    "\uFFFD",
        '"':  "&amp;#34;",
        '\'': "&amp;#39;",
        '+':  "&amp;#43;",
        '&lt;':  "&amp;lt;",
        '&gt;':  "&amp;gt;",
}

// htmlNospaceReplacementTable contains the runes that need to be escaped
// inside an unquoted attribute value.
// The set of runes escaped is the union of the HTML specials and
// those determined by running the JS below in browsers:
// &lt;div id=d&gt;&lt;/div&gt;
// &lt;script&gt;(function () {
// var a = [], d = document.getElementById("d"), i, c, s;
// for (i = 0; i &lt; 0x10000; ++i) {
//   c = String.fromCharCode(i);
//   d.innerHTML = "&lt;span title=" + c + "lt" + c + "&gt;&lt;/span&gt;"
//   s = d.getElementsByTagName("SPAN")[0];
//   if (!s || s.title !== c + "lt" + c) { a.push(i.toString(16)); }
// }
// document.write(a.join(", "));
// })()&lt;/script&gt;
var htmlNospaceReplacementTable = []string{
        0:    "&amp;#xfffd;",
        '\t': "&amp;#9;",
        '\n': "&amp;#10;",
        '\v': "&amp;#11;",
        '\f': "&amp;#12;",
        '\r': "&amp;#13;",
        ' ':  "&amp;#32;",
        '"':  "&amp;#34;",
        '&amp;':  "&amp;amp;",
        '\'': "&amp;#39;",
        '+':  "&amp;#43;",
        '&lt;':  "&amp;lt;",
        '=':  "&amp;#61;",
        '&gt;':  "&amp;gt;",
        // A parse error in the attribute value (unquoted) and
        // before attribute value states.
        // Treated as a quoting character by IE.
        '`': "&amp;#96;",
}

// htmlNospaceNormReplacementTable is like htmlNospaceReplacementTable but
// without '&amp;' to avoid over-encoding existing entities.
var htmlNospaceNormReplacementTable = []string{
        0:    "&amp;#xfffd;",
        '\t': "&amp;#9;",
        '\n': "&amp;#10;",
        '\v': "&amp;#11;",
        '\f': "&amp;#12;",
        '\r': "&amp;#13;",
        ' ':  "&amp;#32;",
        '"':  "&amp;#34;",
        '\'': "&amp;#39;",
        '+':  "&amp;#43;",
        '&lt;':  "&amp;lt;",
        '=':  "&amp;#61;",
        '&gt;':  "&amp;gt;",
        // A parse error in the attribute value (unquoted) and
        // before attribute value states.
        // Treated as a quoting character by IE.
        '`': "&amp;#96;",
}

// htmlReplacer returns s with runes replaced according to replacementTable
// and when badRunes is true, certain bad runes are allowed through unescaped.
func htmlReplacer(s string, replacementTable []string, badRunes bool) string <span class="cov8" title="1">{
        written, b := 0, new(strings.Builder)
        r, w := rune(0), 0
        for i := 0; i &lt; len(s); i += w </span><span class="cov8" title="1">{
                // Cannot use 'for range s' because we need to preserve the width
                // of the runes in the input. If we see a decoding error, the input
                // width will not be utf8.Runelen(r) and we will overrun the buffer.
                r, w = utf8.DecodeRuneInString(s[i:])
                if int(r) &lt; len(replacementTable) </span><span class="cov8" title="1">{
                        if repl := replacementTable[r]; len(repl) != 0 </span><span class="cov8" title="1">{
                                if written == 0 </span><span class="cov8" title="1">{
                                        b.Grow(len(s))
                                }</span>
                                <span class="cov8" title="1">b.WriteString(s[written:i])
                                b.WriteString(repl)
                                written = i + w</span>
                        }
                } else<span class="cov8" title="1"> if badRunes </span>{<span class="cov8" title="1">
                        // No-op.
                        // IE does not allow these ranges in unquoted attrs.
                }</span> else<span class="cov8" title="1"> if 0xfdd0 &lt;= r &amp;&amp; r &lt;= 0xfdef || 0xfff0 &lt;= r &amp;&amp; r &lt;= 0xffff </span><span class="cov8" title="1">{
                        if written == 0 </span><span class="cov0" title="0">{
                                b.Grow(len(s))
                        }</span>
                        <span class="cov8" title="1">fmt.Fprintf(b, "%s&amp;#x%x;", s[written:i], r)
                        written = i + w</span>
                }
        }
        <span class="cov8" title="1">if written == 0 </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">b.WriteString(s[written:])
        return b.String()</span>
}

// stripTags takes a snippet of HTML and returns only the text content.
// For example, `&lt;b&gt;&amp;iexcl;Hi!&lt;/b&gt; &lt;script&gt;...&lt;/script&gt;` -&gt; `&amp;iexcl;Hi! `.
func stripTags(html string) string <span class="cov8" title="1">{
        var b bytes.Buffer
        s, c, i, allText := []byte(html), context{}, 0, true
        // Using the transition funcs helps us avoid mangling
        // `&lt;div title="1&gt;2"&gt;` or `I &lt;3 Ponies!`.
        for i != len(s) </span><span class="cov8" title="1">{
                if c.delim == delimNone </span><span class="cov8" title="1">{
                        st := c.state
                        // Use RCDATA instead of parsing into JS or CSS styles.
                        if c.element != elementNone &amp;&amp; !isInTag(st) </span><span class="cov8" title="1">{
                                st = stateRCDATA
                        }</span>
                        <span class="cov8" title="1">d, nread := transitionFunc[st](c, s[i:])
                        i1 := i + nread
                        if c.state == stateText || c.state == stateRCDATA </span><span class="cov8" title="1">{
                                // Emit text up to the start of the tag or comment.
                                j := i1
                                if d.state != c.state </span><span class="cov8" title="1">{
                                        for j1 := j - 1; j1 &gt;= i; j1-- </span><span class="cov8" title="1">{
                                                if s[j1] == '&lt;' </span><span class="cov8" title="1">{
                                                        j = j1
                                                        break</span>
                                                }
                                        }
                                }
                                <span class="cov8" title="1">b.Write(s[i:j])</span>
                        } else<span class="cov8" title="1"> {
                                allText = false
                        }</span>
                        <span class="cov8" title="1">c, i = d, i1
                        continue</span>
                }
                <span class="cov8" title="1">i1 := i + bytes.IndexAny(s[i:], delimEnds[c.delim])
                if i1 &lt; i </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">if c.delim != delimSpaceOrTagEnd </span><span class="cov8" title="1">{
                        // Consume any quote.
                        i1++
                }</span>
                <span class="cov8" title="1">c, i = context{state: stateTag, element: c.element}, i1</span>
        }
        <span class="cov8" title="1">if allText </span><span class="cov8" title="1">{
                return html
        }</span> else<span class="cov8" title="1"> if c.state == stateText || c.state == stateRCDATA </span><span class="cov8" title="1">{
                b.Write(s[i:])
        }</span>
        <span class="cov8" title="1">return b.String()</span>
}

// htmlNameFilter accepts valid parts of an HTML attribute or tag name or
// a known-safe HTML attribute.
func htmlNameFilter(args ...interface{}) string <span class="cov8" title="1">{
        s, t := stringify(args...)
        if t == contentTypeHTMLAttr </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">if len(s) == 0 </span><span class="cov8" title="1">{
                // Avoid violation of structure preservation.
                // &lt;input checked {{.K}}={{.V}}&gt;.
                // Without this, if .K is empty then .V is the value of
                // checked, but otherwise .V is the value of the attribute
                // named .K.
                return filterFailsafe
        }</span>
        <span class="cov8" title="1">s = strings.ToLower(s)
        if t := attrType(s); t != contentTypePlain </span><span class="cov8" title="1">{
                // TODO: Split attr and element name part filters so we can recognize known attributes.
                return filterFailsafe
        }</span>
        <span class="cov8" title="1">for _, r := range s </span><span class="cov8" title="1">{
                switch </span>{
                case '0' &lt;= r &amp;&amp; r &lt;= '9':<span class="cov8" title="1"></span>
                case 'a' &lt;= r &amp;&amp; r &lt;= 'z':<span class="cov8" title="1"></span>
                default:<span class="cov8" title="1">
                        return filterFailsafe</span>
                }
        }
        <span class="cov8" title="1">return s</span>
}

// commentEscaper returns the empty string regardless of input.
// Comment content does not correspond to any parsed structure or
// human-readable content, so the simplest and most secure policy is to drop
// content interpolated into comments.
// This approach is equally valid whether or not static comment content is
// removed from the template.
func commentEscaper(args ...interface{}) string <span class="cov8" title="1">{
        return ""
}</span>
</pre>
		
		<pre class="file" id="file308" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package template

import (
        template "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate"
)

/*

This files contains the Hugo related addons. All the other files in this
package is auto generated.

*/

// Export it so we can populate Hugo's func map with it, which makes it faster.
var GoFuncs = funcMap

// Prepare returns a template ready for execution.
func (t *Template) Prepare() (*template.Template, error) <span class="cov0" title="0">{
        if err := t.escape(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return t.text, nil</span>
}
</pre>
		
		<pre class="file" id="file309" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "bytes"
        "encoding/json"
        "fmt"
        htmltemplate "html/template"
        "reflect"
        "strings"
        "unicode/utf8"
)

// nextJSCtx returns the context that determines whether a slash after the
// given run of tokens starts a regular expression instead of a division
// operator: / or /=.
//
// This assumes that the token run does not include any string tokens, comment
// tokens, regular expression literal tokens, or division operators.
//
// This fails on some valid but nonsensical JavaScript programs like
// "x = ++/foo/i" which is quite different than "x++/foo/i", but is not known to
// fail on any known useful programs. It is based on the draft
// JavaScript 2.0 lexical grammar and requires one token of lookbehind:
// https://www.mozilla.org/js/language/js20-2000-07/rationale/syntax.html
func nextJSCtx(s []byte, preceding jsCtx) jsCtx <span class="cov8" title="1">{
        s = bytes.TrimRight(s, "\t\n\f\r \u2028\u2029")
        if len(s) == 0 </span><span class="cov8" title="1">{
                return preceding
        }</span>

        // All cases below are in the single-byte UTF-8 group.
        <span class="cov8" title="1">switch c, n := s[len(s)-1], len(s); c </span>{
        case '+', '-':<span class="cov8" title="1">
                // ++ and -- are not regexp preceders, but + and - are whether
                // they are used as infix or prefix operators.
                start := n - 1
                // Count the number of adjacent dashes or pluses.
                for start &gt; 0 &amp;&amp; s[start-1] == c </span><span class="cov8" title="1">{
                        start--
                }</span>
                <span class="cov8" title="1">if (n-start)&amp;1 == 1 </span><span class="cov8" title="1">{
                        // Reached for trailing minus signs since "---" is the
                        // same as "-- -".
                        return jsCtxRegexp
                }</span>
                <span class="cov8" title="1">return jsCtxDivOp</span>
        case '.':<span class="cov8" title="1">
                // Handle "42."
                if n != 1 &amp;&amp; '0' &lt;= s[n-2] &amp;&amp; s[n-2] &lt;= '9' </span><span class="cov8" title="1">{
                        return jsCtxDivOp
                }</span>
                <span class="cov0" title="0">return jsCtxRegexp</span>
        // Suffixes for all punctuators from section 7.7 of the language spec
        // that only end binary operators not handled above.
        case ',', '&lt;', '&gt;', '=', '*', '%', '&amp;', '|', '^', '?':<span class="cov8" title="1">
                return jsCtxRegexp</span>
        // Suffixes for all punctuators from section 7.7 of the language spec
        // that are prefix operators not handled above.
        case '!', '~':<span class="cov8" title="1">
                return jsCtxRegexp</span>
        // Matches all the punctuators from section 7.7 of the language spec
        // that are open brackets not handled above.
        case '(', '[':<span class="cov8" title="1">
                return jsCtxRegexp</span>
        // Matches all the punctuators from section 7.7 of the language spec
        // that precede expression starts.
        case ':', ';', '{':<span class="cov8" title="1">
                return jsCtxRegexp</span>
        // CAVEAT: the close punctuators ('}', ']', ')') precede div ops and
        // are handled in the default except for '}' which can precede a
        // division op as in
        //    ({ valueOf: function () { return 42 } } / 2
        // which is valid, but, in practice, developers don't divide object
        // literals, so our heuristic works well for code like
        //    function () { ... }  /foo/.test(x) &amp;&amp; sideEffect();
        // The ')' punctuator can precede a regular expression as in
        //     if (b) /foo/.test(x) &amp;&amp; ...
        // but this is much less likely than
        //     (a + b) / c
        case '}':<span class="cov8" title="1">
                return jsCtxRegexp</span>
        default:<span class="cov8" title="1">
                // Look for an IdentifierName and see if it is a keyword that
                // can precede a regular expression.
                j := n
                for j &gt; 0 &amp;&amp; isJSIdentPart(rune(s[j-1])) </span><span class="cov8" title="1">{
                        j--
                }</span>
                <span class="cov8" title="1">if regexpPrecederKeywords[string(s[j:])] </span><span class="cov8" title="1">{
                        return jsCtxRegexp
                }</span>
        }
        // Otherwise is a punctuator not listed above, or
        // a string which precedes a div op, or an identifier
        // which precedes a div op.
        <span class="cov8" title="1">return jsCtxDivOp</span>
}

// regexpPrecederKeywords is a set of reserved JS keywords that can precede a
// regular expression in JS source.
var regexpPrecederKeywords = map[string]bool{
        "break":      true,
        "case":       true,
        "continue":   true,
        "delete":     true,
        "do":         true,
        "else":       true,
        "finally":    true,
        "in":         true,
        "instanceof": true,
        "return":     true,
        "throw":      true,
        "try":        true,
        "typeof":     true,
        "void":       true,
}

var jsonMarshalType = reflect.TypeOf((*json.Marshaler)(nil)).Elem()

// indirectToJSONMarshaler returns the value, after dereferencing as many times
// as necessary to reach the base type (or nil) or an implementation of json.Marshal.
func indirectToJSONMarshaler(a interface{}) interface{} <span class="cov8" title="1">{
        // text/template now supports passing untyped nil as a func call
        // argument, so we must support it. Otherwise we'd panic below, as one
        // cannot call the Type or Interface methods on an invalid
        // reflect.Value. See golang.org/issue/18716.
        if a == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">v := reflect.ValueOf(a)
        for !v.Type().Implements(jsonMarshalType) &amp;&amp; v.Kind() == reflect.Ptr &amp;&amp; !v.IsNil() </span><span class="cov0" title="0">{
                v = v.Elem()
        }</span>
        <span class="cov8" title="1">return v.Interface()</span>
}

// jsValEscaper escapes its inputs to a JS Expression (section 11.14) that has
// neither side-effects nor free variables outside (NaN, Infinity).
func jsValEscaper(args ...interface{}) string <span class="cov8" title="1">{
        var a interface{}
        if len(args) == 1 </span><span class="cov8" title="1">{
                a = indirectToJSONMarshaler(args[0])
                switch t := a.(type) </span>{
                case htmltemplate.JS:<span class="cov8" title="1">
                        return string(t)</span>
                case htmltemplate.JSStr:<span class="cov8" title="1">
                        // TODO: normalize quotes.
                        return `"` + string(t) + `"`</span>
                case json.Marshaler:<span class="cov8" title="1"></span>
                        // Do not treat as a Stringer.
                case fmt.Stringer:<span class="cov0" title="0">
                        a = t.String()</span>
                }
        } else<span class="cov0" title="0"> {
                for i, arg := range args </span><span class="cov0" title="0">{
                        args[i] = indirectToJSONMarshaler(arg)
                }</span>
                <span class="cov0" title="0">a = fmt.Sprint(args...)</span>
        }
        // TODO: detect cycles before calling Marshal which loops infinitely on
        // cyclic data. This may be an unacceptable DoS risk.
        <span class="cov8" title="1">b, err := json.Marshal(a)
        if err != nil </span><span class="cov8" title="1">{
                // Put a space before comment so that if it is flush against
                // a division operator it is not turned into a line comment:
                //     x/{{y}}
                // turning into
                //     x//* error marshaling y:
                //          second line of error message */null
                return fmt.Sprintf(" /* %s */null ", strings.ReplaceAll(err.Error(), "*/", "* /"))
        }</span>

        // TODO: maybe post-process output to prevent it from containing
        // "&lt;!--", "--&gt;", "&lt;![CDATA[", "]]&gt;", or "&lt;/script"
        // in case custom marshalers produce output containing those.
        // Note: Do not use \x escaping to save bytes because it is not JSON compatible and this escaper
        // supports ld+json content-type.
        <span class="cov8" title="1">if len(b) == 0 </span><span class="cov0" title="0">{
                // In, `x=y/{{.}}*z` a json.Marshaler that produces "" should
                // not cause the output `x=y/*z`.
                return " null "
        }</span>
        <span class="cov8" title="1">first, _ := utf8.DecodeRune(b)
        last, _ := utf8.DecodeLastRune(b)
        var buf strings.Builder
        // Prevent IdentifierNames and NumericLiterals from running into
        // keywords: in, instanceof, typeof, void
        pad := isJSIdentPart(first) || isJSIdentPart(last)
        if pad </span><span class="cov8" title="1">{
                buf.WriteByte(' ')
        }</span>
        <span class="cov8" title="1">written := 0
        // Make sure that json.Marshal escapes codepoints U+2028 &amp; U+2029
        // so it falls within the subset of JSON which is valid JS.
        for i := 0; i &lt; len(b); </span><span class="cov8" title="1">{
                rune, n := utf8.DecodeRune(b[i:])
                repl := ""
                if rune == 0x2028 </span><span class="cov0" title="0">{
                        repl = `\u2028`
                }</span> else<span class="cov8" title="1"> if rune == 0x2029 </span><span class="cov0" title="0">{
                        repl = `\u2029`
                }</span>
                <span class="cov8" title="1">if repl != "" </span><span class="cov0" title="0">{
                        buf.Write(b[written:i])
                        buf.WriteString(repl)
                        written = i + n
                }</span>
                <span class="cov8" title="1">i += n</span>
        }
        <span class="cov8" title="1">if buf.Len() != 0 </span><span class="cov8" title="1">{
                buf.Write(b[written:])
                if pad </span><span class="cov8" title="1">{
                        buf.WriteByte(' ')
                }</span>
                <span class="cov8" title="1">return buf.String()</span>
        }
        <span class="cov8" title="1">return string(b)</span>
}

// jsStrEscaper produces a string that can be included between quotes in
// JavaScript source, in JavaScript embedded in an HTML5 &lt;script&gt; element,
// or in an HTML5 event handler attribute such as onclick.
func jsStrEscaper(args ...interface{}) string <span class="cov8" title="1">{
        s, t := stringify(args...)
        if t == contentTypeJSStr </span><span class="cov8" title="1">{
                return replace(s, jsStrNormReplacementTable)
        }</span>
        <span class="cov8" title="1">return replace(s, jsStrReplacementTable)</span>
}

// jsRegexpEscaper behaves like jsStrEscaper but escapes regular expression
// specials so the result is treated literally when included in a regular
// expression literal. /foo{{.X}}bar/ matches the string "foo" followed by
// the literal text of {{.X}} followed by the string "bar".
func jsRegexpEscaper(args ...interface{}) string <span class="cov8" title="1">{
        s, _ := stringify(args...)
        s = replace(s, jsRegexpReplacementTable)
        if s == "" </span><span class="cov8" title="1">{
                // /{{.X}}/ should not produce a line comment when .X == "".
                return "(?:)"
        }</span>
        <span class="cov8" title="1">return s</span>
}

// replace replaces each rune r of s with replacementTable[r], provided that
// r &lt; len(replacementTable). If replacementTable[r] is the empty string then
// no replacement is made.
// It also replaces runes U+2028 and U+2029 with the raw strings `\u2028` and
// `\u2029`.
func replace(s string, replacementTable []string) string <span class="cov8" title="1">{
        var b strings.Builder
        r, w, written := rune(0), 0, 0
        for i := 0; i &lt; len(s); i += w </span><span class="cov8" title="1">{
                // See comment in htmlEscaper.
                r, w = utf8.DecodeRuneInString(s[i:])
                var repl string
                switch </span>{
                case int(r) &lt; len(lowUnicodeReplacementTable):<span class="cov8" title="1">
                        repl = lowUnicodeReplacementTable[r]</span>
                case int(r) &lt; len(replacementTable) &amp;&amp; replacementTable[r] != "":<span class="cov8" title="1">
                        repl = replacementTable[r]</span>
                case r == '\u2028':<span class="cov8" title="1">
                        repl = `\u2028`</span>
                case r == '\u2029':<span class="cov8" title="1">
                        repl = `\u2029`</span>
                default:<span class="cov8" title="1">
                        continue</span>
                }
                <span class="cov8" title="1">if written == 0 </span><span class="cov8" title="1">{
                        b.Grow(len(s))
                }</span>
                <span class="cov8" title="1">b.WriteString(s[written:i])
                b.WriteString(repl)
                written = i + w</span>
        }
        <span class="cov8" title="1">if written == 0 </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">b.WriteString(s[written:])
        return b.String()</span>
}

var lowUnicodeReplacementTable = []string{
        0: `\u0000`, 1: `\u0001`, 2: `\u0002`, 3: `\u0003`, 4: `\u0004`, 5: `\u0005`, 6: `\u0006`,
        '\a': `\u0007`,
        '\b': `\u0008`,
        '\t': `\t`,
        '\n': `\n`,
        '\v': `\u000b`, // "\v" == "v" on IE 6.
        '\f': `\f`,
        '\r': `\r`,
        0xe:  `\u000e`, 0xf: `\u000f`, 0x10: `\u0010`, 0x11: `\u0011`, 0x12: `\u0012`, 0x13: `\u0013`,
        0x14: `\u0014`, 0x15: `\u0015`, 0x16: `\u0016`, 0x17: `\u0017`, 0x18: `\u0018`, 0x19: `\u0019`,
        0x1a: `\u001a`, 0x1b: `\u001b`, 0x1c: `\u001c`, 0x1d: `\u001d`, 0x1e: `\u001e`, 0x1f: `\u001f`,
}

var jsStrReplacementTable = []string{
        0:    `\u0000`,
        '\t': `\t`,
        '\n': `\n`,
        '\v': `\u000b`, // "\v" == "v" on IE 6.
        '\f': `\f`,
        '\r': `\r`,
        // Encode HTML specials as hex so the output can be embedded
        // in HTML attributes without further encoding.
        '"':  `\u0022`,
        '&amp;':  `\u0026`,
        '\'': `\u0027`,
        '+':  `\u002b`,
        '/':  `\/`,
        '&lt;':  `\u003c`,
        '&gt;':  `\u003e`,
        '\\': `\\`,
}

// jsStrNormReplacementTable is like jsStrReplacementTable but does not
// overencode existing escapes since this table has no entry for `\`.
var jsStrNormReplacementTable = []string{
        0:    `\u0000`,
        '\t': `\t`,
        '\n': `\n`,
        '\v': `\u000b`, // "\v" == "v" on IE 6.
        '\f': `\f`,
        '\r': `\r`,
        // Encode HTML specials as hex so the output can be embedded
        // in HTML attributes without further encoding.
        '"':  `\u0022`,
        '&amp;':  `\u0026`,
        '\'': `\u0027`,
        '+':  `\u002b`,
        '/':  `\/`,
        '&lt;':  `\u003c`,
        '&gt;':  `\u003e`,
}
var jsRegexpReplacementTable = []string{
        0:    `\u0000`,
        '\t': `\t`,
        '\n': `\n`,
        '\v': `\u000b`, // "\v" == "v" on IE 6.
        '\f': `\f`,
        '\r': `\r`,
        // Encode HTML specials as hex so the output can be embedded
        // in HTML attributes without further encoding.
        '"':  `\u0022`,
        '$':  `\$`,
        '&amp;':  `\u0026`,
        '\'': `\u0027`,
        '(':  `\(`,
        ')':  `\)`,
        '*':  `\*`,
        '+':  `\u002b`,
        '-':  `\-`,
        '.':  `\.`,
        '/':  `\/`,
        '&lt;':  `\u003c`,
        '&gt;':  `\u003e`,
        '?':  `\?`,
        '[':  `\[`,
        '\\': `\\`,
        ']':  `\]`,
        '^':  `\^`,
        '{':  `\{`,
        '|':  `\|`,
        '}':  `\}`,
}

// isJSIdentPart reports whether the given rune is a JS identifier part.
// It does not handle all the non-Latin letters, joiners, and combining marks,
// but it does handle every codepoint that can occur in a numeric literal or
// a keyword.
func isJSIdentPart(r rune) bool <span class="cov8" title="1">{
        switch </span>{
        case r == '$':<span class="cov0" title="0">
                return true</span>
        case '0' &lt;= r &amp;&amp; r &lt;= '9':<span class="cov8" title="1">
                return true</span>
        case 'A' &lt;= r &amp;&amp; r &lt;= 'Z':<span class="cov0" title="0">
                return true</span>
        case r == '_':<span class="cov0" title="0">
                return true</span>
        case 'a' &lt;= r &amp;&amp; r &lt;= 'z':<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// isJSType reports whether the given MIME type should be considered JavaScript.
//
// It is used to determine whether a script tag with a type attribute is a javascript container.
func isJSType(mimeType string) bool <span class="cov8" title="1">{
        // per
        //   https://www.w3.org/TR/html5/scripting-1.html#attr-script-type
        //   https://tools.ietf.org/html/rfc7231#section-3.1.1
        //   https://tools.ietf.org/html/rfc4329#section-3
        //   https://www.ietf.org/rfc/rfc4627.txt
        // discard parameters
        if i := strings.Index(mimeType, ";"); i &gt;= 0 </span><span class="cov8" title="1">{
                mimeType = mimeType[:i]
        }</span>
        <span class="cov8" title="1">mimeType = strings.ToLower(mimeType)
        mimeType = strings.TrimSpace(mimeType)
        switch mimeType </span>{
        case
                "application/ecmascript",
                "application/javascript",
                "application/json",
                "application/ld+json",
                "application/x-ecmascript",
                "application/x-javascript",
                "module",
                "text/ecmascript",
                "text/javascript",
                "text/javascript1.0",
                "text/javascript1.1",
                "text/javascript1.2",
                "text/javascript1.3",
                "text/javascript1.4",
                "text/javascript1.5",
                "text/jscript",
                "text/livescript",
                "text/x-ecmascript",
                "text/x-javascript":<span class="cov8" title="1">
                return true</span>
        default:<span class="cov8" title="1">
                return false</span>
        }
}
</pre>
		
		<pre class="file" id="file310" style="display: none">// Code generated by "stringer -type jsCtx"; DO NOT EDIT.

package template

import "strconv"

const _jsCtx_name = "jsCtxRegexpjsCtxDivOpjsCtxUnknown"

var _jsCtx_index = [...]uint8{0, 11, 21, 33}

func (i jsCtx) String() string <span class="cov8" title="1">{
        if i &gt;= jsCtx(len(_jsCtx_index)-1) </span><span class="cov0" title="0">{
                return "jsCtx(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov8" title="1">return _jsCtx_name[_jsCtx_index[i]:_jsCtx_index[i+1]]</span>
}
</pre>
		
		<pre class="file" id="file311" style="display: none">// Code generated by "stringer -type state"; DO NOT EDIT.

package template

import "strconv"

const _state_name = "stateTextstateTagstateAttrNamestateAfterNamestateBeforeValuestateHTMLCmtstateRCDATAstateAttrstateURLstateSrcsetstateJSstateJSDqStrstateJSSqStrstateJSRegexpstateJSBlockCmtstateJSLineCmtstateCSSstateCSSDqStrstateCSSSqStrstateCSSDqURLstateCSSSqURLstateCSSURLstateCSSBlockCmtstateCSSLineCmtstateError"

var _state_index = [...]uint16{0, 9, 17, 30, 44, 60, 72, 83, 92, 100, 111, 118, 130, 142, 155, 170, 184, 192, 205, 218, 231, 244, 255, 271, 286, 296}

func (i state) String() string <span class="cov8" title="1">{
        if i &gt;= state(len(_state_index)-1) </span><span class="cov0" title="0">{
                return "state(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov8" title="1">return _state_name[_state_index[i]:_state_index[i+1]]</span>
}
</pre>
		
		<pre class="file" id="file312" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "fmt"
        "io"
        "io/fs"
        "os"
        "path"
        "path/filepath"
        "sync"

        template "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate"
        "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/parse"
)

// Template is a specialized Template from "text/template" that produces a safe
// HTML document fragment.
type Template struct {
        // Sticky error if escaping fails, or escapeOK if succeeded.
        escapeErr error
        // We could embed the text/template field, but it's safer not to because
        // we need to keep our version of the name space and the underlying
        // template's in sync.
        text *template.Template
        // The underlying template's parse tree, updated to be HTML-safe.
        Tree       *parse.Tree
        *nameSpace // common to all associated templates
}

// escapeOK is a sentinel value used to indicate valid escaping.
var escapeOK = fmt.Errorf("template escaped correctly")

// nameSpace is the data structure shared by all templates in an association.
type nameSpace struct {
        mu      sync.Mutex
        set     map[string]*Template
        escaped bool
        esc     escaper
}

// Templates returns a slice of the templates associated with t, including t
// itself.
func (t *Template) Templates() []*Template <span class="cov8" title="1">{
        ns := t.nameSpace
        ns.mu.Lock()
        defer ns.mu.Unlock()
        // Return a slice so we don't expose the map.
        m := make([]*Template, 0, len(ns.set))
        for _, v := range ns.set </span><span class="cov8" title="1">{
                m = append(m, v)
        }</span>
        <span class="cov8" title="1">return m</span>
}

// Option sets options for the template. Options are described by
// strings, either a simple string or "key=value". There can be at
// most one equals sign in an option string. If the option string
// is unrecognized or otherwise invalid, Option panics.
//
// Known options:
//
// missingkey: Control the behavior during execution if a map is
// indexed with a key that is not present in the map.
//        "missingkey=default" or "missingkey=invalid"
//                The default behavior: Do nothing and continue execution.
//                If printed, the result of the index operation is the string
//                "&lt;no value&gt;".
//        "missingkey=zero"
//                The operation returns the zero value for the map type's element.
//        "missingkey=error"
//                Execution stops immediately with an error.
//
func (t *Template) Option(opt ...string) *Template <span class="cov8" title="1">{
        t.text.Option(opt...)
        return t
}</span>

// checkCanParse checks whether it is OK to parse templates.
// If not, it returns an error.
func (t *Template) checkCanParse() error <span class="cov8" title="1">{
        if t == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">t.nameSpace.mu.Lock()
        defer t.nameSpace.mu.Unlock()
        if t.nameSpace.escaped </span><span class="cov8" title="1">{
                return fmt.Errorf("html/template: cannot Parse after Execute")
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// escape escapes all associated templates.
func (t *Template) escape() error <span class="cov8" title="1">{
        t.nameSpace.mu.Lock()
        defer t.nameSpace.mu.Unlock()
        t.nameSpace.escaped = true
        if t.escapeErr == nil </span><span class="cov8" title="1">{
                if t.Tree == nil </span><span class="cov8" title="1">{
                        return fmt.Errorf("template: %q is an incomplete or empty template", t.Name())
                }</span>
                <span class="cov8" title="1">if err := escapeTemplate(t, t.text.Root, t.Name()); err != nil </span><span class="cov8" title="1">{
                        return err
                }</span>
        } else<span class="cov8" title="1"> if t.escapeErr != escapeOK </span><span class="cov8" title="1">{
                return t.escapeErr
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Execute applies a parsed template to the specified data object,
// writing the output to wr.
// If an error occurs executing the template or writing its output,
// execution stops, but partial results may already have been written to
// the output writer.
// A template may be executed safely in parallel, although if parallel
// executions share a Writer the output may be interleaved.
func (t *Template) Execute(wr io.Writer, data interface{}) error <span class="cov8" title="1">{
        if err := t.escape(); err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return t.text.Execute(wr, data)</span>
}

// ExecuteTemplate applies the template associated with t that has the given
// name to the specified data object and writes the output to wr.
// If an error occurs executing the template or writing its output,
// execution stops, but partial results may already have been written to
// the output writer.
// A template may be executed safely in parallel, although if parallel
// executions share a Writer the output may be interleaved.
func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error <span class="cov8" title="1">{
        tmpl, err := t.lookupAndEscapeTemplate(name)
        if err != nil </span><span class="cov8" title="1">{
                return err
        }</span>
        <span class="cov8" title="1">return tmpl.text.Execute(wr, data)</span>
}

// lookupAndEscapeTemplate guarantees that the template with the given name
// is escaped, or returns an error if it cannot be. It returns the named
// template.
func (t *Template) lookupAndEscapeTemplate(name string) (tmpl *Template, err error) <span class="cov8" title="1">{
        t.nameSpace.mu.Lock()
        defer t.nameSpace.mu.Unlock()
        t.nameSpace.escaped = true
        tmpl = t.set[name]
        if tmpl == nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("html/template: %q is undefined", name)
        }</span>
        <span class="cov8" title="1">if tmpl.escapeErr != nil &amp;&amp; tmpl.escapeErr != escapeOK </span><span class="cov0" title="0">{
                return nil, tmpl.escapeErr
        }</span>
        <span class="cov8" title="1">if tmpl.text.Tree == nil || tmpl.text.Root == nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("html/template: %q is an incomplete template", name)
        }</span>
        <span class="cov8" title="1">if t.text.Lookup(name) == nil </span><span class="cov0" title="0">{
                panic("html/template internal error: template escaping out of sync")</span>
        }
        <span class="cov8" title="1">if tmpl.escapeErr == nil </span><span class="cov8" title="1">{
                err = escapeTemplate(tmpl, tmpl.text.Root, name)
        }</span>
        <span class="cov8" title="1">return tmpl, err</span>
}

// DefinedTemplates returns a string listing the defined templates,
// prefixed by the string "; defined templates are: ". If there are none,
// it returns the empty string. Used to generate an error message.
func (t *Template) DefinedTemplates() string <span class="cov8" title="1">{
        return t.text.DefinedTemplates()
}</span>

// Parse parses text as a template body for t.
// Named template definitions ({{define ...}} or {{block ...}} statements) in text
// define additional templates associated with t and are removed from the
// definition of t itself.
//
// Templates can be redefined in successive calls to Parse,
// before the first use of Execute on t or any associated template.
// A template definition with a body containing only white space and comments
// is considered empty and will not replace an existing template's body.
// This allows using Parse to add new named template definitions without
// overwriting the main template body.
func (t *Template) Parse(text string) (*Template, error) <span class="cov8" title="1">{
        if err := t.checkCanParse(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ret, err := t.text.Parse(text)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        // In general, all the named templates might have changed underfoot.
        // Regardless, some new ones may have been defined.
        // The template.Template set has been updated; update ours.
        <span class="cov8" title="1">t.nameSpace.mu.Lock()
        defer t.nameSpace.mu.Unlock()
        for _, v := range ret.Templates() </span><span class="cov8" title="1">{
                name := v.Name()
                tmpl := t.set[name]
                if tmpl == nil </span><span class="cov8" title="1">{
                        tmpl = t.new(name)
                }</span>
                <span class="cov8" title="1">tmpl.text = v
                tmpl.Tree = v.Tree</span>
        }
        <span class="cov8" title="1">return t, nil</span>
}

// AddParseTree creates a new template with the name and parse tree
// and associates it with t.
//
// It returns an error if t or any associated template has already been executed.
func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error) <span class="cov8" title="1">{
        if err := t.checkCanParse(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">t.nameSpace.mu.Lock()
        defer t.nameSpace.mu.Unlock()
        text, err := t.text.AddParseTree(name, tree)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ret := &amp;Template{
                nil,
                text,
                text.Tree,
                t.nameSpace,
        }
        t.set[name] = ret
        return ret, nil</span>
}

// Clone returns a duplicate of the template, including all associated
// templates. The actual representation is not copied, but the name space of
// associated templates is, so further calls to Parse in the copy will add
// templates to the copy but not to the original. Clone can be used to prepare
// common templates and use them with variant definitions for other templates
// by adding the variants after the clone is made.
//
// It returns an error if t has already been executed.
func (t *Template) Clone() (*Template, error) <span class="cov8" title="1">{
        t.nameSpace.mu.Lock()
        defer t.nameSpace.mu.Unlock()
        if t.escapeErr != nil </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("html/template: cannot Clone %q after it has executed", t.Name())
        }</span>
        <span class="cov8" title="1">textClone, err := t.text.Clone()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov8" title="1">ns := &amp;nameSpace{set: make(map[string]*Template)}
        ns.esc = makeEscaper(ns)
        ret := &amp;Template{
                nil,
                textClone,
                textClone.Tree,
                ns,
        }
        ret.set[ret.Name()] = ret
        for _, x := range textClone.Templates() </span><span class="cov8" title="1">{
                name := x.Name()
                src := t.set[name]
                if src == nil || src.escapeErr != nil </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("html/template: cannot Clone %q after it has executed", t.Name())
                }</span>
                <span class="cov8" title="1">x.Tree = x.Tree.Copy()
                ret.set[name] = &amp;Template{
                        nil,
                        x,
                        x.Tree,
                        ret.nameSpace,
                }</span>
        }
        // Return the template associated with the name of this template.
        <span class="cov8" title="1">return ret.set[ret.Name()], nil</span>
}

// New allocates a new HTML template with the given name.
func New(name string) *Template <span class="cov8" title="1">{
        ns := &amp;nameSpace{set: make(map[string]*Template)}
        ns.esc = makeEscaper(ns)
        tmpl := &amp;Template{
                nil,
                template.New(name),
                nil,
                ns,
        }
        tmpl.set[name] = tmpl
        return tmpl
}</span>

// New allocates a new HTML template associated with the given one
// and with the same delimiters. The association, which is transitive,
// allows one template to invoke another with a {{template}} action.
//
// If a template with the given name already exists, the new HTML template
// will replace it. The existing template will be reset and disassociated with
// t.
func (t *Template) New(name string) *Template <span class="cov8" title="1">{
        t.nameSpace.mu.Lock()
        defer t.nameSpace.mu.Unlock()
        return t.new(name)
}</span>

// new is the implementation of New, without the lock.
func (t *Template) new(name string) *Template <span class="cov8" title="1">{
        tmpl := &amp;Template{
                nil,
                t.text.New(name),
                nil,
                t.nameSpace,
        }
        if existing, ok := tmpl.set[name]; ok </span><span class="cov8" title="1">{
                emptyTmpl := New(existing.Name())
                *existing = *emptyTmpl
        }</span>
        <span class="cov8" title="1">tmpl.set[name] = tmpl
        return tmpl</span>
}

// Name returns the name of the template.
func (t *Template) Name() string <span class="cov8" title="1">{
        return t.text.Name()
}</span>

// FuncMap is the type of the map defining the mapping from names to
// functions. Each function must have either a single return value, or two
// return values of which the second has type error. In that case, if the
// second (error) argument evaluates to non-nil during execution, execution
// terminates and Execute returns that error. FuncMap has the same base type
// as FuncMap in "text/template", copied here so clients need not import
// "text/template".
type FuncMap map[string]interface{}

// Funcs adds the elements of the argument map to the template's function map.
// It must be called before the template is parsed.
// It panics if a value in the map is not a function with appropriate return
// type. However, it is legal to overwrite elements of the map. The return
// value is the template, so calls can be chained.
func (t *Template) Funcs(funcMap FuncMap) *Template <span class="cov8" title="1">{
        t.text.Funcs(template.FuncMap(funcMap))
        return t
}</span>

// Delims sets the action delimiters to the specified strings, to be used in
// subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template
// definitions will inherit the settings. An empty delimiter stands for the
// corresponding default: {{ or }}.
// The return value is the template, so calls can be chained.
func (t *Template) Delims(left, right string) *Template <span class="cov8" title="1">{
        t.text.Delims(left, right)
        return t
}</span>

// Lookup returns the template with the given name that is associated with t,
// or nil if there is no such template.
func (t *Template) Lookup(name string) *Template <span class="cov8" title="1">{
        t.nameSpace.mu.Lock()
        defer t.nameSpace.mu.Unlock()
        return t.set[name]
}</span>

// Must is a helper that wraps a call to a function returning (*Template, error)
// and panics if the error is non-nil. It is intended for use in variable initializations
// such as
//        var t = template.Must(template.New("name").Parse("html"))
func Must(t *Template, err error) *Template <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return t</span>
}

// ParseFiles creates a new Template and parses the template definitions from
// the named files. The returned template's name will have the (base) name and
// (parsed) contents of the first file. There must be at least one file.
// If an error occurs, parsing stops and the returned *Template is nil.
//
// When parsing multiple files with the same name in different directories,
// the last one mentioned will be the one that results.
// For instance, ParseFiles("a/foo", "b/foo") stores "b/foo" as the template
// named "foo", while "a/foo" is unavailable.
func ParseFiles(filenames ...string) (*Template, error) <span class="cov8" title="1">{
        return parseFiles(nil, readFileOS, filenames...)
}</span>

// ParseFiles parses the named files and associates the resulting templates with
// t. If an error occurs, parsing stops and the returned template is nil;
// otherwise it is t. There must be at least one file.
//
// When parsing multiple files with the same name in different directories,
// the last one mentioned will be the one that results.
//
// ParseFiles returns an error if t or any associated template has already been executed.
func (t *Template) ParseFiles(filenames ...string) (*Template, error) <span class="cov8" title="1">{
        return parseFiles(t, readFileOS, filenames...)
}</span>

// parseFiles is the helper for the method and function. If the argument
// template is nil, it is created from the first file.
func parseFiles(t *Template, readFile func(string) (string, []byte, error), filenames ...string) (*Template, error) <span class="cov8" title="1">{
        if err := t.checkCanParse(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(filenames) == 0 </span><span class="cov0" title="0">{
                // Not really a problem, but be consistent.
                return nil, fmt.Errorf("html/template: no files named in call to ParseFiles")
        }</span>
        <span class="cov8" title="1">for _, filename := range filenames </span><span class="cov8" title="1">{
                name, b, err := readFile(filename)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">s := string(b)
                // First template becomes return value if not already defined,
                // and we use that one for subsequent New calls to associate
                // all the templates together. Also, if this file has the same name
                // as t, this file becomes the contents of t, so
                //  t, err := New(name).Funcs(xxx).ParseFiles(name)
                // works. Otherwise we create a new template associated with t.
                var tmpl *Template
                if t == nil </span><span class="cov0" title="0">{
                        t = New(name)
                }</span>
                <span class="cov8" title="1">if name == t.Name() </span><span class="cov0" title="0">{
                        tmpl = t
                }</span> else<span class="cov8" title="1"> {
                        tmpl = t.New(name)
                }</span>
                <span class="cov8" title="1">_, err = tmpl.Parse(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return t, nil</span>
}

// ParseGlob creates a new Template and parses the template definitions from
// the files identified by the pattern. The files are matched according to the
// semantics of filepath.Match, and the pattern must match at least one file.
// The returned template will have the (base) name and (parsed) contents of the
// first file matched by the pattern. ParseGlob is equivalent to calling
// ParseFiles with the list of files matched by the pattern.
//
// When parsing multiple files with the same name in different directories,
// the last one mentioned will be the one that results.
func ParseGlob(pattern string) (*Template, error) <span class="cov8" title="1">{
        return parseGlob(nil, pattern)
}</span>

// ParseGlob parses the template definitions in the files identified by the
// pattern and associates the resulting templates with t. The files are matched
// according to the semantics of filepath.Match, and the pattern must match at
// least one file. ParseGlob is equivalent to calling t.ParseFiles with the
// list of files matched by the pattern.
//
// When parsing multiple files with the same name in different directories,
// the last one mentioned will be the one that results.
//
// ParseGlob returns an error if t or any associated template has already been executed.
func (t *Template) ParseGlob(pattern string) (*Template, error) <span class="cov8" title="1">{
        return parseGlob(t, pattern)
}</span>

// parseGlob is the implementation of the function and method ParseGlob.
func parseGlob(t *Template, pattern string) (*Template, error) <span class="cov8" title="1">{
        if err := t.checkCanParse(); err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">filenames, err := filepath.Glob(pattern)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(filenames) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("html/template: pattern matches no files: %#q", pattern)
        }</span>
        <span class="cov8" title="1">return parseFiles(t, readFileOS, filenames...)</span>
}

// IsTrue reports whether the value is 'true', in the sense of not the zero of its type,
// and whether the value has a meaningful truth value. This is the definition of
// truth used by if and other such actions.
func IsTrue(val interface{}) (truth, ok bool) <span class="cov0" title="0">{
        return template.IsTrue(val)
}</span>

// ParseFS is like ParseFiles or ParseGlob but reads from the file system fs
// instead of the host operating system's file system.
// It accepts a list of glob patterns.
// (Note that most file names serve as glob patterns matching only themselves.)
func ParseFS(fs fs.FS, patterns ...string) (*Template, error) <span class="cov8" title="1">{
        return parseFS(nil, fs, patterns)
}</span>

// ParseFS is like ParseFiles or ParseGlob but reads from the file system fs
// instead of the host operating system's file system.
// It accepts a list of glob patterns.
// (Note that most file names serve as glob patterns matching only themselves.)
func (t *Template) ParseFS(fs fs.FS, patterns ...string) (*Template, error) <span class="cov8" title="1">{
        return parseFS(t, fs, patterns)
}</span>

func parseFS(t *Template, fsys fs.FS, patterns []string) (*Template, error) <span class="cov8" title="1">{
        var filenames []string
        for _, pattern := range patterns </span><span class="cov8" title="1">{
                list, err := fs.Glob(fsys, pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if len(list) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("template: pattern matches no files: %#q", pattern)
                }</span>
                <span class="cov8" title="1">filenames = append(filenames, list...)</span>
        }
        <span class="cov8" title="1">return parseFiles(t, readFileFS(fsys), filenames...)</span>
}

func readFileOS(file string) (name string, b []byte, err error) <span class="cov8" title="1">{
        name = filepath.Base(file)
        b, err = os.ReadFile(file)
        return
}</span>

func readFileFS(fsys fs.FS) func(string) (string, []byte, error) <span class="cov8" title="1">{
        return func(file string) (name string, b []byte, err error) </span><span class="cov8" title="1">{
                name = path.Base(file)
                b, err = fs.ReadFile(fsys, file)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file313" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "bytes"
        "strings"
)

// transitionFunc is the array of context transition functions for text nodes.
// A transition function takes a context and template text input, and returns
// the updated context and the number of bytes consumed from the front of the
// input.
var transitionFunc = [...]func(context, []byte) (context, int){
        stateText:        tText,
        stateTag:         tTag,
        stateAttrName:    tAttrName,
        stateAfterName:   tAfterName,
        stateBeforeValue: tBeforeValue,
        stateHTMLCmt:     tHTMLCmt,
        stateRCDATA:      tSpecialTagEnd,
        stateAttr:        tAttr,
        stateURL:         tURL,
        stateSrcset:      tURL,
        stateJS:          tJS,
        stateJSDqStr:     tJSDelimited,
        stateJSSqStr:     tJSDelimited,
        stateJSRegexp:    tJSDelimited,
        stateJSBlockCmt:  tBlockCmt,
        stateJSLineCmt:   tLineCmt,
        stateCSS:         tCSS,
        stateCSSDqStr:    tCSSStr,
        stateCSSSqStr:    tCSSStr,
        stateCSSDqURL:    tCSSStr,
        stateCSSSqURL:    tCSSStr,
        stateCSSURL:      tCSSStr,
        stateCSSBlockCmt: tBlockCmt,
        stateCSSLineCmt:  tLineCmt,
        stateError:       tError,
}

var commentStart = []byte("&lt;!--")
var commentEnd = []byte("--&gt;")

// tText is the context transition function for the text state.
func tText(c context, s []byte) (context, int) <span class="cov8" title="1">{
        k := 0
        for </span><span class="cov8" title="1">{
                i := k + bytes.IndexByte(s[k:], '&lt;')
                if i &lt; k || i+1 == len(s) </span><span class="cov8" title="1">{
                        return c, len(s)
                }</span> else<span class="cov8" title="1"> if i+4 &lt;= len(s) &amp;&amp; bytes.Equal(commentStart, s[i:i+4]) </span><span class="cov8" title="1">{
                        return context{state: stateHTMLCmt}, i + 4
                }</span>
                <span class="cov8" title="1">i++
                end := false
                if s[i] == '/' </span><span class="cov8" title="1">{
                        if i+1 == len(s) </span><span class="cov8" title="1">{
                                return c, len(s)
                        }</span>
                        <span class="cov8" title="1">end, i = true, i+1</span>
                }
                <span class="cov8" title="1">j, e := eatTagName(s, i)
                if j != i </span><span class="cov8" title="1">{
                        if end </span><span class="cov8" title="1">{
                                e = elementNone
                        }</span>
                        // We've found an HTML tag.
                        <span class="cov8" title="1">return context{state: stateTag, element: e}, j</span>
                }
                <span class="cov8" title="1">k = j</span>
        }
}

var elementContentType = [...]state{
        elementNone:     stateText,
        elementScript:   stateJS,
        elementStyle:    stateCSS,
        elementTextarea: stateRCDATA,
        elementTitle:    stateRCDATA,
}

// tTag is the context transition function for the tag state.
func tTag(c context, s []byte) (context, int) <span class="cov8" title="1">{
        // Find the attribute name.
        i := eatWhiteSpace(s, 0)
        if i == len(s) </span><span class="cov8" title="1">{
                return c, len(s)
        }</span>
        <span class="cov8" title="1">if s[i] == '&gt;' </span><span class="cov8" title="1">{
                return context{
                        state:   elementContentType[c.element],
                        element: c.element,
                }, i + 1
        }</span>
        <span class="cov8" title="1">j, err := eatAttrName(s, i)
        if err != nil </span><span class="cov8" title="1">{
                return context{state: stateError, err: err}, len(s)
        }</span>
        <span class="cov8" title="1">state, attr := stateTag, attrNone
        if i == j </span><span class="cov8" title="1">{
                return context{
                        state: stateError,
                        err:   errorf(ErrBadHTML, nil, 0, "expected space, attr name, or end of tag, but got %q", s[i:]),
                }, len(s)
        }</span>

        <span class="cov8" title="1">attrName := strings.ToLower(string(s[i:j]))
        if c.element == elementScript &amp;&amp; attrName == "type" </span><span class="cov8" title="1">{
                attr = attrScriptType
        }</span> else<span class="cov8" title="1"> {
                switch attrType(attrName) </span>{
                case contentTypeURL:<span class="cov8" title="1">
                        attr = attrURL</span>
                case contentTypeCSS:<span class="cov8" title="1">
                        attr = attrStyle</span>
                case contentTypeJS:<span class="cov8" title="1">
                        attr = attrScript</span>
                case contentTypeSrcset:<span class="cov8" title="1">
                        attr = attrSrcset</span>
                }
        }

        <span class="cov8" title="1">if j == len(s) </span><span class="cov8" title="1">{
                state = stateAttrName
        }</span> else<span class="cov8" title="1"> {
                state = stateAfterName
        }</span>
        <span class="cov8" title="1">return context{state: state, element: c.element, attr: attr}, j</span>
}

// tAttrName is the context transition function for stateAttrName.
func tAttrName(c context, s []byte) (context, int) <span class="cov8" title="1">{
        i, err := eatAttrName(s, 0)
        if err != nil </span><span class="cov0" title="0">{
                return context{state: stateError, err: err}, len(s)
        }</span> else<span class="cov8" title="1"> if i != len(s) </span><span class="cov8" title="1">{
                c.state = stateAfterName
        }</span>
        <span class="cov8" title="1">return c, i</span>
}

// tAfterName is the context transition function for stateAfterName.
func tAfterName(c context, s []byte) (context, int) <span class="cov8" title="1">{
        // Look for the start of the value.
        i := eatWhiteSpace(s, 0)
        if i == len(s) </span><span class="cov8" title="1">{
                return c, len(s)
        }</span> else<span class="cov8" title="1"> if s[i] != '=' </span><span class="cov8" title="1">{
                // Occurs due to tag ending '&gt;', and valueless attribute.
                c.state = stateTag
                return c, i
        }</span>
        <span class="cov8" title="1">c.state = stateBeforeValue
        // Consume the "=".
        return c, i + 1</span>
}

var attrStartStates = [...]state{
        attrNone:       stateAttr,
        attrScript:     stateJS,
        attrScriptType: stateAttr,
        attrStyle:      stateCSS,
        attrURL:        stateURL,
        attrSrcset:     stateSrcset,
}

// tBeforeValue is the context transition function for stateBeforeValue.
func tBeforeValue(c context, s []byte) (context, int) <span class="cov8" title="1">{
        i := eatWhiteSpace(s, 0)
        if i == len(s) </span><span class="cov8" title="1">{
                return c, len(s)
        }</span>
        // Find the attribute delimiter.
        <span class="cov8" title="1">delim := delimSpaceOrTagEnd
        switch s[i] </span>{
        case '\'':<span class="cov8" title="1">
                delim, i = delimSingleQuote, i+1</span>
        case '"':<span class="cov8" title="1">
                delim, i = delimDoubleQuote, i+1</span>
        }
        <span class="cov8" title="1">c.state, c.delim = attrStartStates[c.attr], delim
        return c, i</span>
}

// tHTMLCmt is the context transition function for stateHTMLCmt.
func tHTMLCmt(c context, s []byte) (context, int) <span class="cov8" title="1">{
        if i := bytes.Index(s, commentEnd); i != -1 </span><span class="cov8" title="1">{
                return context{}, i + 3
        }</span>
        <span class="cov8" title="1">return c, len(s)</span>
}

// specialTagEndMarkers maps element types to the character sequence that
// case-insensitively signals the end of the special tag body.
var specialTagEndMarkers = [...][]byte{
        elementScript:   []byte("script"),
        elementStyle:    []byte("style"),
        elementTextarea: []byte("textarea"),
        elementTitle:    []byte("title"),
}

var (
        specialTagEndPrefix = []byte("&lt;/")
        tagEndSeparators    = []byte("&gt; \t\n\f/")
)

// tSpecialTagEnd is the context transition function for raw text and RCDATA
// element states.
func tSpecialTagEnd(c context, s []byte) (context, int) <span class="cov8" title="1">{
        if c.element != elementNone </span><span class="cov8" title="1">{
                if i := indexTagEnd(s, specialTagEndMarkers[c.element]); i != -1 </span><span class="cov8" title="1">{
                        return context{}, i
                }</span>
        }
        <span class="cov8" title="1">return c, len(s)</span>
}

// indexTagEnd finds the index of a special tag end in a case insensitive way, or returns -1
func indexTagEnd(s []byte, tag []byte) int <span class="cov8" title="1">{
        res := 0
        plen := len(specialTagEndPrefix)
        for len(s) &gt; 0 </span><span class="cov8" title="1">{
                // Try to find the tag end prefix first
                i := bytes.Index(s, specialTagEndPrefix)
                if i == -1 </span><span class="cov8" title="1">{
                        return i
                }</span>
                <span class="cov8" title="1">s = s[i+plen:]
                // Try to match the actual tag if there is still space for it
                if len(tag) &lt;= len(s) &amp;&amp; bytes.EqualFold(tag, s[:len(tag)]) </span><span class="cov8" title="1">{
                        s = s[len(tag):]
                        // Check the tag is followed by a proper separator
                        if len(s) &gt; 0 &amp;&amp; bytes.IndexByte(tagEndSeparators, s[0]) != -1 </span><span class="cov8" title="1">{
                                return res + i
                        }</span>
                        <span class="cov8" title="1">res += len(tag)</span>
                }
                <span class="cov8" title="1">res += i + plen</span>
        }
        <span class="cov8" title="1">return -1</span>
}

// tAttr is the context transition function for the attribute state.
func tAttr(c context, s []byte) (context, int) <span class="cov8" title="1">{
        return c, len(s)
}</span>

// tURL is the context transition function for the URL state.
func tURL(c context, s []byte) (context, int) <span class="cov8" title="1">{
        if bytes.ContainsAny(s, "#?") </span><span class="cov8" title="1">{
                c.urlPart = urlPartQueryOrFrag
        }</span> else<span class="cov8" title="1"> if len(s) != eatWhiteSpace(s, 0) &amp;&amp; c.urlPart == urlPartNone </span><span class="cov8" title="1">{
                // HTML5 uses "Valid URL potentially surrounded by spaces" for
                // attrs: https://www.w3.org/TR/html5/index.html#attributes-1
                c.urlPart = urlPartPreQuery
        }</span>
        <span class="cov8" title="1">return c, len(s)</span>
}

// tJS is the context transition function for the JS state.
func tJS(c context, s []byte) (context, int) <span class="cov8" title="1">{
        i := bytes.IndexAny(s, `"'/`)
        if i == -1 </span><span class="cov8" title="1">{
                // Entire input is non string, comment, regexp tokens.
                c.jsCtx = nextJSCtx(s, c.jsCtx)
                return c, len(s)
        }</span>
        <span class="cov8" title="1">c.jsCtx = nextJSCtx(s[:i], c.jsCtx)
        switch s[i] </span>{
        case '"':<span class="cov8" title="1">
                c.state, c.jsCtx = stateJSDqStr, jsCtxRegexp</span>
        case '\'':<span class="cov8" title="1">
                c.state, c.jsCtx = stateJSSqStr, jsCtxRegexp</span>
        case '/':<span class="cov8" title="1">
                switch </span>{
                case i+1 &lt; len(s) &amp;&amp; s[i+1] == '/':<span class="cov8" title="1">
                        c.state, i = stateJSLineCmt, i+1</span>
                case i+1 &lt; len(s) &amp;&amp; s[i+1] == '*':<span class="cov8" title="1">
                        c.state, i = stateJSBlockCmt, i+1</span>
                case c.jsCtx == jsCtxRegexp:<span class="cov8" title="1">
                        c.state = stateJSRegexp</span>
                case c.jsCtx == jsCtxDivOp:<span class="cov8" title="1">
                        c.jsCtx = jsCtxRegexp</span>
                default:<span class="cov8" title="1">
                        return context{
                                state: stateError,
                                err:   errorf(ErrSlashAmbig, nil, 0, "'/' could start a division or regexp: %.32q", s[i:]),
                        }, len(s)</span>
                }
        default:<span class="cov0" title="0">
                panic("unreachable")</span>
        }
        <span class="cov8" title="1">return c, i + 1</span>
}

// tJSDelimited is the context transition function for the JS string and regexp
// states.
func tJSDelimited(c context, s []byte) (context, int) <span class="cov8" title="1">{
        specials := `\"`
        switch c.state </span>{
        case stateJSSqStr:<span class="cov8" title="1">
                specials = `\'`</span>
        case stateJSRegexp:<span class="cov8" title="1">
                specials = `\/[]`</span>
        }

        <span class="cov8" title="1">k, inCharset := 0, false
        for </span><span class="cov8" title="1">{
                i := k + bytes.IndexAny(s[k:], specials)
                if i &lt; k </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">switch s[i] </span>{
                case '\\':<span class="cov8" title="1">
                        i++
                        if i == len(s) </span><span class="cov8" title="1">{
                                return context{
                                        state: stateError,
                                        err:   errorf(ErrPartialEscape, nil, 0, "unfinished escape sequence in JS string: %q", s),
                                }, len(s)
                        }</span>
                case '[':<span class="cov8" title="1">
                        inCharset = true</span>
                case ']':<span class="cov8" title="1">
                        inCharset = false</span>
                default:<span class="cov8" title="1">
                        // end delimiter
                        if !inCharset </span><span class="cov8" title="1">{
                                c.state, c.jsCtx = stateJS, jsCtxDivOp
                                return c, i + 1
                        }</span>
                }
                <span class="cov8" title="1">k = i + 1</span>
        }

        <span class="cov8" title="1">if inCharset </span><span class="cov8" title="1">{
                // This can be fixed by making context richer if interpolation
                // into charsets is desired.
                return context{
                        state: stateError,
                        err:   errorf(ErrPartialCharset, nil, 0, "unfinished JS regexp charset: %q", s),
                }, len(s)
        }</span>

        <span class="cov8" title="1">return c, len(s)</span>
}

var blockCommentEnd = []byte("*/")

// tBlockCmt is the context transition function for /*comment*/ states.
func tBlockCmt(c context, s []byte) (context, int) <span class="cov8" title="1">{
        i := bytes.Index(s, blockCommentEnd)
        if i == -1 </span><span class="cov8" title="1">{
                return c, len(s)
        }</span>
        <span class="cov8" title="1">switch c.state </span>{
        case stateJSBlockCmt:<span class="cov8" title="1">
                c.state = stateJS</span>
        case stateCSSBlockCmt:<span class="cov8" title="1">
                c.state = stateCSS</span>
        default:<span class="cov0" title="0">
                panic(c.state.String())</span>
        }
        <span class="cov8" title="1">return c, i + 2</span>
}

// tLineCmt is the context transition function for //comment states.
func tLineCmt(c context, s []byte) (context, int) <span class="cov8" title="1">{
        var lineTerminators string
        var endState state
        switch c.state </span>{
        case stateJSLineCmt:<span class="cov8" title="1">
                lineTerminators, endState = "\n\r\u2028\u2029", stateJS</span>
        case stateCSSLineCmt:<span class="cov8" title="1">
                lineTerminators, endState = "\n\f\r", stateCSS</span>
                // Line comments are not part of any published CSS standard but
                // are supported by the 4 major browsers.
                // This defines line comments as
                //     LINECOMMENT ::= "//" [^\n\f\d]*
                // since https://www.w3.org/TR/css3-syntax/#SUBTOK-nl defines
                // newlines:
                //     nl ::= #xA | #xD #xA | #xD | #xC
        default:<span class="cov0" title="0">
                panic(c.state.String())</span>
        }

        <span class="cov8" title="1">i := bytes.IndexAny(s, lineTerminators)
        if i == -1 </span><span class="cov8" title="1">{
                return c, len(s)
        }</span>
        <span class="cov8" title="1">c.state = endState
        // Per section 7.4 of EcmaScript 5 : https://es5.github.com/#x7.4
        // "However, the LineTerminator at the end of the line is not
        // considered to be part of the single-line comment; it is
        // recognized separately by the lexical grammar and becomes part
        // of the stream of input elements for the syntactic grammar."
        return c, i</span>
}

// tCSS is the context transition function for the CSS state.
func tCSS(c context, s []byte) (context, int) <span class="cov8" title="1">{
        // CSS quoted strings are almost never used except for:
        // (1) URLs as in background: "/foo.png"
        // (2) Multiword font-names as in font-family: "Times New Roman"
        // (3) List separators in content values as in inline-lists:
        //    &lt;style&gt;
        //    ul.inlineList { list-style: none; padding:0 }
        //    ul.inlineList &gt; li { display: inline }
        //    ul.inlineList &gt; li:before { content: ", " }
        //    ul.inlineList &gt; li:first-child:before { content: "" }
        //    &lt;/style&gt;
        //    &lt;ul class=inlineList&gt;&lt;li&gt;One&lt;li&gt;Two&lt;li&gt;Three&lt;/ul&gt;
        // (4) Attribute value selectors as in a[href="http://example.com/"]
        //
        // We conservatively treat all strings as URLs, but make some
        // allowances to avoid confusion.
        //
        // In (1), our conservative assumption is justified.
        // In (2), valid font names do not contain ':', '?', or '#', so our
        // conservative assumption is fine since we will never transition past
        // urlPartPreQuery.
        // In (3), our protocol heuristic should not be tripped, and there
        // should not be non-space content after a '?' or '#', so as long as
        // we only %-encode RFC 3986 reserved characters we are ok.
        // In (4), we should URL escape for URL attributes, and for others we
        // have the attribute name available if our conservative assumption
        // proves problematic for real code.

        k := 0
        for </span><span class="cov8" title="1">{
                i := k + bytes.IndexAny(s[k:], `("'/`)
                if i &lt; k </span><span class="cov8" title="1">{
                        return c, len(s)
                }</span>
                <span class="cov8" title="1">switch s[i] </span>{
                case '(':<span class="cov8" title="1">
                        // Look for url to the left.
                        p := bytes.TrimRight(s[:i], "\t\n\f\r ")
                        if endsWithCSSKeyword(p, "url") </span><span class="cov8" title="1">{
                                j := len(s) - len(bytes.TrimLeft(s[i+1:], "\t\n\f\r "))
                                switch </span>{
                                case j != len(s) &amp;&amp; s[j] == '"':<span class="cov8" title="1">
                                        c.state, j = stateCSSDqURL, j+1</span>
                                case j != len(s) &amp;&amp; s[j] == '\'':<span class="cov8" title="1">
                                        c.state, j = stateCSSSqURL, j+1</span>
                                default:<span class="cov8" title="1">
                                        c.state = stateCSSURL</span>
                                }
                                <span class="cov8" title="1">return c, j</span>
                        }
                case '/':<span class="cov8" title="1">
                        if i+1 &lt; len(s) </span><span class="cov8" title="1">{
                                switch s[i+1] </span>{
                                case '/':<span class="cov8" title="1">
                                        c.state = stateCSSLineCmt
                                        return c, i + 2</span>
                                case '*':<span class="cov8" title="1">
                                        c.state = stateCSSBlockCmt
                                        return c, i + 2</span>
                                }
                        }
                case '"':<span class="cov8" title="1">
                        c.state = stateCSSDqStr
                        return c, i + 1</span>
                case '\'':<span class="cov8" title="1">
                        c.state = stateCSSSqStr
                        return c, i + 1</span>
                }
                <span class="cov0" title="0">k = i + 1</span>
        }
}

// tCSSStr is the context transition function for the CSS string and URL states.
func tCSSStr(c context, s []byte) (context, int) <span class="cov8" title="1">{
        var endAndEsc string
        switch c.state </span>{
        case stateCSSDqStr, stateCSSDqURL:<span class="cov8" title="1">
                endAndEsc = `\"`</span>
        case stateCSSSqStr, stateCSSSqURL:<span class="cov8" title="1">
                endAndEsc = `\'`</span>
        case stateCSSURL:<span class="cov8" title="1">
                // Unquoted URLs end with a newline or close parenthesis.
                // The below includes the wc (whitespace character) and nl.
                endAndEsc = "\\\t\n\f\r )"</span>
        default:<span class="cov0" title="0">
                panic(c.state.String())</span>
        }

        <span class="cov8" title="1">k := 0
        for </span><span class="cov8" title="1">{
                i := k + bytes.IndexAny(s[k:], endAndEsc)
                if i &lt; k </span><span class="cov8" title="1">{
                        c, nread := tURL(c, decodeCSS(s[k:]))
                        return c, k + nread
                }</span>
                <span class="cov8" title="1">if s[i] == '\\' </span><span class="cov0" title="0">{
                        i++
                        if i == len(s) </span><span class="cov0" title="0">{
                                return context{
                                        state: stateError,
                                        err:   errorf(ErrPartialEscape, nil, 0, "unfinished escape sequence in CSS string: %q", s),
                                }, len(s)
                        }</span>
                } else<span class="cov8" title="1"> {
                        c.state = stateCSS
                        return c, i + 1
                }</span>
                <span class="cov0" title="0">c, _ = tURL(c, decodeCSS(s[:i+1]))
                k = i + 1</span>
        }
}

// tError is the context transition function for the error state.
func tError(c context, s []byte) (context, int) <span class="cov8" title="1">{
        return c, len(s)
}</span>

// eatAttrName returns the largest j such that s[i:j] is an attribute name.
// It returns an error if s[i:] does not look like it begins with an
// attribute name, such as encountering a quote mark without a preceding
// equals sign.
func eatAttrName(s []byte, i int) (int, *Error) <span class="cov8" title="1">{
        for j := i; j &lt; len(s); j++ </span><span class="cov8" title="1">{
                switch s[j] </span>{
                case ' ', '\t', '\n', '\f', '\r', '=', '&gt;':<span class="cov8" title="1">
                        return j, nil</span>
                case '\'', '"', '&lt;':<span class="cov8" title="1">
                        // These result in a parse warning in HTML5 and are
                        // indicative of serious problems if seen in an attr
                        // name in a template.
                        return -1, errorf(ErrBadHTML, nil, 0, "%q in attribute name: %.32q", s[j:j+1], s)</span>
                default:<span class="cov8" title="1"></span>
                        // No-op.
                }
        }
        <span class="cov8" title="1">return len(s), nil</span>
}

var elementNameMap = map[string]element{
        "script":   elementScript,
        "style":    elementStyle,
        "textarea": elementTextarea,
        "title":    elementTitle,
}

// asciiAlpha reports whether c is an ASCII letter.
func asciiAlpha(c byte) bool <span class="cov8" title="1">{
        return 'A' &lt;= c &amp;&amp; c &lt;= 'Z' || 'a' &lt;= c &amp;&amp; c &lt;= 'z'
}</span>

// asciiAlphaNum reports whether c is an ASCII letter or digit.
func asciiAlphaNum(c byte) bool <span class="cov8" title="1">{
        return asciiAlpha(c) || '0' &lt;= c &amp;&amp; c &lt;= '9'
}</span>

// eatTagName returns the largest j such that s[i:j] is a tag name and the tag type.
func eatTagName(s []byte, i int) (int, element) <span class="cov8" title="1">{
        if i == len(s) || !asciiAlpha(s[i]) </span><span class="cov8" title="1">{
                return i, elementNone
        }</span>
        <span class="cov8" title="1">j := i + 1
        for j &lt; len(s) </span><span class="cov8" title="1">{
                x := s[j]
                if asciiAlphaNum(x) </span><span class="cov8" title="1">{
                        j++
                        continue</span>
                }
                // Allow "x-y" or "x:y" but not "x-", "-y", or "x--y".
                <span class="cov8" title="1">if (x == ':' || x == '-') &amp;&amp; j+1 &lt; len(s) &amp;&amp; asciiAlphaNum(s[j+1]) </span><span class="cov8" title="1">{
                        j += 2
                        continue</span>
                }
                <span class="cov8" title="1">break</span>
        }
        <span class="cov8" title="1">return j, elementNameMap[strings.ToLower(string(s[i:j]))]</span>
}

// eatWhiteSpace returns the largest j such that s[i:j] is white space.
func eatWhiteSpace(s []byte, i int) int <span class="cov8" title="1">{
        for j := i; j &lt; len(s); j++ </span><span class="cov8" title="1">{
                switch s[j] </span>{
                case ' ', '\t', '\n', '\f', '\r':<span class="cov8" title="1"></span>
                        // No-op.
                default:<span class="cov8" title="1">
                        return j</span>
                }
        }
        <span class="cov8" title="1">return len(s)</span>
}
</pre>
		
		<pre class="file" id="file314" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "bytes"
        "fmt"
        "strings"
)

// urlFilter returns its input unless it contains an unsafe scheme in which
// case it defangs the entire URL.
//
// Schemes that cause unintended side effects that are irreversible without user
// interaction are considered unsafe. For example, clicking on a "javascript:"
// link can immediately trigger JavaScript code execution.
//
// This filter conservatively assumes that all schemes other than the following
// are unsafe:
//    * http:   Navigates to a new website, and may open a new window or tab.
//              These side effects can be reversed by navigating back to the
//              previous website, or closing the window or tab. No irreversible
//              changes will take place without further user interaction with
//              the new website.
//    * https:  Same as http.
//    * mailto: Opens an email program and starts a new draft. This side effect
//              is not irreversible until the user explicitly clicks send; it
//              can be undone by closing the email program.
//
// To allow URLs containing other schemes to bypass this filter, developers must
// explicitly indicate that such a URL is expected and safe by encapsulating it
// in a template.URL value.
func urlFilter(args ...interface{}) string <span class="cov8" title="1">{
        s, t := stringify(args...)
        if t == contentTypeURL </span><span class="cov0" title="0">{
                return s
        }</span>
        <span class="cov8" title="1">if !isSafeURL(s) </span><span class="cov8" title="1">{
                return "#" + filterFailsafe
        }</span>
        <span class="cov8" title="1">return s</span>
}

// isSafeURL is true if s is a relative URL or if URL has a protocol in
// (http, https, mailto).
func isSafeURL(s string) bool <span class="cov8" title="1">{
        if i := strings.IndexRune(s, ':'); i &gt;= 0 &amp;&amp; !strings.ContainsRune(s[:i], '/') </span><span class="cov8" title="1">{

                protocol := s[:i]
                if !strings.EqualFold(protocol, "http") &amp;&amp; !strings.EqualFold(protocol, "https") &amp;&amp; !strings.EqualFold(protocol, "mailto") </span><span class="cov8" title="1">{
                        return false
                }</span>
        }
        <span class="cov8" title="1">return true</span>
}

// urlEscaper produces an output that can be embedded in a URL query.
// The output can be embedded in an HTML attribute without further escaping.
func urlEscaper(args ...interface{}) string <span class="cov8" title="1">{
        return urlProcessor(false, args...)
}</span>

// urlNormalizer normalizes URL content so it can be embedded in a quote-delimited
// string or parenthesis delimited url(...).
// The normalizer does not encode all HTML specials. Specifically, it does not
// encode '&amp;' so correct embedding in an HTML attribute requires escaping of
// '&amp;' to '&amp;amp;'.
func urlNormalizer(args ...interface{}) string <span class="cov8" title="1">{
        return urlProcessor(true, args...)
}</span>

// urlProcessor normalizes (when norm is true) or escapes its input to produce
// a valid hierarchical or opaque URL part.
func urlProcessor(norm bool, args ...interface{}) string <span class="cov8" title="1">{
        s, t := stringify(args...)
        if t == contentTypeURL </span><span class="cov8" title="1">{
                norm = true
        }</span>
        <span class="cov8" title="1">var b bytes.Buffer
        if processURLOnto(s, norm, &amp;b) </span><span class="cov8" title="1">{
                return b.String()
        }</span>
        <span class="cov8" title="1">return s</span>
}

// processURLOnto appends a normalized URL corresponding to its input to b
// and reports whether the appended content differs from s.
func processURLOnto(s string, norm bool, b *bytes.Buffer) bool <span class="cov8" title="1">{
        b.Grow(len(s) + 16)
        written := 0
        // The byte loop below assumes that all URLs use UTF-8 as the
        // content-encoding. This is similar to the URI to IRI encoding scheme
        // defined in section 3.1 of  RFC 3987, and behaves the same as the
        // EcmaScript builtin encodeURIComponent.
        // It should not cause any misencoding of URLs in pages with
        // Content-type: text/html;charset=UTF-8.
        for i, n := 0, len(s); i &lt; n; i++ </span><span class="cov8" title="1">{
                c := s[i]
                switch c </span>{
                // Single quote and parens are sub-delims in RFC 3986, but we
                // escape them so the output can be embedded in single
                // quoted attributes and unquoted CSS url(...) constructs.
                // Single quotes are reserved in URLs, but are only used in
                // the obsolete "mark" rule in an appendix in RFC 3986
                // so can be safely encoded.
                case '!', '#', '$', '&amp;', '*', '+', ',', '/', ':', ';', '=', '?', '@', '[', ']':<span class="cov8" title="1">
                        if norm </span><span class="cov8" title="1">{
                                continue</span>
                        }
                // Unreserved according to RFC 3986 sec 2.3
                // "For consistency, percent-encoded octets in the ranges of
                // ALPHA (%41-%5A and %61-%7A), DIGIT (%30-%39), hyphen (%2D),
                // period (%2E), underscore (%5F), or tilde (%7E) should not be
                // created by URI producers
                case '-', '.', '_', '~':<span class="cov8" title="1">
                        continue</span>
                case '%':<span class="cov8" title="1">
                        // When normalizing do not re-encode valid escapes.
                        if norm &amp;&amp; i+2 &lt; len(s) &amp;&amp; isHex(s[i+1]) &amp;&amp; isHex(s[i+2]) </span><span class="cov8" title="1">{
                                continue</span>
                        }
                default:<span class="cov8" title="1">
                        // Unreserved according to RFC 3986 sec 2.3
                        if 'a' &lt;= c &amp;&amp; c &lt;= 'z' </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if 'A' &lt;= c &amp;&amp; c &lt;= 'Z' </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">if '0' &lt;= c &amp;&amp; c &lt;= '9' </span><span class="cov8" title="1">{
                                continue</span>
                        }
                }
                <span class="cov8" title="1">b.WriteString(s[written:i])
                fmt.Fprintf(b, "%%%02x", c)
                written = i + 1</span>
        }
        <span class="cov8" title="1">b.WriteString(s[written:])
        return written != 0</span>
}

// Filters and normalizes srcset values which are comma separated
// URLs followed by metadata.
func srcsetFilterAndEscaper(args ...interface{}) string <span class="cov8" title="1">{
        s, t := stringify(args...)
        switch t </span>{
        case contentTypeSrcset:<span class="cov8" title="1">
                return s</span>
        case contentTypeURL:<span class="cov8" title="1">
                // Normalizing gets rid of all HTML whitespace
                // which separate the image URL from its metadata.
                var b bytes.Buffer
                if processURLOnto(s, true, &amp;b) </span><span class="cov8" title="1">{
                        s = b.String()
                }</span>
                // Additionally, commas separate one source from another.
                <span class="cov8" title="1">return strings.ReplaceAll(s, ",", "%2c")</span>
        }

        <span class="cov8" title="1">var b bytes.Buffer
        written := 0
        for i := 0; i &lt; len(s); i++ </span><span class="cov8" title="1">{
                if s[i] == ',' </span><span class="cov8" title="1">{
                        filterSrcsetElement(s, written, i, &amp;b)
                        b.WriteString(",")
                        written = i + 1
                }</span>
        }
        <span class="cov8" title="1">filterSrcsetElement(s, written, len(s), &amp;b)
        return b.String()</span>
}

// Derived from https://play.golang.org/p/Dhmj7FORT5
const htmlSpaceAndASCIIAlnumBytes = "\x00\x36\x00\x00\x01\x00\xff\x03\xfe\xff\xff\x07\xfe\xff\xff\x07"

// isHTMLSpace is true iff c is a whitespace character per
// https://infra.spec.whatwg.org/#ascii-whitespace
func isHTMLSpace(c byte) bool <span class="cov8" title="1">{
        return (c &lt;= 0x20) &amp;&amp; 0 != (htmlSpaceAndASCIIAlnumBytes[c&gt;&gt;3]&amp;(1&lt;&lt;uint(c&amp;0x7)))
}</span>

func isHTMLSpaceOrASCIIAlnum(c byte) bool <span class="cov8" title="1">{
        return (c &lt; 0x80) &amp;&amp; 0 != (htmlSpaceAndASCIIAlnumBytes[c&gt;&gt;3]&amp;(1&lt;&lt;uint(c&amp;0x7)))
}</span>

func filterSrcsetElement(s string, left int, right int, b *bytes.Buffer) <span class="cov8" title="1">{
        start := left
        for start &lt; right &amp;&amp; isHTMLSpace(s[start]) </span><span class="cov8" title="1">{
                start++
        }</span>
        <span class="cov8" title="1">end := right
        for i := start; i &lt; right; i++ </span><span class="cov8" title="1">{
                if isHTMLSpace(s[i]) </span><span class="cov8" title="1">{
                        end = i
                        break</span>
                }
        }
        <span class="cov8" title="1">if url := s[start:end]; isSafeURL(url) </span><span class="cov8" title="1">{
                // If image metadata is only spaces or alnums then
                // we don't need to URL normalize it.
                metadataOk := true
                for i := end; i &lt; right; i++ </span><span class="cov8" title="1">{
                        if !isHTMLSpaceOrASCIIAlnum(s[i]) </span><span class="cov8" title="1">{
                                metadataOk = false
                                break</span>
                        }
                }
                <span class="cov8" title="1">if metadataOk </span><span class="cov8" title="1">{
                        b.WriteString(s[left:start])
                        processURLOnto(url, true, b)
                        b.WriteString(s[end:right])
                        return
                }</span>
        }
        <span class="cov8" title="1">b.WriteString("#")
        b.WriteString(filterFailsafe)</span>
}
</pre>
		
		<pre class="file" id="file315" style="display: none">// Code generated by "stringer -type urlPart"; DO NOT EDIT.

package template

import "strconv"

const _urlPart_name = "urlPartNoneurlPartPreQueryurlPartQueryOrFragurlPartUnknown"

var _urlPart_index = [...]uint8{0, 11, 26, 44, 58}

func (i urlPart) String() string <span class="cov8" title="1">{
        if i &gt;= urlPart(len(_urlPart_index)-1) </span><span class="cov0" title="0">{
                return "urlPart(" + strconv.FormatInt(int64(i), 10) + ")"
        }</span>
        <span class="cov8" title="1">return _urlPart_name[_urlPart_index[i]:_urlPart_index[i+1]]</span>
}
</pre>
		
		<pre class="file" id="file316" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "fmt"
        "io"
        "reflect"
        "runtime"
        "strings"

        "github.com/gohugoio/hugo/tpl/internal/go_templates/fmtsort"
        "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/parse"
)

// maxExecDepth specifies the maximum stack depth of templates within
// templates. This limit is only practically reached by accidentally
// recursive template invocations. This limit allows us to return
// an error instead of triggering a stack overflow.
var maxExecDepth = initMaxExecDepth()

func initMaxExecDepth() int <span class="cov8" title="1">{
        if runtime.GOARCH == "wasm" </span><span class="cov0" title="0">{
                return 1000
        }</span>
        <span class="cov8" title="1">return 100000</span>
}

// state represents the state of an execution. It's not part of the
// template so that multiple executions of the same template
// can execute in parallel.
type stateOld struct {
        tmpl  *Template
        wr    io.Writer
        node  parse.Node // current node, for errors
        vars  []variable // push-down stack of variable values.
        depth int        // the height of the stack of executing templates.
}

// variable holds the dynamic value of a variable such as $, $x etc.
type variable struct {
        name  string
        value reflect.Value
}

// push pushes a new variable on the stack.
func (s *state) push(name string, value reflect.Value) <span class="cov8" title="1">{
        s.vars = append(s.vars, variable{name, value})
}</span>

// mark returns the length of the variable stack.
func (s *state) mark() int <span class="cov8" title="1">{
        return len(s.vars)
}</span>

// pop pops the variable stack up to the mark.
func (s *state) pop(mark int) <span class="cov8" title="1">{
        s.vars = s.vars[0:mark]
}</span>

// setVar overwrites the last declared variable with the given name.
// Used by variable assignments.
func (s *state) setVar(name string, value reflect.Value) <span class="cov8" title="1">{
        for i := s.mark() - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if s.vars[i].name == name </span><span class="cov8" title="1">{
                        s.vars[i].value = value
                        return
                }</span>
        }
        <span class="cov0" title="0">s.errorf("undefined variable: %s", name)</span>
}

// setTopVar overwrites the top-nth variable on the stack. Used by range iterations.
func (s *state) setTopVar(n int, value reflect.Value) <span class="cov8" title="1">{
        s.vars[len(s.vars)-n].value = value
}</span>

// varValue returns the value of the named variable.
func (s *state) varValue(name string) reflect.Value <span class="cov8" title="1">{
        for i := s.mark() - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if s.vars[i].name == name </span><span class="cov8" title="1">{
                        return s.vars[i].value
                }</span>
        }
        <span class="cov0" title="0">s.errorf("undefined variable: %s", name)
        return zero</span>
}

var zero reflect.Value

type missingValType struct{}

var missingVal = reflect.ValueOf(missingValType{})

// at marks the state to be on node n, for error reporting.
func (s *state) at(node parse.Node) <span class="cov8" title="1">{
        s.node = node
}</span>

// doublePercent returns the string with %'s replaced by %%, if necessary,
// so it can be used safely inside a Printf format string.
func doublePercent(str string) string <span class="cov8" title="1">{
        return strings.ReplaceAll(str, "%", "%%")
}</span>

// TODO: It would be nice if ExecError was more broken down, but
// the way ErrorContext embeds the template name makes the
// processing too clumsy.

// ExecError is the custom error type returned when Execute has an
// error evaluating its template. (If a write error occurs, the actual
// error is returned; it will not be of type ExecError.)
type ExecError struct {
        Name string // Name of template.
        Err  error  // Pre-formatted error.
}

func (e ExecError) Error() string <span class="cov8" title="1">{
        return e.Err.Error()
}</span>

func (e ExecError) Unwrap() error <span class="cov0" title="0">{
        return e.Err
}</span>

// errorf records an ExecError and terminates processing.
func (s *state) errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        name := doublePercent(s.tmpl.Name())
        if s.node == nil </span><span class="cov8" title="1">{
                format = fmt.Sprintf("template: %s: %s", name, format)
        }</span> else<span class="cov8" title="1"> {
                location, context := s.tmpl.ErrorContext(s.node)
                format = fmt.Sprintf("template: %s: executing %q at &lt;%s&gt;: %s", location, name, doublePercent(context), format)
        }</span>
        <span class="cov8" title="1">panic(ExecError{
                Name: s.tmpl.Name(),
                Err:  fmt.Errorf(format, args...),
        })</span>
}

// writeError is the wrapper type used internally when Execute has an
// error writing to its output. We strip the wrapper in errRecover.
// Note that this is not an implementation of error, so it cannot escape
// from the package as an error value.
type writeError struct {
        Err error // Original error.
}

func (s *state) writeError(err error) <span class="cov8" title="1">{
        panic(writeError{
                Err: err,
        })</span>
}

// errRecover is the handler that turns panics into returns from the top
// level of Parse.
func errRecover(errp *error) <span class="cov8" title="1">{
        e := recover()
        if e != nil </span><span class="cov8" title="1">{
                switch err := e.(type) </span>{
                case runtime.Error:<span class="cov0" title="0">
                        panic(e)</span>
                case writeError:<span class="cov8" title="1">
                        *errp = err.Err</span> // Strip the wrapper.
                case ExecError:<span class="cov8" title="1">
                        *errp = err</span> // Keep the wrapper.
                default:<span class="cov0" title="0">
                        panic(e)</span>
                }
        }
}

// ExecuteTemplate applies the template associated with t that has the given name
// to the specified data object and writes the output to wr.
// If an error occurs executing the template or writing its output,
// execution stops, but partial results may already have been written to
// the output writer.
// A template may be executed safely in parallel, although if parallel
// executions share a Writer the output may be interleaved.
func (t *Template) ExecuteTemplate(wr io.Writer, name string, data interface{}) error <span class="cov8" title="1">{
        tmpl := t.Lookup(name)
        if tmpl == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("template: no template %q associated with template %q", name, t.name)
        }</span>
        <span class="cov8" title="1">return tmpl.Execute(wr, data)</span>
}

// Execute applies a parsed template to the specified data object,
// and writes the output to wr.
// If an error occurs executing the template or writing its output,
// execution stops, but partial results may already have been written to
// the output writer.
// A template may be executed safely in parallel, although if parallel
// executions share a Writer the output may be interleaved.
//
// If data is a reflect.Value, the template applies to the concrete
// value that the reflect.Value holds, as in fmt.Print.
func (t *Template) Execute(wr io.Writer, data interface{}) error <span class="cov8" title="1">{
        return t.execute(wr, data)
}</span>

func (t *Template) execute(wr io.Writer, data interface{}) (err error) <span class="cov8" title="1">{
        defer errRecover(&amp;err)
        value, ok := data.(reflect.Value)
        if !ok </span><span class="cov8" title="1">{
                value = reflect.ValueOf(data)
        }</span>
        <span class="cov8" title="1">state := &amp;state{
                tmpl: t,
                wr:   wr,
                vars: []variable{{"$", value}},
        }
        if t.Tree == nil || t.Root == nil </span><span class="cov8" title="1">{
                state.errorf("%q is an incomplete or empty template", t.Name())
        }</span>
        <span class="cov8" title="1">state.walk(value, t.Root)
        return</span>
}

// DefinedTemplates returns a string listing the defined templates,
// prefixed by the string "; defined templates are: ". If there are none,
// it returns the empty string. For generating an error message here
// and in html/template.
func (t *Template) DefinedTemplates() string <span class="cov0" title="0">{
        if t.common == nil </span><span class="cov0" title="0">{
                return ""
        }</span>
        <span class="cov0" title="0">var b strings.Builder
        // temporary Hugo-fix
        t.muTmpl.RLock()
        defer t.muTmpl.RUnlock()
        for name, tmpl := range t.tmpl </span><span class="cov0" title="0">{
                if tmpl.Tree == nil || tmpl.Root == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">if b.Len() == 0 </span><span class="cov0" title="0">{
                        b.WriteString("; defined templates are: ")
                }</span> else<span class="cov0" title="0"> {
                        b.WriteString(", ")
                }</span>
                <span class="cov0" title="0">fmt.Fprintf(&amp;b, "%q", name)</span>
        }
        <span class="cov0" title="0">return b.String()</span>
}

// Walk functions step through the major pieces of the template structure,
// generating output as they go.
func (s *state) walk(dot reflect.Value, node parse.Node) <span class="cov8" title="1">{
        s.at(node)
        switch node := node.(type) </span>{
        case *parse.ActionNode:<span class="cov8" title="1">
                // Do not pop variables so they persist until next end.
                // Also, if the action declares variables, don't print the result.
                val := s.evalPipeline(dot, node.Pipe)
                if len(node.Pipe.Decl) == 0 </span><span class="cov8" title="1">{
                        s.printValue(node, val)
                }</span>
        case *parse.CommentNode:<span class="cov0" title="0"></span>
        case *parse.IfNode:<span class="cov8" title="1">
                s.walkIfOrWith(parse.NodeIf, dot, node.Pipe, node.List, node.ElseList)</span>
        case *parse.ListNode:<span class="cov8" title="1">
                for _, node := range node.Nodes </span><span class="cov8" title="1">{
                        s.walk(dot, node)
                }</span>
        case *parse.RangeNode:<span class="cov8" title="1">
                s.walkRange(dot, node)</span>
        case *parse.TemplateNode:<span class="cov8" title="1">
                s.walkTemplate(dot, node)</span>
        case *parse.TextNode:<span class="cov8" title="1">
                if _, err := s.wr.Write(node.Text); err != nil </span><span class="cov8" title="1">{
                        s.writeError(err)
                }</span>
        case *parse.WithNode:<span class="cov8" title="1">
                s.walkIfOrWith(parse.NodeWith, dot, node.Pipe, node.List, node.ElseList)</span>
        default:<span class="cov0" title="0">
                s.errorf("unknown node: %s", node)</span>
        }
}

// walkIfOrWith walks an 'if' or 'with' node. The two control structures
// are identical in behavior except that 'with' sets dot.
func (s *state) walkIfOrWith(typ parse.NodeType, dot reflect.Value, pipe *parse.PipeNode, list, elseList *parse.ListNode) <span class="cov8" title="1">{
        defer s.pop(s.mark())
        val := s.evalPipeline(dot, pipe)
        truth, ok := isTrue(indirectInterface(val))
        if !ok </span><span class="cov0" title="0">{
                s.errorf("if/with can't use %v", val)
        }</span>
        <span class="cov8" title="1">if truth </span><span class="cov8" title="1">{
                if typ == parse.NodeWith </span><span class="cov8" title="1">{
                        s.walk(val, list)
                }</span> else<span class="cov8" title="1"> {
                        s.walk(dot, list)
                }</span>
        } else<span class="cov8" title="1"> if elseList != nil </span><span class="cov8" title="1">{
                s.walk(dot, elseList)
        }</span>
}

// IsTrue reports whether the value is 'true', in the sense of not the zero of its type,
// and whether the value has a meaningful truth value. This is the definition of
// truth used by if and other such actions.
func IsTrue(val interface{}) (truth, ok bool) <span class="cov0" title="0">{
        return isTrue(reflect.ValueOf(val))
}</span>

func isTrueOld(val reflect.Value) (truth, ok bool) <span class="cov0" title="0">{
        if !val.IsValid() </span><span class="cov0" title="0">{
                // Something like var x interface{}, never set. It's a form of nil.
                return false, true
        }</span>
        <span class="cov0" title="0">switch val.Kind() </span>{
        case reflect.Array, reflect.Map, reflect.Slice, reflect.String:<span class="cov0" title="0">
                truth = val.Len() &gt; 0</span>
        case reflect.Bool:<span class="cov0" title="0">
                truth = val.Bool()</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov0" title="0">
                truth = val.Complex() != 0</span>
        case reflect.Chan, reflect.Func, reflect.Ptr, reflect.Interface:<span class="cov0" title="0">
                truth = !val.IsNil()</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov0" title="0">
                truth = val.Int() != 0</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                truth = val.Float() != 0</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                truth = val.Uint() != 0</span>
        case reflect.Struct:<span class="cov0" title="0">
                truth = true</span> // Struct values are always true.
        default:<span class="cov0" title="0">
                return</span>
        }
        <span class="cov0" title="0">return truth, true</span>
}

func (s *state) walkRange(dot reflect.Value, r *parse.RangeNode) <span class="cov8" title="1">{
        s.at(r)
        defer s.pop(s.mark())
        val, _ := indirect(s.evalPipeline(dot, r.Pipe))
        // mark top of stack before any variables in the body are pushed.
        mark := s.mark()
        oneIteration := func(index, elem reflect.Value) </span><span class="cov8" title="1">{
                // Set top var (lexically the second if there are two) to the element.
                if len(r.Pipe.Decl) &gt; 0 </span><span class="cov8" title="1">{
                        s.setTopVar(1, elem)
                }</span>
                // Set next var (lexically the first if there are two) to the index.
                <span class="cov8" title="1">if len(r.Pipe.Decl) &gt; 1 </span><span class="cov8" title="1">{
                        s.setTopVar(2, index)
                }</span>
                <span class="cov8" title="1">s.walk(elem, r.List)
                s.pop(mark)</span>
        }
        <span class="cov8" title="1">switch val.Kind() </span>{
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                if val.Len() == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">for i := 0; i &lt; val.Len(); i++ </span><span class="cov8" title="1">{
                        oneIteration(reflect.ValueOf(i), val.Index(i))
                }</span>
                <span class="cov8" title="1">return</span>
        case reflect.Map:<span class="cov8" title="1">
                if val.Len() == 0 </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">om := fmtsort.Sort(val)
                for i, key := range om.Key </span><span class="cov8" title="1">{
                        oneIteration(key, om.Value[i])
                }</span>
                <span class="cov8" title="1">return</span>
        case reflect.Chan:<span class="cov8" title="1">
                if val.IsNil() </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">if val.Type().ChanDir() == reflect.SendDir </span><span class="cov8" title="1">{
                        s.errorf("range over send-only channel %v", val)
                        break</span>
                }
                <span class="cov8" title="1">i := 0
                for ; ; i++ </span><span class="cov8" title="1">{
                        elem, ok := val.Recv()
                        if !ok </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov8" title="1">oneIteration(reflect.ValueOf(i), elem)</span>
                }
                <span class="cov8" title="1">if i == 0 </span><span class="cov0" title="0">{
                        break</span>
                }
                <span class="cov8" title="1">return</span>
        case reflect.Invalid:<span class="cov8" title="1">
                break</span> // An invalid value is likely a nil map, etc. and acts like an empty map.
        default:<span class="cov0" title="0">
                s.errorf("range can't iterate over %v", val)</span>
        }
        <span class="cov8" title="1">if r.ElseList != nil </span><span class="cov8" title="1">{
                s.walk(dot, r.ElseList)
        }</span>
}

func (s *state) walkTemplate(dot reflect.Value, t *parse.TemplateNode) <span class="cov8" title="1">{
        s.at(t)
        tmpl := s.tmpl.Lookup(t.Name)
        if tmpl == nil </span><span class="cov0" title="0">{
                s.errorf("template %q not defined", t.Name)
        }</span>
        <span class="cov8" title="1">if s.depth == maxExecDepth </span><span class="cov8" title="1">{
                s.errorf("exceeded maximum template depth (%v)", maxExecDepth)
        }</span>
        // Variables declared by the pipeline persist.
        <span class="cov8" title="1">dot = s.evalPipeline(dot, t.Pipe)
        newState := *s
        newState.depth++
        newState.tmpl = tmpl
        // No dynamic scoping: template invocations inherit no variables.
        newState.vars = []variable{{"$", dot}}
        newState.walk(dot, tmpl.Root)</span>
}

// Eval functions evaluate pipelines, commands, and their elements and extract
// values from the data structure by examining fields, calling methods, and so on.
// The printing of those values happens only through walk functions.

// evalPipeline returns the value acquired by evaluating a pipeline. If the
// pipeline has a variable declaration, the variable will be pushed on the
// stack. Callers should therefore pop the stack after they are finished
// executing commands depending on the pipeline value.
func (s *state) evalPipeline(dot reflect.Value, pipe *parse.PipeNode) (value reflect.Value) <span class="cov8" title="1">{
        if pipe == nil </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">s.at(pipe)
        value = missingVal
        for _, cmd := range pipe.Cmds </span><span class="cov8" title="1">{
                value = s.evalCommand(dot, cmd, value) // previous value is this one's final arg.
                // If the object has type interface{}, dig down one level to the thing inside.
                if value.Kind() == reflect.Interface &amp;&amp; value.Type().NumMethod() == 0 </span><span class="cov8" title="1">{
                        value = reflect.ValueOf(value.Interface()) // lovely!
                }</span>
        }
        <span class="cov8" title="1">for _, variable := range pipe.Decl </span><span class="cov8" title="1">{
                if pipe.IsAssign </span><span class="cov8" title="1">{
                        s.setVar(variable.Ident[0], value)
                }</span> else<span class="cov8" title="1"> {
                        s.push(variable.Ident[0], value)
                }</span>
        }
        <span class="cov8" title="1">return value</span>
}

func (s *state) notAFunction(args []parse.Node, final reflect.Value) <span class="cov8" title="1">{
        if len(args) &gt; 1 || final != missingVal </span><span class="cov8" title="1">{
                s.errorf("can't give argument to non-function %s", args[0])
        }</span>
}

func (s *state) evalCommand(dot reflect.Value, cmd *parse.CommandNode, final reflect.Value) reflect.Value <span class="cov8" title="1">{
        firstWord := cmd.Args[0]
        switch n := firstWord.(type) </span>{
        case *parse.FieldNode:<span class="cov8" title="1">
                return s.evalFieldNode(dot, n, cmd.Args, final)</span>
        case *parse.ChainNode:<span class="cov8" title="1">
                return s.evalChainNode(dot, n, cmd.Args, final)</span>
        case *parse.IdentifierNode:<span class="cov8" title="1">
                // Must be a function.
                return s.evalFunction(dot, n, cmd, cmd.Args, final)</span>
        case *parse.PipeNode:<span class="cov8" title="1">
                // Parenthesized pipeline. The arguments are all inside the pipeline; final must be absent.
                s.notAFunction(cmd.Args, final)
                return s.evalPipeline(dot, n)</span>
        case *parse.VariableNode:<span class="cov8" title="1">
                return s.evalVariableNode(dot, n, cmd.Args, final)</span>
        }
        <span class="cov8" title="1">s.at(firstWord)
        s.notAFunction(cmd.Args, final)
        switch word := firstWord.(type) </span>{
        case *parse.BoolNode:<span class="cov8" title="1">
                return reflect.ValueOf(word.True)</span>
        case *parse.DotNode:<span class="cov8" title="1">
                return dot</span>
        case *parse.NilNode:<span class="cov8" title="1">
                s.errorf("nil is not a command")</span>
        case *parse.NumberNode:<span class="cov8" title="1">
                return s.idealConstant(word)</span>
        case *parse.StringNode:<span class="cov8" title="1">
                return reflect.ValueOf(word.Text)</span>
        }
        <span class="cov0" title="0">s.errorf("can't evaluate command %q", firstWord)
        panic("not reached")</span>
}

// idealConstant is called to return the value of a number in a context where
// we don't know the type. In that case, the syntax of the number tells us
// its type, and we use Go rules to resolve. Note there is no such thing as
// a uint ideal constant in this situation - the value must be of int type.
func (s *state) idealConstant(constant *parse.NumberNode) reflect.Value <span class="cov8" title="1">{
        // These are ideal constants but we don't know the type
        // and we have no context.  (If it was a method argument,
        // we'd know what we need.) The syntax guides us to some extent.
        s.at(constant)
        switch </span>{
        case constant.IsComplex:<span class="cov8" title="1">
                return reflect.ValueOf(constant.Complex128)</span> // incontrovertible.

        case constant.IsFloat &amp;&amp;
                !isHexInt(constant.Text) &amp;&amp; !isRuneInt(constant.Text) &amp;&amp;
                strings.ContainsAny(constant.Text, ".eEpP"):<span class="cov8" title="1">
                return reflect.ValueOf(constant.Float64)</span>

        case constant.IsInt:<span class="cov8" title="1">
                n := int(constant.Int64)
                if int64(n) != constant.Int64 </span><span class="cov0" title="0">{
                        s.errorf("%s overflows int", constant.Text)
                }</span>
                <span class="cov8" title="1">return reflect.ValueOf(n)</span>

        case constant.IsUint:<span class="cov8" title="1">
                s.errorf("%s overflows int", constant.Text)</span>
        }
        <span class="cov0" title="0">return zero</span>
}

func isRuneInt(s string) bool <span class="cov8" title="1">{
        return len(s) &gt; 0 &amp;&amp; s[0] == '\''
}</span>

func isHexInt(s string) bool <span class="cov8" title="1">{
        return len(s) &gt; 2 &amp;&amp; s[0] == '0' &amp;&amp; (s[1] == 'x' || s[1] == 'X') &amp;&amp; !strings.ContainsAny(s, "pP")
}</span>

func (s *state) evalFieldNode(dot reflect.Value, field *parse.FieldNode, args []parse.Node, final reflect.Value) reflect.Value <span class="cov8" title="1">{
        s.at(field)
        return s.evalFieldChain(dot, dot, field, field.Ident, args, final)
}</span>

func (s *state) evalChainNode(dot reflect.Value, chain *parse.ChainNode, args []parse.Node, final reflect.Value) reflect.Value <span class="cov8" title="1">{
        s.at(chain)
        if len(chain.Field) == 0 </span><span class="cov0" title="0">{
                s.errorf("internal error: no fields in evalChainNode")
        }</span>
        <span class="cov8" title="1">if chain.Node.Type() == parse.NodeNil </span><span class="cov0" title="0">{
                s.errorf("indirection through explicit nil in %s", chain)
        }</span>
        // (pipe).Field1.Field2 has pipe as .Node, fields as .Field. Eval the pipeline, then the fields.
        <span class="cov8" title="1">pipe := s.evalArg(dot, nil, chain.Node)
        return s.evalFieldChain(dot, pipe, chain, chain.Field, args, final)</span>
}

func (s *state) evalVariableNode(dot reflect.Value, variable *parse.VariableNode, args []parse.Node, final reflect.Value) reflect.Value <span class="cov8" title="1">{
        // $x.Field has $x as the first ident, Field as the second. Eval the var, then the fields.
        s.at(variable)
        value := s.varValue(variable.Ident[0])
        if len(variable.Ident) == 1 </span><span class="cov8" title="1">{
                s.notAFunction(args, final)
                return value
        }</span>
        <span class="cov8" title="1">return s.evalFieldChain(dot, value, variable, variable.Ident[1:], args, final)</span>
}

// evalFieldChain evaluates .X.Y.Z possibly followed by arguments.
// dot is the environment in which to evaluate arguments, while
// receiver is the value being walked along the chain.
func (s *state) evalFieldChain(dot, receiver reflect.Value, node parse.Node, ident []string, args []parse.Node, final reflect.Value) reflect.Value <span class="cov8" title="1">{
        n := len(ident)
        for i := 0; i &lt; n-1; i++ </span><span class="cov8" title="1">{
                receiver = s.evalField(dot, ident[i], node, nil, missingVal, receiver)
        }</span>
        // Now if it's a method, it gets the arguments.
        <span class="cov8" title="1">return s.evalField(dot, ident[n-1], node, args, final, receiver)</span>
}

func (s *state) evalFunctionOld(dot reflect.Value, node *parse.IdentifierNode, cmd parse.Node, args []parse.Node, final reflect.Value) reflect.Value <span class="cov0" title="0">{
        s.at(node)
        name := node.Ident
        function, ok := findFunction(name, s.tmpl)
        if !ok </span><span class="cov0" title="0">{
                s.errorf("%q is not a defined function", name)
        }</span>
        <span class="cov0" title="0">return s.evalCall(dot, function, cmd, name, args, final)</span>
}

// evalField evaluates an expression like (.Field) or (.Field arg1 arg2).
// The 'final' argument represents the return value from the preceding
// value of the pipeline, if any.
func (s *state) evalFieldOld(dot reflect.Value, fieldName string, node parse.Node, args []parse.Node, final, receiver reflect.Value) reflect.Value <span class="cov0" title="0">{
        if !receiver.IsValid() </span><span class="cov0" title="0">{
                if s.tmpl.option.missingKey == mapError </span><span class="cov0" title="0">{ // Treat invalid value as missing map key.
                        s.errorf("nil data; no entry for key %q", fieldName)
                }</span>
                <span class="cov0" title="0">return zero</span>
        }
        <span class="cov0" title="0">typ := receiver.Type()
        receiver, isNil := indirect(receiver)
        if receiver.Kind() == reflect.Interface &amp;&amp; isNil </span><span class="cov0" title="0">{
                // Calling a method on a nil interface can't work. The
                // MethodByName method call below would panic.
                s.errorf("nil pointer evaluating %s.%s", typ, fieldName)
                return zero
        }</span>

        // Unless it's an interface, need to get to a value of type *T to guarantee
        // we see all methods of T and *T.
        <span class="cov0" title="0">ptr := receiver
        if ptr.Kind() != reflect.Interface &amp;&amp; ptr.Kind() != reflect.Ptr &amp;&amp; ptr.CanAddr() </span><span class="cov0" title="0">{
                ptr = ptr.Addr()
        }</span>
        <span class="cov0" title="0">if method := ptr.MethodByName(fieldName); method.IsValid() </span><span class="cov0" title="0">{
                return s.evalCall(dot, method, node, fieldName, args, final)
        }</span>
        <span class="cov0" title="0">hasArgs := len(args) &gt; 1 || final != missingVal
        // It's not a method; must be a field of a struct or an element of a map.
        switch receiver.Kind() </span>{
        case reflect.Struct:<span class="cov0" title="0">
                tField, ok := receiver.Type().FieldByName(fieldName)
                if ok </span><span class="cov0" title="0">{
                        field := receiver.FieldByIndex(tField.Index)
                        if tField.PkgPath != "" </span><span class="cov0" title="0">{ // field is unexported
                                s.errorf("%s is an unexported field of struct type %s", fieldName, typ)
                        }</span>
                        // If it's a function, we must call it.
                        <span class="cov0" title="0">if hasArgs </span><span class="cov0" title="0">{
                                s.errorf("%s has arguments but cannot be invoked as function", fieldName)
                        }</span>
                        <span class="cov0" title="0">return field</span>
                }
        case reflect.Map:<span class="cov0" title="0">
                // If it's a map, attempt to use the field name as a key.
                nameVal := reflect.ValueOf(fieldName)
                if nameVal.Type().AssignableTo(receiver.Type().Key()) </span><span class="cov0" title="0">{
                        if hasArgs </span><span class="cov0" title="0">{
                                s.errorf("%s is not a method but has arguments", fieldName)
                        }</span>
                        <span class="cov0" title="0">result := receiver.MapIndex(nameVal)
                        if !result.IsValid() </span><span class="cov0" title="0">{
                                switch s.tmpl.option.missingKey </span>{
                                case mapInvalid:<span class="cov0" title="0"></span>
                                        // Just use the invalid value.
                                case mapZeroValue:<span class="cov0" title="0">
                                        result = reflect.Zero(receiver.Type().Elem())</span>
                                case mapError:<span class="cov0" title="0">
                                        s.errorf("map has no entry for key %q", fieldName)</span>
                                }
                        }
                        <span class="cov0" title="0">return result</span>
                }
        case reflect.Ptr:<span class="cov0" title="0">
                etyp := receiver.Type().Elem()
                if etyp.Kind() == reflect.Struct </span><span class="cov0" title="0">{
                        if _, ok := etyp.FieldByName(fieldName); !ok </span><span class="cov0" title="0">{
                                // If there's no such field, say "can't evaluate"
                                // instead of "nil pointer evaluating".
                                break</span>
                        }
                }
                <span class="cov0" title="0">if isNil </span><span class="cov0" title="0">{
                        s.errorf("nil pointer evaluating %s.%s", typ, fieldName)
                }</span>
        }
        <span class="cov0" title="0">s.errorf("can't evaluate field %s in type %s", fieldName, typ)
        panic("not reached")</span>
}

var (
        errorType        = reflect.TypeOf((*error)(nil)).Elem()
        fmtStringerType  = reflect.TypeOf((*fmt.Stringer)(nil)).Elem()
        reflectValueType = reflect.TypeOf((*reflect.Value)(nil)).Elem()
)

// evalCall executes a function or method call. If it's a method, fun already has the receiver bound, so
// it looks just like a function call. The arg list, if non-nil, includes (in the manner of the shell), arg[0]
// as the function itself.
func (s *state) evalCallOld(dot, fun reflect.Value, node parse.Node, name string, args []parse.Node, final reflect.Value) reflect.Value <span class="cov0" title="0">{
        if args != nil </span><span class="cov0" title="0">{
                args = args[1:] // Zeroth arg is function name/node; not passed to function.
        }</span>
        <span class="cov0" title="0">typ := fun.Type()
        numIn := len(args)
        if final != missingVal </span><span class="cov0" title="0">{
                numIn++
        }</span>
        <span class="cov0" title="0">numFixed := len(args)
        if typ.IsVariadic() </span><span class="cov0" title="0">{
                numFixed = typ.NumIn() - 1 // last arg is the variadic one.
                if numIn &lt; numFixed </span><span class="cov0" title="0">{
                        s.errorf("wrong number of args for %s: want at least %d got %d", name, typ.NumIn()-1, len(args))
                }</span>
        } else<span class="cov0" title="0"> if numIn != typ.NumIn() </span><span class="cov0" title="0">{
                s.errorf("wrong number of args for %s: want %d got %d", name, typ.NumIn(), numIn)
        }</span>
        <span class="cov0" title="0">if !goodFunc(typ) </span><span class="cov0" title="0">{
                // TODO: This could still be a confusing error; maybe goodFunc should provide info.
                s.errorf("can't call method/function %q with %d results", name, typ.NumOut())
        }</span>
        // Build the arg list.
        <span class="cov0" title="0">argv := make([]reflect.Value, numIn)
        // Args must be evaluated. Fixed args first.
        i := 0
        for ; i &lt; numFixed &amp;&amp; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                argv[i] = s.evalArg(dot, typ.In(i), args[i])
        }</span>
        // Now the ... args.
        <span class="cov0" title="0">if typ.IsVariadic() </span><span class="cov0" title="0">{
                argType := typ.In(typ.NumIn() - 1).Elem() // Argument is a slice.
                for ; i &lt; len(args); i++ </span><span class="cov0" title="0">{
                        argv[i] = s.evalArg(dot, argType, args[i])
                }</span>
        }
        // Add final value if necessary.
        <span class="cov0" title="0">if final != missingVal </span><span class="cov0" title="0">{
                t := typ.In(typ.NumIn() - 1)
                if typ.IsVariadic() </span><span class="cov0" title="0">{
                        if numIn-1 &lt; numFixed </span><span class="cov0" title="0">{
                                // The added final argument corresponds to a fixed parameter of the function.
                                // Validate against the type of the actual parameter.
                                t = typ.In(numIn - 1)
                        }</span> else<span class="cov0" title="0"> {
                                // The added final argument corresponds to the variadic part.
                                // Validate against the type of the elements of the variadic slice.
                                t = t.Elem()
                        }</span>
                }
                <span class="cov0" title="0">argv[i] = s.validateType(final, t)</span>
        }
        <span class="cov0" title="0">v, err := safeCall(fun, argv)
        // If we have an error that is not nil, stop execution and return that
        // error to the caller.
        if err != nil </span><span class="cov0" title="0">{
                s.at(node)
                s.errorf("error calling %s: %v", name, err)
        }</span>
        <span class="cov0" title="0">if v.Type() == reflectValueType </span><span class="cov0" title="0">{
                v = v.Interface().(reflect.Value)
        }</span>
        <span class="cov0" title="0">return v</span>
}

// canBeNil reports whether an untyped nil can be assigned to the type. See reflect.Zero.
func canBeNil(typ reflect.Type) bool <span class="cov8" title="1">{
        switch typ.Kind() </span>{
        case reflect.Chan, reflect.Func, reflect.Interface, reflect.Map, reflect.Ptr, reflect.Slice:<span class="cov8" title="1">
                return true</span>
        case reflect.Struct:<span class="cov8" title="1">
                return typ == reflectValueType</span>
        }
        <span class="cov8" title="1">return false</span>
}

// validateType guarantees that the value is valid and assignable to the type.
func (s *state) validateType(value reflect.Value, typ reflect.Type) reflect.Value <span class="cov8" title="1">{
        if !value.IsValid() </span><span class="cov8" title="1">{
                if typ == nil </span><span class="cov8" title="1">{
                        // An untyped nil interface{}. Accept as a proper nil value.
                        return reflect.ValueOf(nil)
                }</span>
                <span class="cov8" title="1">if canBeNil(typ) </span><span class="cov8" title="1">{
                        // Like above, but use the zero value of the non-nil type.
                        return reflect.Zero(typ)
                }</span>
                <span class="cov0" title="0">s.errorf("invalid value; expected %s", typ)</span>
        }
        <span class="cov8" title="1">if typ == reflectValueType &amp;&amp; value.Type() != typ </span><span class="cov8" title="1">{
                return reflect.ValueOf(value)
        }</span>
        <span class="cov8" title="1">if typ != nil &amp;&amp; !value.Type().AssignableTo(typ) </span><span class="cov8" title="1">{
                if value.Kind() == reflect.Interface &amp;&amp; !value.IsNil() </span><span class="cov8" title="1">{
                        value = value.Elem()
                        if value.Type().AssignableTo(typ) </span><span class="cov8" title="1">{
                                return value
                        }</span>
                        // fallthrough
                }
                // Does one dereference or indirection work? We could do more, as we
                // do with method receivers, but that gets messy and method receivers
                // are much more constrained, so it makes more sense there than here.
                // Besides, one is almost always all you need.
                <span class="cov8" title="1">switch </span>{
                case value.Kind() == reflect.Ptr &amp;&amp; value.Type().Elem().AssignableTo(typ):<span class="cov8" title="1">
                        value = value.Elem()
                        if !value.IsValid() </span><span class="cov8" title="1">{
                                s.errorf("dereference of nil pointer of type %s", typ)
                        }</span>
                case reflect.PtrTo(value.Type()).AssignableTo(typ) &amp;&amp; value.CanAddr():<span class="cov8" title="1">
                        value = value.Addr()</span>
                case value.IsZero():<span class="cov8" title="1">
                        s.errorf("got &lt;nil&gt;, expected %s", typ)</span>
                default:<span class="cov8" title="1">
                        s.errorf("wrong type for value; expected %s; got %s", typ, value.Type())</span>
                }
        }
        <span class="cov8" title="1">return value</span>
}

func (s *state) evalArg(dot reflect.Value, typ reflect.Type, n parse.Node) reflect.Value <span class="cov8" title="1">{
        s.at(n)
        switch arg := n.(type) </span>{
        case *parse.DotNode:<span class="cov8" title="1">
                return s.validateType(dot, typ)</span>
        case *parse.NilNode:<span class="cov8" title="1">
                if canBeNil(typ) </span><span class="cov8" title="1">{
                        return reflect.Zero(typ)
                }</span>
                <span class="cov0" title="0">s.errorf("cannot assign nil to %s", typ)</span>
        case *parse.FieldNode:<span class="cov8" title="1">
                return s.validateType(s.evalFieldNode(dot, arg, []parse.Node{n}, missingVal), typ)</span>
        case *parse.VariableNode:<span class="cov8" title="1">
                return s.validateType(s.evalVariableNode(dot, arg, nil, missingVal), typ)</span>
        case *parse.PipeNode:<span class="cov8" title="1">
                return s.validateType(s.evalPipeline(dot, arg), typ)</span>
        case *parse.IdentifierNode:<span class="cov8" title="1">
                return s.validateType(s.evalFunction(dot, arg, arg, nil, missingVal), typ)</span>
        case *parse.ChainNode:<span class="cov8" title="1">
                return s.validateType(s.evalChainNode(dot, arg, nil, missingVal), typ)</span>
        }
        <span class="cov8" title="1">switch typ.Kind() </span>{
        case reflect.Bool:<span class="cov8" title="1">
                return s.evalBool(typ, n)</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov0" title="0">
                return s.evalComplex(typ, n)</span>
        case reflect.Float32, reflect.Float64:<span class="cov0" title="0">
                return s.evalFloat(typ, n)</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return s.evalInteger(typ, n)</span>
        case reflect.Interface:<span class="cov8" title="1">
                if typ.NumMethod() == 0 </span><span class="cov8" title="1">{
                        return s.evalEmptyInterface(dot, n)
                }</span>
        case reflect.Struct:<span class="cov8" title="1">
                if typ == reflectValueType </span><span class="cov8" title="1">{
                        return reflect.ValueOf(s.evalEmptyInterface(dot, n))
                }</span>
        case reflect.String:<span class="cov8" title="1">
                return s.evalString(typ, n)</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov8" title="1">
                return s.evalUnsignedInteger(typ, n)</span>
        }
        <span class="cov0" title="0">s.errorf("can't handle %s for arg of type %s", n, typ)
        panic("not reached")</span>
}

func (s *state) evalBool(typ reflect.Type, n parse.Node) reflect.Value <span class="cov8" title="1">{
        s.at(n)
        if n, ok := n.(*parse.BoolNode); ok </span><span class="cov8" title="1">{
                value := reflect.New(typ).Elem()
                value.SetBool(n.True)
                return value
        }</span>
        <span class="cov0" title="0">s.errorf("expected bool; found %s", n)
        panic("not reached")</span>
}

func (s *state) evalString(typ reflect.Type, n parse.Node) reflect.Value <span class="cov8" title="1">{
        s.at(n)
        if n, ok := n.(*parse.StringNode); ok </span><span class="cov8" title="1">{
                value := reflect.New(typ).Elem()
                value.SetString(n.Text)
                return value
        }</span>
        <span class="cov0" title="0">s.errorf("expected string; found %s", n)
        panic("not reached")</span>
}

func (s *state) evalInteger(typ reflect.Type, n parse.Node) reflect.Value <span class="cov8" title="1">{
        s.at(n)
        if n, ok := n.(*parse.NumberNode); ok &amp;&amp; n.IsInt </span><span class="cov8" title="1">{
                value := reflect.New(typ).Elem()
                value.SetInt(n.Int64)
                return value
        }</span>
        <span class="cov0" title="0">s.errorf("expected integer; found %s", n)
        panic("not reached")</span>
}

func (s *state) evalUnsignedInteger(typ reflect.Type, n parse.Node) reflect.Value <span class="cov8" title="1">{
        s.at(n)
        if n, ok := n.(*parse.NumberNode); ok &amp;&amp; n.IsUint </span><span class="cov8" title="1">{
                value := reflect.New(typ).Elem()
                value.SetUint(n.Uint64)
                return value
        }</span>
        <span class="cov0" title="0">s.errorf("expected unsigned integer; found %s", n)
        panic("not reached")</span>
}

func (s *state) evalFloat(typ reflect.Type, n parse.Node) reflect.Value <span class="cov0" title="0">{
        s.at(n)
        if n, ok := n.(*parse.NumberNode); ok &amp;&amp; n.IsFloat </span><span class="cov0" title="0">{
                value := reflect.New(typ).Elem()
                value.SetFloat(n.Float64)
                return value
        }</span>
        <span class="cov0" title="0">s.errorf("expected float; found %s", n)
        panic("not reached")</span>
}

func (s *state) evalComplex(typ reflect.Type, n parse.Node) reflect.Value <span class="cov0" title="0">{
        if n, ok := n.(*parse.NumberNode); ok &amp;&amp; n.IsComplex </span><span class="cov0" title="0">{
                value := reflect.New(typ).Elem()
                value.SetComplex(n.Complex128)
                return value
        }</span>
        <span class="cov0" title="0">s.errorf("expected complex; found %s", n)
        panic("not reached")</span>
}

func (s *state) evalEmptyInterface(dot reflect.Value, n parse.Node) reflect.Value <span class="cov8" title="1">{
        s.at(n)
        switch n := n.(type) </span>{
        case *parse.BoolNode:<span class="cov8" title="1">
                return reflect.ValueOf(n.True)</span>
        case *parse.DotNode:<span class="cov0" title="0">
                return dot</span>
        case *parse.FieldNode:<span class="cov0" title="0">
                return s.evalFieldNode(dot, n, nil, missingVal)</span>
        case *parse.IdentifierNode:<span class="cov0" title="0">
                return s.evalFunction(dot, n, n, nil, missingVal)</span>
        case *parse.NilNode:<span class="cov0" title="0">
                // NilNode is handled in evalArg, the only place that calls here.
                s.errorf("evalEmptyInterface: nil (can't happen)")</span>
        case *parse.NumberNode:<span class="cov8" title="1">
                return s.idealConstant(n)</span>
        case *parse.StringNode:<span class="cov8" title="1">
                return reflect.ValueOf(n.Text)</span>
        case *parse.VariableNode:<span class="cov0" title="0">
                return s.evalVariableNode(dot, n, nil, missingVal)</span>
        case *parse.PipeNode:<span class="cov0" title="0">
                return s.evalPipeline(dot, n)</span>
        }
        <span class="cov0" title="0">s.errorf("can't handle assignment of %s to empty interface argument", n)
        panic("not reached")</span>
}

// indirect returns the item at the end of indirection, and a bool to indicate
// if it's nil. If the returned bool is true, the returned value's kind will be
// either a pointer or interface.
func indirect(v reflect.Value) (rv reflect.Value, isNil bool) <span class="cov8" title="1">{
        for ; v.Kind() == reflect.Ptr || v.Kind() == reflect.Interface; v = v.Elem() </span><span class="cov8" title="1">{
                if v.IsNil() </span><span class="cov8" title="1">{
                        return v, true
                }</span>
        }
        <span class="cov8" title="1">return v, false</span>
}

// indirectInterface returns the concrete value in an interface value,
// or else the zero reflect.Value.
// That is, if v represents the interface value x, the result is the same as reflect.ValueOf(x):
// the fact that x was an interface value is forgotten.
func indirectInterface(v reflect.Value) reflect.Value <span class="cov8" title="1">{
        if v.Kind() != reflect.Interface </span><span class="cov8" title="1">{
                return v
        }</span>
        <span class="cov8" title="1">if v.IsNil() </span><span class="cov8" title="1">{
                return reflect.Value{}
        }</span>
        <span class="cov8" title="1">return v.Elem()</span>
}

// printValue writes the textual representation of the value to the output of
// the template.
func (s *state) printValue(n parse.Node, v reflect.Value) <span class="cov8" title="1">{
        s.at(n)
        iface, ok := printableValue(v)
        if !ok </span><span class="cov8" title="1">{
                s.errorf("can't print %s of type %s", n, v.Type())
        }</span>
        <span class="cov8" title="1">_, err := fmt.Fprint(s.wr, iface)
        if err != nil </span><span class="cov0" title="0">{
                s.writeError(err)
        }</span>
}

// printableValue returns the, possibly indirected, interface value inside v that
// is best for a call to formatted printer.
func printableValue(v reflect.Value) (interface{}, bool) <span class="cov8" title="1">{
        if v.Kind() == reflect.Ptr </span><span class="cov8" title="1">{
                v, _ = indirect(v) // fmt.Fprint handles nil.
        }</span>
        <span class="cov8" title="1">if !v.IsValid() </span><span class="cov8" title="1">{
                return "&lt;no value&gt;", true
        }</span>

        <span class="cov8" title="1">if !v.Type().Implements(errorType) &amp;&amp; !v.Type().Implements(fmtStringerType) </span><span class="cov8" title="1">{
                if v.CanAddr() &amp;&amp; (reflect.PtrTo(v.Type()).Implements(errorType) || reflect.PtrTo(v.Type()).Implements(fmtStringerType)) </span><span class="cov8" title="1">{
                        v = v.Addr()
                }</span> else<span class="cov8" title="1"> {
                        switch v.Kind() </span>{
                        case reflect.Chan, reflect.Func:<span class="cov8" title="1">
                                return nil, false</span>
                        }
                }
        }
        <span class="cov8" title="1">return v.Interface(), true</span>
}
</pre>
		
		<pre class="file" id="file317" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "bytes"
        "errors"
        "fmt"
        "io"
        "net/url"
        "reflect"
        "strings"
        "sync"
        "unicode"
        "unicode/utf8"
)

// FuncMap is the type of the map defining the mapping from names to functions.
// Each function must have either a single return value, or two return values of
// which the second has type error. In that case, if the second (error)
// return value evaluates to non-nil during execution, execution terminates and
// Execute returns that error.
//
// When template execution invokes a function with an argument list, that list
// must be assignable to the function's parameter types. Functions meant to
// apply to arguments of arbitrary type can use parameters of type interface{} or
// of type reflect.Value. Similarly, functions meant to return a result of arbitrary
// type can return interface{} or reflect.Value.
type FuncMap map[string]interface{}

// builtins returns the FuncMap.
// It is not a global variable so the linker can dead code eliminate
// more when this isn't called. See golang.org/issue/36021.
// TODO: revert this back to a global map once golang.org/issue/2559 is fixed.
func builtins() FuncMap <span class="cov8" title="1">{
        return FuncMap{
                "and":      and,
                "call":     call,
                "html":     HTMLEscaper,
                "index":    index,
                "slice":    slice,
                "js":       JSEscaper,
                "len":      length,
                "not":      not,
                "or":       or,
                "print":    fmt.Sprint,
                "printf":   fmt.Sprintf,
                "println":  fmt.Sprintln,
                "urlquery": URLQueryEscaper,

                // Comparisons
                "eq": eq, // ==
                "ge": ge, // &gt;=
                "gt": gt, // &gt;
                "le": le, // &lt;=
                "lt": lt, // &lt;
                "ne": ne, // !=
        }
}</span>

var builtinFuncsOnce struct {
        sync.Once
        v map[string]reflect.Value
}

// builtinFuncsOnce lazily computes &amp; caches the builtinFuncs map.
// TODO: revert this back to a global map once golang.org/issue/2559 is fixed.
func builtinFuncs() map[string]reflect.Value <span class="cov8" title="1">{
        builtinFuncsOnce.Do(func() </span><span class="cov8" title="1">{
                builtinFuncsOnce.v = createValueFuncs(builtins())
        }</span>)
        <span class="cov8" title="1">return builtinFuncsOnce.v</span>
}

// createValueFuncs turns a FuncMap into a map[string]reflect.Value
func createValueFuncs(funcMap FuncMap) map[string]reflect.Value <span class="cov8" title="1">{
        m := make(map[string]reflect.Value)
        addValueFuncs(m, funcMap)
        return m
}</span>

// addValueFuncs adds to values the functions in funcs, converting them to reflect.Values.
func addValueFuncs(out map[string]reflect.Value, in FuncMap) <span class="cov8" title="1">{
        for name, fn := range in </span><span class="cov8" title="1">{
                if !goodName(name) </span><span class="cov8" title="1">{
                        panic(fmt.Errorf("function name %q is not a valid identifier", name))</span>
                }
                <span class="cov8" title="1">v := reflect.ValueOf(fn)
                if v.Kind() != reflect.Func </span><span class="cov0" title="0">{
                        panic("value for " + name + " not a function")</span>
                }
                <span class="cov8" title="1">if !goodFunc(v.Type()) </span><span class="cov0" title="0">{
                        panic(fmt.Errorf("can't install method/function %q with %d results", name, v.Type().NumOut()))</span>
                }
                <span class="cov8" title="1">out[name] = v</span>
        }
}

// addFuncs adds to values the functions in funcs. It does no checking of the input -
// call addValueFuncs first.
func addFuncs(out, in FuncMap) <span class="cov8" title="1">{
        for name, fn := range in </span><span class="cov8" title="1">{
                out[name] = fn
        }</span>
}

// goodFunc reports whether the function or method has the right result signature.
func goodFunc(typ reflect.Type) bool <span class="cov8" title="1">{
        // We allow functions with 1 result or 2 results where the second is an error.
        switch </span>{
        case typ.NumOut() == 1:<span class="cov8" title="1">
                return true</span>
        case typ.NumOut() == 2 &amp;&amp; typ.Out(1) == errorType:<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov0" title="0">return false</span>
}

// goodName reports whether the function name is a valid identifier.
func goodName(name string) bool <span class="cov8" title="1">{
        if name == "" </span><span class="cov8" title="1">{
                return false
        }</span>
        <span class="cov8" title="1">for i, r := range name </span><span class="cov8" title="1">{
                switch </span>{
                case r == '_':<span class="cov8" title="1"></span>
                case i == 0 &amp;&amp; !unicode.IsLetter(r):<span class="cov8" title="1">
                        return false</span>
                case !unicode.IsLetter(r) &amp;&amp; !unicode.IsDigit(r):<span class="cov8" title="1">
                        return false</span>
                }
        }
        <span class="cov8" title="1">return true</span>
}

// findFunction looks for a function in the template, and global map.
func findFunction(name string, tmpl *Template) (reflect.Value, bool) <span class="cov8" title="1">{
        if tmpl != nil &amp;&amp; tmpl.common != nil </span><span class="cov8" title="1">{
                tmpl.muFuncs.RLock()
                defer tmpl.muFuncs.RUnlock()
                if fn := tmpl.execFuncs[name]; fn.IsValid() </span><span class="cov8" title="1">{
                        return fn, true
                }</span>
        }
        <span class="cov8" title="1">if fn := builtinFuncs()[name]; fn.IsValid() </span><span class="cov8" title="1">{
                return fn, true
        }</span>
        <span class="cov0" title="0">return reflect.Value{}, false</span>
}

// prepareArg checks if value can be used as an argument of type argType, and
// converts an invalid value to appropriate zero if possible.
func prepareArg(value reflect.Value, argType reflect.Type) (reflect.Value, error) <span class="cov8" title="1">{
        if !value.IsValid() </span><span class="cov8" title="1">{
                if !canBeNil(argType) </span><span class="cov8" title="1">{
                        return reflect.Value{}, fmt.Errorf("value is nil; should be of type %s", argType)
                }</span>
                <span class="cov8" title="1">value = reflect.Zero(argType)</span>
        }
        <span class="cov8" title="1">if value.Type().AssignableTo(argType) </span><span class="cov8" title="1">{
                return value, nil
        }</span>
        <span class="cov8" title="1">if intLike(value.Kind()) &amp;&amp; intLike(argType.Kind()) &amp;&amp; value.Type().ConvertibleTo(argType) </span><span class="cov8" title="1">{
                value = value.Convert(argType)
                return value, nil
        }</span>
        <span class="cov8" title="1">return reflect.Value{}, fmt.Errorf("value has type %s; should be %s", value.Type(), argType)</span>
}

func intLike(typ reflect.Kind) bool <span class="cov8" title="1">{
        switch typ </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return true</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return false</span>
}

// indexArg checks if a reflect.Value can be used as an index, and converts it to int if possible.
func indexArg(index reflect.Value, cap int) (int, error) <span class="cov8" title="1">{
        var x int64
        switch index.Kind() </span>{
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                x = index.Int()</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov0" title="0">
                x = int64(index.Uint())</span>
        case reflect.Invalid:<span class="cov8" title="1">
                return 0, fmt.Errorf("cannot index slice/array with nil")</span>
        default:<span class="cov8" title="1">
                return 0, fmt.Errorf("cannot index slice/array with type %s", index.Type())</span>
        }
        <span class="cov8" title="1">if x &lt; 0 || int(x) &lt; 0 || int(x) &gt; cap </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("index out of range: %d", x)
        }</span>
        <span class="cov8" title="1">return int(x), nil</span>
}

// Indexing.

// index returns the result of indexing its first argument by the following
// arguments. Thus "index x 1 2 3" is, in Go syntax, x[1][2][3]. Each
// indexed item must be a map, slice, or array.
func index(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error) <span class="cov8" title="1">{
        item = indirectInterface(item)
        if !item.IsValid() </span><span class="cov8" title="1">{
                return reflect.Value{}, fmt.Errorf("index of untyped nil")
        }</span>
        <span class="cov8" title="1">for _, index := range indexes </span><span class="cov8" title="1">{
                index = indirectInterface(index)
                var isNil bool
                if item, isNil = indirect(item); isNil </span><span class="cov0" title="0">{
                        return reflect.Value{}, fmt.Errorf("index of nil pointer")
                }</span>
                <span class="cov8" title="1">switch item.Kind() </span>{
                case reflect.Array, reflect.Slice, reflect.String:<span class="cov8" title="1">
                        x, err := indexArg(index, item.Len())
                        if err != nil </span><span class="cov8" title="1">{
                                return reflect.Value{}, err
                        }</span>
                        <span class="cov8" title="1">item = item.Index(x)</span>
                case reflect.Map:<span class="cov8" title="1">
                        index, err := prepareArg(index, item.Type().Key())
                        if err != nil </span><span class="cov8" title="1">{
                                return reflect.Value{}, err
                        }</span>
                        <span class="cov8" title="1">if x := item.MapIndex(index); x.IsValid() </span><span class="cov8" title="1">{
                                item = x
                        }</span> else<span class="cov8" title="1"> {
                                item = reflect.Zero(item.Type().Elem())
                        }</span>
                case reflect.Invalid:<span class="cov0" title="0">
                        // the loop holds invariant: item.IsValid()
                        panic("unreachable")</span>
                default:<span class="cov0" title="0">
                        return reflect.Value{}, fmt.Errorf("can't index item of type %s", item.Type())</span>
                }
        }
        <span class="cov8" title="1">return item, nil</span>
}

// Slicing.

// slice returns the result of slicing its first argument by the remaining
// arguments. Thus "slice x 1 2" is, in Go syntax, x[1:2], while "slice x"
// is x[:], "slice x 1" is x[1:], and "slice x 1 2 3" is x[1:2:3]. The first
// argument must be a string, slice, or array.
func slice(item reflect.Value, indexes ...reflect.Value) (reflect.Value, error) <span class="cov8" title="1">{
        item = indirectInterface(item)
        if !item.IsValid() </span><span class="cov0" title="0">{
                return reflect.Value{}, fmt.Errorf("slice of untyped nil")
        }</span>
        <span class="cov8" title="1">if len(indexes) &gt; 3 </span><span class="cov0" title="0">{
                return reflect.Value{}, fmt.Errorf("too many slice indexes: %d", len(indexes))
        }</span>
        <span class="cov8" title="1">var cap int
        switch item.Kind() </span>{
        case reflect.String:<span class="cov8" title="1">
                if len(indexes) == 3 </span><span class="cov8" title="1">{
                        return reflect.Value{}, fmt.Errorf("cannot 3-index slice a string")
                }</span>
                <span class="cov8" title="1">cap = item.Len()</span>
        case reflect.Array, reflect.Slice:<span class="cov8" title="1">
                cap = item.Cap()</span>
        default:<span class="cov0" title="0">
                return reflect.Value{}, fmt.Errorf("can't slice item of type %s", item.Type())</span>
        }
        // set default values for cases item[:], item[i:].
        <span class="cov8" title="1">idx := [3]int{0, item.Len()}
        for i, index := range indexes </span><span class="cov8" title="1">{
                x, err := indexArg(index, cap)
                if err != nil </span><span class="cov8" title="1">{
                        return reflect.Value{}, err
                }</span>
                <span class="cov8" title="1">idx[i] = x</span>
        }
        // given item[i:j], make sure i &lt;= j.
        <span class="cov8" title="1">if idx[0] &gt; idx[1] </span><span class="cov8" title="1">{
                return reflect.Value{}, fmt.Errorf("invalid slice index: %d &gt; %d", idx[0], idx[1])
        }</span>
        <span class="cov8" title="1">if len(indexes) &lt; 3 </span><span class="cov8" title="1">{
                return item.Slice(idx[0], idx[1]), nil
        }</span>
        // given item[i:j:k], make sure i &lt;= j &lt;= k.
        <span class="cov8" title="1">if idx[1] &gt; idx[2] </span><span class="cov8" title="1">{
                return reflect.Value{}, fmt.Errorf("invalid slice index: %d &gt; %d", idx[1], idx[2])
        }</span>
        <span class="cov8" title="1">return item.Slice3(idx[0], idx[1], idx[2]), nil</span>
}

// Length

// length returns the length of the item, with an error if it has no defined length.
func length(item reflect.Value) (int, error) <span class="cov8" title="1">{
        item, isNil := indirect(item)
        if isNil </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("len of nil pointer")
        }</span>
        <span class="cov8" title="1">switch item.Kind() </span>{
        case reflect.Array, reflect.Chan, reflect.Map, reflect.Slice, reflect.String:<span class="cov8" title="1">
                return item.Len(), nil</span>
        }
        <span class="cov8" title="1">return 0, fmt.Errorf("len of type %s", item.Type())</span>
}

// Function invocation

// call returns the result of evaluating the first argument as a function.
// The function must return 1 result, or 2 results, the second of which is an error.
func call(fn reflect.Value, args ...reflect.Value) (reflect.Value, error) <span class="cov8" title="1">{
        fn = indirectInterface(fn)
        if !fn.IsValid() </span><span class="cov8" title="1">{
                return reflect.Value{}, fmt.Errorf("call of nil")
        }</span>
        <span class="cov8" title="1">typ := fn.Type()
        if typ.Kind() != reflect.Func </span><span class="cov0" title="0">{
                return reflect.Value{}, fmt.Errorf("non-function of type %s", typ)
        }</span>
        <span class="cov8" title="1">if !goodFunc(typ) </span><span class="cov0" title="0">{
                return reflect.Value{}, fmt.Errorf("function called with %d args; should be 1 or 2", typ.NumOut())
        }</span>
        <span class="cov8" title="1">numIn := typ.NumIn()
        var dddType reflect.Type
        if typ.IsVariadic() </span><span class="cov8" title="1">{
                if len(args) &lt; numIn-1 </span><span class="cov8" title="1">{
                        return reflect.Value{}, fmt.Errorf("wrong number of args: got %d want at least %d", len(args), numIn-1)
                }</span>
                <span class="cov8" title="1">dddType = typ.In(numIn - 1).Elem()</span>
        } else<span class="cov8" title="1"> {
                if len(args) != numIn </span><span class="cov8" title="1">{
                        return reflect.Value{}, fmt.Errorf("wrong number of args: got %d want %d", len(args), numIn)
                }</span>
        }
        <span class="cov8" title="1">argv := make([]reflect.Value, len(args))
        for i, arg := range args </span><span class="cov8" title="1">{
                arg = indirectInterface(arg)
                // Compute the expected type. Clumsy because of variadics.
                argType := dddType
                if !typ.IsVariadic() || i &lt; numIn-1 </span><span class="cov8" title="1">{
                        argType = typ.In(i)
                }</span>

                <span class="cov8" title="1">var err error
                if argv[i], err = prepareArg(arg, argType); err != nil </span><span class="cov8" title="1">{
                        return reflect.Value{}, fmt.Errorf("arg %d: %s", i, err)
                }</span>
        }
        <span class="cov8" title="1">return safeCall(fn, argv)</span>
}

// safeCall runs fun.Call(args), and returns the resulting value and error, if
// any. If the call panics, the panic value is returned as an error.
func safeCall(fun reflect.Value, args []reflect.Value) (val reflect.Value, err error) <span class="cov8" title="1">{
        defer func() </span><span class="cov8" title="1">{
                if r := recover(); r != nil </span><span class="cov8" title="1">{
                        if e, ok := r.(error); ok </span><span class="cov8" title="1">{
                                err = e
                        }</span> else<span class="cov8" title="1"> {
                                err = fmt.Errorf("%v", r)
                        }</span>
                }
        }()
        <span class="cov8" title="1">ret := fun.Call(args)
        if len(ret) == 2 &amp;&amp; !ret[1].IsNil() </span><span class="cov8" title="1">{
                return ret[0], ret[1].Interface().(error)
        }</span>
        <span class="cov8" title="1">return ret[0], nil</span>
}

// Boolean logic.

func truth(arg reflect.Value) bool <span class="cov8" title="1">{
        t, _ := isTrue(indirectInterface(arg))
        return t
}</span>

// and computes the Boolean AND of its arguments, returning
// the first false argument it encounters, or the last argument.
func and(arg0 reflect.Value, args ...reflect.Value) reflect.Value <span class="cov8" title="1">{
        if !truth(arg0) </span><span class="cov8" title="1">{
                return arg0
        }</span>
        <span class="cov8" title="1">for i := range args </span><span class="cov8" title="1">{
                arg0 = args[i]
                if !truth(arg0) </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return arg0</span>
}

// or computes the Boolean OR of its arguments, returning
// the first true argument it encounters, or the last argument.
func or(arg0 reflect.Value, args ...reflect.Value) reflect.Value <span class="cov8" title="1">{
        if truth(arg0) </span><span class="cov8" title="1">{
                return arg0
        }</span>
        <span class="cov8" title="1">for i := range args </span><span class="cov8" title="1">{
                arg0 = args[i]
                if truth(arg0) </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return arg0</span>
}

// not returns the Boolean negation of its argument.
func not(arg reflect.Value) bool <span class="cov8" title="1">{
        return !truth(arg)
}</span>

// Comparison.

// TODO: Perhaps allow comparison between signed and unsigned integers.

var (
        errBadComparisonType = errors.New("invalid type for comparison")
        errBadComparison     = errors.New("incompatible types for comparison")
        errNoComparison      = errors.New("missing argument for comparison")
)

type kind int

const (
        invalidKind kind = iota
        boolKind
        complexKind
        intKind
        floatKind
        stringKind
        uintKind
)

func basicKind(v reflect.Value) (kind, error) <span class="cov8" title="1">{
        switch v.Kind() </span>{
        case reflect.Bool:<span class="cov8" title="1">
                return boolKind, nil</span>
        case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64:<span class="cov8" title="1">
                return intKind, nil</span>
        case reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64, reflect.Uintptr:<span class="cov8" title="1">
                return uintKind, nil</span>
        case reflect.Float32, reflect.Float64:<span class="cov8" title="1">
                return floatKind, nil</span>
        case reflect.Complex64, reflect.Complex128:<span class="cov8" title="1">
                return complexKind, nil</span>
        case reflect.String:<span class="cov8" title="1">
                return stringKind, nil</span>
        }
        <span class="cov8" title="1">return invalidKind, errBadComparisonType</span>
}

// eq evaluates the comparison a == b || a == c || ...
func eq(arg1 reflect.Value, arg2 ...reflect.Value) (bool, error) <span class="cov8" title="1">{
        arg1 = indirectInterface(arg1)
        if arg1 != zero </span><span class="cov8" title="1">{
                if t1 := arg1.Type(); !t1.Comparable() </span><span class="cov8" title="1">{
                        return false, fmt.Errorf("uncomparable type %s: %v", t1, arg1)
                }</span>
        }
        <span class="cov8" title="1">if len(arg2) == 0 </span><span class="cov0" title="0">{
                return false, errNoComparison
        }</span>
        <span class="cov8" title="1">k1, _ := basicKind(arg1)
        for _, arg := range arg2 </span><span class="cov8" title="1">{
                arg = indirectInterface(arg)
                k2, _ := basicKind(arg)
                truth := false
                if k1 != k2 </span><span class="cov8" title="1">{
                        // Special case: Can compare integer values regardless of type's sign.
                        switch </span>{
                        case k1 == intKind &amp;&amp; k2 == uintKind:<span class="cov8" title="1">
                                truth = arg1.Int() &gt;= 0 &amp;&amp; uint64(arg1.Int()) == arg.Uint()</span>
                        case k1 == uintKind &amp;&amp; k2 == intKind:<span class="cov8" title="1">
                                truth = arg.Int() &gt;= 0 &amp;&amp; arg1.Uint() == uint64(arg.Int())</span>
                        default:<span class="cov8" title="1">
                                return false, errBadComparison</span>
                        }
                } else<span class="cov8" title="1"> {
                        switch k1 </span>{
                        case boolKind:<span class="cov8" title="1">
                                truth = arg1.Bool() == arg.Bool()</span>
                        case complexKind:<span class="cov8" title="1">
                                truth = arg1.Complex() == arg.Complex()</span>
                        case floatKind:<span class="cov8" title="1">
                                truth = arg1.Float() == arg.Float()</span>
                        case intKind:<span class="cov8" title="1">
                                truth = arg1.Int() == arg.Int()</span>
                        case stringKind:<span class="cov8" title="1">
                                truth = arg1.String() == arg.String()</span>
                        case uintKind:<span class="cov8" title="1">
                                truth = arg1.Uint() == arg.Uint()</span>
                        default:<span class="cov8" title="1">
                                if arg == zero </span><span class="cov8" title="1">{
                                        truth = arg1 == arg
                                }</span> else<span class="cov8" title="1"> {
                                        if t2 := arg.Type(); !t2.Comparable() </span><span class="cov0" title="0">{
                                                return false, fmt.Errorf("uncomparable type %s: %v", t2, arg)
                                        }</span>
                                        <span class="cov8" title="1">truth = arg1.Interface() == arg.Interface()</span>
                                }
                        }
                }
                <span class="cov8" title="1">if truth </span><span class="cov8" title="1">{
                        return true, nil
                }</span>
        }
        <span class="cov8" title="1">return false, nil</span>
}

// ne evaluates the comparison a != b.
func ne(arg1, arg2 reflect.Value) (bool, error) <span class="cov8" title="1">{
        // != is the inverse of ==.
        equal, err := eq(arg1, arg2)
        return !equal, err
}</span>

// lt evaluates the comparison a &lt; b.
func lt(arg1, arg2 reflect.Value) (bool, error) <span class="cov8" title="1">{
        arg1 = indirectInterface(arg1)
        k1, err := basicKind(arg1)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">arg2 = indirectInterface(arg2)
        k2, err := basicKind(arg2)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">truth := false
        if k1 != k2 </span><span class="cov8" title="1">{
                // Special case: Can compare integer values regardless of type's sign.
                switch </span>{
                case k1 == intKind &amp;&amp; k2 == uintKind:<span class="cov8" title="1">
                        truth = arg1.Int() &lt; 0 || uint64(arg1.Int()) &lt; arg2.Uint()</span>
                case k1 == uintKind &amp;&amp; k2 == intKind:<span class="cov8" title="1">
                        truth = arg2.Int() &gt;= 0 &amp;&amp; arg1.Uint() &lt; uint64(arg2.Int())</span>
                default:<span class="cov0" title="0">
                        return false, errBadComparison</span>
                }
        } else<span class="cov8" title="1"> {
                switch k1 </span>{
                case boolKind, complexKind:<span class="cov8" title="1">
                        return false, errBadComparisonType</span>
                case floatKind:<span class="cov8" title="1">
                        truth = arg1.Float() &lt; arg2.Float()</span>
                case intKind:<span class="cov8" title="1">
                        truth = arg1.Int() &lt; arg2.Int()</span>
                case stringKind:<span class="cov8" title="1">
                        truth = arg1.String() &lt; arg2.String()</span>
                case uintKind:<span class="cov8" title="1">
                        truth = arg1.Uint() &lt; arg2.Uint()</span>
                default:<span class="cov0" title="0">
                        panic("invalid kind")</span>
                }
        }
        <span class="cov8" title="1">return truth, nil</span>
}

// le evaluates the comparison &lt;= b.
func le(arg1, arg2 reflect.Value) (bool, error) <span class="cov8" title="1">{
        // &lt;= is &lt; or ==.
        lessThan, err := lt(arg1, arg2)
        if lessThan || err != nil </span><span class="cov8" title="1">{
                return lessThan, err
        }</span>
        <span class="cov8" title="1">return eq(arg1, arg2)</span>
}

// gt evaluates the comparison a &gt; b.
func gt(arg1, arg2 reflect.Value) (bool, error) <span class="cov8" title="1">{
        // &gt; is the inverse of &lt;=.
        lessOrEqual, err := le(arg1, arg2)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return !lessOrEqual, nil</span>
}

// ge evaluates the comparison a &gt;= b.
func ge(arg1, arg2 reflect.Value) (bool, error) <span class="cov8" title="1">{
        // &gt;= is the inverse of &lt;.
        lessThan, err := lt(arg1, arg2)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>
        <span class="cov8" title="1">return !lessThan, nil</span>
}

// HTML escaping.

var (
        htmlQuot = []byte("&amp;#34;") // shorter than "&amp;quot;"
        htmlApos = []byte("&amp;#39;") // shorter than "&amp;apos;" and apos was not in HTML until HTML5
        htmlAmp  = []byte("&amp;amp;")
        htmlLt   = []byte("&amp;lt;")
        htmlGt   = []byte("&amp;gt;")
        htmlNull = []byte("\uFFFD")
)

// HTMLEscape writes to w the escaped HTML equivalent of the plain text data b.
func HTMLEscape(w io.Writer, b []byte) <span class="cov8" title="1">{
        last := 0
        for i, c := range b </span><span class="cov8" title="1">{
                var html []byte
                switch c </span>{
                case '\000':<span class="cov0" title="0">
                        html = htmlNull</span>
                case '"':<span class="cov8" title="1">
                        html = htmlQuot</span>
                case '\'':<span class="cov0" title="0">
                        html = htmlApos</span>
                case '&amp;':<span class="cov0" title="0">
                        html = htmlAmp</span>
                case '&lt;':<span class="cov8" title="1">
                        html = htmlLt</span>
                case '&gt;':<span class="cov8" title="1">
                        html = htmlGt</span>
                default:<span class="cov8" title="1">
                        continue</span>
                }
                <span class="cov8" title="1">w.Write(b[last:i])
                w.Write(html)
                last = i + 1</span>
        }
        <span class="cov8" title="1">w.Write(b[last:])</span>
}

// HTMLEscapeString returns the escaped HTML equivalent of the plain text data s.
func HTMLEscapeString(s string) string <span class="cov8" title="1">{
        // Avoid allocation if we can.
        if !strings.ContainsAny(s, "'\"&amp;&lt;&gt;\000") </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">var b bytes.Buffer
        HTMLEscape(&amp;b, []byte(s))
        return b.String()</span>
}

// HTMLEscaper returns the escaped HTML equivalent of the textual
// representation of its arguments.
func HTMLEscaper(args ...interface{}) string <span class="cov8" title="1">{
        return HTMLEscapeString(evalArgs(args))
}</span>

// JavaScript escaping.

var (
        jsLowUni = []byte(`\u00`)
        hex      = []byte("0123456789ABCDEF")

        jsBackslash = []byte(`\\`)
        jsApos      = []byte(`\'`)
        jsQuot      = []byte(`\"`)
        jsLt        = []byte(`\u003C`)
        jsGt        = []byte(`\u003E`)
        jsAmp       = []byte(`\u0026`)
        jsEq        = []byte(`\u003D`)
)

// JSEscape writes to w the escaped JavaScript equivalent of the plain text data b.
func JSEscape(w io.Writer, b []byte) <span class="cov8" title="1">{
        last := 0
        for i := 0; i &lt; len(b); i++ </span><span class="cov8" title="1">{
                c := b[i]

                if !jsIsSpecial(rune(c)) </span><span class="cov8" title="1">{
                        // fast path: nothing to do
                        continue</span>
                }
                <span class="cov8" title="1">w.Write(b[last:i])

                if c &lt; utf8.RuneSelf </span><span class="cov8" title="1">{
                        // Quotes, slashes and angle brackets get quoted.
                        // Control characters get written as \u00XX.
                        switch c </span>{
                        case '\\':<span class="cov8" title="1">
                                w.Write(jsBackslash)</span>
                        case '\'':<span class="cov8" title="1">
                                w.Write(jsApos)</span>
                        case '"':<span class="cov8" title="1">
                                w.Write(jsQuot)</span>
                        case '&lt;':<span class="cov8" title="1">
                                w.Write(jsLt)</span>
                        case '&gt;':<span class="cov8" title="1">
                                w.Write(jsGt)</span>
                        case '&amp;':<span class="cov8" title="1">
                                w.Write(jsAmp)</span>
                        case '=':<span class="cov8" title="1">
                                w.Write(jsEq)</span>
                        default:<span class="cov0" title="0">
                                w.Write(jsLowUni)
                                t, b := c&gt;&gt;4, c&amp;0x0f
                                w.Write(hex[t : t+1])
                                w.Write(hex[b : b+1])</span>
                        }
                } else<span class="cov8" title="1"> {
                        // Unicode rune.
                        r, size := utf8.DecodeRune(b[i:])
                        if unicode.IsPrint(r) </span><span class="cov8" title="1">{
                                w.Write(b[i : i+size])
                        }</span> else<span class="cov8" title="1"> {
                                fmt.Fprintf(w, "\\u%04X", r)
                        }</span>
                        <span class="cov8" title="1">i += size - 1</span>
                }
                <span class="cov8" title="1">last = i + 1</span>
        }
        <span class="cov8" title="1">w.Write(b[last:])</span>
}

// JSEscapeString returns the escaped JavaScript equivalent of the plain text data s.
func JSEscapeString(s string) string <span class="cov8" title="1">{
        // Avoid allocation if we can.
        if strings.IndexFunc(s, jsIsSpecial) &lt; 0 </span><span class="cov8" title="1">{
                return s
        }</span>
        <span class="cov8" title="1">var b bytes.Buffer
        JSEscape(&amp;b, []byte(s))
        return b.String()</span>
}

func jsIsSpecial(r rune) bool <span class="cov8" title="1">{
        switch r </span>{
        case '\\', '\'', '"', '&lt;', '&gt;', '&amp;', '=':<span class="cov8" title="1">
                return true</span>
        }
        <span class="cov8" title="1">return r &lt; ' ' || utf8.RuneSelf &lt;= r</span>
}

// JSEscaper returns the escaped JavaScript equivalent of the textual
// representation of its arguments.
func JSEscaper(args ...interface{}) string <span class="cov8" title="1">{
        return JSEscapeString(evalArgs(args))
}</span>

// URLQueryEscaper returns the escaped value of the textual representation of
// its arguments in a form suitable for embedding in a URL query.
func URLQueryEscaper(args ...interface{}) string <span class="cov8" title="1">{
        return url.QueryEscape(evalArgs(args))
}</span>

// evalArgs formats the list of arguments into a string. It is therefore equivalent to
//        fmt.Sprint(args...)
// except that each argument is indirected (if a pointer), as required,
// using the same rules as the default string evaluation during template
// execution.
func evalArgs(args []interface{}) string <span class="cov8" title="1">{
        ok := false
        var s string
        // Fast path for simple common case.
        if len(args) == 1 </span><span class="cov8" title="1">{
                s, ok = args[0].(string)
        }</span>
        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                for i, arg := range args </span><span class="cov8" title="1">{
                        a, ok := printableValue(reflect.ValueOf(arg))
                        if ok </span><span class="cov8" title="1">{
                                args[i] = a
                        }</span> // else let fmt do its thing
                }
                <span class="cov8" title="1">s = fmt.Sprint(args...)</span>
        }
        <span class="cov8" title="1">return s</span>
}
</pre>
		
		<pre class="file" id="file318" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Helper functions to make constructing templates easier.

package template

import (
        "fmt"
        "io/fs"
        "os"
        "path"
        "path/filepath"
)

// Functions and methods to parse templates.

// Must is a helper that wraps a call to a function returning (*Template, error)
// and panics if the error is non-nil. It is intended for use in variable
// initializations such as
//        var t = template.Must(template.New("name").Parse("text"))
func Must(t *Template, err error) *Template <span class="cov8" title="1">{
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">return t</span>
}

// ParseFiles creates a new Template and parses the template definitions from
// the named files. The returned template's name will have the base name and
// parsed contents of the first file. There must be at least one file.
// If an error occurs, parsing stops and the returned *Template is nil.
//
// When parsing multiple files with the same name in different directories,
// the last one mentioned will be the one that results.
// For instance, ParseFiles("a/foo", "b/foo") stores "b/foo" as the template
// named "foo", while "a/foo" is unavailable.
func ParseFiles(filenames ...string) (*Template, error) <span class="cov8" title="1">{
        return parseFiles(nil, readFileOS, filenames...)
}</span>

// ParseFiles parses the named files and associates the resulting templates with
// t. If an error occurs, parsing stops and the returned template is nil;
// otherwise it is t. There must be at least one file.
// Since the templates created by ParseFiles are named by the base
// names of the argument files, t should usually have the name of one
// of the (base) names of the files. If it does not, depending on t's
// contents before calling ParseFiles, t.Execute may fail. In that
// case use t.ExecuteTemplate to execute a valid template.
//
// When parsing multiple files with the same name in different directories,
// the last one mentioned will be the one that results.
func (t *Template) ParseFiles(filenames ...string) (*Template, error) <span class="cov8" title="1">{
        t.init()
        return parseFiles(t, readFileOS, filenames...)
}</span>

// parseFiles is the helper for the method and function. If the argument
// template is nil, it is created from the first file.
func parseFiles(t *Template, readFile func(string) (string, []byte, error), filenames ...string) (*Template, error) <span class="cov8" title="1">{
        if len(filenames) == 0 </span><span class="cov0" title="0">{
                // Not really a problem, but be consistent.
                return nil, fmt.Errorf("template: no files named in call to ParseFiles")
        }</span>
        <span class="cov8" title="1">for _, filename := range filenames </span><span class="cov8" title="1">{
                name, b, err := readFile(filename)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">s := string(b)
                // First template becomes return value if not already defined,
                // and we use that one for subsequent New calls to associate
                // all the templates together. Also, if this file has the same name
                // as t, this file becomes the contents of t, so
                //  t, err := New(name).Funcs(xxx).ParseFiles(name)
                // works. Otherwise we create a new template associated with t.
                var tmpl *Template
                if t == nil </span><span class="cov0" title="0">{
                        t = New(name)
                }</span>
                <span class="cov8" title="1">if name == t.Name() </span><span class="cov0" title="0">{
                        tmpl = t
                }</span> else<span class="cov8" title="1"> {
                        tmpl = t.New(name)
                }</span>
                <span class="cov8" title="1">_, err = tmpl.Parse(s)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return t, nil</span>
}

// ParseGlob creates a new Template and parses the template definitions from
// the files identified by the pattern. The files are matched according to the
// semantics of filepath.Match, and the pattern must match at least one file.
// The returned template will have the (base) name and (parsed) contents of the
// first file matched by the pattern. ParseGlob is equivalent to calling
// ParseFiles with the list of files matched by the pattern.
//
// When parsing multiple files with the same name in different directories,
// the last one mentioned will be the one that results.
func ParseGlob(pattern string) (*Template, error) <span class="cov8" title="1">{
        return parseGlob(nil, pattern)
}</span>

// ParseGlob parses the template definitions in the files identified by the
// pattern and associates the resulting templates with t. The files are matched
// according to the semantics of filepath.Match, and the pattern must match at
// least one file. ParseGlob is equivalent to calling t.ParseFiles with the
// list of files matched by the pattern.
//
// When parsing multiple files with the same name in different directories,
// the last one mentioned will be the one that results.
func (t *Template) ParseGlob(pattern string) (*Template, error) <span class="cov8" title="1">{
        t.init()
        return parseGlob(t, pattern)
}</span>

// parseGlob is the implementation of the function and method ParseGlob.
func parseGlob(t *Template, pattern string) (*Template, error) <span class="cov8" title="1">{
        filenames, err := filepath.Glob(pattern)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        <span class="cov8" title="1">if len(filenames) == 0 </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("template: pattern matches no files: %#q", pattern)
        }</span>
        <span class="cov8" title="1">return parseFiles(t, readFileOS, filenames...)</span>
}

// ParseFS is like ParseFiles or ParseGlob but reads from the file system fsys
// instead of the host operating system's file system.
// It accepts a list of glob patterns.
// (Note that most file names serve as glob patterns matching only themselves.)
func ParseFS(fsys fs.FS, patterns ...string) (*Template, error) <span class="cov8" title="1">{
        return parseFS(nil, fsys, patterns)
}</span>

// ParseFS is like ParseFiles or ParseGlob but reads from the file system fsys
// instead of the host operating system's file system.
// It accepts a list of glob patterns.
// (Note that most file names serve as glob patterns matching only themselves.)
func (t *Template) ParseFS(fsys fs.FS, patterns ...string) (*Template, error) <span class="cov8" title="1">{
        t.init()
        return parseFS(t, fsys, patterns)
}</span>

func parseFS(t *Template, fsys fs.FS, patterns []string) (*Template, error) <span class="cov8" title="1">{
        var filenames []string
        for _, pattern := range patterns </span><span class="cov8" title="1">{
                list, err := fs.Glob(fsys, pattern)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if len(list) == 0 </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("template: pattern matches no files: %#q", pattern)
                }</span>
                <span class="cov8" title="1">filenames = append(filenames, list...)</span>
        }
        <span class="cov8" title="1">return parseFiles(t, readFileFS(fsys), filenames...)</span>
}

func readFileOS(file string) (name string, b []byte, err error) <span class="cov8" title="1">{
        name = filepath.Base(file)
        b, err = os.ReadFile(file)
        return
}</span>

func readFileFS(fsys fs.FS) func(string) (string, []byte, error) <span class="cov8" title="1">{
        return func(file string) (name string, b []byte, err error) </span><span class="cov8" title="1">{
                name = path.Base(file)
                b, err = fs.ReadFile(fsys, file)
                return
        }</span>
}
</pre>
		
		<pre class="file" id="file319" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package template

import (
        "io"
        "reflect"

        "github.com/gohugoio/hugo/common/hreflect"

        "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/parse"
)

/*

This files contains the Hugo related addons. All the other files in this
package is auto generated.

*/

// Export it so we can populate Hugo's func map with it, which makes it faster.
var GoFuncs = builtinFuncs()

// Preparer prepares the template before execution.
type Preparer interface {
        Prepare() (*Template, error)
}

// ExecHelper allows some custom eval hooks.
type ExecHelper interface {
        GetFunc(tmpl Preparer, name string) (reflect.Value, bool)
        GetMethod(tmpl Preparer, receiver reflect.Value, name string) (method reflect.Value, firstArg reflect.Value)
        GetMapValue(tmpl Preparer, receiver, key reflect.Value) (reflect.Value, bool)
}

// Executer executes a given template.
type Executer interface {
        Execute(p Preparer, wr io.Writer, data interface{}) error
}

type executer struct {
        helper ExecHelper
}

func NewExecuter(helper ExecHelper) Executer <span class="cov8" title="1">{
        return &amp;executer{helper: helper}
}</span>

func (t *executer) Execute(p Preparer, wr io.Writer, data interface{}) error <span class="cov8" title="1">{
        tmpl, err := p.Prepare()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">value, ok := data.(reflect.Value)
        if !ok </span><span class="cov8" title="1">{
                value = reflect.ValueOf(data)
        }</span>

        <span class="cov8" title="1">state := &amp;state{
                helper: t.helper,
                prep:   p,
                tmpl:   tmpl,
                wr:     wr,
                vars:   []variable{{"$", value}},
        }

        return tmpl.executeWithState(state, value)</span>

}

// Prepare returns a template ready for execution.
func (t *Template) Prepare() (*Template, error) <span class="cov8" title="1">{
        return t, nil
}</span>

func (t *Template) executeWithState(state *state, value reflect.Value) (err error) <span class="cov8" title="1">{
        defer errRecover(&amp;err)
        if t.Tree == nil || t.Root == nil </span><span class="cov0" title="0">{
                state.errorf("%q is an incomplete or empty template", t.Name())
        }</span>
        <span class="cov8" title="1">state.walk(value, t.Root)
        return</span>
}

// Below are modified structs etc. The changes are marked with "Added for Hugo."

// state represents the state of an execution. It's not part of the
// template so that multiple executions of the same template
// can execute in parallel.
type state struct {
        tmpl   *Template
        prep   Preparer   // Added for Hugo.
        helper ExecHelper // Added for Hugo.
        wr     io.Writer
        node   parse.Node // current node, for errors
        vars   []variable // push-down stack of variable values.
        depth  int        // the height of the stack of executing templates.
}

func (s *state) evalFunction(dot reflect.Value, node *parse.IdentifierNode, cmd parse.Node, args []parse.Node, final reflect.Value) reflect.Value <span class="cov8" title="1">{
        s.at(node)
        name := node.Ident

        var function reflect.Value
        var ok bool
        if s.helper != nil </span><span class="cov8" title="1">{
                // Added for Hugo.
                function, ok = s.helper.GetFunc(s.prep, name)
        }</span>

        <span class="cov8" title="1">if !ok </span><span class="cov8" title="1">{
                function, ok = findFunction(name, s.tmpl)
        }</span>

        <span class="cov8" title="1">if !ok </span><span class="cov0" title="0">{
                s.errorf("%q is not a defined function", name)
        }</span>
        <span class="cov8" title="1">return s.evalCall(dot, function, cmd, name, args, final)</span>
}

// evalField evaluates an expression like (.Field) or (.Field arg1 arg2).
// The 'final' argument represents the return value from the preceding
// value of the pipeline, if any.
func (s *state) evalField(dot reflect.Value, fieldName string, node parse.Node, args []parse.Node, final, receiver reflect.Value) reflect.Value <span class="cov8" title="1">{
        if !receiver.IsValid() </span><span class="cov8" title="1">{
                if s.tmpl.option.missingKey == mapError </span><span class="cov8" title="1">{ // Treat invalid value as missing map key.
                        s.errorf("nil data; no entry for key %q", fieldName)
                }</span>
                <span class="cov8" title="1">return zero</span>
        }
        <span class="cov8" title="1">typ := receiver.Type()
        receiver, isNil := indirect(receiver)
        if receiver.Kind() == reflect.Interface &amp;&amp; isNil </span><span class="cov8" title="1">{
                // Calling a method on a nil interface can't work. The
                // MethodByName method call below would panic.
                s.errorf("nil pointer evaluating %s.%s", typ, fieldName)
                return zero
        }</span>

        // Unless it's an interface, need to get to a value of type *T to guarantee
        // we see all methods of T and *T.
        <span class="cov8" title="1">ptr := receiver
        if ptr.Kind() != reflect.Interface &amp;&amp; ptr.Kind() != reflect.Ptr &amp;&amp; ptr.CanAddr() </span><span class="cov8" title="1">{
                ptr = ptr.Addr()
        }</span>
        // Added for Hugo.
        <span class="cov8" title="1">var first reflect.Value
        var method reflect.Value
        if s.helper != nil </span><span class="cov8" title="1">{
                method, first = s.helper.GetMethod(s.prep, ptr, fieldName)
        }</span> else<span class="cov8" title="1"> {
                method = ptr.MethodByName(fieldName)
        }</span>

        <span class="cov8" title="1">if method.IsValid() </span><span class="cov8" title="1">{
                if first != zero </span><span class="cov8" title="1">{
                        return s.evalCall(dot, method, node, fieldName, args, final, first)
                }</span>

                <span class="cov8" title="1">return s.evalCall(dot, method, node, fieldName, args, final)</span>
        }

        <span class="cov8" title="1">hasArgs := len(args) &gt; 1 || final != missingVal
        // It's not a method; must be a field of a struct or an element of a map.
        switch receiver.Kind() </span>{
        case reflect.Struct:<span class="cov8" title="1">
                tField, ok := receiver.Type().FieldByName(fieldName)
                if ok </span><span class="cov8" title="1">{
                        field := receiver.FieldByIndex(tField.Index)
                        if tField.PkgPath != "" </span><span class="cov8" title="1">{ // field is unexported
                                s.errorf("%s is an unexported field of struct type %s", fieldName, typ)
                        }</span>
                        // If it's a function, we must call it.
                        <span class="cov8" title="1">if hasArgs </span><span class="cov8" title="1">{
                                s.errorf("%s has arguments but cannot be invoked as function", fieldName)
                        }</span>
                        <span class="cov8" title="1">return field</span>
                }
        case reflect.Map:<span class="cov8" title="1">
                // If it's a map, attempt to use the field name as a key.
                nameVal := reflect.ValueOf(fieldName)
                if nameVal.Type().AssignableTo(receiver.Type().Key()) </span><span class="cov8" title="1">{
                        if hasArgs </span><span class="cov8" title="1">{
                                s.errorf("%s is not a method but has arguments", fieldName)
                        }</span>
                        <span class="cov8" title="1">var result reflect.Value
                        if s.helper != nil </span><span class="cov8" title="1">{
                                // Added for Hugo.
                                result, _ = s.helper.GetMapValue(s.prep, receiver, nameVal)
                        }</span> else<span class="cov8" title="1"> {
                                result = receiver.MapIndex(nameVal)
                        }</span>
                        <span class="cov8" title="1">if !result.IsValid() </span><span class="cov8" title="1">{
                                switch s.tmpl.option.missingKey </span>{
                                case mapInvalid:<span class="cov8" title="1"></span>
                                        // Just use the invalid value.
                                case mapZeroValue:<span class="cov8" title="1">
                                        result = reflect.Zero(receiver.Type().Elem())</span>
                                case mapError:<span class="cov8" title="1">
                                        s.errorf("map has no entry for key %q", fieldName)</span>
                                }
                        }
                        <span class="cov8" title="1">return result</span>
                }
        case reflect.Ptr:<span class="cov8" title="1">
                etyp := receiver.Type().Elem()
                if etyp.Kind() == reflect.Struct </span><span class="cov8" title="1">{
                        if _, ok := etyp.FieldByName(fieldName); !ok </span><span class="cov8" title="1">{
                                // If there's no such field, say "can't evaluate"
                                // instead of "nil pointer evaluating".
                                break</span>
                        }
                }
                <span class="cov8" title="1">if isNil </span><span class="cov8" title="1">{
                        s.errorf("nil pointer evaluating %s.%s", typ, fieldName)
                }</span>
        }
        <span class="cov8" title="1">s.errorf("can't evaluate field %s in type %s", fieldName, typ)
        panic("not reached")</span>
}

// evalCall executes a function or method call. If it's a method, fun already has the receiver bound, so
// it looks just like a function call. The arg list, if non-nil, includes (in the manner of the shell), arg[0]
// as the function itself.
func (s *state) evalCall(dot, fun reflect.Value, node parse.Node, name string, args []parse.Node, final reflect.Value, first ...reflect.Value) reflect.Value <span class="cov8" title="1">{
        if args != nil </span><span class="cov8" title="1">{
                args = args[1:] // Zeroth arg is function name/node; not passed to function.
        }</span>
        <span class="cov8" title="1">typ := fun.Type()
        numFirst := len(first)
        numIn := len(args) + numFirst // // Added for Hugo
        if final != missingVal </span><span class="cov8" title="1">{
                numIn++
        }</span>
        <span class="cov8" title="1">numFixed := len(args) + len(first)
        if typ.IsVariadic() </span><span class="cov8" title="1">{
                numFixed = typ.NumIn() - 1 // last arg is the variadic one.
                if numIn &lt; numFixed </span><span class="cov0" title="0">{
                        s.errorf("wrong number of args for %s: want at least %d got %d", name, typ.NumIn()-1, len(args))
                }</span>
        } else<span class="cov8" title="1"> if numIn != typ.NumIn() </span><span class="cov0" title="0">{
                s.errorf("wrong number of args for %s: want %d got %d", name, typ.NumIn(), numIn)
        }</span>
        <span class="cov8" title="1">if !goodFunc(typ) </span><span class="cov0" title="0">{
                // TODO: This could still be a confusing error; maybe goodFunc should provide info.
                s.errorf("can't call method/function %q with %d results", name, typ.NumOut())
        }</span>
        // Build the arg list.
        <span class="cov8" title="1">argv := make([]reflect.Value, numIn)
        // Args must be evaluated. Fixed args first.
        i := len(first)
        for ; i &lt; numFixed &amp;&amp; i &lt; len(args)+numFirst; i++ </span><span class="cov8" title="1">{
                argv[i] = s.evalArg(dot, typ.In(i), args[i-numFirst])
        }</span>
        // Now the ... args.
        <span class="cov8" title="1">if typ.IsVariadic() </span><span class="cov8" title="1">{
                argType := typ.In(typ.NumIn() - 1).Elem() // Argument is a slice.
                for ; i &lt; len(args)+numFirst; i++ </span><span class="cov8" title="1">{
                        argv[i] = s.evalArg(dot, argType, args[i-numFirst])
                }</span>

        }
        // Add final value if necessary.
        <span class="cov8" title="1">if final != missingVal </span><span class="cov8" title="1">{
                t := typ.In(typ.NumIn() - 1)
                if typ.IsVariadic() </span><span class="cov8" title="1">{
                        if numIn-1 &lt; numFixed </span><span class="cov8" title="1">{
                                // The added final argument corresponds to a fixed parameter of the function.
                                // Validate against the type of the actual parameter.
                                t = typ.In(numIn - 1)
                        }</span> else<span class="cov8" title="1"> {
                                // The added final argument corresponds to the variadic part.
                                // Validate against the type of the elements of the variadic slice.
                                t = t.Elem()
                        }</span>
                }
                <span class="cov8" title="1">argv[i] = s.validateType(final, t)</span>
        }

        // Added for Hugo
        <span class="cov8" title="1">for i := 0; i &lt; len(first); i++ </span><span class="cov8" title="1">{
                argv[i] = s.validateType(first[i], typ.In(i))
        }</span>

        <span class="cov8" title="1">v, err := safeCall(fun, argv)
        // If we have an error that is not nil, stop execution and return that
        // error to the caller.
        if err != nil </span><span class="cov8" title="1">{
                s.at(node)
                s.errorf("error calling %s: %v", name, err)
        }</span>
        <span class="cov8" title="1">if v.Type() == reflectValueType </span><span class="cov8" title="1">{
                v = v.Interface().(reflect.Value)
        }</span>
        <span class="cov8" title="1">return v</span>
}

func isTrue(val reflect.Value) (truth, ok bool) <span class="cov8" title="1">{
        return hreflect.IsTruthfulValue(val), true
}</span>
</pre>
		
		<pre class="file" id="file320" style="display: none">// Copyright 2015 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// This file contains the code to handle template options.

package template

import "strings"

// missingKeyAction defines how to respond to indexing a map with a key that is not present.
type missingKeyAction int

const (
        mapInvalid   missingKeyAction = iota // Return an invalid reflect.Value.
        mapZeroValue                         // Return the zero value for the map element.
        mapError                             // Error out
)

type option struct {
        missingKey missingKeyAction
}

// Option sets options for the template. Options are described by
// strings, either a simple string or "key=value". There can be at
// most one equals sign in an option string. If the option string
// is unrecognized or otherwise invalid, Option panics.
//
// Known options:
//
// missingkey: Control the behavior during execution if a map is
// indexed with a key that is not present in the map.
//        "missingkey=default" or "missingkey=invalid"
//                The default behavior: Do nothing and continue execution.
//                If printed, the result of the index operation is the string
//                "&lt;no value&gt;".
//        "missingkey=zero"
//                The operation returns the zero value for the map type's element.
//        "missingkey=error"
//                Execution stops immediately with an error.
//
func (t *Template) Option(opt ...string) *Template <span class="cov8" title="1">{
        t.init()
        for _, s := range opt </span><span class="cov8" title="1">{
                t.setOption(s)
        }</span>
        <span class="cov8" title="1">return t</span>
}

func (t *Template) setOption(opt string) <span class="cov8" title="1">{
        if opt == "" </span><span class="cov0" title="0">{
                panic("empty option string")</span>
        }
        <span class="cov8" title="1">elems := strings.Split(opt, "=")
        switch len(elems) </span>{
        case 2:<span class="cov8" title="1">
                // key=value
                switch elems[0] </span>{
                case "missingkey":<span class="cov8" title="1">
                        switch elems[1] </span>{
                        case "invalid", "default":<span class="cov8" title="1">
                                t.option.missingKey = mapInvalid
                                return</span>
                        case "zero":<span class="cov8" title="1">
                                t.option.missingKey = mapZeroValue
                                return</span>
                        case "error":<span class="cov8" title="1">
                                t.option.missingKey = mapError
                                return</span>
                        }
                }
        }
        <span class="cov0" title="0">panic("unrecognized option: " + opt)</span>
}
</pre>
		
		<pre class="file" id="file321" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package parse

import (
        "fmt"
        "strings"
        "unicode"
        "unicode/utf8"
)

// item represents a token or text string returned from the scanner.
type item struct {
        typ  itemType // The type of this item.
        pos  Pos      // The starting position, in bytes, of this item in the input string.
        val  string   // The value of this item.
        line int      // The line number at the start of this item.
}

func (i item) String() string <span class="cov8" title="1">{
        switch </span>{
        case i.typ == itemEOF:<span class="cov0" title="0">
                return "EOF"</span>
        case i.typ == itemError:<span class="cov8" title="1">
                return i.val</span>
        case i.typ &gt; itemKeyword:<span class="cov8" title="1">
                return fmt.Sprintf("&lt;%s&gt;", i.val)</span>
        case len(i.val) &gt; 10:<span class="cov0" title="0">
                return fmt.Sprintf("%.10q...", i.val)</span>
        }
        <span class="cov8" title="1">return fmt.Sprintf("%q", i.val)</span>
}

// itemType identifies the type of lex items.
type itemType int

const (
        itemError        itemType = iota // error occurred; value is text of error
        itemBool                         // boolean constant
        itemChar                         // printable ASCII character; grab bag for comma etc.
        itemCharConstant                 // character constant
        itemComment                      // comment text
        itemComplex                      // complex constant (1+2i); imaginary is just a number
        itemAssign                       // equals ('=') introducing an assignment
        itemDeclare                      // colon-equals (':=') introducing a declaration
        itemEOF
        itemField      // alphanumeric identifier starting with '.'
        itemIdentifier // alphanumeric identifier not starting with '.'
        itemLeftDelim  // left action delimiter
        itemLeftParen  // '(' inside action
        itemNumber     // simple number, including imaginary
        itemPipe       // pipe symbol
        itemRawString  // raw quoted string (includes quotes)
        itemRightDelim // right action delimiter
        itemRightParen // ')' inside action
        itemSpace      // run of spaces separating arguments
        itemString     // quoted string (includes quotes)
        itemText       // plain text
        itemVariable   // variable starting with '$', such as '$' or  '$1' or '$hello'
        // Keywords appear after all the rest.
        itemKeyword  // used only to delimit the keywords
        itemBlock    // block keyword
        itemDot      // the cursor, spelled '.'
        itemDefine   // define keyword
        itemElse     // else keyword
        itemEnd      // end keyword
        itemIf       // if keyword
        itemNil      // the untyped nil constant, easiest to treat as a keyword
        itemRange    // range keyword
        itemTemplate // template keyword
        itemWith     // with keyword
)

var key = map[string]itemType{
        ".":        itemDot,
        "block":    itemBlock,
        "define":   itemDefine,
        "else":     itemElse,
        "end":      itemEnd,
        "if":       itemIf,
        "range":    itemRange,
        "nil":      itemNil,
        "template": itemTemplate,
        "with":     itemWith,
}

const eof = -1

// Trimming spaces.
// If the action begins "{{- " rather than "{{", then all space/tab/newlines
// preceding the action are trimmed; conversely if it ends " -}}" the
// leading spaces are trimmed. This is done entirely in the lexer; the
// parser never sees it happen. We require an ASCII space (' ', \t, \r, \n)
// to be present to avoid ambiguity with things like "{{-3}}". It reads
// better with the space present anyway. For simplicity, only ASCII
// does the job.
const (
        spaceChars    = " \t\r\n"  // These are the space characters defined by Go itself.
        trimMarker    = '-'        // Attached to left/right delimiter, trims trailing spaces from preceding/following text.
        trimMarkerLen = Pos(1 + 1) // marker plus space before or after
)

// stateFn represents the state of the scanner as a function that returns the next state.
type stateFn func(*lexer) stateFn

// lexer holds the state of the scanner.
type lexer struct {
        name        string    // the name of the input; used only for error reports
        input       string    // the string being scanned
        leftDelim   string    // start of action
        rightDelim  string    // end of action
        emitComment bool      // emit itemComment tokens.
        pos         Pos       // current position in the input
        start       Pos       // start position of this item
        width       Pos       // width of last rune read from input
        items       chan item // channel of scanned items
        parenDepth  int       // nesting depth of ( ) exprs
        line        int       // 1+number of newlines seen
        startLine   int       // start line of this item
}

// next returns the next rune in the input.
func (l *lexer) next() rune <span class="cov8" title="1">{
        if int(l.pos) &gt;= len(l.input) </span><span class="cov8" title="1">{
                l.width = 0
                return eof
        }</span>
        <span class="cov8" title="1">r, w := utf8.DecodeRuneInString(l.input[l.pos:])
        l.width = Pos(w)
        l.pos += l.width
        if r == '\n' </span><span class="cov8" title="1">{
                l.line++
        }</span>
        <span class="cov8" title="1">return r</span>
}

// peek returns but does not consume the next rune in the input.
func (l *lexer) peek() rune <span class="cov8" title="1">{
        r := l.next()
        l.backup()
        return r
}</span>

// backup steps back one rune. Can only be called once per call of next.
func (l *lexer) backup() <span class="cov8" title="1">{
        l.pos -= l.width
        // Correct newline count.
        if l.width == 1 &amp;&amp; l.input[l.pos] == '\n' </span><span class="cov8" title="1">{
                l.line--
        }</span>
}

// emit passes an item back to the client.
func (l *lexer) emit(t itemType) <span class="cov8" title="1">{
        l.items &lt;- item{t, l.start, l.input[l.start:l.pos], l.startLine}
        l.start = l.pos
        l.startLine = l.line
}</span>

// ignore skips over the pending input before this point.
func (l *lexer) ignore() <span class="cov8" title="1">{
        l.line += strings.Count(l.input[l.start:l.pos], "\n")
        l.start = l.pos
        l.startLine = l.line
}</span>

// accept consumes the next rune if it's from the valid set.
func (l *lexer) accept(valid string) bool <span class="cov8" title="1">{
        if strings.ContainsRune(valid, l.next()) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">l.backup()
        return false</span>
}

// acceptRun consumes a run of runes from the valid set.
func (l *lexer) acceptRun(valid string) <span class="cov8" title="1">{
        for strings.ContainsRune(valid, l.next()) </span>{<span class="cov8" title="1">
        }</span>
        <span class="cov8" title="1">l.backup()</span>
}

// errorf returns an error token and terminates the scan by passing
// back a nil pointer that will be the next state, terminating l.nextItem.
func (l *lexer) errorf(format string, args ...interface{}) stateFn <span class="cov8" title="1">{
        l.items &lt;- item{itemError, l.start, fmt.Sprintf(format, args...), l.startLine}
        return nil
}</span>

// nextItem returns the next item from the input.
// Called by the parser, not in the lexing goroutine.
func (l *lexer) nextItem() item <span class="cov8" title="1">{
        return &lt;-l.items
}</span>

// drain drains the output so the lexing goroutine will exit.
// Called by the parser, not in the lexing goroutine.
func (l *lexer) drain() <span class="cov8" title="1">{
        for range l.items </span>{<span class="cov8" title="1">
        }</span>
}

// lex creates a new scanner for the input string.
func lex(name, input, left, right string, emitComment bool) *lexer <span class="cov8" title="1">{
        if left == "" </span><span class="cov8" title="1">{
                left = leftDelim
        }</span>
        <span class="cov8" title="1">if right == "" </span><span class="cov8" title="1">{
                right = rightDelim
        }</span>
        <span class="cov8" title="1">l := &amp;lexer{
                name:        name,
                input:       input,
                leftDelim:   left,
                rightDelim:  right,
                emitComment: emitComment,
                items:       make(chan item),
                line:        1,
                startLine:   1,
        }
        go l.run()
        return l</span>
}

// run runs the state machine for the lexer.
func (l *lexer) run() <span class="cov8" title="1">{
        for state := lexText; state != nil; </span><span class="cov8" title="1">{
                state = state(l)
        }</span>
        <span class="cov8" title="1">close(l.items)</span>
}

// state functions

const (
        leftDelim    = "{{"
        rightDelim   = "}}"
        leftComment  = "/*"
        rightComment = "*/"
)

// lexText scans until an opening action delimiter, "{{".
func lexText(l *lexer) stateFn <span class="cov8" title="1">{
        l.width = 0
        if x := strings.Index(l.input[l.pos:], l.leftDelim); x &gt;= 0 </span><span class="cov8" title="1">{
                ldn := Pos(len(l.leftDelim))
                l.pos += Pos(x)
                trimLength := Pos(0)
                if hasLeftTrimMarker(l.input[l.pos+ldn:]) </span><span class="cov8" title="1">{
                        trimLength = rightTrimLength(l.input[l.start:l.pos])
                }</span>
                <span class="cov8" title="1">l.pos -= trimLength
                if l.pos &gt; l.start </span><span class="cov8" title="1">{
                        l.line += strings.Count(l.input[l.start:l.pos], "\n")
                        l.emit(itemText)
                }</span>
                <span class="cov8" title="1">l.pos += trimLength
                l.ignore()
                return lexLeftDelim</span>
        }
        <span class="cov8" title="1">l.pos = Pos(len(l.input))
        // Correctly reached EOF.
        if l.pos &gt; l.start </span><span class="cov8" title="1">{
                l.line += strings.Count(l.input[l.start:l.pos], "\n")
                l.emit(itemText)
        }</span>
        <span class="cov8" title="1">l.emit(itemEOF)
        return nil</span>
}

// rightTrimLength returns the length of the spaces at the end of the string.
func rightTrimLength(s string) Pos <span class="cov8" title="1">{
        return Pos(len(s) - len(strings.TrimRight(s, spaceChars)))
}</span>

// atRightDelim reports whether the lexer is at a right delimiter, possibly preceded by a trim marker.
func (l *lexer) atRightDelim() (delim, trimSpaces bool) <span class="cov8" title="1">{
        if hasRightTrimMarker(l.input[l.pos:]) &amp;&amp; strings.HasPrefix(l.input[l.pos+trimMarkerLen:], l.rightDelim) </span><span class="cov8" title="1">{ // With trim marker.
                return true, true
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(l.input[l.pos:], l.rightDelim) </span><span class="cov8" title="1">{ // Without trim marker.
                return true, false
        }</span>
        <span class="cov8" title="1">return false, false</span>
}

// leftTrimLength returns the length of the spaces at the beginning of the string.
func leftTrimLength(s string) Pos <span class="cov8" title="1">{
        return Pos(len(s) - len(strings.TrimLeft(s, spaceChars)))
}</span>

// lexLeftDelim scans the left delimiter, which is known to be present, possibly with a trim marker.
func lexLeftDelim(l *lexer) stateFn <span class="cov8" title="1">{
        l.pos += Pos(len(l.leftDelim))
        trimSpace := hasLeftTrimMarker(l.input[l.pos:])
        afterMarker := Pos(0)
        if trimSpace </span><span class="cov8" title="1">{
                afterMarker = trimMarkerLen
        }</span>
        <span class="cov8" title="1">if strings.HasPrefix(l.input[l.pos+afterMarker:], leftComment) </span><span class="cov8" title="1">{
                l.pos += afterMarker
                l.ignore()
                return lexComment
        }</span>
        <span class="cov8" title="1">l.emit(itemLeftDelim)
        l.pos += afterMarker
        l.ignore()
        l.parenDepth = 0
        return lexInsideAction</span>
}

// lexComment scans a comment. The left comment marker is known to be present.
func lexComment(l *lexer) stateFn <span class="cov8" title="1">{
        l.pos += Pos(len(leftComment))
        i := strings.Index(l.input[l.pos:], rightComment)
        if i &lt; 0 </span><span class="cov8" title="1">{
                return l.errorf("unclosed comment")
        }</span>
        <span class="cov8" title="1">l.pos += Pos(i + len(rightComment))
        delim, trimSpace := l.atRightDelim()
        if !delim </span><span class="cov8" title="1">{
                return l.errorf("comment ends before closing delimiter")
        }</span>
        <span class="cov8" title="1">if l.emitComment </span><span class="cov8" title="1">{
                l.emit(itemComment)
        }</span>
        <span class="cov8" title="1">if trimSpace </span><span class="cov8" title="1">{
                l.pos += trimMarkerLen
        }</span>
        <span class="cov8" title="1">l.pos += Pos(len(l.rightDelim))
        if trimSpace </span><span class="cov8" title="1">{
                l.pos += leftTrimLength(l.input[l.pos:])
        }</span>
        <span class="cov8" title="1">l.ignore()
        return lexText</span>
}

// lexRightDelim scans the right delimiter, which is known to be present, possibly with a trim marker.
func lexRightDelim(l *lexer) stateFn <span class="cov8" title="1">{
        trimSpace := hasRightTrimMarker(l.input[l.pos:])
        if trimSpace </span><span class="cov8" title="1">{
                l.pos += trimMarkerLen
                l.ignore()
        }</span>
        <span class="cov8" title="1">l.pos += Pos(len(l.rightDelim))
        l.emit(itemRightDelim)
        if trimSpace </span><span class="cov8" title="1">{
                l.pos += leftTrimLength(l.input[l.pos:])
                l.ignore()
        }</span>
        <span class="cov8" title="1">return lexText</span>
}

// lexInsideAction scans the elements inside action delimiters.
func lexInsideAction(l *lexer) stateFn <span class="cov8" title="1">{
        // Either number, quoted string, or identifier.
        // Spaces separate arguments; runs of spaces turn into itemSpace.
        // Pipe symbols separate and are emitted.
        delim, _ := l.atRightDelim()
        if delim </span><span class="cov8" title="1">{
                if l.parenDepth == 0 </span><span class="cov8" title="1">{
                        return lexRightDelim
                }</span>
                <span class="cov8" title="1">return l.errorf("unclosed left paren")</span>
        }
        <span class="cov8" title="1">switch r := l.next(); </span>{
        case r == eof:<span class="cov8" title="1">
                return l.errorf("unclosed action")</span>
        case isSpace(r):<span class="cov8" title="1">
                l.backup() // Put space back in case we have " -}}".
                return lexSpace</span>
        case r == '=':<span class="cov8" title="1">
                l.emit(itemAssign)</span>
        case r == ':':<span class="cov8" title="1">
                if l.next() != '=' </span><span class="cov0" title="0">{
                        return l.errorf("expected :=")
                }</span>
                <span class="cov8" title="1">l.emit(itemDeclare)</span>
        case r == '|':<span class="cov8" title="1">
                l.emit(itemPipe)</span>
        case r == '"':<span class="cov8" title="1">
                return lexQuote</span>
        case r == '`':<span class="cov8" title="1">
                return lexRawQuote</span>
        case r == '$':<span class="cov8" title="1">
                return lexVariable</span>
        case r == '\'':<span class="cov8" title="1">
                return lexChar</span>
        case r == '.':<span class="cov8" title="1">
                // special look-ahead for ".field" so we don't break l.backup().
                if l.pos &lt; Pos(len(l.input)) </span><span class="cov8" title="1">{
                        r := l.input[l.pos]
                        if r &lt; '0' || '9' &lt; r </span><span class="cov8" title="1">{
                                return lexField
                        }</span>
                }
                <span class="cov8" title="1">fallthrough</span> // '.' can start a number.
        case r == '+' || r == '-' || ('0' &lt;= r &amp;&amp; r &lt;= '9'):<span class="cov8" title="1">
                l.backup()
                return lexNumber</span>
        case isAlphaNumeric(r):<span class="cov8" title="1">
                l.backup()
                return lexIdentifier</span>
        case r == '(':<span class="cov8" title="1">
                l.emit(itemLeftParen)
                l.parenDepth++</span>
        case r == ')':<span class="cov8" title="1">
                l.emit(itemRightParen)
                l.parenDepth--
                if l.parenDepth &lt; 0 </span><span class="cov8" title="1">{
                        return l.errorf("unexpected right paren %#U", r)
                }</span>
        case r &lt;= unicode.MaxASCII &amp;&amp; unicode.IsPrint(r):<span class="cov8" title="1">
                l.emit(itemChar)</span>
        default:<span class="cov8" title="1">
                return l.errorf("unrecognized character in action: %#U", r)</span>
        }
        <span class="cov8" title="1">return lexInsideAction</span>
}

// lexSpace scans a run of space characters.
// We have not consumed the first space, which is known to be present.
// Take care if there is a trim-marked right delimiter, which starts with a space.
func lexSpace(l *lexer) stateFn <span class="cov8" title="1">{
        var r rune
        var numSpaces int
        for </span><span class="cov8" title="1">{
                r = l.peek()
                if !isSpace(r) </span><span class="cov8" title="1">{
                        break</span>
                }
                <span class="cov8" title="1">l.next()
                numSpaces++</span>
        }
        // Be careful about a trim-marked closing delimiter, which has a minus
        // after a space. We know there is a space, so check for the '-' that might follow.
        <span class="cov8" title="1">if hasRightTrimMarker(l.input[l.pos-1:]) &amp;&amp; strings.HasPrefix(l.input[l.pos-1+trimMarkerLen:], l.rightDelim) </span><span class="cov8" title="1">{
                l.backup() // Before the space.
                if numSpaces == 1 </span><span class="cov0" title="0">{
                        return lexRightDelim // On the delim, so go right to that.
                }</span>
        }
        <span class="cov8" title="1">l.emit(itemSpace)
        return lexInsideAction</span>
}

// lexIdentifier scans an alphanumeric.
func lexIdentifier(l *lexer) stateFn <span class="cov8" title="1">{
Loop:
        for </span><span class="cov8" title="1">{
                switch r := l.next(); </span>{
                case isAlphaNumeric(r):<span class="cov8" title="1"></span>
                        // absorb.
                default:<span class="cov8" title="1">
                        l.backup()
                        word := l.input[l.start:l.pos]
                        if !l.atTerminator() </span><span class="cov8" title="1">{
                                return l.errorf("bad character %#U", r)
                        }</span>
                        <span class="cov8" title="1">switch </span>{
                        case key[word] &gt; itemKeyword:<span class="cov8" title="1">
                                l.emit(key[word])</span>
                        case word[0] == '.':<span class="cov0" title="0">
                                l.emit(itemField)</span>
                        case word == "true", word == "false":<span class="cov8" title="1">
                                l.emit(itemBool)</span>
                        default:<span class="cov8" title="1">
                                l.emit(itemIdentifier)</span>
                        }
                        <span class="cov8" title="1">break Loop</span>
                }
        }
        <span class="cov8" title="1">return lexInsideAction</span>
}

// lexField scans a field: .Alphanumeric.
// The . has been scanned.
func lexField(l *lexer) stateFn <span class="cov8" title="1">{
        return lexFieldOrVariable(l, itemField)
}</span>

// lexVariable scans a Variable: $Alphanumeric.
// The $ has been scanned.
func lexVariable(l *lexer) stateFn <span class="cov8" title="1">{
        if l.atTerminator() </span><span class="cov8" title="1">{ // Nothing interesting follows -&gt; "$".
                l.emit(itemVariable)
                return lexInsideAction
        }</span>
        <span class="cov8" title="1">return lexFieldOrVariable(l, itemVariable)</span>
}

// lexVariable scans a field or variable: [.$]Alphanumeric.
// The . or $ has been scanned.
func lexFieldOrVariable(l *lexer, typ itemType) stateFn <span class="cov8" title="1">{
        if l.atTerminator() </span><span class="cov8" title="1">{ // Nothing interesting follows -&gt; "." or "$".
                if typ == itemVariable </span><span class="cov0" title="0">{
                        l.emit(itemVariable)
                }</span> else<span class="cov8" title="1"> {
                        l.emit(itemDot)
                }</span>
                <span class="cov8" title="1">return lexInsideAction</span>
        }
        <span class="cov8" title="1">var r rune
        for </span><span class="cov8" title="1">{
                r = l.next()
                if !isAlphaNumeric(r) </span><span class="cov8" title="1">{
                        l.backup()
                        break</span>
                }
        }
        <span class="cov8" title="1">if !l.atTerminator() </span><span class="cov8" title="1">{
                return l.errorf("bad character %#U", r)
        }</span>
        <span class="cov8" title="1">l.emit(typ)
        return lexInsideAction</span>
}

// atTerminator reports whether the input is at valid termination character to
// appear after an identifier. Breaks .X.Y into two pieces. Also catches cases
// like "$x+2" not being acceptable without a space, in case we decide one
// day to implement arithmetic.
func (l *lexer) atTerminator() bool <span class="cov8" title="1">{
        r := l.peek()
        if isSpace(r) </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">switch r </span>{
        case eof, '.', ',', '|', ':', ')', '(':<span class="cov8" title="1">
                return true</span>
        }
        // Does r start the delimiter? This can be ambiguous (with delim=="//", $x/2 will
        // succeed but should fail) but only in extremely rare cases caused by willfully
        // bad choice of delimiter.
        <span class="cov8" title="1">if rd, _ := utf8.DecodeRuneInString(l.rightDelim); rd == r </span><span class="cov8" title="1">{
                return true
        }</span>
        <span class="cov8" title="1">return false</span>
}

// lexChar scans a character constant. The initial quote is already
// scanned. Syntax checking is done by the parser.
func lexChar(l *lexer) stateFn <span class="cov8" title="1">{
Loop:
        for </span><span class="cov8" title="1">{
                switch l.next() </span>{
                case '\\':<span class="cov8" title="1">
                        if r := l.next(); r != eof &amp;&amp; r != '\n' </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">fallthrough</span>
                case eof, '\n':<span class="cov8" title="1">
                        return l.errorf("unterminated character constant")</span>
                case '\'':<span class="cov8" title="1">
                        break Loop</span>
                }
        }
        <span class="cov8" title="1">l.emit(itemCharConstant)
        return lexInsideAction</span>
}

// lexNumber scans a number: decimal, octal, hex, float, or imaginary. This
// isn't a perfect number scanner - for instance it accepts "." and "0x0.2"
// and "089" - but when it's wrong the input is invalid and the parser (via
// strconv) will notice.
func lexNumber(l *lexer) stateFn <span class="cov8" title="1">{
        if !l.scanNumber() </span><span class="cov8" title="1">{
                return l.errorf("bad number syntax: %q", l.input[l.start:l.pos])
        }</span>
        <span class="cov8" title="1">if sign := l.peek(); sign == '+' || sign == '-' </span><span class="cov8" title="1">{
                // Complex: 1+2i. No spaces, must end in 'i'.
                if !l.scanNumber() || l.input[l.pos-1] != 'i' </span><span class="cov0" title="0">{
                        return l.errorf("bad number syntax: %q", l.input[l.start:l.pos])
                }</span>
                <span class="cov8" title="1">l.emit(itemComplex)</span>
        } else<span class="cov8" title="1"> {
                l.emit(itemNumber)
        }</span>
        <span class="cov8" title="1">return lexInsideAction</span>
}

func (l *lexer) scanNumber() bool <span class="cov8" title="1">{
        // Optional leading sign.
        l.accept("+-")
        // Is it hex?
        digits := "0123456789_"
        if l.accept("0") </span><span class="cov8" title="1">{
                // Note: Leading 0 does not mean octal in floats.
                if l.accept("xX") </span><span class="cov8" title="1">{
                        digits = "0123456789abcdefABCDEF_"
                }</span> else<span class="cov8" title="1"> if l.accept("oO") </span><span class="cov0" title="0">{
                        digits = "01234567_"
                }</span> else<span class="cov8" title="1"> if l.accept("bB") </span><span class="cov0" title="0">{
                        digits = "01_"
                }</span>
        }
        <span class="cov8" title="1">l.acceptRun(digits)
        if l.accept(".") </span><span class="cov8" title="1">{
                l.acceptRun(digits)
        }</span>
        <span class="cov8" title="1">if len(digits) == 10+1 &amp;&amp; l.accept("eE") </span><span class="cov8" title="1">{
                l.accept("+-")
                l.acceptRun("0123456789_")
        }</span>
        <span class="cov8" title="1">if len(digits) == 16+6+1 &amp;&amp; l.accept("pP") </span><span class="cov8" title="1">{
                l.accept("+-")
                l.acceptRun("0123456789_")
        }</span>
        // Is it imaginary?
        <span class="cov8" title="1">l.accept("i")
        // Next thing mustn't be alphanumeric.
        if isAlphaNumeric(l.peek()) </span><span class="cov8" title="1">{
                l.next()
                return false
        }</span>
        <span class="cov8" title="1">return true</span>
}

// lexQuote scans a quoted string.
func lexQuote(l *lexer) stateFn <span class="cov8" title="1">{
Loop:
        for </span><span class="cov8" title="1">{
                switch l.next() </span>{
                case '\\':<span class="cov8" title="1">
                        if r := l.next(); r != eof &amp;&amp; r != '\n' </span><span class="cov8" title="1">{
                                break</span>
                        }
                        <span class="cov0" title="0">fallthrough</span>
                case eof, '\n':<span class="cov8" title="1">
                        return l.errorf("unterminated quoted string")</span>
                case '"':<span class="cov8" title="1">
                        break Loop</span>
                }
        }
        <span class="cov8" title="1">l.emit(itemString)
        return lexInsideAction</span>
}

// lexRawQuote scans a raw quoted string.
func lexRawQuote(l *lexer) stateFn <span class="cov8" title="1">{
Loop:
        for </span><span class="cov8" title="1">{
                switch l.next() </span>{
                case eof:<span class="cov8" title="1">
                        return l.errorf("unterminated raw quoted string")</span>
                case '`':<span class="cov8" title="1">
                        break Loop</span>
                }
        }
        <span class="cov8" title="1">l.emit(itemRawString)
        return lexInsideAction</span>
}

// isSpace reports whether r is a space character.
func isSpace(r rune) bool <span class="cov8" title="1">{
        return r == ' ' || r == '\t' || r == '\r' || r == '\n'
}</span>

// isAlphaNumeric reports whether r is an alphabetic, digit, or underscore.
func isAlphaNumeric(r rune) bool <span class="cov8" title="1">{
        return r == '_' || unicode.IsLetter(r) || unicode.IsDigit(r)
}</span>

func hasLeftTrimMarker(s string) bool <span class="cov8" title="1">{
        return len(s) &gt;= 2 &amp;&amp; s[0] == trimMarker &amp;&amp; isSpace(rune(s[1]))
}</span>

func hasRightTrimMarker(s string) bool <span class="cov8" title="1">{
        return len(s) &gt;= 2 &amp;&amp; isSpace(rune(s[0])) &amp;&amp; s[1] == trimMarker
}</span>
</pre>
		
		<pre class="file" id="file322" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Parse nodes.

package parse

import (
        "fmt"
        "strconv"
        "strings"
)

var textFormat = "%s" // Changed to "%q" in tests for better error messages.

// A Node is an element in the parse tree. The interface is trivial.
// The interface contains an unexported method so that only
// types local to this package can satisfy it.
type Node interface {
        Type() NodeType
        String() string
        // Copy does a deep copy of the Node and all its components.
        // To avoid type assertions, some XxxNodes also have specialized
        // CopyXxx methods that return *XxxNode.
        Copy() Node
        Position() Pos // byte position of start of node in full original input string
        // tree returns the containing *Tree.
        // It is unexported so all implementations of Node are in this package.
        tree() *Tree
        // writeTo writes the String output to the builder.
        writeTo(*strings.Builder)
}

// NodeType identifies the type of a parse tree node.
type NodeType int

// Pos represents a byte position in the original input text from which
// this template was parsed.
type Pos int

func (p Pos) Position() Pos <span class="cov8" title="1">{
        return p
}</span>

// Type returns itself and provides an easy default implementation
// for embedding in a Node. Embedded in all non-trivial Nodes.
func (t NodeType) Type() NodeType <span class="cov8" title="1">{
        return t
}</span>

const (
        NodeText       NodeType = iota // Plain text.
        NodeAction                     // A non-control action such as a field evaluation.
        NodeBool                       // A boolean constant.
        NodeChain                      // A sequence of field accesses.
        NodeCommand                    // An element of a pipeline.
        NodeDot                        // The cursor, dot.
        nodeElse                       // An else action. Not added to tree.
        nodeEnd                        // An end action. Not added to tree.
        NodeField                      // A field or method name.
        NodeIdentifier                 // An identifier; always a function name.
        NodeIf                         // An if action.
        NodeList                       // A list of Nodes.
        NodeNil                        // An untyped nil constant.
        NodeNumber                     // A numerical constant.
        NodePipe                       // A pipeline of commands.
        NodeRange                      // A range action.
        NodeString                     // A string constant.
        NodeTemplate                   // A template invocation action.
        NodeVariable                   // A $ variable.
        NodeWith                       // A with action.
        NodeComment                    // A comment.
)

// Nodes.

// ListNode holds a sequence of nodes.
type ListNode struct {
        NodeType
        Pos
        tr    *Tree
        Nodes []Node // The element nodes in lexical order.
}

func (t *Tree) newList(pos Pos) *ListNode <span class="cov8" title="1">{
        return &amp;ListNode{tr: t, NodeType: NodeList, Pos: pos}
}</span>

func (l *ListNode) append(n Node) <span class="cov8" title="1">{
        l.Nodes = append(l.Nodes, n)
}</span>

func (l *ListNode) tree() *Tree <span class="cov0" title="0">{
        return l.tr
}</span>

func (l *ListNode) String() string <span class="cov8" title="1">{
        var sb strings.Builder
        l.writeTo(&amp;sb)
        return sb.String()
}</span>

func (l *ListNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        for _, n := range l.Nodes </span><span class="cov8" title="1">{
                n.writeTo(sb)
        }</span>
}

func (l *ListNode) CopyList() *ListNode <span class="cov8" title="1">{
        if l == nil </span><span class="cov8" title="1">{
                return l
        }</span>
        <span class="cov8" title="1">n := l.tr.newList(l.Pos)
        for _, elem := range l.Nodes </span><span class="cov8" title="1">{
                n.append(elem.Copy())
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (l *ListNode) Copy() Node <span class="cov8" title="1">{
        return l.CopyList()
}</span>

// TextNode holds plain text.
type TextNode struct {
        NodeType
        Pos
        tr   *Tree
        Text []byte // The text; may span newlines.
}

func (t *Tree) newText(pos Pos, text string) *TextNode <span class="cov8" title="1">{
        return &amp;TextNode{tr: t, NodeType: NodeText, Pos: pos, Text: []byte(text)}
}</span>

func (t *TextNode) String() string <span class="cov8" title="1">{
        return fmt.Sprintf(textFormat, t.Text)
}</span>

func (t *TextNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        sb.WriteString(t.String())
}</span>

func (t *TextNode) tree() *Tree <span class="cov0" title="0">{
        return t.tr
}</span>

func (t *TextNode) Copy() Node <span class="cov8" title="1">{
        return &amp;TextNode{tr: t.tr, NodeType: NodeText, Pos: t.Pos, Text: append([]byte{}, t.Text...)}
}</span>

// CommentNode holds a comment.
type CommentNode struct {
        NodeType
        Pos
        tr   *Tree
        Text string // Comment text.
}

func (t *Tree) newComment(pos Pos, text string) *CommentNode <span class="cov8" title="1">{
        return &amp;CommentNode{tr: t, NodeType: NodeComment, Pos: pos, Text: text}
}</span>

func (c *CommentNode) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        c.writeTo(&amp;sb)
        return sb.String()
}</span>

func (c *CommentNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        sb.WriteString("{{")
        sb.WriteString(c.Text)
        sb.WriteString("}}")
}</span>

func (c *CommentNode) tree() *Tree <span class="cov0" title="0">{
        return c.tr
}</span>

func (c *CommentNode) Copy() Node <span class="cov0" title="0">{
        return &amp;CommentNode{tr: c.tr, NodeType: NodeComment, Pos: c.Pos, Text: c.Text}
}</span>

// PipeNode holds a pipeline with optional declaration
type PipeNode struct {
        NodeType
        Pos
        tr       *Tree
        Line     int             // The line number in the input. Deprecated: Kept for compatibility.
        IsAssign bool            // The variables are being assigned, not declared.
        Decl     []*VariableNode // Variables in lexical order.
        Cmds     []*CommandNode  // The commands in lexical order.
}

func (t *Tree) newPipeline(pos Pos, line int, vars []*VariableNode) *PipeNode <span class="cov8" title="1">{
        return &amp;PipeNode{tr: t, NodeType: NodePipe, Pos: pos, Line: line, Decl: vars}
}</span>

func (p *PipeNode) append(command *CommandNode) <span class="cov8" title="1">{
        p.Cmds = append(p.Cmds, command)
}</span>

func (p *PipeNode) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        p.writeTo(&amp;sb)
        return sb.String()
}</span>

func (p *PipeNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        if len(p.Decl) &gt; 0 </span><span class="cov8" title="1">{
                for i, v := range p.Decl </span><span class="cov8" title="1">{
                        if i &gt; 0 </span><span class="cov8" title="1">{
                                sb.WriteString(", ")
                        }</span>
                        <span class="cov8" title="1">v.writeTo(sb)</span>
                }
                <span class="cov8" title="1">sb.WriteString(" := ")</span>
        }
        <span class="cov8" title="1">for i, c := range p.Cmds </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteString(" | ")
                }</span>
                <span class="cov8" title="1">c.writeTo(sb)</span>
        }
}

func (p *PipeNode) tree() *Tree <span class="cov0" title="0">{
        return p.tr
}</span>

func (p *PipeNode) CopyPipe() *PipeNode <span class="cov8" title="1">{
        if p == nil </span><span class="cov8" title="1">{
                return p
        }</span>
        <span class="cov8" title="1">vars := make([]*VariableNode, len(p.Decl))
        for i, d := range p.Decl </span><span class="cov8" title="1">{
                vars[i] = d.Copy().(*VariableNode)
        }</span>
        <span class="cov8" title="1">n := p.tr.newPipeline(p.Pos, p.Line, vars)
        n.IsAssign = p.IsAssign
        for _, c := range p.Cmds </span><span class="cov8" title="1">{
                n.append(c.Copy().(*CommandNode))
        }</span>
        <span class="cov8" title="1">return n</span>
}

func (p *PipeNode) Copy() Node <span class="cov8" title="1">{
        return p.CopyPipe()
}</span>

// ActionNode holds an action (something bounded by delimiters).
// Control actions have their own nodes; ActionNode represents simple
// ones such as field evaluations and parenthesized pipelines.
type ActionNode struct {
        NodeType
        Pos
        tr   *Tree
        Line int       // The line number in the input. Deprecated: Kept for compatibility.
        Pipe *PipeNode // The pipeline in the action.
}

func (t *Tree) newAction(pos Pos, line int, pipe *PipeNode) *ActionNode <span class="cov8" title="1">{
        return &amp;ActionNode{tr: t, NodeType: NodeAction, Pos: pos, Line: line, Pipe: pipe}
}</span>

func (a *ActionNode) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        a.writeTo(&amp;sb)
        return sb.String()
}</span>

func (a *ActionNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        sb.WriteString("{{")
        a.Pipe.writeTo(sb)
        sb.WriteString("}}")
}</span>

func (a *ActionNode) tree() *Tree <span class="cov0" title="0">{
        return a.tr
}</span>

func (a *ActionNode) Copy() Node <span class="cov8" title="1">{
        return a.tr.newAction(a.Pos, a.Line, a.Pipe.CopyPipe())

}</span>

// CommandNode holds a command (a pipeline inside an evaluating action).
type CommandNode struct {
        NodeType
        Pos
        tr   *Tree
        Args []Node // Arguments in lexical order: Identifier, field, or constant.
}

func (t *Tree) newCommand(pos Pos) *CommandNode <span class="cov8" title="1">{
        return &amp;CommandNode{tr: t, NodeType: NodeCommand, Pos: pos}
}</span>

func (c *CommandNode) append(arg Node) <span class="cov8" title="1">{
        c.Args = append(c.Args, arg)
}</span>

func (c *CommandNode) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        c.writeTo(&amp;sb)
        return sb.String()
}</span>

func (c *CommandNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        for i, arg := range c.Args </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteByte(' ')
                }</span>
                <span class="cov8" title="1">if arg, ok := arg.(*PipeNode); ok </span><span class="cov8" title="1">{
                        sb.WriteByte('(')
                        arg.writeTo(sb)
                        sb.WriteByte(')')
                        continue</span>
                }
                <span class="cov8" title="1">arg.writeTo(sb)</span>
        }
}

func (c *CommandNode) tree() *Tree <span class="cov0" title="0">{
        return c.tr
}</span>

func (c *CommandNode) Copy() Node <span class="cov8" title="1">{
        if c == nil </span><span class="cov0" title="0">{
                return c
        }</span>
        <span class="cov8" title="1">n := c.tr.newCommand(c.Pos)
        for _, c := range c.Args </span><span class="cov8" title="1">{
                n.append(c.Copy())
        }</span>
        <span class="cov8" title="1">return n</span>
}

// IdentifierNode holds an identifier.
type IdentifierNode struct {
        NodeType
        Pos
        tr    *Tree
        Ident string // The identifier's name.
}

// NewIdentifier returns a new IdentifierNode with the given identifier name.
func NewIdentifier(ident string) *IdentifierNode <span class="cov8" title="1">{
        return &amp;IdentifierNode{NodeType: NodeIdentifier, Ident: ident}
}</span>

// SetPos sets the position. NewIdentifier is a public method so we can't modify its signature.
// Chained for convenience.
// TODO: fix one day?
func (i *IdentifierNode) SetPos(pos Pos) *IdentifierNode <span class="cov8" title="1">{
        i.Pos = pos
        return i
}</span>

// SetTree sets the parent tree for the node. NewIdentifier is a public method so we can't modify its signature.
// Chained for convenience.
// TODO: fix one day?
func (i *IdentifierNode) SetTree(t *Tree) *IdentifierNode <span class="cov8" title="1">{
        i.tr = t
        return i
}</span>

func (i *IdentifierNode) String() string <span class="cov8" title="1">{
        return i.Ident
}</span>

func (i *IdentifierNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        sb.WriteString(i.String())
}</span>

func (i *IdentifierNode) tree() *Tree <span class="cov0" title="0">{
        return i.tr
}</span>

func (i *IdentifierNode) Copy() Node <span class="cov8" title="1">{
        return NewIdentifier(i.Ident).SetTree(i.tr).SetPos(i.Pos)
}</span>

// VariableNode holds a list of variable names, possibly with chained field
// accesses. The dollar sign is part of the (first) name.
type VariableNode struct {
        NodeType
        Pos
        tr    *Tree
        Ident []string // Variable name and fields in lexical order.
}

func (t *Tree) newVariable(pos Pos, ident string) *VariableNode <span class="cov8" title="1">{
        return &amp;VariableNode{tr: t, NodeType: NodeVariable, Pos: pos, Ident: strings.Split(ident, ".")}
}</span>

func (v *VariableNode) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        v.writeTo(&amp;sb)
        return sb.String()
}</span>

func (v *VariableNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        for i, id := range v.Ident </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        sb.WriteByte('.')
                }</span>
                <span class="cov8" title="1">sb.WriteString(id)</span>
        }
}

func (v *VariableNode) tree() *Tree <span class="cov0" title="0">{
        return v.tr
}</span>

func (v *VariableNode) Copy() Node <span class="cov8" title="1">{
        return &amp;VariableNode{tr: v.tr, NodeType: NodeVariable, Pos: v.Pos, Ident: append([]string{}, v.Ident...)}
}</span>

// DotNode holds the special identifier '.'.
type DotNode struct {
        NodeType
        Pos
        tr *Tree
}

func (t *Tree) newDot(pos Pos) *DotNode <span class="cov8" title="1">{
        return &amp;DotNode{tr: t, NodeType: NodeDot, Pos: pos}
}</span>

func (d *DotNode) Type() NodeType <span class="cov8" title="1">{
        // Override method on embedded NodeType for API compatibility.
        // TODO: Not really a problem; could change API without effect but
        // api tool complains.
        return NodeDot
}</span>

func (d *DotNode) String() string <span class="cov8" title="1">{
        return "."
}</span>

func (d *DotNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        sb.WriteString(d.String())
}</span>

func (d *DotNode) tree() *Tree <span class="cov0" title="0">{
        return d.tr
}</span>

func (d *DotNode) Copy() Node <span class="cov8" title="1">{
        return d.tr.newDot(d.Pos)
}</span>

// NilNode holds the special identifier 'nil' representing an untyped nil constant.
type NilNode struct {
        NodeType
        Pos
        tr *Tree
}

func (t *Tree) newNil(pos Pos) *NilNode <span class="cov8" title="1">{
        return &amp;NilNode{tr: t, NodeType: NodeNil, Pos: pos}
}</span>

func (n *NilNode) Type() NodeType <span class="cov8" title="1">{
        // Override method on embedded NodeType for API compatibility.
        // TODO: Not really a problem; could change API without effect but
        // api tool complains.
        return NodeNil
}</span>

func (n *NilNode) String() string <span class="cov8" title="1">{
        return "nil"
}</span>

func (n *NilNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        sb.WriteString(n.String())
}</span>

func (n *NilNode) tree() *Tree <span class="cov0" title="0">{
        return n.tr
}</span>

func (n *NilNode) Copy() Node <span class="cov8" title="1">{
        return n.tr.newNil(n.Pos)
}</span>

// FieldNode holds a field (identifier starting with '.').
// The names may be chained ('.x.y').
// The period is dropped from each ident.
type FieldNode struct {
        NodeType
        Pos
        tr    *Tree
        Ident []string // The identifiers in lexical order.
}

func (t *Tree) newField(pos Pos, ident string) *FieldNode <span class="cov8" title="1">{
        return &amp;FieldNode{tr: t, NodeType: NodeField, Pos: pos, Ident: strings.Split(ident[1:], ".")} // [1:] to drop leading period
}</span>

func (f *FieldNode) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        f.writeTo(&amp;sb)
        return sb.String()
}</span>

func (f *FieldNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        for _, id := range f.Ident </span><span class="cov8" title="1">{
                sb.WriteByte('.')
                sb.WriteString(id)
        }</span>
}

func (f *FieldNode) tree() *Tree <span class="cov0" title="0">{
        return f.tr
}</span>

func (f *FieldNode) Copy() Node <span class="cov8" title="1">{
        return &amp;FieldNode{tr: f.tr, NodeType: NodeField, Pos: f.Pos, Ident: append([]string{}, f.Ident...)}
}</span>

// ChainNode holds a term followed by a chain of field accesses (identifier starting with '.').
// The names may be chained ('.x.y').
// The periods are dropped from each ident.
type ChainNode struct {
        NodeType
        Pos
        tr    *Tree
        Node  Node
        Field []string // The identifiers in lexical order.
}

func (t *Tree) newChain(pos Pos, node Node) *ChainNode <span class="cov8" title="1">{
        return &amp;ChainNode{tr: t, NodeType: NodeChain, Pos: pos, Node: node}
}</span>

// Add adds the named field (which should start with a period) to the end of the chain.
func (c *ChainNode) Add(field string) <span class="cov8" title="1">{
        if len(field) == 0 || field[0] != '.' </span><span class="cov0" title="0">{
                panic("no dot in field")</span>
        }
        <span class="cov8" title="1">field = field[1:] // Remove leading dot.
        if field == "" </span><span class="cov0" title="0">{
                panic("empty field")</span>
        }
        <span class="cov8" title="1">c.Field = append(c.Field, field)</span>
}

func (c *ChainNode) String() string <span class="cov8" title="1">{
        var sb strings.Builder
        c.writeTo(&amp;sb)
        return sb.String()
}</span>

func (c *ChainNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        if _, ok := c.Node.(*PipeNode); ok </span><span class="cov8" title="1">{
                sb.WriteByte('(')
                c.Node.writeTo(sb)
                sb.WriteByte(')')
        }</span> else<span class="cov8" title="1"> {
                c.Node.writeTo(sb)
        }</span>
        <span class="cov8" title="1">for _, field := range c.Field </span><span class="cov8" title="1">{
                sb.WriteByte('.')
                sb.WriteString(field)
        }</span>
}

func (c *ChainNode) tree() *Tree <span class="cov0" title="0">{
        return c.tr
}</span>

func (c *ChainNode) Copy() Node <span class="cov8" title="1">{
        return &amp;ChainNode{tr: c.tr, NodeType: NodeChain, Pos: c.Pos, Node: c.Node, Field: append([]string{}, c.Field...)}
}</span>

// BoolNode holds a boolean constant.
type BoolNode struct {
        NodeType
        Pos
        tr   *Tree
        True bool // The value of the boolean constant.
}

func (t *Tree) newBool(pos Pos, true bool) *BoolNode <span class="cov8" title="1">{
        return &amp;BoolNode{tr: t, NodeType: NodeBool, Pos: pos, True: true}
}</span>

func (b *BoolNode) String() string <span class="cov8" title="1">{
        if b.True </span><span class="cov8" title="1">{
                return "true"
        }</span>
        <span class="cov8" title="1">return "false"</span>
}

func (b *BoolNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        sb.WriteString(b.String())
}</span>

func (b *BoolNode) tree() *Tree <span class="cov0" title="0">{
        return b.tr
}</span>

func (b *BoolNode) Copy() Node <span class="cov8" title="1">{
        return b.tr.newBool(b.Pos, b.True)
}</span>

// NumberNode holds a number: signed or unsigned integer, float, or complex.
// The value is parsed and stored under all the types that can represent the value.
// This simulates in a small amount of code the behavior of Go's ideal constants.
type NumberNode struct {
        NodeType
        Pos
        tr         *Tree
        IsInt      bool       // Number has an integral value.
        IsUint     bool       // Number has an unsigned integral value.
        IsFloat    bool       // Number has a floating-point value.
        IsComplex  bool       // Number is complex.
        Int64      int64      // The signed integer value.
        Uint64     uint64     // The unsigned integer value.
        Float64    float64    // The floating-point value.
        Complex128 complex128 // The complex value.
        Text       string     // The original textual representation from the input.
}

func (t *Tree) newNumber(pos Pos, text string, typ itemType) (*NumberNode, error) <span class="cov8" title="1">{
        n := &amp;NumberNode{tr: t, NodeType: NodeNumber, Pos: pos, Text: text}
        switch typ </span>{
        case itemCharConstant:<span class="cov8" title="1">
                rune, _, tail, err := strconv.UnquoteChar(text[1:], text[0])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">if tail != "'" </span><span class="cov8" title="1">{
                        return nil, fmt.Errorf("malformed character constant: %s", text)
                }</span>
                <span class="cov8" title="1">n.Int64 = int64(rune)
                n.IsInt = true
                n.Uint64 = uint64(rune)
                n.IsUint = true
                n.Float64 = float64(rune) // odd but those are the rules.
                n.IsFloat = true
                return n, nil</span>
        case itemComplex:<span class="cov8" title="1">
                // fmt.Sscan can parse the pair, so let it do the work.
                if _, err := fmt.Sscan(text, &amp;n.Complex128); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">n.IsComplex = true
                n.simplifyComplex()
                return n, nil</span>
        }
        // Imaginary constants can only be complex unless they are zero.
        <span class="cov8" title="1">if len(text) &gt; 0 &amp;&amp; text[len(text)-1] == 'i' </span><span class="cov8" title="1">{
                f, err := strconv.ParseFloat(text[:len(text)-1], 64)
                if err == nil </span><span class="cov8" title="1">{
                        n.IsComplex = true
                        n.Complex128 = complex(0, f)
                        n.simplifyComplex()
                        return n, nil
                }</span>
        }
        // Do integer test first so we get 0x123 etc.
        <span class="cov8" title="1">u, err := strconv.ParseUint(text, 0, 64) // will fail for -0; fixed below.
        if err == nil </span><span class="cov8" title="1">{
                n.IsUint = true
                n.Uint64 = u
        }</span>
        <span class="cov8" title="1">i, err := strconv.ParseInt(text, 0, 64)
        if err == nil </span><span class="cov8" title="1">{
                n.IsInt = true
                n.Int64 = i
                if i == 0 </span><span class="cov8" title="1">{
                        n.IsUint = true // in case of -0.
                        n.Uint64 = u
                }</span>
        }
        // If an integer extraction succeeded, promote the float.
        <span class="cov8" title="1">if n.IsInt </span><span class="cov8" title="1">{
                n.IsFloat = true
                n.Float64 = float64(n.Int64)
        }</span> else<span class="cov8" title="1"> if n.IsUint </span><span class="cov0" title="0">{
                n.IsFloat = true
                n.Float64 = float64(n.Uint64)
        }</span> else<span class="cov8" title="1"> {
                f, err := strconv.ParseFloat(text, 64)
                if err == nil </span><span class="cov8" title="1">{
                        // If we parsed it as a float but it looks like an integer,
                        // it's a huge number too large to fit in an int. Reject it.
                        if !strings.ContainsAny(text, ".eEpP") </span><span class="cov0" title="0">{
                                return nil, fmt.Errorf("integer overflow: %q", text)
                        }</span>
                        <span class="cov8" title="1">n.IsFloat = true
                        n.Float64 = f
                        // If a floating-point extraction succeeded, extract the int if needed.
                        if !n.IsInt &amp;&amp; float64(int64(f)) == f </span><span class="cov8" title="1">{
                                n.IsInt = true
                                n.Int64 = int64(f)
                        }</span>
                        <span class="cov8" title="1">if !n.IsUint &amp;&amp; float64(uint64(f)) == f </span><span class="cov8" title="1">{
                                n.IsUint = true
                                n.Uint64 = uint64(f)
                        }</span>
                }
        }
        <span class="cov8" title="1">if !n.IsInt &amp;&amp; !n.IsUint &amp;&amp; !n.IsFloat </span><span class="cov8" title="1">{
                return nil, fmt.Errorf("illegal number syntax: %q", text)
        }</span>
        <span class="cov8" title="1">return n, nil</span>
}

// simplifyComplex pulls out any other types that are represented by the complex number.
// These all require that the imaginary part be zero.
func (n *NumberNode) simplifyComplex() <span class="cov8" title="1">{
        n.IsFloat = imag(n.Complex128) == 0
        if n.IsFloat </span><span class="cov8" title="1">{
                n.Float64 = real(n.Complex128)
                n.IsInt = float64(int64(n.Float64)) == n.Float64
                if n.IsInt </span><span class="cov8" title="1">{
                        n.Int64 = int64(n.Float64)
                }</span>
                <span class="cov8" title="1">n.IsUint = float64(uint64(n.Float64)) == n.Float64
                if n.IsUint </span><span class="cov8" title="1">{
                        n.Uint64 = uint64(n.Float64)
                }</span>
        }
}

func (n *NumberNode) String() string <span class="cov8" title="1">{
        return n.Text
}</span>

func (n *NumberNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        sb.WriteString(n.String())
}</span>

func (n *NumberNode) tree() *Tree <span class="cov0" title="0">{
        return n.tr
}</span>

func (n *NumberNode) Copy() Node <span class="cov8" title="1">{
        nn := new(NumberNode)
        *nn = *n // Easy, fast, correct.
        return nn
}</span>

// StringNode holds a string constant. The value has been "unquoted".
type StringNode struct {
        NodeType
        Pos
        tr     *Tree
        Quoted string // The original text of the string, with quotes.
        Text   string // The string, after quote processing.
}

func (t *Tree) newString(pos Pos, orig, text string) *StringNode <span class="cov8" title="1">{
        return &amp;StringNode{tr: t, NodeType: NodeString, Pos: pos, Quoted: orig, Text: text}
}</span>

func (s *StringNode) String() string <span class="cov8" title="1">{
        return s.Quoted
}</span>

func (s *StringNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        sb.WriteString(s.String())
}</span>

func (s *StringNode) tree() *Tree <span class="cov0" title="0">{
        return s.tr
}</span>

func (s *StringNode) Copy() Node <span class="cov8" title="1">{
        return s.tr.newString(s.Pos, s.Quoted, s.Text)
}</span>

// endNode represents an {{end}} action.
// It does not appear in the final parse tree.
type endNode struct {
        NodeType
        Pos
        tr *Tree
}

func (t *Tree) newEnd(pos Pos) *endNode <span class="cov8" title="1">{
        return &amp;endNode{tr: t, NodeType: nodeEnd, Pos: pos}
}</span>

func (e *endNode) String() string <span class="cov8" title="1">{
        return "{{end}}"
}</span>

func (e *endNode) writeTo(sb *strings.Builder) <span class="cov0" title="0">{
        sb.WriteString(e.String())
}</span>

func (e *endNode) tree() *Tree <span class="cov0" title="0">{
        return e.tr
}</span>

func (e *endNode) Copy() Node <span class="cov0" title="0">{
        return e.tr.newEnd(e.Pos)
}</span>

// elseNode represents an {{else}} action. Does not appear in the final tree.
type elseNode struct {
        NodeType
        Pos
        tr   *Tree
        Line int // The line number in the input. Deprecated: Kept for compatibility.
}

func (t *Tree) newElse(pos Pos, line int) *elseNode <span class="cov8" title="1">{
        return &amp;elseNode{tr: t, NodeType: nodeElse, Pos: pos, Line: line}
}</span>

func (e *elseNode) Type() NodeType <span class="cov8" title="1">{
        return nodeElse
}</span>

func (e *elseNode) String() string <span class="cov8" title="1">{
        return "{{else}}"
}</span>

func (e *elseNode) writeTo(sb *strings.Builder) <span class="cov0" title="0">{
        sb.WriteString(e.String())
}</span>

func (e *elseNode) tree() *Tree <span class="cov0" title="0">{
        return e.tr
}</span>

func (e *elseNode) Copy() Node <span class="cov0" title="0">{
        return e.tr.newElse(e.Pos, e.Line)
}</span>

// BranchNode is the common representation of if, range, and with.
type BranchNode struct {
        NodeType
        Pos
        tr       *Tree
        Line     int       // The line number in the input. Deprecated: Kept for compatibility.
        Pipe     *PipeNode // The pipeline to be evaluated.
        List     *ListNode // What to execute if the value is non-empty.
        ElseList *ListNode // What to execute if the value is empty (nil if absent).
}

func (b *BranchNode) String() string <span class="cov8" title="1">{
        var sb strings.Builder
        b.writeTo(&amp;sb)
        return sb.String()
}</span>

func (b *BranchNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        name := ""
        switch b.NodeType </span>{
        case NodeIf:<span class="cov8" title="1">
                name = "if"</span>
        case NodeRange:<span class="cov8" title="1">
                name = "range"</span>
        case NodeWith:<span class="cov8" title="1">
                name = "with"</span>
        default:<span class="cov0" title="0">
                panic("unknown branch type")</span>
        }
        <span class="cov8" title="1">sb.WriteString("{{")
        sb.WriteString(name)
        sb.WriteByte(' ')
        b.Pipe.writeTo(sb)
        sb.WriteString("}}")
        b.List.writeTo(sb)
        if b.ElseList != nil </span><span class="cov8" title="1">{
                sb.WriteString("{{else}}")
                b.ElseList.writeTo(sb)
        }</span>
        <span class="cov8" title="1">sb.WriteString("{{end}}")</span>
}

func (b *BranchNode) tree() *Tree <span class="cov8" title="1">{
        return b.tr
}</span>

func (b *BranchNode) Copy() Node <span class="cov0" title="0">{
        switch b.NodeType </span>{
        case NodeIf:<span class="cov0" title="0">
                return b.tr.newIf(b.Pos, b.Line, b.Pipe, b.List, b.ElseList)</span>
        case NodeRange:<span class="cov0" title="0">
                return b.tr.newRange(b.Pos, b.Line, b.Pipe, b.List, b.ElseList)</span>
        case NodeWith:<span class="cov0" title="0">
                return b.tr.newWith(b.Pos, b.Line, b.Pipe, b.List, b.ElseList)</span>
        default:<span class="cov0" title="0">
                panic("unknown branch type")</span>
        }
}

// IfNode represents an {{if}} action and its commands.
type IfNode struct {
        BranchNode
}

func (t *Tree) newIf(pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) *IfNode <span class="cov8" title="1">{
        return &amp;IfNode{BranchNode{tr: t, NodeType: NodeIf, Pos: pos, Line: line, Pipe: pipe, List: list, ElseList: elseList}}
}</span>

func (i *IfNode) Copy() Node <span class="cov8" title="1">{
        return i.tr.newIf(i.Pos, i.Line, i.Pipe.CopyPipe(), i.List.CopyList(), i.ElseList.CopyList())
}</span>

// RangeNode represents a {{range}} action and its commands.
type RangeNode struct {
        BranchNode
}

func (t *Tree) newRange(pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) *RangeNode <span class="cov8" title="1">{
        return &amp;RangeNode{BranchNode{tr: t, NodeType: NodeRange, Pos: pos, Line: line, Pipe: pipe, List: list, ElseList: elseList}}
}</span>

func (r *RangeNode) Copy() Node <span class="cov8" title="1">{
        return r.tr.newRange(r.Pos, r.Line, r.Pipe.CopyPipe(), r.List.CopyList(), r.ElseList.CopyList())
}</span>

// WithNode represents a {{with}} action and its commands.
type WithNode struct {
        BranchNode
}

func (t *Tree) newWith(pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) *WithNode <span class="cov8" title="1">{
        return &amp;WithNode{BranchNode{tr: t, NodeType: NodeWith, Pos: pos, Line: line, Pipe: pipe, List: list, ElseList: elseList}}
}</span>

func (w *WithNode) Copy() Node <span class="cov8" title="1">{
        return w.tr.newWith(w.Pos, w.Line, w.Pipe.CopyPipe(), w.List.CopyList(), w.ElseList.CopyList())
}</span>

// TemplateNode represents a {{template}} action.
type TemplateNode struct {
        NodeType
        Pos
        tr   *Tree
        Line int       // The line number in the input. Deprecated: Kept for compatibility.
        Name string    // The name of the template (unquoted).
        Pipe *PipeNode // The command to evaluate as dot for the template.
}

func (t *Tree) newTemplate(pos Pos, line int, name string, pipe *PipeNode) *TemplateNode <span class="cov8" title="1">{
        return &amp;TemplateNode{tr: t, NodeType: NodeTemplate, Pos: pos, Line: line, Name: name, Pipe: pipe}
}</span>

func (t *TemplateNode) String() string <span class="cov0" title="0">{
        var sb strings.Builder
        t.writeTo(&amp;sb)
        return sb.String()
}</span>

func (t *TemplateNode) writeTo(sb *strings.Builder) <span class="cov8" title="1">{
        sb.WriteString("{{template ")
        sb.WriteString(strconv.Quote(t.Name))
        if t.Pipe != nil </span><span class="cov8" title="1">{
                sb.WriteByte(' ')
                t.Pipe.writeTo(sb)
        }</span>
        <span class="cov8" title="1">sb.WriteString("}}")</span>
}

func (t *TemplateNode) tree() *Tree <span class="cov0" title="0">{
        return t.tr
}</span>

func (t *TemplateNode) Copy() Node <span class="cov8" title="1">{
        return t.tr.newTemplate(t.Pos, t.Line, t.Name, t.Pipe.CopyPipe())
}</span>
</pre>
		
		<pre class="file" id="file323" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// Package parse builds parse trees for templates as defined by text/template
// and html/template. Clients should use those packages to construct templates
// rather than this one, which provides shared internal data structures not
// intended for general use.
package parse

import (
        "bytes"
        "fmt"
        "runtime"
        "strconv"
        "strings"
)

// Tree is the representation of a single parsed template.
type Tree struct {
        Name      string    // name of the template represented by the tree.
        ParseName string    // name of the top-level template during parsing, for error messages.
        Root      *ListNode // top-level root of the tree.
        Mode      Mode      // parsing mode.
        text      string    // text parsed to create the template (or its parent)
        // Parsing only; cleared after parse.
        funcs      []map[string]interface{}
        lex        *lexer
        token      [3]item // three-token lookahead for parser.
        peekCount  int
        vars       []string // variables defined at the moment.
        treeSet    map[string]*Tree
        actionLine int // line of left delim starting action
        mode       Mode
}

// A mode value is a set of flags (or 0). Modes control parser behavior.
type Mode uint

const (
        ParseComments Mode = 1 &lt;&lt; iota // parse comments and add them to AST
)

// Copy returns a copy of the Tree. Any parsing state is discarded.
func (t *Tree) Copy() *Tree <span class="cov8" title="1">{
        if t == nil </span><span class="cov0" title="0">{
                return nil
        }</span>
        <span class="cov8" title="1">return &amp;Tree{
                Name:      t.Name,
                ParseName: t.ParseName,
                Root:      t.Root.CopyList(),
                text:      t.text,
        }</span>
}

// Parse returns a map from template name to parse.Tree, created by parsing the
// templates described in the argument string. The top-level template will be
// given the specified name. If an error is encountered, parsing stops and an
// empty map is returned with the error.
func Parse(name, text, leftDelim, rightDelim string, funcs ...map[string]interface{}) (map[string]*Tree, error) <span class="cov0" title="0">{
        treeSet := make(map[string]*Tree)
        t := New(name)
        t.text = text
        _, err := t.Parse(text, leftDelim, rightDelim, treeSet, funcs...)
        return treeSet, err
}</span>

// next returns the next token.
func (t *Tree) next() item <span class="cov8" title="1">{
        if t.peekCount &gt; 0 </span><span class="cov8" title="1">{
                t.peekCount--
        }</span> else<span class="cov8" title="1"> {
                t.token[0] = t.lex.nextItem()
        }</span>
        <span class="cov8" title="1">return t.token[t.peekCount]</span>
}

// backup backs the input stream up one token.
func (t *Tree) backup() <span class="cov8" title="1">{
        t.peekCount++
}</span>

// backup2 backs the input stream up two tokens.
// The zeroth token is already there.
func (t *Tree) backup2(t1 item) <span class="cov8" title="1">{
        t.token[1] = t1
        t.peekCount = 2
}</span>

// backup3 backs the input stream up three tokens
// The zeroth token is already there.
func (t *Tree) backup3(t2, t1 item) <span class="cov8" title="1">{ // Reverse order: we're pushing back.
        t.token[1] = t1
        t.token[2] = t2
        t.peekCount = 3
}</span>

// peek returns but does not consume the next token.
func (t *Tree) peek() item <span class="cov8" title="1">{
        if t.peekCount &gt; 0 </span><span class="cov8" title="1">{
                return t.token[t.peekCount-1]
        }</span>
        <span class="cov8" title="1">t.peekCount = 1
        t.token[0] = t.lex.nextItem()
        return t.token[0]</span>
}

// nextNonSpace returns the next non-space token.
func (t *Tree) nextNonSpace() (token item) <span class="cov8" title="1">{
        for </span><span class="cov8" title="1">{
                token = t.next()
                if token.typ != itemSpace </span><span class="cov8" title="1">{
                        break</span>
                }
        }
        <span class="cov8" title="1">return token</span>
}

// peekNonSpace returns but does not consume the next non-space token.
func (t *Tree) peekNonSpace() item <span class="cov8" title="1">{
        token := t.nextNonSpace()
        t.backup()
        return token
}</span>

// Parsing.

// New allocates a new parse tree with the given name.
func New(name string, funcs ...map[string]interface{}) *Tree <span class="cov8" title="1">{
        return &amp;Tree{
                Name:  name,
                funcs: funcs,
        }
}</span>

// ErrorContext returns a textual representation of the location of the node in the input text.
// The receiver is only used when the node does not have a pointer to the tree inside,
// which can occur in old code.
func (t *Tree) ErrorContext(n Node) (location, context string) <span class="cov8" title="1">{
        pos := int(n.Position())
        tree := n.tree()
        if tree == nil </span><span class="cov0" title="0">{
                tree = t
        }</span>
        <span class="cov8" title="1">text := tree.text[:pos]
        byteNum := strings.LastIndex(text, "\n")
        if byteNum == -1 </span><span class="cov8" title="1">{
                byteNum = pos // On first line.
        }</span> else<span class="cov0" title="0"> {
                byteNum++ // After the newline.
                byteNum = pos - byteNum
        }</span>
        <span class="cov8" title="1">lineNum := 1 + strings.Count(text, "\n")
        context = n.String()
        return fmt.Sprintf("%s:%d:%d", tree.ParseName, lineNum, byteNum), context</span>
}

// errorf formats the error and terminates processing.
func (t *Tree) errorf(format string, args ...interface{}) <span class="cov8" title="1">{
        t.Root = nil
        format = fmt.Sprintf("template: %s:%d: %s", t.ParseName, t.token[0].line, format)
        panic(fmt.Errorf(format, args...))</span>
}

// error terminates processing.
func (t *Tree) error(err error) <span class="cov8" title="1">{
        t.errorf("%s", err)
}</span>

// expect consumes the next token and guarantees it has the required type.
func (t *Tree) expect(expected itemType, context string) item <span class="cov8" title="1">{
        token := t.nextNonSpace()
        if token.typ != expected </span><span class="cov0" title="0">{
                t.unexpected(token, context)
        }</span>
        <span class="cov8" title="1">return token</span>
}

// expectOneOf consumes the next token and guarantees it has one of the required types.
func (t *Tree) expectOneOf(expected1, expected2 itemType, context string) item <span class="cov8" title="1">{
        token := t.nextNonSpace()
        if token.typ != expected1 &amp;&amp; token.typ != expected2 </span><span class="cov8" title="1">{
                t.unexpected(token, context)
        }</span>
        <span class="cov8" title="1">return token</span>
}

// unexpected complains about the token and terminates processing.
func (t *Tree) unexpected(token item, context string) <span class="cov8" title="1">{
        if token.typ == itemError </span><span class="cov8" title="1">{
                extra := ""
                if t.actionLine != 0 &amp;&amp; t.actionLine != token.line </span><span class="cov8" title="1">{
                        extra = fmt.Sprintf(" in action started at %s:%d", t.ParseName, t.actionLine)
                        if strings.HasSuffix(token.val, " action") </span><span class="cov8" title="1">{
                                extra = extra[len(" in action"):] // avoid "action in action"
                        }</span>
                }
                <span class="cov8" title="1">t.errorf("%s%s", token, extra)</span>
        }
        <span class="cov8" title="1">t.errorf("unexpected %s in %s", token, context)</span>
}

// recover is the handler that turns panics into returns from the top level of Parse.
func (t *Tree) recover(errp *error) <span class="cov8" title="1">{
        e := recover()
        if e != nil </span><span class="cov8" title="1">{
                if _, ok := e.(runtime.Error); ok </span><span class="cov0" title="0">{
                        panic(e)</span>
                }
                <span class="cov8" title="1">if t != nil </span><span class="cov8" title="1">{
                        t.lex.drain()
                        t.stopParse()
                }</span>
                <span class="cov8" title="1">*errp = e.(error)</span>
        }
}

// startParse initializes the parser, using the lexer.
func (t *Tree) startParse(funcs []map[string]interface{}, lex *lexer, treeSet map[string]*Tree) <span class="cov8" title="1">{
        t.Root = nil
        t.lex = lex
        t.vars = []string{"$"}
        t.funcs = funcs
        t.treeSet = treeSet
}</span>

// stopParse terminates parsing.
func (t *Tree) stopParse() <span class="cov8" title="1">{
        t.lex = nil
        t.vars = nil
        t.funcs = nil
        t.treeSet = nil
}</span>

// Parse parses the template definition string to construct a representation of
// the template for execution. If either action delimiter string is empty, the
// default ("{{" or "}}") is used. Embedded template definitions are added to
// the treeSet map.
func (t *Tree) Parse(text, leftDelim, rightDelim string, treeSet map[string]*Tree, funcs ...map[string]interface{}) (tree *Tree, err error) <span class="cov8" title="1">{
        defer t.recover(&amp;err)
        t.ParseName = t.Name
        emitComment := t.Mode&amp;ParseComments != 0
        t.startParse(funcs, lex(t.Name, text, leftDelim, rightDelim, emitComment), treeSet)
        t.text = text
        t.parse()
        t.add()
        t.stopParse()
        return t, nil
}</span>

// add adds tree to t.treeSet.
func (t *Tree) add() <span class="cov8" title="1">{
        tree := t.treeSet[t.Name]
        if tree == nil || IsEmptyTree(tree.Root) </span><span class="cov8" title="1">{
                t.treeSet[t.Name] = t
                return
        }</span>
        <span class="cov8" title="1">if !IsEmptyTree(t.Root) </span><span class="cov8" title="1">{
                t.errorf("template: multiple definition of template %q", t.Name)
        }</span>
}

// IsEmptyTree reports whether this tree (node) is empty of everything but space or comments.
func IsEmptyTree(n Node) bool <span class="cov8" title="1">{
        switch n := n.(type) </span>{
        case nil:<span class="cov8" title="1">
                return true</span>
        case *ActionNode:<span class="cov0" title="0"></span>
        case *CommentNode:<span class="cov0" title="0">
                return true</span>
        case *IfNode:<span class="cov8" title="1"></span>
        case *ListNode:<span class="cov8" title="1">
                for _, node := range n.Nodes </span><span class="cov8" title="1">{
                        if !IsEmptyTree(node) </span><span class="cov8" title="1">{
                                return false
                        }</span>
                }
                <span class="cov8" title="1">return true</span>
        case *RangeNode:<span class="cov0" title="0"></span>
        case *TemplateNode:<span class="cov0" title="0"></span>
        case *TextNode:<span class="cov8" title="1">
                return len(bytes.TrimSpace(n.Text)) == 0</span>
        case *WithNode:<span class="cov0" title="0"></span>
        default:<span class="cov0" title="0">
                panic("unknown node: " + n.String())</span>
        }
        <span class="cov8" title="1">return false</span>
}

// parse is the top-level parser for a template, essentially the same
// as itemList except it also parses {{define}} actions.
// It runs to EOF.
func (t *Tree) parse() <span class="cov8" title="1">{
        t.Root = t.newList(t.peek().pos)
        for t.peek().typ != itemEOF </span><span class="cov8" title="1">{
                if t.peek().typ == itemLeftDelim </span><span class="cov8" title="1">{
                        delim := t.next()
                        if t.nextNonSpace().typ == itemDefine </span><span class="cov8" title="1">{
                                newT := New("definition") // name will be updated once we know it.
                                newT.text = t.text
                                newT.Mode = t.Mode
                                newT.ParseName = t.ParseName
                                newT.startParse(t.funcs, t.lex, t.treeSet)
                                newT.parseDefinition()
                                continue</span>
                        }
                        <span class="cov8" title="1">t.backup2(delim)</span>
                }
                <span class="cov8" title="1">switch n := t.textOrAction(); n.Type() </span>{
                case nodeEnd, nodeElse:<span class="cov8" title="1">
                        t.errorf("unexpected %s", n)</span>
                default:<span class="cov8" title="1">
                        t.Root.append(n)</span>
                }
        }
}

// parseDefinition parses a {{define}} ...  {{end}} template definition and
// installs the definition in t.treeSet. The "define" keyword has already
// been scanned.
func (t *Tree) parseDefinition() <span class="cov8" title="1">{
        const context = "define clause"
        name := t.expectOneOf(itemString, itemRawString, context)
        var err error
        t.Name, err = strconv.Unquote(name.val)
        if err != nil </span><span class="cov0" title="0">{
                t.error(err)
        }</span>
        <span class="cov8" title="1">t.expect(itemRightDelim, context)
        var end Node
        t.Root, end = t.itemList()
        if end.Type() != nodeEnd </span><span class="cov0" title="0">{
                t.errorf("unexpected %s in %s", end, context)
        }</span>
        <span class="cov8" title="1">t.add()
        t.stopParse()</span>
}

// itemList:
//        textOrAction*
// Terminates at {{end}} or {{else}}, returned separately.
func (t *Tree) itemList() (list *ListNode, next Node) <span class="cov8" title="1">{
        list = t.newList(t.peekNonSpace().pos)
        for t.peekNonSpace().typ != itemEOF </span><span class="cov8" title="1">{
                n := t.textOrAction()
                switch n.Type() </span>{
                case nodeEnd, nodeElse:<span class="cov8" title="1">
                        return list, n</span>
                }
                <span class="cov8" title="1">list.append(n)</span>
        }
        <span class="cov8" title="1">t.errorf("unexpected EOF")
        return</span>
}

// textOrAction:
//        text | comment | action
func (t *Tree) textOrAction() Node <span class="cov8" title="1">{
        switch token := t.nextNonSpace(); token.typ </span>{
        case itemText:<span class="cov8" title="1">
                return t.newText(token.pos, token.val)</span>
        case itemLeftDelim:<span class="cov8" title="1">
                t.actionLine = token.line
                defer t.clearActionLine()
                return t.action()</span>
        case itemComment:<span class="cov8" title="1">
                return t.newComment(token.pos, token.val)</span>
        default:<span class="cov8" title="1">
                t.unexpected(token, "input")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

func (t *Tree) clearActionLine() <span class="cov8" title="1">{
        t.actionLine = 0
}</span>

// Action:
//        control
//        command ("|" command)*
// Left delim is past. Now get actions.
// First word could be a keyword such as range.
func (t *Tree) action() (n Node) <span class="cov8" title="1">{
        switch token := t.nextNonSpace(); token.typ </span>{
        case itemBlock:<span class="cov8" title="1">
                return t.blockControl()</span>
        case itemElse:<span class="cov8" title="1">
                return t.elseControl()</span>
        case itemEnd:<span class="cov8" title="1">
                return t.endControl()</span>
        case itemIf:<span class="cov8" title="1">
                return t.ifControl()</span>
        case itemRange:<span class="cov8" title="1">
                return t.rangeControl()</span>
        case itemTemplate:<span class="cov8" title="1">
                return t.templateControl()</span>
        case itemWith:<span class="cov8" title="1">
                return t.withControl()</span>
        }
        <span class="cov8" title="1">t.backup()
        token := t.peek()
        // Do not pop variables; they persist until "end".
        return t.newAction(token.pos, token.line, t.pipeline("command", itemRightDelim))</span>
}

// Pipeline:
//        declarations? command ('|' command)*
func (t *Tree) pipeline(context string, end itemType) (pipe *PipeNode) <span class="cov8" title="1">{
        token := t.peekNonSpace()
        pipe = t.newPipeline(token.pos, token.line, nil)
        // Are there declarations or assignments?
</span>decls:
        <span class="cov8" title="1">if v := t.peekNonSpace(); v.typ == itemVariable </span><span class="cov8" title="1">{
                t.next()
                // Since space is a token, we need 3-token look-ahead here in the worst case:
                // in "$x foo" we need to read "foo" (as opposed to ":=") to know that $x is an
                // argument variable rather than a declaration. So remember the token
                // adjacent to the variable so we can push it back if necessary.
                tokenAfterVariable := t.peek()
                next := t.peekNonSpace()
                switch </span>{
                case next.typ == itemAssign, next.typ == itemDeclare:<span class="cov8" title="1">
                        pipe.IsAssign = next.typ == itemAssign
                        t.nextNonSpace()
                        pipe.Decl = append(pipe.Decl, t.newVariable(v.pos, v.val))
                        t.vars = append(t.vars, v.val)</span>
                case next.typ == itemChar &amp;&amp; next.val == ",":<span class="cov8" title="1">
                        t.nextNonSpace()
                        pipe.Decl = append(pipe.Decl, t.newVariable(v.pos, v.val))
                        t.vars = append(t.vars, v.val)
                        if context == "range" &amp;&amp; len(pipe.Decl) &lt; 2 </span><span class="cov8" title="1">{
                                switch t.peekNonSpace().typ </span>{
                                case itemVariable, itemRightDelim, itemRightParen:<span class="cov8" title="1">
                                        // second initialized variable in a range pipeline
                                        goto decls</span>
                                default:<span class="cov8" title="1">
                                        t.errorf("range can only initialize variables")</span>
                                }
                        }
                        <span class="cov8" title="1">t.errorf("too many declarations in %s", context)</span>
                case tokenAfterVariable.typ == itemSpace:<span class="cov8" title="1">
                        t.backup3(v, tokenAfterVariable)</span>
                default:<span class="cov8" title="1">
                        t.backup2(v)</span>
                }
        }
        <span class="cov8" title="1">for </span><span class="cov8" title="1">{
                switch token := t.nextNonSpace(); token.typ </span>{
                case end:<span class="cov8" title="1">
                        // At this point, the pipeline is complete
                        t.checkPipeline(pipe, context)
                        return</span>
                case itemBool, itemCharConstant, itemComplex, itemDot, itemField, itemIdentifier,
                        itemNumber, itemNil, itemRawString, itemString, itemVariable, itemLeftParen:<span class="cov8" title="1">
                        t.backup()
                        pipe.append(t.command())</span>
                default:<span class="cov8" title="1">
                        t.unexpected(token, context)</span>
                }
        }
}

func (t *Tree) checkPipeline(pipe *PipeNode, context string) <span class="cov8" title="1">{
        // Reject empty pipelines
        if len(pipe.Cmds) == 0 </span><span class="cov8" title="1">{
                t.errorf("missing value for %s", context)
        }</span>
        // Only the first command of a pipeline can start with a non executable operand
        <span class="cov8" title="1">for i, c := range pipe.Cmds[1:] </span><span class="cov8" title="1">{
                switch c.Args[0].Type() </span>{
                case NodeBool, NodeDot, NodeNil, NodeNumber, NodeString:<span class="cov8" title="1">
                        // With A|B|C, pipeline stage 2 is B
                        t.errorf("non executable command in pipeline stage %d", i+2)</span>
                }
        }
}

func (t *Tree) parseControl(allowElseIf bool, context string) (pos Pos, line int, pipe *PipeNode, list, elseList *ListNode) <span class="cov8" title="1">{
        defer t.popVars(len(t.vars))
        pipe = t.pipeline(context, itemRightDelim)
        var next Node
        list, next = t.itemList()
        switch next.Type() </span>{
        case nodeEnd:<span class="cov8" title="1"></span> //done
        case nodeElse:<span class="cov8" title="1">
                if allowElseIf </span><span class="cov8" title="1">{
                        // Special case for "else if". If the "else" is followed immediately by an "if",
                        // the elseControl will have left the "if" token pending. Treat
                        //        {{if a}}_{{else if b}}_{{end}}
                        // as
                        //        {{if a}}_{{else}}{{if b}}_{{end}}{{end}}.
                        // To do this, parse the if as usual and stop at it {{end}}; the subsequent{{end}}
                        // is assumed. This technique works even for long if-else-if chains.
                        // TODO: Should we allow else-if in with and range?
                        if t.peek().typ == itemIf </span><span class="cov8" title="1">{
                                t.next() // Consume the "if" token.
                                elseList = t.newList(next.Position())
                                elseList.append(t.ifControl())
                                // Do not consume the next item - only one {{end}} required.
                                break</span>
                        }
                }
                <span class="cov8" title="1">elseList, next = t.itemList()
                if next.Type() != nodeEnd </span><span class="cov8" title="1">{
                        t.errorf("expected end; found %s", next)
                }</span>
        }
        <span class="cov8" title="1">return pipe.Position(), pipe.Line, pipe, list, elseList</span>
}

// If:
//        {{if pipeline}} itemList {{end}}
//        {{if pipeline}} itemList {{else}} itemList {{end}}
// If keyword is past.
func (t *Tree) ifControl() Node <span class="cov8" title="1">{
        return t.newIf(t.parseControl(true, "if"))
}</span>

// Range:
//        {{range pipeline}} itemList {{end}}
//        {{range pipeline}} itemList {{else}} itemList {{end}}
// Range keyword is past.
func (t *Tree) rangeControl() Node <span class="cov8" title="1">{
        return t.newRange(t.parseControl(false, "range"))
}</span>

// With:
//        {{with pipeline}} itemList {{end}}
//        {{with pipeline}} itemList {{else}} itemList {{end}}
// If keyword is past.
func (t *Tree) withControl() Node <span class="cov8" title="1">{
        return t.newWith(t.parseControl(false, "with"))
}</span>

// End:
//        {{end}}
// End keyword is past.
func (t *Tree) endControl() Node <span class="cov8" title="1">{
        return t.newEnd(t.expect(itemRightDelim, "end").pos)
}</span>

// Else:
//        {{else}}
// Else keyword is past.
func (t *Tree) elseControl() Node <span class="cov8" title="1">{
        // Special case for "else if".
        peek := t.peekNonSpace()
        if peek.typ == itemIf </span><span class="cov8" title="1">{
                // We see "{{else if ... " but in effect rewrite it to {{else}}{{if ... ".
                return t.newElse(peek.pos, peek.line)
        }</span>
        <span class="cov8" title="1">token := t.expect(itemRightDelim, "else")
        return t.newElse(token.pos, token.line)</span>
}

// Block:
//        {{block stringValue pipeline}}
// Block keyword is past.
// The name must be something that can evaluate to a string.
// The pipeline is mandatory.
func (t *Tree) blockControl() Node <span class="cov8" title="1">{
        const context = "block clause"

        token := t.nextNonSpace()
        name := t.parseTemplateName(token, context)
        pipe := t.pipeline(context, itemRightDelim)

        block := New(name) // name will be updated once we know it.
        block.text = t.text
        block.Mode = t.Mode
        block.ParseName = t.ParseName
        block.startParse(t.funcs, t.lex, t.treeSet)
        var end Node
        block.Root, end = block.itemList()
        if end.Type() != nodeEnd </span><span class="cov0" title="0">{
                t.errorf("unexpected %s in %s", end, context)
        }</span>
        <span class="cov8" title="1">block.add()
        block.stopParse()

        return t.newTemplate(token.pos, token.line, name, pipe)</span>
}

// Template:
//        {{template stringValue pipeline}}
// Template keyword is past. The name must be something that can evaluate
// to a string.
func (t *Tree) templateControl() Node <span class="cov8" title="1">{
        const context = "template clause"
        token := t.nextNonSpace()
        name := t.parseTemplateName(token, context)
        var pipe *PipeNode
        if t.nextNonSpace().typ != itemRightDelim </span><span class="cov8" title="1">{
                t.backup()
                // Do not pop variables; they persist until "end".
                pipe = t.pipeline(context, itemRightDelim)
        }</span>
        <span class="cov8" title="1">return t.newTemplate(token.pos, token.line, name, pipe)</span>
}

func (t *Tree) parseTemplateName(token item, context string) (name string) <span class="cov8" title="1">{
        switch token.typ </span>{
        case itemString, itemRawString:<span class="cov8" title="1">
                s, err := strconv.Unquote(token.val)
                if err != nil </span><span class="cov0" title="0">{
                        t.error(err)
                }</span>
                <span class="cov8" title="1">name = s</span>
        default:<span class="cov8" title="1">
                t.unexpected(token, context)</span>
        }
        <span class="cov8" title="1">return</span>
}

// command:
//        operand (space operand)*
// space-separated arguments up to a pipeline character or right delimiter.
// we consume the pipe character but leave the right delim to terminate the action.
func (t *Tree) command() *CommandNode <span class="cov8" title="1">{
        cmd := t.newCommand(t.peekNonSpace().pos)
        for </span><span class="cov8" title="1">{
                t.peekNonSpace() // skip leading spaces.
                operand := t.operand()
                if operand != nil </span><span class="cov8" title="1">{
                        cmd.append(operand)
                }</span>
                <span class="cov8" title="1">switch token := t.next(); token.typ </span>{
                case itemSpace:<span class="cov8" title="1">
                        continue</span>
                case itemRightDelim, itemRightParen:<span class="cov8" title="1">
                        t.backup()</span>
                case itemPipe:<span class="cov8" title="1"></span>
                        // nothing here; break loop below
                default:<span class="cov8" title="1">
                        t.unexpected(token, "operand")</span>
                }
                <span class="cov8" title="1">break</span>
        }
        <span class="cov8" title="1">if len(cmd.Args) == 0 </span><span class="cov0" title="0">{
                t.errorf("empty command")
        }</span>
        <span class="cov8" title="1">return cmd</span>
}

// operand:
//        term .Field*
// An operand is a space-separated component of a command,
// a term possibly followed by field accesses.
// A nil return means the next item is not an operand.
func (t *Tree) operand() Node <span class="cov8" title="1">{
        node := t.term()
        if node == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">if t.peek().typ == itemField </span><span class="cov8" title="1">{
                chain := t.newChain(t.peek().pos, node)
                for t.peek().typ == itemField </span><span class="cov8" title="1">{
                        chain.Add(t.next().val)
                }</span>
                // Compatibility with original API: If the term is of type NodeField
                // or NodeVariable, just put more fields on the original.
                // Otherwise, keep the Chain node.
                // Obvious parsing errors involving literal values are detected here.
                // More complex error cases will have to be handled at execution time.
                <span class="cov8" title="1">switch node.Type() </span>{
                case NodeField:<span class="cov8" title="1">
                        node = t.newField(chain.Position(), chain.String())</span>
                case NodeVariable:<span class="cov8" title="1">
                        node = t.newVariable(chain.Position(), chain.String())</span>
                case NodeBool, NodeString, NodeNumber, NodeNil, NodeDot:<span class="cov8" title="1">
                        t.errorf("unexpected . after term %q", node.String())</span>
                default:<span class="cov8" title="1">
                        node = chain</span>
                }
        }
        <span class="cov8" title="1">return node</span>
}

// term:
//        literal (number, string, nil, boolean)
//        function (identifier)
//        .
//        .Field
//        $
//        '(' pipeline ')'
// A term is a simple "expression".
// A nil return means the next item is not a term.
func (t *Tree) term() Node <span class="cov8" title="1">{
        switch token := t.nextNonSpace(); token.typ </span>{
        case itemIdentifier:<span class="cov8" title="1">
                if !t.hasFunction(token.val) </span><span class="cov8" title="1">{
                        t.errorf("function %q not defined", token.val)
                }</span>
                <span class="cov8" title="1">return NewIdentifier(token.val).SetTree(t).SetPos(token.pos)</span>
        case itemDot:<span class="cov8" title="1">
                return t.newDot(token.pos)</span>
        case itemNil:<span class="cov8" title="1">
                return t.newNil(token.pos)</span>
        case itemVariable:<span class="cov8" title="1">
                return t.useVar(token.pos, token.val)</span>
        case itemField:<span class="cov8" title="1">
                return t.newField(token.pos, token.val)</span>
        case itemBool:<span class="cov8" title="1">
                return t.newBool(token.pos, token.val == "true")</span>
        case itemCharConstant, itemComplex, itemNumber:<span class="cov8" title="1">
                number, err := t.newNumber(token.pos, token.val, token.typ)
                if err != nil </span><span class="cov8" title="1">{
                        t.error(err)
                }</span>
                <span class="cov8" title="1">return number</span>
        case itemLeftParen:<span class="cov8" title="1">
                return t.pipeline("parenthesized pipeline", itemRightParen)</span>
        case itemString, itemRawString:<span class="cov8" title="1">
                s, err := strconv.Unquote(token.val)
                if err != nil </span><span class="cov0" title="0">{
                        t.error(err)
                }</span>
                <span class="cov8" title="1">return t.newString(token.pos, token.val, s)</span>
        }
        <span class="cov8" title="1">t.backup()
        return nil</span>
}

// hasFunction reports if a function name exists in the Tree's maps.
func (t *Tree) hasFunction(name string) bool <span class="cov8" title="1">{
        for _, funcMap := range t.funcs </span><span class="cov8" title="1">{
                if funcMap == nil </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov8" title="1">if funcMap[name] != nil </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// popVars trims the variable list to the specified length
func (t *Tree) popVars(n int) <span class="cov8" title="1">{
        t.vars = t.vars[:n]
}</span>

// useVar returns a node for a variable reference. It errors if the
// variable is not defined.
func (t *Tree) useVar(pos Pos, name string) Node <span class="cov8" title="1">{
        v := t.newVariable(pos, name)
        for _, varName := range t.vars </span><span class="cov8" title="1">{
                if varName == v.Ident[0] </span><span class="cov8" title="1">{
                        return v
                }</span>
        }
        <span class="cov8" title="1">t.errorf("undefined variable %q", v.Ident[0])
        return nil</span>
}
</pre>
		
		<pre class="file" id="file324" style="display: none">// Copyright 2011 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

package template

import (
        "reflect"
        "sync"

        "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/parse"
)

// common holds the information shared by related templates.
type common struct {
        muTmpl sync.RWMutex         // protects tmpl (temporary Hugo-fix)
        tmpl   map[string]*Template // Map from name to defined templates.
        option option
        // We use two maps, one for parsing and one for execution.
        // This separation makes the API cleaner since it doesn't
        // expose reflection to the client.
        muFuncs    sync.RWMutex // protects parseFuncs and execFuncs
        parseFuncs FuncMap
        execFuncs  map[string]reflect.Value
}

// Template is the representation of a parsed template. The *parse.Tree
// field is exported only for use by html/template and should be treated
// as unexported by all other clients.
type Template struct {
        name string
        *parse.Tree
        *common
        leftDelim  string
        rightDelim string
}

// New allocates a new, undefined template with the given name.
func New(name string) *Template <span class="cov8" title="1">{
        t := &amp;Template{
                name: name,
        }
        t.init()
        return t
}</span>

// Name returns the name of the template.
func (t *Template) Name() string <span class="cov8" title="1">{
        return t.name
}</span>

// New allocates a new, undefined template associated with the given one and with the same
// delimiters. The association, which is transitive, allows one template to
// invoke another with a {{template}} action.
//
// Because associated templates share underlying data, template construction
// cannot be done safely in parallel. Once the templates are constructed, they
// can be executed in parallel.
func (t *Template) New(name string) *Template <span class="cov8" title="1">{
        t.init()
        nt := &amp;Template{
                name:       name,
                common:     t.common,
                leftDelim:  t.leftDelim,
                rightDelim: t.rightDelim,
        }
        return nt
}</span>

// init guarantees that t has a valid common structure.
func (t *Template) init() <span class="cov8" title="1">{
        if t.common == nil </span><span class="cov8" title="1">{
                c := new(common)
                c.tmpl = make(map[string]*Template)
                c.parseFuncs = make(FuncMap)
                c.execFuncs = make(map[string]reflect.Value)
                t.common = c
        }</span>
}

// Clone returns a duplicate of the template, including all associated
// templates. The actual representation is not copied, but the name space of
// associated templates is, so further calls to Parse in the copy will add
// templates to the copy but not to the original. Clone can be used to prepare
// common templates and use them with variant definitions for other templates
// by adding the variants after the clone is made.
func (t *Template) Clone() (*Template, error) <span class="cov8" title="1">{
        nt := t.copy(nil)
        nt.init()
        if t.common == nil </span><span class="cov0" title="0">{
                return nt, nil
        }</span>
        // temporary Hugo-fix
        <span class="cov8" title="1">t.muTmpl.RLock()
        defer t.muTmpl.RUnlock()
        for k, v := range t.tmpl </span><span class="cov8" title="1">{
                if k == t.name </span><span class="cov8" title="1">{
                        nt.tmpl[t.name] = nt
                        continue</span>
                }
                // The associated templates share nt's common structure.
                <span class="cov8" title="1">tmpl := v.copy(nt.common)
                nt.tmpl[k] = tmpl</span>
        }
        <span class="cov8" title="1">t.muFuncs.RLock()
        defer t.muFuncs.RUnlock()
        for k, v := range t.parseFuncs </span><span class="cov0" title="0">{
                nt.parseFuncs[k] = v
        }</span>
        <span class="cov8" title="1">for k, v := range t.execFuncs </span><span class="cov0" title="0">{
                nt.execFuncs[k] = v
        }</span>
        <span class="cov8" title="1">return nt, nil</span>
}

// copy returns a shallow copy of t, with common set to the argument.
func (t *Template) copy(c *common) *Template <span class="cov8" title="1">{
        return &amp;Template{
                name:       t.name,
                Tree:       t.Tree,
                common:     c,
                leftDelim:  t.leftDelim,
                rightDelim: t.rightDelim,
        }
}</span>

// AddParseTree associates the argument parse tree with the template t, giving
// it the specified name. If the template has not been defined, this tree becomes
// its definition. If it has been defined and already has that name, the existing
// definition is replaced; otherwise a new template is created, defined, and returned.
func (t *Template) AddParseTree(name string, tree *parse.Tree) (*Template, error) <span class="cov8" title="1">{
        // temporary Hugo-fix
        t.muTmpl.Lock()
        defer t.muTmpl.Unlock()
        t.init()
        nt := t
        if name != t.name </span><span class="cov8" title="1">{
                nt = t.New(name)
        }</span>
        // Even if nt == t, we need to install it in the common.tmpl map.
        <span class="cov8" title="1">if t.associate(nt, tree) || nt.Tree == nil </span><span class="cov8" title="1">{
                nt.Tree = tree
        }</span>
        <span class="cov8" title="1">return nt, nil</span>
}

// Templates returns a slice of defined templates associated with t.
func (t *Template) Templates() []*Template <span class="cov8" title="1">{
        if t.common == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        // Return a slice so we don't expose the map.
        // temporary Hugo-fix
        <span class="cov8" title="1">t.muTmpl.RLock()
        defer t.muTmpl.RUnlock()
        m := make([]*Template, 0, len(t.tmpl))
        for _, v := range t.tmpl </span><span class="cov8" title="1">{
                m = append(m, v)
        }</span>
        <span class="cov8" title="1">return m</span>
}

// Delims sets the action delimiters to the specified strings, to be used in
// subsequent calls to Parse, ParseFiles, or ParseGlob. Nested template
// definitions will inherit the settings. An empty delimiter stands for the
// corresponding default: {{ or }}.
// The return value is the template, so calls can be chained.
func (t *Template) Delims(left, right string) *Template <span class="cov8" title="1">{
        t.init()
        t.leftDelim = left
        t.rightDelim = right
        return t
}</span>

// Funcs adds the elements of the argument map to the template's function map.
// It must be called before the template is parsed.
// It panics if a value in the map is not a function with appropriate return
// type or if the name cannot be used syntactically as a function in a template.
// It is legal to overwrite elements of the map. The return value is the template,
// so calls can be chained.
func (t *Template) Funcs(funcMap FuncMap) *Template <span class="cov8" title="1">{
        t.init()
        t.muFuncs.Lock()
        defer t.muFuncs.Unlock()
        addValueFuncs(t.execFuncs, funcMap)
        addFuncs(t.parseFuncs, funcMap)
        return t
}</span>

// Lookup returns the template with the given name that is associated with t.
// It returns nil if there is no such template or the template has no definition.
func (t *Template) Lookup(name string) *Template <span class="cov8" title="1">{
        if t.common == nil </span><span class="cov8" title="1">{
                return nil
        }</span>
        // temporary Hugo-fix
        <span class="cov8" title="1">t.muTmpl.RLock()
        defer t.muTmpl.RUnlock()
        return t.tmpl[name]</span>
}

// Parse parses text as a template body for t.
// Named template definitions ({{define ...}} or {{block ...}} statements) in text
// define additional templates associated with t and are removed from the
// definition of t itself.
//
// Templates can be redefined in successive calls to Parse.
// A template definition with a body containing only white space and comments
// is considered empty and will not replace an existing template's body.
// This allows using Parse to add new named template definitions without
// overwriting the main template body.
func (t *Template) Parse(text string) (*Template, error) <span class="cov8" title="1">{
        t.init()
        t.muFuncs.RLock()
        trees, err := parse.Parse(t.name, text, t.leftDelim, t.rightDelim, t.parseFuncs, builtins())
        t.muFuncs.RUnlock()
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>
        // Add the newly parsed trees, including the one for t, into our common structure.
        <span class="cov8" title="1">for name, tree := range trees </span><span class="cov8" title="1">{
                if _, err := t.AddParseTree(name, tree); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }
        <span class="cov8" title="1">return t, nil</span>
}

// associate installs the new template into the group of templates associated
// with t. The two are already known to share the common structure.
// The boolean return value reports whether to store this tree as t.Tree.
func (t *Template) associate(new *Template, tree *parse.Tree) bool <span class="cov8" title="1">{
        if new.common != t.common </span><span class="cov0" title="0">{
                panic("internal error: associate not common")</span>
        }
        <span class="cov8" title="1">if old := t.tmpl[new.name]; old != nil &amp;&amp; parse.IsEmptyTree(tree.Root) &amp;&amp; old.Tree != nil </span><span class="cov8" title="1">{
                // If a template by that name exists,
                // don't replace it with an empty template.
                return false
        }</span>
        <span class="cov8" title="1">t.tmpl[new.name] = new
        return true</span>
}
</pre>
		
		<pre class="file" id="file325" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Portions Copyright The Go Authors.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package internal

import (
        "bytes"
        "encoding/json"
        "fmt"
        "go/doc"
        "go/parser"
        "go/token"
        "io/ioutil"
        "log"
        "os"
        "path/filepath"
        "reflect"
        "runtime"
        "strings"
        "sync"

        "github.com/gohugoio/hugo/deps"
)

// TemplateFuncsNamespaceRegistry describes a registry of functions that provide
// namespaces.
var TemplateFuncsNamespaceRegistry []func(d *deps.Deps) *TemplateFuncsNamespace

// AddTemplateFuncsNamespace adds a given function to a registry.
func AddTemplateFuncsNamespace(ns func(d *deps.Deps) *TemplateFuncsNamespace) <span class="cov0" title="0">{
        TemplateFuncsNamespaceRegistry = append(TemplateFuncsNamespaceRegistry, ns)
}</span>

// TemplateFuncsNamespace represents a template function namespace.
type TemplateFuncsNamespace struct {
        // The namespace name, "strings", "lang", etc.
        Name string

        // This is the method receiver.
        Context func(v ...interface{}) (interface{}, error)

        // Additional info, aliases and examples, per method name.
        MethodMappings map[string]TemplateFuncMethodMapping
}

// TemplateFuncsNamespaces is a slice of TemplateFuncsNamespace.
type TemplateFuncsNamespaces []*TemplateFuncsNamespace

// AddMethodMapping adds a method to a template function namespace.
func (t *TemplateFuncsNamespace) AddMethodMapping(m interface{}, aliases []string, examples [][2]string) <span class="cov0" title="0">{
        if t.MethodMappings == nil </span><span class="cov0" title="0">{
                t.MethodMappings = make(map[string]TemplateFuncMethodMapping)
        }</span>

        <span class="cov0" title="0">name := methodToName(m)

        // sanity check
        for _, e := range examples </span><span class="cov0" title="0">{
                if e[0] == "" </span><span class="cov0" title="0">{
                        panic(t.Name + ": Empty example for " + name)</span>
                }
        }
        <span class="cov0" title="0">for _, a := range aliases </span><span class="cov0" title="0">{
                if a == "" </span><span class="cov0" title="0">{
                        panic(t.Name + ": Empty alias for " + name)</span>
                }
        }

        <span class="cov0" title="0">t.MethodMappings[name] = TemplateFuncMethodMapping{
                Method:   m,
                Aliases:  aliases,
                Examples: examples,
        }</span>
}

// TemplateFuncMethodMapping represents a mapping of functions to methods for a
// given namespace.
type TemplateFuncMethodMapping struct {
        Method interface{}

        // Any template funcs aliases. This is mainly motivated by keeping
        // backwards compatibility, but some new template funcs may also make
        // sense to give short and snappy aliases.
        // Note that these aliases are global and will be merged, so the last
        // key will win.
        Aliases []string

        // A slice of input/expected examples.
        // We keep it a the namespace level for now, but may find a way to keep track
        // of the single template func, for documentation purposes.
        // Some of these, hopefully just a few, may depend on some test data to run.
        Examples [][2]string
}

func methodToName(m interface{}) string <span class="cov8" title="1">{
        name := runtime.FuncForPC(reflect.ValueOf(m).Pointer()).Name()
        name = filepath.Ext(name)
        name = strings.TrimPrefix(name, ".")
        name = strings.TrimSuffix(name, "-fm")
        return name
}</span>

type goDocFunc struct {
        Name        string
        Description string
        Args        []string
        Aliases     []string
        Examples    [][2]string
}

func (t goDocFunc) toJSON() ([]byte, error) <span class="cov0" title="0">{
        args, err := json.Marshal(t.Args)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">aliases, err := json.Marshal(t.Aliases)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">examples, err := json.Marshal(t.Examples)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">var buf bytes.Buffer
        buf.WriteString(fmt.Sprintf(`%q:
    { "Description": %q, "Args": %s, "Aliases": %s, "Examples": %s }        
`, t.Name, t.Description, args, aliases, examples))

        return buf.Bytes(), nil</span>
}

// MarshalJSON returns the JSON encoding of namespaces.
func (namespaces TemplateFuncsNamespaces) MarshalJSON() ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer

        buf.WriteString("{")

        for i, ns := range namespaces </span><span class="cov0" title="0">{
                if i != 0 </span><span class="cov0" title="0">{
                        buf.WriteString(",")
                }</span>
                <span class="cov0" title="0">b, err := ns.toJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">buf.Write(b)</span>
        }

        <span class="cov0" title="0">buf.WriteString("}")

        return buf.Bytes(), nil</span>
}

func (t *TemplateFuncsNamespace) toJSON() ([]byte, error) <span class="cov0" title="0">{
        var buf bytes.Buffer

        godoc := getGetTplPackagesGoDoc()[t.Name]

        var funcs []goDocFunc

        buf.WriteString(fmt.Sprintf(`%q: {`, t.Name))

        ctx, err := t.Context()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">ctxType := reflect.TypeOf(ctx)
        for i := 0; i &lt; ctxType.NumMethod(); i++ </span><span class="cov0" title="0">{
                method := ctxType.Method(i)
                f := goDocFunc{
                        Name: method.Name,
                }

                methodGoDoc := godoc[method.Name]

                if mapping, ok := t.MethodMappings[method.Name]; ok </span><span class="cov0" title="0">{
                        f.Aliases = mapping.Aliases
                        f.Examples = mapping.Examples
                        f.Description = methodGoDoc.Description
                        f.Args = methodGoDoc.Args
                }</span>

                <span class="cov0" title="0">funcs = append(funcs, f)</span>
        }

        <span class="cov0" title="0">for i, f := range funcs </span><span class="cov0" title="0">{
                if i != 0 </span><span class="cov0" title="0">{
                        buf.WriteString(",")
                }</span>
                <span class="cov0" title="0">funcStr, err := f.toJSON()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov0" title="0">buf.Write(funcStr)</span>
        }

        <span class="cov0" title="0">buf.WriteString("}")

        return buf.Bytes(), nil</span>
}

type methodGoDocInfo struct {
        Description string
        Args        []string
}

var (
        tplPackagesGoDoc     map[string]map[string]methodGoDocInfo
        tplPackagesGoDocInit sync.Once
)

func getGetTplPackagesGoDoc() map[string]map[string]methodGoDocInfo <span class="cov0" title="0">{
        tplPackagesGoDocInit.Do(func() </span><span class="cov0" title="0">{
                tplPackagesGoDoc = make(map[string]map[string]methodGoDocInfo)
                pwd, err := os.Getwd()
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">fset := token.NewFileSet()

                // pwd will be inside one of the namespace packages during tests
                var basePath string
                if strings.Contains(pwd, "tpl") </span><span class="cov0" title="0">{
                        basePath = filepath.Join(pwd, "..")
                }</span> else<span class="cov0" title="0"> {
                        basePath = filepath.Join(pwd, "tpl")
                }</span>

                <span class="cov0" title="0">files, err := ioutil.ReadDir(basePath)
                if err != nil </span><span class="cov0" title="0">{
                        log.Fatal(err)
                }</span>

                <span class="cov0" title="0">for _, fi := range files </span><span class="cov0" title="0">{
                        if !fi.IsDir() </span><span class="cov0" title="0">{
                                continue</span>
                        }

                        <span class="cov0" title="0">namespaceDoc := make(map[string]methodGoDocInfo)
                        packagePath := filepath.Join(basePath, fi.Name())

                        d, err := parser.ParseDir(fset, packagePath, nil, parser.ParseComments)
                        if err != nil </span><span class="cov0" title="0">{
                                log.Fatal(err)
                        }</span>

                        <span class="cov0" title="0">for _, f := range d </span><span class="cov0" title="0">{
                                p := doc.New(f, "./", 0)

                                for _, t := range p.Types </span><span class="cov0" title="0">{
                                        if t.Name == "Namespace" </span><span class="cov0" title="0">{
                                                for _, tt := range t.Methods </span><span class="cov0" title="0">{
                                                        var args []string
                                                        for _, p := range tt.Decl.Type.Params.List </span><span class="cov0" title="0">{
                                                                for _, pp := range p.Names </span><span class="cov0" title="0">{
                                                                        args = append(args, pp.Name)
                                                                }</span>
                                                        }

                                                        <span class="cov0" title="0">description := strings.TrimSpace(tt.Doc)
                                                        di := methodGoDocInfo{Description: description, Args: args}
                                                        namespaceDoc[tt.Name] = di</span>
                                                }
                                        }
                                }
                        }

                        <span class="cov0" title="0">tplPackagesGoDoc[fi.Name()] = namespaceDoc</span>
                }
        })

        <span class="cov0" title="0">return tplPackagesGoDoc</span>
}
</pre>
		
		<pre class="file" id="file326" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package lang

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "lang"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d, langs.GetTranslator(d.Language))

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Translate,
                        []string{"i18n", "T"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.FormatNumber,
                        nil,
                        [][2]string{
                                {`{{ 512.5032 | lang.FormatNumber 2 }}`, `512.50`},
                        },
                )

                ns.AddMethodMapping(ctx.FormatPercent,
                        nil,
                        [][2]string{
                                {`{{ 512.5032 | lang.FormatPercent 2 }}`, `512.50%`},
                        },
                )

                ns.AddMethodMapping(ctx.FormatCurrency,
                        nil,
                        [][2]string{
                                {`{{ 512.5032 | lang.FormatCurrency 2 "USD" }}`, `$512.50`},
                        },
                )

                ns.AddMethodMapping(ctx.FormatAccounting,
                        nil,
                        [][2]string{
                                {`{{ 512.5032 | lang.FormatAccounting 2 "NOK" }}`, `NOK512.50`},
                        },
                )

                ns.AddMethodMapping(ctx.FormatNumberCustom,
                        nil,
                        [][2]string{
                                {`{{ lang.FormatNumberCustom 2 12345.6789 }}`, `12,345.68`},
                                {`{{ lang.FormatNumberCustom 2 12345.6789 "- , ." }}`, `12.345,68`},
                                {`{{ lang.FormatNumberCustom 6 -12345.6789 "- ." }}`, `-12345.678900`},
                                {`{{ lang.FormatNumberCustom 0 -12345.6789 "- . ," }}`, `-12,346`},
                                {`{{ -98765.4321 | lang.FormatNumberCustom 2 }}`, `-98,765.43`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file327" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package lang provides template functions for content internationalization.
package lang

import (
        "fmt"
        "math"
        "strconv"
        "strings"

        "github.com/gohugoio/locales"
        translators "github.com/gohugoio/localescompressed"
        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/deps"
        "github.com/spf13/cast"
)

// New returns a new instance of the lang-namespaced template functions.
func New(deps *deps.Deps, translator locales.Translator) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                translator: translator,
                deps:       deps,
        }
}</span>

// Namespace provides template functions for the "lang" namespace.
type Namespace struct {
        translator locales.Translator
        deps       *deps.Deps
}

// Translate returns a translated string for id.
func (ns *Namespace) Translate(id interface{}, args ...interface{}) (string, error) <span class="cov0" title="0">{
        var templateData interface{}

        if len(args) &gt; 0 </span><span class="cov0" title="0">{
                if len(args) &gt; 1 </span><span class="cov0" title="0">{
                        return "", errors.Errorf("wrong number of arguments, expecting at most 2, got %d", len(args)+1)
                }</span>
                <span class="cov0" title="0">templateData = args[0]</span>
        }

        <span class="cov0" title="0">sid, err := cast.ToStringE(id)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">return ns.deps.Translate(sid, templateData), nil</span>
}

// FormatNumber formats number with the given precision for the current language.
func (ns *Namespace) FormatNumber(precision, number interface{}) (string, error) <span class="cov8" title="1">{
        p, n, err := ns.castPrecisionNumber(precision, number)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return ns.translator.FmtNumber(n, p), nil</span>
}

// FormatPercent formats number with the given precision for the current language.
// Note that the number is assumed to be a percentage.
func (ns *Namespace) FormatPercent(precision, number interface{}) (string, error) <span class="cov8" title="1">{
        p, n, err := ns.castPrecisionNumber(precision, number)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">return ns.translator.FmtPercent(n, p), nil</span>
}

// FormatCurrency returns the currency representation of number for the given currency and precision
// for the current language.
//
// The return value is formatted with at least two decimal places.
func (ns *Namespace) FormatCurrency(precision, currency, number interface{}) (string, error) <span class="cov8" title="1">{
        p, n, err := ns.castPrecisionNumber(precision, number)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">c := translators.GetCurrency(cast.ToString(currency))
        if c &lt; 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unknown currency code: %q", currency)
        }</span>
        <span class="cov8" title="1">return ns.translator.FmtCurrency(n, p, c), nil</span>
}

// FormatAccounting returns the currency representation of number for the given currency and precision
// for the current language in accounting notation.
//
// The return value is formatted with at least two decimal places.
func (ns *Namespace) FormatAccounting(precision, currency, number interface{}) (string, error) <span class="cov8" title="1">{
        p, n, err := ns.castPrecisionNumber(precision, number)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">c := translators.GetCurrency(cast.ToString(currency))
        if c &lt; 0 </span><span class="cov0" title="0">{
                return "", fmt.Errorf("unknown currency code: %q", currency)
        }</span>
        <span class="cov8" title="1">return ns.translator.FmtAccounting(n, p, c), nil</span>
}

func (ns *Namespace) castPrecisionNumber(precision, number interface{}) (uint64, float64, error) <span class="cov8" title="1">{
        p, err := cast.ToUint64E(precision)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>

        // Sanity check.
        <span class="cov8" title="1">if p &gt; 20 </span><span class="cov0" title="0">{
                return 0, 0, fmt.Errorf("invalid precision: %d", precision)
        }</span>

        <span class="cov8" title="1">n, err := cast.ToFloat64E(number)
        if err != nil </span><span class="cov0" title="0">{
                return 0, 0, err
        }</span>
        <span class="cov8" title="1">return p, n, nil</span>
}

// FormatNumberCustom formats a number with the given precision using the
// negative, decimal, and grouping options.  The `options`
// parameter is a string consisting of `&lt;negative&gt; &lt;decimal&gt; &lt;grouping&gt;`.  The
// default `options` value is `- . ,`.
//
// Note that numbers are rounded up at 5 or greater.
// So, with precision set to 0, 1.5 becomes `2`, and 1.4 becomes `1`.
//
// For a simpler function that adapts to the current language, see FormatNumber.
func (ns *Namespace) FormatNumberCustom(precision, number interface{}, options ...interface{}) (string, error) <span class="cov8" title="1">{
        prec, err := cast.ToIntE(precision)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">n, err := cast.ToFloat64E(number)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">var neg, dec, grp string

        if len(options) == 0 </span><span class="cov8" title="1">{
                // defaults
                neg, dec, grp = "-", ".", ","
        }</span> else<span class="cov8" title="1"> {
                delim := " "

                if len(options) == 2 </span><span class="cov8" title="1">{
                        // custom delimiter
                        s, err := cast.ToStringE(options[1])
                        if err != nil </span><span class="cov0" title="0">{
                                return "", nil
                        }</span>

                        <span class="cov8" title="1">delim = s</span>
                }

                <span class="cov8" title="1">s, err := cast.ToStringE(options[0])
                if err != nil </span><span class="cov0" title="0">{
                        return "", nil
                }</span>

                <span class="cov8" title="1">rs := strings.Split(s, delim)
                switch len(rs) </span>{
                case 0:<span class="cov0" title="0"></span>
                case 1:<span class="cov0" title="0">
                        neg = rs[0]</span>
                case 2:<span class="cov8" title="1">
                        neg, dec = rs[0], rs[1]</span>
                case 3:<span class="cov8" title="1">
                        neg, dec, grp = rs[0], rs[1], rs[2]</span>
                default:<span class="cov0" title="0">
                        return "", errors.New("too many fields in options parameter to NumFmt")</span>
                }
        }

        <span class="cov8" title="1">exp := math.Pow(10.0, float64(prec))
        r := math.Round(n*exp) / exp

        // Logic from MIT Licensed github.com/gohugoio/locales/
        // Original Copyright (c) 2016 Go Playground

        s := strconv.FormatFloat(math.Abs(r), 'f', prec, 64)
        L := len(s) + 2 + len(s[:len(s)-1-prec])/3

        var count int
        inWhole := prec == 0
        b := make([]byte, 0, L)

        for i := len(s) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                if s[i] == '.' </span><span class="cov8" title="1">{
                        for j := len(dec) - 1; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                                b = append(b, dec[j])
                        }</span>
                        <span class="cov8" title="1">inWhole = true
                        continue</span>
                }

                <span class="cov8" title="1">if inWhole </span><span class="cov8" title="1">{
                        if count == 3 </span><span class="cov8" title="1">{
                                for j := len(grp) - 1; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                                        b = append(b, grp[j])
                                }</span>
                                <span class="cov8" title="1">count = 1</span>
                        } else<span class="cov8" title="1"> {
                                count++
                        }</span>
                }

                <span class="cov8" title="1">b = append(b, s[i])</span>
        }

        <span class="cov8" title="1">if n &lt; 0 </span><span class="cov8" title="1">{
                for j := len(neg) - 1; j &gt;= 0; j-- </span><span class="cov8" title="1">{
                        b = append(b, neg[j])
                }</span>
        }

        // reverse
        <span class="cov8" title="1">for i, j := 0, len(b)-1; i &lt; j; i, j = i+1, j-1 </span><span class="cov8" title="1">{
                b[i], b[j] = b[j], b[i]
        }</span>

        <span class="cov8" title="1">return string(b), nil</span>
}

// NumFmt is deprecated, use FormatNumberCustom.
// We renamed this in Hugo 0.87.
// Deprecated: Use FormatNumberCustom
func (ns *Namespace) NumFmt(precision, number interface{}, options ...interface{}) (string, error) <span class="cov0" title="0">{
        return ns.FormatNumberCustom(precision, number, options...)
}</span>

type pagesLanguageMerger interface {
        MergeByLanguageInterface(other interface{}) (interface{}, error)
}

// Merge creates a union of pages from two languages.
func (ns *Namespace) Merge(p2, p1 interface{}) (interface{}, error) <span class="cov0" title="0">{
        merger, ok := p1.(pagesLanguageMerger)
        if !ok </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("language merge not supported for %T", p1)
        }</span>
        <span class="cov0" title="0">return merger.MergeByLanguageInterface(p2)</span>
}
</pre>
		
		<pre class="file" id="file328" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package math

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "math"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Add,
                        []string{"add"},
                        [][2]string{
                                {"{{add 1 2}}", "3"},
                        },
                )

                ns.AddMethodMapping(ctx.Ceil,
                        nil,
                        [][2]string{
                                {"{{math.Ceil 2.1}}", "3"},
                        },
                )

                ns.AddMethodMapping(ctx.Div,
                        []string{"div"},
                        [][2]string{
                                {"{{div 6 3}}", "2"},
                        },
                )

                ns.AddMethodMapping(ctx.Floor,
                        nil,
                        [][2]string{
                                {"{{math.Floor 1.9}}", "1"},
                        },
                )

                ns.AddMethodMapping(ctx.Log,
                        nil,
                        [][2]string{
                                {"{{math.Log 1}}", "0"},
                        },
                )

                ns.AddMethodMapping(ctx.Max,
                        nil,
                        [][2]string{
                                {"{{math.Max 1 2 }}", "2"},
                        },
                )

                ns.AddMethodMapping(ctx.Min,
                        nil,
                        [][2]string{
                                {"{{math.Min 1 2 }}", "1"},
                        },
                )

                ns.AddMethodMapping(ctx.Mod,
                        []string{"mod"},
                        [][2]string{
                                {"{{mod 15 3}}", "0"},
                        },
                )

                ns.AddMethodMapping(ctx.ModBool,
                        []string{"modBool"},
                        [][2]string{
                                {"{{modBool 15 3}}", "true"},
                        },
                )

                ns.AddMethodMapping(ctx.Mul,
                        []string{"mul"},
                        [][2]string{
                                {"{{mul 2 3}}", "6"},
                        },
                )

                ns.AddMethodMapping(ctx.Pow,
                        []string{"pow"},
                        [][2]string{
                                {"{{math.Pow 2 3}}", "8"},
                        },
                )

                ns.AddMethodMapping(ctx.Round,
                        nil,
                        [][2]string{
                                {"{{math.Round 1.5}}", "2"},
                        },
                )

                ns.AddMethodMapping(ctx.Sqrt,
                        nil,
                        [][2]string{
                                {"{{math.Sqrt 81}}", "9"},
                        },
                )

                ns.AddMethodMapping(ctx.Sub,
                        []string{"sub"},
                        [][2]string{
                                {"{{sub 3 2}}", "1"},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file329" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package math provides template functions for mathematical operations.
package math

import (
        "errors"
        "math"

        _math "github.com/gohugoio/hugo/common/math"

        "github.com/spf13/cast"
)

// New returns a new instance of the math-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "math" namespace.
type Namespace struct{}

// Add adds two numbers.
func (ns *Namespace) Add(a, b interface{}) (interface{}, error) <span class="cov8" title="1">{
        return _math.DoArithmetic(a, b, '+')
}</span>

// Ceil returns the least integer value greater than or equal to x.
func (ns *Namespace) Ceil(x interface{}) (float64, error) <span class="cov8" title="1">{
        xf, err := cast.ToFloat64E(x)
        if err != nil </span><span class="cov8" title="1">{
                return 0, errors.New("Ceil operator can't be used with non-float value")
        }</span>

        <span class="cov8" title="1">return math.Ceil(xf), nil</span>
}

// Div divides two numbers.
func (ns *Namespace) Div(a, b interface{}) (interface{}, error) <span class="cov8" title="1">{
        return _math.DoArithmetic(a, b, '/')
}</span>

// Floor returns the greatest integer value less than or equal to x.
func (ns *Namespace) Floor(x interface{}) (float64, error) <span class="cov8" title="1">{
        xf, err := cast.ToFloat64E(x)
        if err != nil </span><span class="cov8" title="1">{
                return 0, errors.New("Floor operator can't be used with non-float value")
        }</span>

        <span class="cov8" title="1">return math.Floor(xf), nil</span>
}

// Log returns the natural logarithm of a number.
func (ns *Namespace) Log(a interface{}) (float64, error) <span class="cov8" title="1">{
        af, err := cast.ToFloat64E(a)
        if err != nil </span><span class="cov8" title="1">{
                return 0, errors.New("Log operator can't be used with non integer or float value")
        }</span>

        <span class="cov8" title="1">return math.Log(af), nil</span>
}

// Max returns the greater of two numbers.
func (ns *Namespace) Max(a, b interface{}) (float64, error) <span class="cov8" title="1">{
        af, erra := cast.ToFloat64E(a)
        bf, errb := cast.ToFloat64E(b)

        if erra != nil || errb != nil </span><span class="cov8" title="1">{
                return 0, errors.New("Max operator can't be used with non-float value")
        }</span>

        <span class="cov8" title="1">return math.Max(af, bf), nil</span>
}

// Min returns the smaller of two numbers.
func (ns *Namespace) Min(a, b interface{}) (float64, error) <span class="cov8" title="1">{
        af, erra := cast.ToFloat64E(a)
        bf, errb := cast.ToFloat64E(b)

        if erra != nil || errb != nil </span><span class="cov8" title="1">{
                return 0, errors.New("Min operator can't be used with non-float value")
        }</span>

        <span class="cov8" title="1">return math.Min(af, bf), nil</span>
}

// Mod returns a % b.
func (ns *Namespace) Mod(a, b interface{}) (int64, error) <span class="cov8" title="1">{
        ai, erra := cast.ToInt64E(a)
        bi, errb := cast.ToInt64E(b)

        if erra != nil || errb != nil </span><span class="cov8" title="1">{
                return 0, errors.New("modulo operator can't be used with non integer value")
        }</span>

        <span class="cov8" title="1">if bi == 0 </span><span class="cov8" title="1">{
                return 0, errors.New("the number can't be divided by zero at modulo operation")
        }</span>

        <span class="cov8" title="1">return ai % bi, nil</span>
}

// ModBool returns the boolean of a % b.  If a % b == 0, return true.
func (ns *Namespace) ModBool(a, b interface{}) (bool, error) <span class="cov8" title="1">{
        res, err := ns.Mod(a, b)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return res == int64(0), nil</span>
}

// Mul multiplies two numbers.
func (ns *Namespace) Mul(a, b interface{}) (interface{}, error) <span class="cov8" title="1">{
        return _math.DoArithmetic(a, b, '*')
}</span>

// Pow returns a raised to the power of b.
func (ns *Namespace) Pow(a, b interface{}) (float64, error) <span class="cov8" title="1">{
        af, erra := cast.ToFloat64E(a)
        bf, errb := cast.ToFloat64E(b)

        if erra != nil || errb != nil </span><span class="cov8" title="1">{
                return 0, errors.New("Pow operator can't be used with non-float value")
        }</span>

        <span class="cov8" title="1">return math.Pow(af, bf), nil</span>
}

// Round returns the nearest integer, rounding half away from zero.
func (ns *Namespace) Round(x interface{}) (float64, error) <span class="cov8" title="1">{
        xf, err := cast.ToFloat64E(x)
        if err != nil </span><span class="cov8" title="1">{
                return 0, errors.New("Round operator can't be used with non-float value")
        }</span>

        <span class="cov8" title="1">return _round(xf), nil</span>
}

// Sqrt returns the square root of a number.
func (ns *Namespace) Sqrt(a interface{}) (float64, error) <span class="cov8" title="1">{
        af, err := cast.ToFloat64E(a)
        if err != nil </span><span class="cov8" title="1">{
                return 0, errors.New("Sqrt operator can't be used with non integer or float value")
        }</span>

        <span class="cov8" title="1">return math.Sqrt(af), nil</span>
}

// Sub subtracts two numbers.
func (ns *Namespace) Sub(a, b interface{}) (interface{}, error) <span class="cov8" title="1">{
        return _math.DoArithmetic(a, b, '-')
}</span>
</pre>
		
		<pre class="file" id="file330" style="display: none">// Copyright 2009 The Go Authors. All rights reserved.
// Use of this source code is governed by a BSD-style
// license that can be found in the LICENSE file.

// According to https://github.com/golang/go/issues/20100, the Go stdlib will
// include math.Round beginning with Go 1.10.
//
// The following implementation was taken from https://golang.org/cl/43652.

package math

import "math"

const (
        mask  = 0x7FF
        shift = 64 - 11 - 1
        bias  = 1023
)

// Round returns the nearest integer, rounding half away from zero.
//
// Special cases are:
//        Round(±0) = ±0
//        Round(±Inf) = ±Inf
//        Round(NaN) = NaN
func _round(x float64) float64 <span class="cov8" title="1">{
        // Round is a faster implementation of:
        //
        // func Round(x float64) float64 {
        //   t := Trunc(x)
        //   if Abs(x-t) &gt;= 0.5 {
        //     return t + Copysign(1, x)
        //   }
        //   return t
        // }
        const (
                signMask = 1 &lt;&lt; 63
                fracMask = 1&lt;&lt;shift - 1
                half     = 1 &lt;&lt; (shift - 1)
                one      = bias &lt;&lt; shift
        )

        bits := math.Float64bits(x)
        e := uint(bits&gt;&gt;shift) &amp; mask
        if e &lt; bias </span><span class="cov8" title="1">{
                // Round abs(x) &lt; 1 including denormals.
                bits &amp;= signMask // +-0
                if e == bias-1 </span><span class="cov8" title="1">{
                        bits |= one // +-1
                }</span>
        } else<span class="cov8" title="1"> if e &lt; bias+shift </span><span class="cov8" title="1">{
                // Round any abs(x) &gt;= 1 containing a fractional component [0,1).
                //
                // Numbers with larger exponents are returned unchanged since they
                // must be either an integer, infinity, or NaN.
                e -= bias
                bits += half &gt;&gt; e
                bits &amp;^= fracMask &gt;&gt; e
        }</span>
        <span class="cov8" title="1">return math.Float64frombits(bits)</span>
}
</pre>
		
		<pre class="file" id="file331" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package openapi3

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "openapi3"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Unmarshal,
                        nil,
                        [][2]string{},
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file332" style="display: none">// Copyright 2020 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package openapi3

import (
        "io/ioutil"

        gyaml "github.com/ghodss/yaml"

        "github.com/pkg/errors"

        kopenapi3 "github.com/getkin/kin-openapi/openapi3"
        "github.com/gohugoio/hugo/cache/namedmemcache"
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/parser/metadecoders"
        "github.com/gohugoio/hugo/resources/resource"
)

// New returns a new instance of the openapi3-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        // TODO(bep) consolidate when merging that "other branch" -- but be aware of the keys.
        cache := namedmemcache.New()
        deps.BuildStartListeners.Add(
                func() </span><span class="cov8" title="1">{
                        cache.Clear()
                }</span>)

        <span class="cov8" title="1">return &amp;Namespace{
                cache: cache,
                deps:  deps,
        }</span>
}

// Namespace provides template functions for the "openapi3".
type Namespace struct {
        cache *namedmemcache.Cache
        deps  *deps.Deps
}

func (ns *Namespace) Unmarshal(r resource.UnmarshableResource) (*kopenapi3.T, error) <span class="cov8" title="1">{
        key := r.Key()
        if key == "" </span><span class="cov0" title="0">{
                return nil, errors.New("no Key set in Resource")
        }</span>

        <span class="cov8" title="1">v, err := ns.cache.GetOrCreate(key, func() (interface{}, error) </span><span class="cov8" title="1">{
                f := metadecoders.FormatFromMediaType(r.MediaType())
                if f == "" </span><span class="cov0" title="0">{
                        return nil, errors.Errorf("MIME %q not supported", r.MediaType())
                }</span>

                <span class="cov8" title="1">reader, err := r.ReadSeekCloser()
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">defer reader.Close()

                b, err := ioutil.ReadAll(reader)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">s := &amp;kopenapi3.T{}
                switch f </span>{
                case metadecoders.YAML:<span class="cov8" title="1">
                        err = gyaml.Unmarshal(b, s)</span>
                default:<span class="cov0" title="0">
                        err = metadecoders.Default.UnmarshalTo(b, f, s)</span>
                }
                <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov8" title="1">err = kopenapi3.NewLoader().ResolveRefsIn(s, nil)

                return s, err</span>
        })
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return v.(*kopenapi3.T), nil</span>
}
</pre>
		
		<pre class="file" id="file333" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package os

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "os"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Getenv,
                        []string{"getenv"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.ReadDir,
                        []string{"readDir"},
                        [][2]string{
                                {`{{ range (readDir "files") }}{{ .Name }}{{ end }}`, "README.txt"},
                        },
                )

                ns.AddMethodMapping(ctx.ReadFile,
                        []string{"readFile"},
                        [][2]string{
                                {`{{ readFile "files/README.txt" }}`, `Hugo Rocks!`},
                        },
                )

                ns.AddMethodMapping(ctx.FileExists,
                        []string{"fileExists"},
                        [][2]string{
                                {`{{ fileExists "foo.txt" }}`, `false`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file334" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package os provides template functions for interacting with the operating
// system.
package os

import (
        "errors"
        "fmt"
        _os "os"

        "github.com/gohugoio/hugo/deps"
        "github.com/spf13/afero"
        "github.com/spf13/cast"
)

// New returns a new instance of the os-namespaced template functions.
func New(d *deps.Deps) *Namespace <span class="cov8" title="1">{
        var rfs afero.Fs
        if d.Fs != nil </span><span class="cov8" title="1">{
                rfs = d.Fs.WorkingDir
                if d.PathSpec != nil &amp;&amp; d.PathSpec.BaseFs != nil </span><span class="cov0" title="0">{
                        rfs = afero.NewReadOnlyFs(afero.NewCopyOnWriteFs(d.PathSpec.BaseFs.Content.Fs, d.Fs.WorkingDir))
                }</span>

        }

        <span class="cov8" title="1">return &amp;Namespace{
                readFileFs: rfs,
                deps:       d,
        }</span>
}

// Namespace provides template functions for the "os" namespace.
type Namespace struct {
        readFileFs afero.Fs
        deps       *deps.Deps
}

// Getenv retrieves the value of the environment variable named by the key.
// It returns the value, which will be empty if the variable is not present.
func (ns *Namespace) Getenv(key interface{}) (string, error) <span class="cov0" title="0">{
        skey, err := cast.ToStringE(key)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">if err = ns.deps.ExecHelper.Sec().CheckAllowedGetEnv(skey); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return _os.Getenv(skey), nil</span>
}

// readFile reads the file named by filename in the given filesystem
// and returns the contents as a string.
func readFile(fs afero.Fs, filename string) (string, error) <span class="cov8" title="1">{
        if filename == "" </span><span class="cov8" title="1">{
                return "", errors.New("readFile needs a filename")
        }</span>

        <span class="cov8" title="1">b, err := afero.ReadFile(fs, filename)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return string(b), nil</span>
}

// ReadFile reads the file named by filename relative to the configured WorkingDir.
// It returns the contents as a string.
// There is an upper size limit set at 1 megabytes.
func (ns *Namespace) ReadFile(i interface{}) (string, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(i)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">if ns.deps.PathSpec != nil </span><span class="cov0" title="0">{
                s = ns.deps.PathSpec.RelPathify(s)
        }</span>

        <span class="cov8" title="1">return readFile(ns.readFileFs, s)</span>
}

// ReadDir lists the directory contents relative to the configured WorkingDir.
func (ns *Namespace) ReadDir(i interface{}) ([]_os.FileInfo, error) <span class="cov0" title="0">{
        path, err := cast.ToStringE(i)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">list, err := afero.ReadDir(ns.deps.Fs.WorkingDir, path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read directory %q: %s", path, err)
        }</span>

        <span class="cov0" title="0">return list, nil</span>
}

// FileExists checks whether a file exists under the given path.
func (ns *Namespace) FileExists(i interface{}) (bool, error) <span class="cov8" title="1">{
        path, err := cast.ToStringE(i)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">if path == "" </span><span class="cov8" title="1">{
                return false, errors.New("fileExists needs a path to a file")
        }</span>

        <span class="cov8" title="1">status, err := afero.Exists(ns.readFileFs, path)
        if err != nil </span><span class="cov0" title="0">{
                return false, err
        }</span>

        <span class="cov8" title="1">return status, nil</span>
}

// Stat returns the os.FileInfo structure describing file.
func (ns *Namespace) Stat(i interface{}) (_os.FileInfo, error) <span class="cov8" title="1">{
        path, err := cast.ToStringE(i)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if path == "" </span><span class="cov8" title="1">{
                return nil, errors.New("fileStat needs a path to a file")
        }</span>

        <span class="cov8" title="1">r, err := ns.readFileFs.Stat(path)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return r, nil</span>
}
</pre>
		
		<pre class="file" id="file335" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package partials

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "partials"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Include,
                        []string{"partial"},
                        [][2]string{
                                {`{{ partial "header.html" . }}`, `&lt;title&gt;Hugo Rocks!&lt;/title&gt;`},
                        },
                )

                // TODO(bep) we need the return to be a valid identifier, but
                // should consider another way of adding it.
                ns.AddMethodMapping(func() string </span><span class="cov0" title="0">{ return "" }</span>,
                        []string{"return"},
                        [][2]string{},
                )

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.IncludeCached,
                        []string{"partialCached"},
                        [][2]string{},
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file336" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package partials provides template functions for working with reusable
// templates.
package partials

import (
        "errors"
        "fmt"
        "html/template"
        "io"
        "io/ioutil"
        "reflect"
        "strings"
        "sync"

        texttemplate "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/tpl"

        bp "github.com/gohugoio/hugo/bufferpool"
        "github.com/gohugoio/hugo/deps"
)

// TestTemplateProvider is global deps.ResourceProvider.
// NOTE: It's currently unused.
var TestTemplateProvider deps.ResourceProvider

type partialCacheKey struct {
        name    string
        variant interface{}
}

// partialCache represents a cache of partials protected by a mutex.
type partialCache struct {
        sync.RWMutex
        p map[partialCacheKey]interface{}
}

func (p *partialCache) clear() <span class="cov0" title="0">{
        p.Lock()
        defer p.Unlock()
        p.p = make(map[partialCacheKey]interface{})
}</span>

// New returns a new instance of the templates-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        cache := &amp;partialCache{p: make(map[partialCacheKey]interface{})}
        deps.BuildStartListeners.Add(
                func() </span><span class="cov0" title="0">{
                        cache.clear()
                }</span>)

        <span class="cov8" title="1">return &amp;Namespace{
                deps:           deps,
                cachedPartials: cache,
        }</span>
}

// Namespace provides template functions for the "templates" namespace.
type Namespace struct {
        deps           *deps.Deps
        cachedPartials *partialCache
}

// contextWrapper makes room for a return value in a partial invocation.
type contextWrapper struct {
        Arg    interface{}
        Result interface{}
}

// Set sets the return value and returns an empty string.
func (c *contextWrapper) Set(in interface{}) string <span class="cov0" title="0">{
        c.Result = in
        return ""
}</span>

// Include executes the named partial.
// If the partial contains a return statement, that value will be returned.
// Else, the rendered output will be returned:
// A string if the partial is a text/template, or template.HTML when html/template.
func (ns *Namespace) Include(name string, contextList ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        name = strings.TrimPrefix(name, "partials/")

        var context interface{}
        if len(contextList) &gt; 0 </span><span class="cov0" title="0">{
                context = contextList[0]
        }</span>

        <span class="cov0" title="0">n := "partials/" + name
        templ, found := ns.deps.Tmpl().Lookup(n)

        if !found </span><span class="cov0" title="0">{
                // For legacy reasons.
                templ, found = ns.deps.Tmpl().Lookup(n + ".html")
        }</span>

        <span class="cov0" title="0">if !found </span><span class="cov0" title="0">{
                return "", fmt.Errorf("partial %q not found", name)
        }</span>

        <span class="cov0" title="0">var info tpl.ParseInfo
        if ip, ok := templ.(tpl.Info); ok </span><span class="cov0" title="0">{
                info = ip.ParseInfo()
        }</span>

        <span class="cov0" title="0">var w io.Writer

        if info.HasReturn </span><span class="cov0" title="0">{
                // Wrap the context sent to the template to capture the return value.
                // Note that the template is rewritten to make sure that the dot (".")
                // and the $ variable points to Arg.
                context = &amp;contextWrapper{
                        Arg: context,
                }

                // We don't care about any template output.
                w = ioutil.Discard
        }</span> else<span class="cov0" title="0"> {
                b := bp.GetBuffer()
                defer bp.PutBuffer(b)
                w = b
        }</span>

        <span class="cov0" title="0">if err := ns.deps.Tmpl().Execute(templ, w, context); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">var result interface{}

        if ctx, ok := context.(*contextWrapper); ok </span><span class="cov0" title="0">{
                result = ctx.Result
        }</span> else<span class="cov0" title="0"> if _, ok := templ.(*texttemplate.Template); ok </span><span class="cov0" title="0">{
                result = w.(fmt.Stringer).String()
        }</span> else<span class="cov0" title="0"> {
                result = template.HTML(w.(fmt.Stringer).String())
        }</span>

        <span class="cov0" title="0">if ns.deps.Metrics != nil </span><span class="cov0" title="0">{
                ns.deps.Metrics.TrackValue(templ.Name(), result)
        }</span>

        <span class="cov0" title="0">return result, nil</span>
}

// IncludeCached executes and caches partial templates.  The cache is created with name+variants as the key.
func (ns *Namespace) IncludeCached(name string, context interface{}, variants ...interface{}) (interface{}, error) <span class="cov0" title="0">{
        key, err := createKey(name, variants...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">result, err := ns.getOrCreate(key, context)
        if err == errUnHashable </span><span class="cov0" title="0">{
                // Try one more
                key.variant = helpers.HashString(key.variant)
                result, err = ns.getOrCreate(key, context)
        }</span>

        <span class="cov0" title="0">return result, err</span>
}

func createKey(name string, variants ...interface{}) (partialCacheKey, error) <span class="cov8" title="1">{
        var variant interface{}

        if len(variants) &gt; 1 </span><span class="cov8" title="1">{
                variant = helpers.HashString(variants...)
        }</span> else<span class="cov8" title="1"> if len(variants) == 1 </span><span class="cov8" title="1">{
                variant = variants[0]
                t := reflect.TypeOf(variant)
                switch t.Kind() </span>{
                // This isn't an exhaustive list of unhashable types.
                // There may be structs with slices,
                // but that should be very rare. We do recover from that situation
                // below.
                case reflect.Slice, reflect.Array, reflect.Map:<span class="cov8" title="1">
                        variant = helpers.HashString(variant)</span>
                }
        }

        <span class="cov8" title="1">return partialCacheKey{name: name, variant: variant}, nil</span>
}

var errUnHashable = errors.New("unhashable")

func (ns *Namespace) getOrCreate(key partialCacheKey, context interface{}) (result interface{}, err error) <span class="cov0" title="0">{
        defer func() </span><span class="cov0" title="0">{
                if r := recover(); r != nil </span><span class="cov0" title="0">{
                        err = r.(error)
                        if strings.Contains(err.Error(), "unhashable type") </span><span class="cov0" title="0">{
                                ns.cachedPartials.RUnlock()
                                err = errUnHashable
                        }</span>
                }
        }()

        <span class="cov0" title="0">ns.cachedPartials.RLock()
        p, ok := ns.cachedPartials.p[key]
        ns.cachedPartials.RUnlock()

        if ok </span><span class="cov0" title="0">{
                return p, nil
        }</span>

        <span class="cov0" title="0">p, err = ns.Include(key.name, context)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov0" title="0">ns.cachedPartials.Lock()
        defer ns.cachedPartials.Unlock()
        // Double-check.
        if p2, ok := ns.cachedPartials.p[key]; ok </span><span class="cov0" title="0">{
                return p2, nil
        }</span>
        <span class="cov0" title="0">ns.cachedPartials.p[key] = p

        return p, nil</span>
}
</pre>
		
		<pre class="file" id="file337" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package path

import (
        "fmt"
        "path/filepath"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "path"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Split,
                        nil,
                        [][2]string{
                                {`{{ "/my/path/filename.txt" | path.Split }}`, `/my/path/|filename.txt`},
                                {fmt.Sprintf(`{{ %q | path.Split }}`, filepath.FromSlash("/my/path/filename.txt")), `/my/path/|filename.txt`},
                        },
                )

                testDir := filepath.Join("my", "path")
                testFile := filepath.Join(testDir, "filename.txt")

                ns.AddMethodMapping(ctx.Join,
                        nil,
                        [][2]string{
                                {fmt.Sprintf(`{{ slice %q "filename.txt" | path.Join  }}`, testDir), `my/path/filename.txt`},
                                {`{{  path.Join "my" "path" "filename.txt" }}`, `my/path/filename.txt`},
                                {fmt.Sprintf(`{{ %q | path.Ext  }}`, testFile), `.txt`},
                                {fmt.Sprintf(`{{ %q | path.Base  }}`, testFile), `filename.txt`},
                                {fmt.Sprintf(`{{ %q | path.Dir  }}`, testFile), `my/path`},
                        },
                )

                return ns</span>
        }
        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file338" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package path provides template functions for manipulating paths.
package path

import (
        "fmt"
        _path "path"
        "path/filepath"

        "github.com/gohugoio/hugo/deps"
        "github.com/spf13/cast"
)

// New returns a new instance of the path-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                deps: deps,
        }
}</span>

// Namespace provides template functions for the "os" namespace.
type Namespace struct {
        deps *deps.Deps
}

// DirFile holds the result from path.Split.
type DirFile struct {
        Dir  string
        File string
}

// Used in test.
func (df DirFile) String() string <span class="cov8" title="1">{
        return fmt.Sprintf("%s|%s", df.Dir, df.File)
}</span>

// Ext returns the file name extension used by path.
// The extension is the suffix beginning at the final dot
// in the final slash-separated element of path;
// it is empty if there is no dot.
// The input path is passed into filepath.ToSlash converting any Windows slashes
// to forward slashes.
func (ns *Namespace) Ext(path interface{}) (string, error) <span class="cov8" title="1">{
        spath, err := cast.ToStringE(path)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">spath = filepath.ToSlash(spath)
        return _path.Ext(spath), nil</span>
}

// Dir returns all but the last element of path, typically the path's directory.
// After dropping the final element using Split, the path is Cleaned and trailing
// slashes are removed.
// If the path is empty, Dir returns ".".
// If the path consists entirely of slashes followed by non-slash bytes, Dir
// returns a single slash. In any other case, the returned path does not end in a
// slash.
// The input path is passed into filepath.ToSlash converting any Windows slashes
// to forward slashes.
func (ns *Namespace) Dir(path interface{}) (string, error) <span class="cov8" title="1">{
        spath, err := cast.ToStringE(path)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">spath = filepath.ToSlash(spath)
        return _path.Dir(spath), nil</span>
}

// Base returns the last element of path.
// Trailing slashes are removed before extracting the last element.
// If the path is empty, Base returns ".".
// If the path consists entirely of slashes, Base returns "/".
// The input path is passed into filepath.ToSlash converting any Windows slashes
// to forward slashes.
func (ns *Namespace) Base(path interface{}) (string, error) <span class="cov8" title="1">{
        spath, err := cast.ToStringE(path)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">spath = filepath.ToSlash(spath)
        return _path.Base(spath), nil</span>
}

// Split splits path immediately following the final slash,
// separating it into a directory and file name component.
// If there is no slash in path, Split returns an empty dir and
// file set to path.
// The input path is passed into filepath.ToSlash converting any Windows slashes
// to forward slashes.
// The returned values have the property that path = dir+file.
func (ns *Namespace) Split(path interface{}) (DirFile, error) <span class="cov8" title="1">{
        spath, err := cast.ToStringE(path)
        if err != nil </span><span class="cov8" title="1">{
                return DirFile{}, err
        }</span>
        <span class="cov8" title="1">spath = filepath.ToSlash(spath)
        dir, file := _path.Split(spath)

        return DirFile{Dir: dir, File: file}, nil</span>
}

// Join joins any number of path elements into a single path, adding a
// separating slash if necessary. All the input
// path elements are passed into filepath.ToSlash converting any Windows slashes
// to forward slashes.
// The result is Cleaned; in particular,
// all empty strings are ignored.
func (ns *Namespace) Join(elements ...interface{}) (string, error) <span class="cov8" title="1">{
        var pathElements []string
        for _, elem := range elements </span><span class="cov8" title="1">{
                switch v := elem.(type) </span>{
                case []string:<span class="cov8" title="1">
                        for _, e := range v </span><span class="cov8" title="1">{
                                pathElements = append(pathElements, filepath.ToSlash(e))
                        }</span>
                case []interface{}:<span class="cov8" title="1">
                        for _, e := range v </span><span class="cov8" title="1">{
                                elemStr, err := cast.ToStringE(e)
                                if err != nil </span><span class="cov8" title="1">{
                                        return "", err
                                }</span>
                                <span class="cov8" title="1">pathElements = append(pathElements, filepath.ToSlash(elemStr))</span>
                        }
                default:<span class="cov8" title="1">
                        elemStr, err := cast.ToStringE(elem)
                        if err != nil </span><span class="cov8" title="1">{
                                return "", err
                        }</span>
                        <span class="cov8" title="1">pathElements = append(pathElements, filepath.ToSlash(elemStr))</span>
                }
        }
        <span class="cov8" title="1">return _path.Join(pathElements...), nil</span>
}

// Clean replaces the separators used with standard slashes and then
// extraneous slashes are removed.
func (ns *Namespace) Clean(path interface{}) (string, error) <span class="cov8" title="1">{
        spath, err := cast.ToStringE(path)

        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>
        <span class="cov8" title="1">spath = filepath.ToSlash(spath)
        return _path.Clean(spath), nil</span>
}
</pre>
		
		<pre class="file" id="file339" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package reflect provides template functions for run-time object reflection.
package reflect

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "reflect"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.IsMap,
                        nil,
                        [][2]string{
                                {`{{ if reflect.IsMap (dict "a" 1) }}Map{{ end }}`, `Map`},
                        },
                )

                ns.AddMethodMapping(ctx.IsSlice,
                        nil,
                        [][2]string{
                                {`{{ if reflect.IsSlice (slice 1 2 3) }}Slice{{ end }}`, `Slice`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file340" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package reflect

import (
        "reflect"
)

// New returns a new instance of the reflect-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "reflect" namespace.
type Namespace struct{}

// IsMap reports whether v is a map.
func (ns *Namespace) IsMap(v interface{}) bool <span class="cov8" title="1">{
        return reflect.ValueOf(v).Kind() == reflect.Map
}</span>

// IsSlice reports whether v is a slice.
func (ns *Namespace) IsSlice(v interface{}) bool <span class="cov8" title="1">{
        return reflect.ValueOf(v).Kind() == reflect.Slice
}</span>
</pre>
		
		<pre class="file" id="file341" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package safe

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "safe"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New()

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.CSS,
                        []string{"safeCSS"},
                        [][2]string{
                                {`{{ "Bat&amp;Man" | safeCSS | safeCSS }}`, `Bat&amp;amp;Man`},
                        },
                )

                ns.AddMethodMapping(ctx.HTML,
                        []string{"safeHTML"},
                        [][2]string{
                                {`{{ "Bat&amp;Man" | safeHTML | safeHTML }}`, `Bat&amp;Man`},
                                {`{{ "Bat&amp;Man" | safeHTML }}`, `Bat&amp;Man`},
                        },
                )

                ns.AddMethodMapping(ctx.HTMLAttr,
                        []string{"safeHTMLAttr"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.JS,
                        []string{"safeJS"},
                        [][2]string{
                                {`{{ "(1*2)" | safeJS | safeJS }}`, `(1*2)`},
                        },
                )

                ns.AddMethodMapping(ctx.JSStr,
                        []string{"safeJSStr"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.URL,
                        []string{"safeURL"},
                        [][2]string{
                                {`{{ "http://gohugo.io" | safeURL | safeURL }}`, `http://gohugo.io`},
                        },
                )

                ns.AddMethodMapping(ctx.SanitizeURL,
                        []string{"sanitizeURL", "sanitizeurl"},
                        [][2]string{},
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file342" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package safe provides template functions for escaping untrusted content or
// encapsulating trusted content.
package safe

import (
        "html/template"

        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/cast"
)

// New returns a new instance of the safe-namespaced template functions.
func New() *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{}
}</span>

// Namespace provides template functions for the "safe" namespace.
type Namespace struct{}

// CSS returns a given string as html/template CSS content.
func (ns *Namespace) CSS(a interface{}) (template.CSS, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(a)
        return template.CSS(s), err
}</span>

// HTML returns a given string as html/template HTML content.
func (ns *Namespace) HTML(a interface{}) (template.HTML, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(a)
        return template.HTML(s), err
}</span>

// HTMLAttr returns a given string as html/template HTMLAttr content.
func (ns *Namespace) HTMLAttr(a interface{}) (template.HTMLAttr, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(a)
        return template.HTMLAttr(s), err
}</span>

// JS returns the given string as a html/template JS content.
func (ns *Namespace) JS(a interface{}) (template.JS, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(a)
        return template.JS(s), err
}</span>

// JSStr returns the given string as a html/template JSStr content.
func (ns *Namespace) JSStr(a interface{}) (template.JSStr, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(a)
        return template.JSStr(s), err
}</span>

// URL returns a given string as html/template URL content.
func (ns *Namespace) URL(a interface{}) (template.URL, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(a)
        return template.URL(s), err
}</span>

// SanitizeURL returns a given string as html/template URL content.
func (ns *Namespace) SanitizeURL(a interface{}) (string, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(a)
        return helpers.SanitizeURL(s), err
}</span>
</pre>
		
		<pre class="file" id="file343" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package site provides template functions for accessing the Site object.
package site

import (
        "github.com/gohugoio/hugo/deps"

        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "site"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                s := d.Site
                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return s, nil }</span>,
                }

                <span class="cov8" title="1">if s == nil </span><span class="cov0" title="0">{
                        panic("no Site")</span>
                }

                // We just add the Site as the namespace here. No method mappings.

                <span class="cov8" title="1">return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file344" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package strings

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "strings"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Chomp,
                        []string{"chomp"},
                        [][2]string{
                                {`{{chomp "&lt;p&gt;Blockhead&lt;/p&gt;\n" | safeHTML }}`, `&lt;p&gt;Blockhead&lt;/p&gt;`},
                        },
                )

                ns.AddMethodMapping(ctx.CountRunes,
                        []string{"countrunes"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.RuneCount,
                        nil,
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.CountWords,
                        []string{"countwords"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Count,
                        nil,
                        [][2]string{
                                {`{{"aabab" | strings.Count "a" }}`, `3`},
                        },
                )

                ns.AddMethodMapping(ctx.Contains,
                        nil,
                        [][2]string{
                                {`{{ strings.Contains "abc" "b" }}`, `true`},
                                {`{{ strings.Contains "abc" "d" }}`, `false`},
                        },
                )

                ns.AddMethodMapping(ctx.ContainsAny,
                        nil,
                        [][2]string{
                                {`{{ strings.ContainsAny "abc" "bcd" }}`, `true`},
                                {`{{ strings.ContainsAny "abc" "def" }}`, `false`},
                        },
                )

                ns.AddMethodMapping(ctx.FindRE,
                        []string{"findRE"},
                        [][2]string{
                                {
                                        `{{ findRE "[G|g]o" "Hugo is a static side generator written in Go." "1" }}`,
                                        `[go]`,
                                },
                        },
                )

                ns.AddMethodMapping(ctx.HasPrefix,
                        []string{"hasPrefix"},
                        [][2]string{
                                {`{{ hasPrefix "Hugo" "Hu" }}`, `true`},
                                {`{{ hasPrefix "Hugo" "Fu" }}`, `false`},
                        },
                )

                ns.AddMethodMapping(ctx.ToLower,
                        []string{"lower"},
                        [][2]string{
                                {`{{lower "BatMan"}}`, `batman`},
                        },
                )

                ns.AddMethodMapping(ctx.Replace,
                        []string{"replace"},
                        [][2]string{
                                {
                                        `{{ replace "Batman and Robin" "Robin" "Catwoman" }}`,
                                        `Batman and Catwoman`,
                                },
                                {
                                        `{{ replace "aabbaabb" "a" "z" 2 }}`,
                                        `zzbbaabb`,
                                },
                        },
                )

                ns.AddMethodMapping(ctx.ReplaceRE,
                        []string{"replaceRE"},
                        [][2]string{
                                {
                                        `{{ replaceRE "a+b" "X" "aabbaabbab" }}`,
                                        `XbXbX`,
                                },
                                {
                                        `{{ replaceRE "a+b" "X" "aabbaabbab" 1 }}`,
                                        `Xbaabbab`,
                                },
                        },
                )

                ns.AddMethodMapping(ctx.SliceString,
                        []string{"slicestr"},
                        [][2]string{
                                {`{{slicestr "BatMan" 0 3}}`, `Bat`},
                                {`{{slicestr "BatMan" 3}}`, `Man`},
                        },
                )

                ns.AddMethodMapping(ctx.Split,
                        []string{"split"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Substr,
                        []string{"substr"},
                        [][2]string{
                                {`{{substr "BatMan" 0 -3}}`, `Bat`},
                                {`{{substr "BatMan" 3 3}}`, `Man`},
                        },
                )

                ns.AddMethodMapping(ctx.Trim,
                        []string{"trim"},
                        [][2]string{
                                {`{{ trim "++Batman--" "+-" }}`, `Batman`},
                        },
                )

                ns.AddMethodMapping(ctx.TrimLeft,
                        nil,
                        [][2]string{
                                {`{{ "aabbaa" | strings.TrimLeft "a" }}`, `bbaa`},
                        },
                )

                ns.AddMethodMapping(ctx.TrimPrefix,
                        nil,
                        [][2]string{
                                {`{{ "aabbaa" | strings.TrimPrefix "a" }}`, `abbaa`},
                                {`{{ "aabbaa" | strings.TrimPrefix "aa" }}`, `bbaa`},
                        },
                )

                ns.AddMethodMapping(ctx.TrimRight,
                        nil,
                        [][2]string{
                                {`{{ "aabbaa" | strings.TrimRight "a" }}`, `aabb`},
                        },
                )

                ns.AddMethodMapping(ctx.TrimSuffix,
                        nil,
                        [][2]string{
                                {`{{ "aabbaa" | strings.TrimSuffix "a" }}`, `aabba`},
                                {`{{ "aabbaa" | strings.TrimSuffix "aa" }}`, `aabb`},
                        },
                )

                ns.AddMethodMapping(ctx.Title,
                        []string{"title"},
                        [][2]string{
                                {`{{title "Bat man"}}`, `Bat Man`},
                                {`{{title "somewhere over the rainbow"}}`, `Somewhere Over the Rainbow`},
                        },
                )

                ns.AddMethodMapping(ctx.FirstUpper,
                        nil,
                        [][2]string{
                                {`{{ "hugo rocks!" | strings.FirstUpper }}`, `Hugo rocks!`},
                        },
                )

                ns.AddMethodMapping(ctx.Truncate,
                        []string{"truncate"},
                        [][2]string{
                                {`{{ "this is a very long text" | truncate 10 " ..." }}`, `this is a ...`},
                                {`{{ "With [Markdown](/markdown) inside." | markdownify | truncate 14 }}`, `With &lt;a href="/markdown"&gt;Markdown …&lt;/a&gt;`},
                        },
                )

                ns.AddMethodMapping(ctx.Repeat,
                        nil,
                        [][2]string{
                                {`{{ "yo" | strings.Repeat 4 }}`, `yoyoyoyo`},
                        },
                )

                ns.AddMethodMapping(ctx.ToUpper,
                        []string{"upper"},
                        [][2]string{
                                {`{{upper "BatMan"}}`, `BATMAN`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file345" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package strings

import (
        "regexp"
        "sync"

        "github.com/spf13/cast"
)

// FindRE returns a list of strings that match the regular expression. By default all matches
// will be included. The number of matches can be limited with an optional third parameter.
func (ns *Namespace) FindRE(expr string, content interface{}, limit ...interface{}) ([]string, error) <span class="cov8" title="1">{
        re, err := reCache.Get(expr)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">conv, err := cast.ToStringE(content)
        if err != nil </span><span class="cov8" title="1">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if len(limit) == 0 </span><span class="cov0" title="0">{
                return re.FindAllString(conv, -1), nil
        }</span>

        <span class="cov8" title="1">lim, err := cast.ToIntE(limit[0])
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return re.FindAllString(conv, lim), nil</span>
}

// ReplaceRE returns a copy of s, replacing all matches of the regular
// expression pattern with the replacement text repl. The number of replacements
// can be limited with an optional fourth parameter.
func (ns *Namespace) ReplaceRE(pattern, repl, s interface{}, n ...interface{}) (_ string, err error) <span class="cov8" title="1">{
        sp, err := cast.ToStringE(pattern)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">sr, err := cast.ToStringE(repl)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">nn := -1
        if len(n) &gt; 0 </span><span class="cov8" title="1">{
                nn, err = cast.ToIntE(n[0])
                if err != nil </span><span class="cov0" title="0">{
                        return
                }</span>
        }

        <span class="cov8" title="1">re, err := reCache.Get(sp)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return re.ReplaceAllStringFunc(ss, func(str string) string </span><span class="cov8" title="1">{
                if nn == 0 </span><span class="cov8" title="1">{
                        return str
                }</span>

                <span class="cov8" title="1">nn -= 1
                return re.ReplaceAllString(str, sr)</span>
        }), nil
}

// regexpCache represents a cache of regexp objects protected by a mutex.
type regexpCache struct {
        mu sync.RWMutex
        re map[string]*regexp.Regexp
}

// Get retrieves a regexp object from the cache based upon the pattern.
// If the pattern is not found in the cache, create one
func (rc *regexpCache) Get(pattern string) (re *regexp.Regexp, err error) <span class="cov8" title="1">{
        var ok bool

        if re, ok = rc.get(pattern); !ok </span><span class="cov8" title="1">{
                re, err = regexp.Compile(pattern)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">rc.set(pattern, re)</span>
        }

        <span class="cov8" title="1">return re, nil</span>
}

func (rc *regexpCache) get(key string) (re *regexp.Regexp, ok bool) <span class="cov8" title="1">{
        rc.mu.RLock()
        re, ok = rc.re[key]
        rc.mu.RUnlock()
        return
}</span>

func (rc *regexpCache) set(key string, re *regexp.Regexp) <span class="cov8" title="1">{
        rc.mu.Lock()
        rc.re[key] = re
        rc.mu.Unlock()
}</span>

var reCache = regexpCache{re: make(map[string]*regexp.Regexp)}
</pre>
		
		<pre class="file" id="file346" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package strings provides template functions for manipulating strings.
package strings

import (
        "errors"
        "html/template"
        "regexp"
        "strings"
        "unicode/utf8"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"

        _errors "github.com/pkg/errors"
        "github.com/spf13/cast"
)

// New returns a new instance of the strings-namespaced template functions.
func New(d *deps.Deps) *Namespace <span class="cov8" title="1">{
        titleCaseStyle := d.Cfg.GetString("titleCaseStyle")
        titleFunc := helpers.GetTitleFunc(titleCaseStyle)
        return &amp;Namespace{deps: d, titleFunc: titleFunc}
}</span>

// Namespace provides template functions for the "strings" namespace.
// Most functions mimic the Go stdlib, but the order of the parameters may be
// different to ease their use in the Go template system.
type Namespace struct {
        titleFunc func(s string) string
        deps      *deps.Deps
}

// CountRunes returns the number of runes in s, excluding whitespace.
func (ns *Namespace) CountRunes(s interface{}) (int, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return 0, _errors.Wrap(err, "Failed to convert content to string")
        }</span>

        <span class="cov8" title="1">counter := 0
        for _, r := range helpers.StripHTML(ss) </span><span class="cov8" title="1">{
                if !helpers.IsWhitespace(r) </span><span class="cov8" title="1">{
                        counter++
                }</span>
        }

        <span class="cov8" title="1">return counter, nil</span>
}

// RuneCount returns the number of runes in s.
func (ns *Namespace) RuneCount(s interface{}) (int, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return 0, _errors.Wrap(err, "Failed to convert content to string")
        }</span>
        <span class="cov8" title="1">return utf8.RuneCountInString(ss), nil</span>
}

// CountWords returns the approximate word count in s.
func (ns *Namespace) CountWords(s interface{}) (int, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return 0, _errors.Wrap(err, "Failed to convert content to string")
        }</span>

        <span class="cov8" title="1">isCJKLanguage, err := regexp.MatchString(`\p{Han}|\p{Hangul}|\p{Hiragana}|\p{Katakana}`, ss)
        if err != nil </span><span class="cov0" title="0">{
                return 0, _errors.Wrap(err, "Failed to match regex pattern against string")
        }</span>

        <span class="cov8" title="1">if !isCJKLanguage </span><span class="cov8" title="1">{
                return len(strings.Fields(helpers.StripHTML((ss)))), nil
        }</span>

        <span class="cov8" title="1">counter := 0
        for _, word := range strings.Fields(helpers.StripHTML(ss)) </span><span class="cov8" title="1">{
                runeCount := utf8.RuneCountInString(word)
                if len(word) == runeCount </span><span class="cov0" title="0">{
                        counter++
                }</span> else<span class="cov8" title="1"> {
                        counter += runeCount
                }</span>
        }

        <span class="cov8" title="1">return counter, nil</span>
}

// Count counts the number of non-overlapping instances of substr in s.
// If substr is an empty string, Count returns 1 + the number of Unicode code points in s.
func (ns *Namespace) Count(substr, s interface{}) (int, error) <span class="cov0" title="0">{
        substrs, err := cast.ToStringE(substr)
        if err != nil </span><span class="cov0" title="0">{
                return 0, _errors.Wrap(err, "Failed to convert substr to string")
        }</span>
        <span class="cov0" title="0">ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return 0, _errors.Wrap(err, "Failed to convert s to string")
        }</span>
        <span class="cov0" title="0">return strings.Count(ss, substrs), nil</span>
}

// Chomp returns a copy of s with all trailing newline characters removed.
func (ns *Namespace) Chomp(s interface{}) (interface{}, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">res := strings.TrimRight(ss, "\r\n")
        switch s.(type) </span>{
        case template.HTML:<span class="cov8" title="1">
                return template.HTML(res), nil</span>
        default:<span class="cov8" title="1">
                return res, nil</span>
        }
}

// Contains reports whether substr is in s.
func (ns *Namespace) Contains(s, substr interface{}) (bool, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">su, err := cast.ToStringE(substr)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return strings.Contains(ss, su), nil</span>
}

// ContainsAny reports whether any Unicode code points in chars are within s.
func (ns *Namespace) ContainsAny(s, chars interface{}) (bool, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">sc, err := cast.ToStringE(chars)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return strings.ContainsAny(ss, sc), nil</span>
}

// HasPrefix tests whether the input s begins with prefix.
func (ns *Namespace) HasPrefix(s, prefix interface{}) (bool, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">sx, err := cast.ToStringE(prefix)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return strings.HasPrefix(ss, sx), nil</span>
}

// HasSuffix tests whether the input s begins with suffix.
func (ns *Namespace) HasSuffix(s, suffix interface{}) (bool, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">sx, err := cast.ToStringE(suffix)
        if err != nil </span><span class="cov8" title="1">{
                return false, err
        }</span>

        <span class="cov8" title="1">return strings.HasSuffix(ss, sx), nil</span>
}

// Replace returns a copy of the string s with all occurrences of old replaced
// with new.  The number of replacements can be limited with an optional fourth
// parameter.
func (ns *Namespace) Replace(s, old, new interface{}, limit ...interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">so, err := cast.ToStringE(old)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">sn, err := cast.ToStringE(new)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if len(limit) == 0 </span><span class="cov8" title="1">{
                return strings.ReplaceAll(ss, so, sn), nil
        }</span>

        <span class="cov8" title="1">lim, err := cast.ToIntE(limit[0])
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.Replace(ss, so, sn, lim), nil</span>
}

// SliceString slices a string by specifying a half-open range with
// two indices, start and end. 1 and 4 creates a slice including elements 1 through 3.
// The end index can be omitted, it defaults to the string's length.
func (ns *Namespace) SliceString(a interface{}, startEnd ...interface{}) (string, error) <span class="cov8" title="1">{
        aStr, err := cast.ToStringE(a)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">var argStart, argEnd int

        argNum := len(startEnd)

        if argNum &gt; 0 </span><span class="cov8" title="1">{
                if argStart, err = cast.ToIntE(startEnd[0]); err != nil </span><span class="cov8" title="1">{
                        return "", errors.New("start argument must be integer")
                }</span>
        }
        <span class="cov8" title="1">if argNum &gt; 1 </span><span class="cov8" title="1">{
                if argEnd, err = cast.ToIntE(startEnd[1]); err != nil </span><span class="cov8" title="1">{
                        return "", errors.New("end argument must be integer")
                }</span>
        }

        <span class="cov8" title="1">if argNum &gt; 2 </span><span class="cov8" title="1">{
                return "", errors.New("too many arguments")
        }</span>

        <span class="cov8" title="1">asRunes := []rune(aStr)

        if argNum &gt; 0 &amp;&amp; (argStart &lt; 0 || argStart &gt;= len(asRunes)) </span><span class="cov8" title="1">{
                return "", errors.New("slice bounds out of range")
        }</span>

        <span class="cov8" title="1">if argNum == 2 </span><span class="cov8" title="1">{
                if argEnd &lt; 0 || argEnd &gt; len(asRunes) </span><span class="cov8" title="1">{
                        return "", errors.New("slice bounds out of range")
                }</span>
                <span class="cov8" title="1">return string(asRunes[argStart:argEnd]), nil</span>
        } else<span class="cov8" title="1"> if argNum == 1 </span><span class="cov8" title="1">{
                return string(asRunes[argStart:]), nil
        }</span> else<span class="cov8" title="1"> {
                return string(asRunes[:]), nil
        }</span>
}

// Split slices an input string into all substrings separated by delimiter.
func (ns *Namespace) Split(a interface{}, delimiter string) ([]string, error) <span class="cov8" title="1">{
        aStr, err := cast.ToStringE(a)
        if err != nil </span><span class="cov8" title="1">{
                return []string{}, err
        }</span>

        <span class="cov8" title="1">return strings.Split(aStr, delimiter), nil</span>
}

// Substr extracts parts of a string, beginning at the character at the specified
// position, and returns the specified number of characters.
//
// It normally takes two parameters: start and length.
// It can also take one parameter: start, i.e. length is omitted, in which case
// the substring starting from start until the end of the string will be returned.
//
// To extract characters from the end of the string, use a negative start number.
//
// In addition, borrowing from the extended behavior described at http://php.net/substr,
// if length is given and is negative, then that many characters will be omitted from
// the end of string.
func (ns *Namespace) Substr(a interface{}, nums ...interface{}) (string, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">asRunes := []rune(s)
        rlen := len(asRunes)

        var start, length int

        switch len(nums) </span>{
        case 0:<span class="cov8" title="1">
                return "", errors.New("too few arguments")</span>
        case 1:<span class="cov8" title="1">
                if start, err = cast.ToIntE(nums[0]); err != nil </span><span class="cov8" title="1">{
                        return "", errors.New("start argument must be an integer")
                }</span>
                <span class="cov8" title="1">length = rlen</span>
        case 2:<span class="cov8" title="1">
                if start, err = cast.ToIntE(nums[0]); err != nil </span><span class="cov8" title="1">{
                        return "", errors.New("start argument must be an integer")
                }</span>
                <span class="cov8" title="1">if length, err = cast.ToIntE(nums[1]); err != nil </span><span class="cov8" title="1">{
                        return "", errors.New("length argument must be an integer")
                }</span>
        default:<span class="cov8" title="1">
                return "", errors.New("too many arguments")</span>
        }

        <span class="cov8" title="1">if rlen == 0 </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">if start &lt; 0 </span><span class="cov8" title="1">{
                start += rlen
        }</span>

        // start was originally negative beyond rlen
        <span class="cov8" title="1">if start &lt; 0 </span><span class="cov8" title="1">{
                start = 0
        }</span>

        <span class="cov8" title="1">if start &gt; rlen-1 </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">end := rlen

        switch </span>{
        case length == 0:<span class="cov8" title="1">
                return "", nil</span>
        case length &lt; 0:<span class="cov8" title="1">
                end += length</span>
        case length &gt; 0:<span class="cov8" title="1">
                end = start + length</span>
        }

        <span class="cov8" title="1">if start &gt;= end </span><span class="cov8" title="1">{
                return "", nil
        }</span>

        <span class="cov8" title="1">if end &lt; 0 </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov8" title="1">if end &gt; rlen </span><span class="cov8" title="1">{
                end = rlen
        }</span>

        <span class="cov8" title="1">return string(asRunes[start:end]), nil</span>
}

// Title returns a copy of the input s with all Unicode letters that begin words
// mapped to their title case.
func (ns *Namespace) Title(s interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return ns.titleFunc(ss), nil</span>
}

// FirstUpper returns a string with the first character as upper case.
func (ns *Namespace) FirstUpper(s interface{}) (string, error) <span class="cov0" title="0">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return helpers.FirstUpper(ss), nil</span>
}

// ToLower returns a copy of the input s with all Unicode letters mapped to their
// lower case.
func (ns *Namespace) ToLower(s interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.ToLower(ss), nil</span>
}

// ToUpper returns a copy of the input s with all Unicode letters mapped to their
// upper case.
func (ns *Namespace) ToUpper(s interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.ToUpper(ss), nil</span>
}

// Trim returns a string with all leading and trailing characters defined
// contained in cutset removed.
func (ns *Namespace) Trim(s, cutset interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">sc, err := cast.ToStringE(cutset)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.Trim(ss, sc), nil</span>
}

// TrimLeft returns a slice of the string s with all leading characters
// contained in cutset removed.
func (ns *Namespace) TrimLeft(cutset, s interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">sc, err := cast.ToStringE(cutset)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.TrimLeft(ss, sc), nil</span>
}

// TrimPrefix returns s without the provided leading prefix string. If s doesn't
// start with prefix, s is returned unchanged.
func (ns *Namespace) TrimPrefix(prefix, s interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">sx, err := cast.ToStringE(prefix)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.TrimPrefix(ss, sx), nil</span>
}

// TrimRight returns a slice of the string s with all trailing characters
// contained in cutset removed.
func (ns *Namespace) TrimRight(cutset, s interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">sc, err := cast.ToStringE(cutset)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.TrimRight(ss, sc), nil</span>
}

// TrimSuffix returns s without the provided trailing suffix string. If s
// doesn't end with suffix, s is returned unchanged.
func (ns *Namespace) TrimSuffix(suffix, s interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">sx, err := cast.ToStringE(suffix)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return strings.TrimSuffix(ss, sx), nil</span>
}

// Repeat returns a new string consisting of count copies of the string s.
func (ns *Namespace) Repeat(n, s interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">sn, err := cast.ToIntE(n)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if sn &lt; 0 </span><span class="cov8" title="1">{
                return "", errors.New("strings: negative Repeat count")
        }</span>

        <span class="cov8" title="1">return strings.Repeat(ss, sn), nil</span>
}
</pre>
		
		<pre class="file" id="file347" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package strings

import (
        "errors"
        "html"
        "html/template"
        "regexp"
        "unicode"
        "unicode/utf8"

        "github.com/spf13/cast"
)

var (
        tagRE        = regexp.MustCompile(`^&lt;(/)?([^ ]+?)(?:(\s*/)| .*?)?&gt;`)
        htmlSinglets = map[string]bool{
                "br": true, "col": true, "link": true,
                "base": true, "img": true, "param": true,
                "area": true, "hr": true, "input": true,
        }
)

type htmlTag struct {
        name    string
        pos     int
        openTag bool
}

// Truncate truncates a given string to the specified length.
func (ns *Namespace) Truncate(a interface{}, options ...interface{}) (template.HTML, error) <span class="cov8" title="1">{
        length, err := cast.ToIntE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov8" title="1">var textParam interface{}
        var ellipsis string

        switch len(options) </span>{
        case 0:<span class="cov8" title="1">
                return "", errors.New("truncate requires a length and a string")</span>
        case 1:<span class="cov8" title="1">
                textParam = options[0]
                ellipsis = " …"</span>
        case 2:<span class="cov8" title="1">
                textParam = options[1]
                ellipsis, err = cast.ToStringE(options[0])
                if err != nil </span><span class="cov0" title="0">{
                        return "", errors.New("ellipsis must be a string")
                }</span>
                <span class="cov8" title="1">if _, ok := options[0].(template.HTML); !ok </span><span class="cov8" title="1">{
                        ellipsis = html.EscapeString(ellipsis)
                }</span>
        default:<span class="cov8" title="1">
                return "", errors.New("too many arguments passed to truncate")</span>
        }
        <span class="cov8" title="1">if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("text to truncate must be a string")
        }</span>
        <span class="cov8" title="1">text, err := cast.ToStringE(textParam)
        if err != nil </span><span class="cov0" title="0">{
                return "", errors.New("text must be a string")
        }</span>

        <span class="cov8" title="1">_, isHTML := textParam.(template.HTML)

        if utf8.RuneCountInString(text) &lt;= length </span><span class="cov0" title="0">{
                if isHTML </span><span class="cov0" title="0">{
                        return template.HTML(text), nil
                }</span>
                <span class="cov0" title="0">return template.HTML(html.EscapeString(text)), nil</span>
        }

        <span class="cov8" title="1">tags := []htmlTag{}
        var lastWordIndex, lastNonSpace, currentLen, endTextPos, nextTag int

        for i, r := range text </span><span class="cov8" title="1">{
                if i &lt; nextTag </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">if isHTML </span><span class="cov8" title="1">{
                        // Make sure we keep tag of HTML tags
                        slice := text[i:]
                        m := tagRE.FindStringSubmatchIndex(slice)
                        if len(m) &gt; 0 &amp;&amp; m[0] == 0 </span><span class="cov8" title="1">{
                                nextTag = i + m[1]
                                tagname := slice[m[4]:m[5]]
                                lastWordIndex = lastNonSpace
                                _, singlet := htmlSinglets[tagname]
                                if !singlet &amp;&amp; m[6] == -1 </span><span class="cov8" title="1">{
                                        tags = append(tags, htmlTag{name: tagname, pos: i, openTag: m[2] == -1})
                                }</span>

                                <span class="cov8" title="1">continue</span>
                        }
                }

                <span class="cov8" title="1">currentLen++
                if unicode.IsSpace(r) </span><span class="cov8" title="1">{
                        lastWordIndex = lastNonSpace
                }</span> else<span class="cov8" title="1"> if unicode.In(r, unicode.Han, unicode.Hangul, unicode.Hiragana, unicode.Katakana) </span><span class="cov8" title="1">{
                        lastWordIndex = i
                }</span> else<span class="cov8" title="1"> {
                        lastNonSpace = i + utf8.RuneLen(r)
                }</span>

                <span class="cov8" title="1">if currentLen &gt; length </span><span class="cov8" title="1">{
                        if lastWordIndex == 0 </span><span class="cov8" title="1">{
                                endTextPos = i
                        }</span> else<span class="cov8" title="1"> {
                                endTextPos = lastWordIndex
                        }</span>
                        <span class="cov8" title="1">out := text[0:endTextPos]
                        if isHTML </span><span class="cov8" title="1">{
                                out += ellipsis
                                // Close out any open HTML tags
                                var currentTag *htmlTag
                                for i := len(tags) - 1; i &gt;= 0; i-- </span><span class="cov8" title="1">{
                                        tag := tags[i]
                                        if tag.pos &gt;= endTextPos || currentTag != nil </span><span class="cov8" title="1">{
                                                if currentTag != nil &amp;&amp; currentTag.name == tag.name </span><span class="cov8" title="1">{
                                                        currentTag = nil
                                                }</span>
                                                <span class="cov8" title="1">continue</span>
                                        }

                                        <span class="cov8" title="1">if tag.openTag </span><span class="cov8" title="1">{
                                                out += ("&lt;/" + tag.name + "&gt;")
                                        }</span> else<span class="cov8" title="1"> {
                                                currentTag = &amp;tag
                                        }</span>
                                }

                                <span class="cov8" title="1">return template.HTML(out), nil</span>
                        }
                        <span class="cov8" title="1">return template.HTML(html.EscapeString(out) + ellipsis), nil</span>
                }
        }

        <span class="cov0" title="0">if isHTML </span><span class="cov0" title="0">{
                return template.HTML(text), nil
        }</span>
        <span class="cov0" title="0">return template.HTML(html.EscapeString(text)), nil</span>
}
</pre>
		
		<pre class="file" id="file348" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tpl

import (
        "io"
        "reflect"
        "regexp"

        "github.com/gohugoio/hugo/output"

        texttemplate "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate"
)

// TemplateManager manages the collection of templates.
type TemplateManager interface {
        TemplateHandler
        TemplateFuncGetter
        AddTemplate(name, tpl string) error
        MarkReady() error
}

// TemplateVariants describes the possible variants of a template.
// All of these may be empty.
type TemplateVariants struct {
        Language     string
        OutputFormat output.Format
}

// TemplateFinder finds templates.
type TemplateFinder interface {
        TemplateLookup
        TemplateLookupVariant
}

// TemplateHandler finds and executes templates.
type TemplateHandler interface {
        TemplateFinder
        Execute(t Template, wr io.Writer, data interface{}) error
        LookupLayout(d output.LayoutDescriptor, f output.Format) (Template, bool, error)
        HasTemplate(name string) bool
}

type TemplateLookup interface {
        Lookup(name string) (Template, bool)
}

type TemplateLookupVariant interface {
        // TODO(bep) this currently only works for shortcodes.
        // We may unify and expand this variant pattern to the
        // other templates, but we need this now for the shortcodes to
        // quickly determine if a shortcode has a template for a given
        // output format.
        // It returns the template, if it was found or not and if there are
        // alternative representations (output format, language).
        // We are currently only interested in output formats, so we should improve
        // this for speed.
        LookupVariant(name string, variants TemplateVariants) (Template, bool, bool)
        LookupVariants(name string) []Template
}

// Template is the common interface between text/template and html/template.
type Template interface {
        Name() string
        Prepare() (*texttemplate.Template, error)
}

// TemplateParser is used to parse ad-hoc templates, e.g. in the Resource chain.
type TemplateParser interface {
        Parse(name, tpl string) (Template, error)
}

// TemplateParseFinder provides both parsing and finding.
type TemplateParseFinder interface {
        TemplateParser
        TemplateFinder
}

// TemplateDebugger prints some debug info to stdout.
type TemplateDebugger interface {
        Debug()
}

// templateInfo wraps a Template with some additional information.
type templateInfo struct {
        Template
        Info
}

// templateInfo wraps a Template with some additional information.
type templateInfoManager struct {
        Template
        InfoManager
}

// TemplatesProvider as implemented by deps.Deps.
type TemplatesProvider interface {
        Tmpl() TemplateHandler
        TextTmpl() TemplateParseFinder
}

// WithInfo wraps the info in a template.
func WithInfo(templ Template, info Info) Template <span class="cov0" title="0">{
        if manager, ok := info.(InfoManager); ok </span><span class="cov0" title="0">{
                return &amp;templateInfoManager{
                        Template:    templ,
                        InfoManager: manager,
                }
        }</span>

        <span class="cov0" title="0">return &amp;templateInfo{
                Template: templ,
                Info:     info,
        }</span>
}

var baseOfRe = regexp.MustCompile("template: (.*?):")

func extractBaseOf(err string) string <span class="cov8" title="1">{
        m := baseOfRe.FindStringSubmatch(err)
        if len(m) == 2 </span><span class="cov8" title="1">{
                return m[1]
        }</span>
        <span class="cov8" title="1">return ""</span>
}

// TemplateFuncGetter allows to find a template func by name.
type TemplateFuncGetter interface {
        GetFunc(name string) (reflect.Value, bool)
}
</pre>
		
		<pre class="file" id="file349" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tpl

import (
        "github.com/gohugoio/hugo/identity"
)

// Increments on breaking changes.
const TemplateVersion = 2

type Info interface {
        ParseInfo() ParseInfo

        // Identifies this template and its dependencies.
        identity.Provider
}

type InfoManager interface {
        ParseInfo() ParseInfo

        // Identifies and manages this template and its dependencies.
        identity.Manager
}

type defaultInfo struct {
        identity.Manager
        parseInfo ParseInfo
}

func NewInfo(id identity.Manager, parseInfo ParseInfo) Info <span class="cov0" title="0">{
        return &amp;defaultInfo{
                Manager:   id,
                parseInfo: parseInfo,
        }
}</span>

func (info *defaultInfo) ParseInfo() ParseInfo <span class="cov0" title="0">{
        return info.parseInfo
}</span>

type ParseInfo struct {
        // Set for shortcode templates with any {{ .Inner }}
        IsInner bool

        // Set for partials with a return statement.
        HasReturn bool

        // Config extracted from template.
        Config ParseConfig
}

func (info ParseInfo) IsZero() bool <span class="cov0" title="0">{
        return info.Config.Version == 0
}</span>

// Info holds some info extracted from a parsed template.
type Info1 struct {
}

type ParseConfig struct {
        Version int
}

var DefaultParseConfig = ParseConfig{
        Version: TemplateVersion,
}

var DefaultParseInfo = ParseInfo{
        Config: DefaultParseConfig,
}
</pre>
		
		<pre class="file" id="file350" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package templates

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "templates"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Exists,
                        nil,
                        [][2]string{
                                {`{{ if (templates.Exists "partials/header.html") }}Yes!{{ end }}`, `Yes!`},
                                {`{{ if not (templates.Exists "partials/doesnotexist.html") }}No!{{ end }}`, `No!`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file351" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package templates provides template functions for working with templates.
package templates

import (
        "github.com/gohugoio/hugo/deps"
)

// New returns a new instance of the templates-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                deps: deps,
        }
}</span>

// Namespace provides template functions for the "templates" namespace.
type Namespace struct {
        deps *deps.Deps
}

// Exists returns whether the template with the given name exists.
// Note that this is the Unix-styled relative path including filename suffix,
// e.g. partials/header.html
func (ns *Namespace) Exists(name string) bool <span class="cov8" title="1">{
        return ns.deps.Tmpl().HasTemplate(name)
}</span>
</pre>
		
		<pre class="file" id="file352" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package time

import (
        "errors"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/langs"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "time"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                if d.Language == nil </span><span class="cov0" title="0">{
                        panic("Language must be set")</span>
                }
                <span class="cov8" title="1">ctx := New(langs.GetTranslator(d.Language), langs.GetLocation(d.Language))

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name: name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{
                                // Handle overlapping "time" namespace and func.
                                //
                                // If no args are passed to `time`, assume namespace usage and
                                // return namespace context.
                                //
                                // If args are passed, call AsTime().

                                switch len(args) </span>{
                                case 0:<span class="cov8" title="1">
                                        return ctx, nil</span>
                                case 1:<span class="cov0" title="0">
                                        return ctx.AsTime(args[0])</span>
                                case 2:<span class="cov0" title="0">
                                        return ctx.AsTime(args[0], args[1])</span>

                                // 3 or more arguments. Currently not supported.
                                default:<span class="cov0" title="0">
                                        return nil, errors.New("Invalid arguments supplied to `time`. Refer to time documentation: https://gohugo.io/functions/time/")</span>
                                }
                        },
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Format,
                        []string{"dateFormat"},
                        [][2]string{
                                {`dateFormat: {{ dateFormat "Monday, Jan 2, 2006" "2015-01-21" }}`, `dateFormat: Wednesday, Jan 21, 2015`},
                        },
                )

                ns.AddMethodMapping(ctx.Now,
                        []string{"now"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.AsTime,
                        nil,
                        [][2]string{
                                {`{{ (time "2015-01-21").Year }}`, `2015`},
                        },
                )

                ns.AddMethodMapping(ctx.Duration,
                        []string{"duration"},
                        [][2]string{
                                {`{{ mul 60 60 | duration "second" }}`, `1h0m0s`},
                        },
                )

                ns.AddMethodMapping(ctx.ParseDuration,
                        nil,
                        [][2]string{
                                {`{{ "1h12m10s" | time.ParseDuration }}`, `1h12m10s`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file353" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package time provides template functions for measuring and displaying time.
package time

import (
        "fmt"
        "time"
        _time "time"

        "github.com/gohugoio/hugo/common/htime"

        "github.com/gohugoio/locales"

        "github.com/spf13/cast"
)

// New returns a new instance of the time-namespaced template functions.
func New(translator locales.Translator, location *time.Location) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                timeFormatter: htime.NewTimeFormatter(translator),
                location:      location,
        }
}</span>

// Namespace provides template functions for the "time" namespace.
type Namespace struct {
        timeFormatter htime.TimeFormatter
        location      *time.Location
}

// AsTime converts the textual representation of the datetime string into
// a time.Time interface.
func (ns *Namespace) AsTime(v interface{}, args ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        loc := ns.location
        if len(args) &gt; 0 </span><span class="cov8" title="1">{
                locStr, err := cast.ToStringE(args[0])
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
                <span class="cov8" title="1">loc, err = _time.LoadLocation(locStr)
                if err != nil </span><span class="cov8" title="1">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return htime.ToTimeInDefaultLocationE(v, loc)</span>

}

// Format converts the textual representation of the datetime string into
// the other form or returns it of the time.Time value. These are formatted
// with the layout string
func (ns *Namespace) Format(layout string, v interface{}) (string, error) <span class="cov8" title="1">{
        t, err := htime.ToTimeInDefaultLocationE(v, ns.location)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return ns.timeFormatter.Format(t, layout), nil</span>
}

// Now returns the current local time.
func (ns *Namespace) Now() _time.Time <span class="cov0" title="0">{
        return _time.Now()
}</span>

// ParseDuration parses a duration string.
// A duration string is a possibly signed sequence of
// decimal numbers, each with optional fraction and a unit suffix,
// such as "300ms", "-1.5h" or "2h45m".
// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
// See https://golang.org/pkg/time/#ParseDuration
func (ns *Namespace) ParseDuration(in interface{}) (_time.Duration, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(in)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov0" title="0">return _time.ParseDuration(s)</span>
}

var durationUnits = map[string]_time.Duration{
        "nanosecond":  _time.Nanosecond,
        "ns":          _time.Nanosecond,
        "microsecond": _time.Microsecond,
        "us":          _time.Microsecond,
        "µs":          _time.Microsecond,
        "millisecond": _time.Millisecond,
        "ms":          _time.Millisecond,
        "second":      _time.Second,
        "s":           _time.Second,
        "minute":      _time.Minute,
        "m":           _time.Minute,
        "hour":        _time.Hour,
        "h":           _time.Hour,
}

// Duration converts the given number to a time.Duration.
// Unit is one of nanosecond/ns, microsecond/us/µs, millisecond/ms, second/s, minute/m or hour/h.
func (ns *Namespace) Duration(unit interface{}, number interface{}) (_time.Duration, error) <span class="cov8" title="1">{
        unitStr, err := cast.ToStringE(unit)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">unitDuration, found := durationUnits[unitStr]
        if !found </span><span class="cov8" title="1">{
                return 0, fmt.Errorf("%q is not a valid duration unit", unit)
        }</span>
        <span class="cov8" title="1">n, err := cast.ToInt64E(number)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>
        <span class="cov8" title="1">return _time.Duration(n) * unitDuration, nil</span>
}
</pre>
		
		<pre class="file" id="file354" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "strings"

        "github.com/gohugoio/hugo/tpl"
)

// Currently lang, outFormat, suffix
const numTemplateVariants = 3

type shortcodeVariant struct {

        // The possible variants: lang, outFormat, suffix
        // gtag
        // gtag.html
        // gtag.no.html
        // gtag.no.amp.html
        // A slice of length numTemplateVariants.
        variants []string

        ts *templateState
}

type shortcodeTemplates struct {
        variants []shortcodeVariant
}

func (s *shortcodeTemplates) indexOf(variants []string) int <span class="cov8" title="1">{
L:
        for i, v1 := range s.variants </span><span class="cov8" title="1">{
                for i, v2 := range v1.variants </span><span class="cov8" title="1">{
                        if v2 != variants[i] </span><span class="cov8" title="1">{
                                continue L</span>
                        }
                }
                <span class="cov8" title="1">return i</span>
        }
        <span class="cov8" title="1">return -1</span>
}

func (s *shortcodeTemplates) fromVariants(variants tpl.TemplateVariants) (shortcodeVariant, bool) <span class="cov8" title="1">{
        return s.fromVariantsSlice([]string{
                variants.Language,
                strings.ToLower(variants.OutputFormat.Name),
                variants.OutputFormat.MediaType.FirstSuffix.Suffix,
        })
}</span>

func (s *shortcodeTemplates) fromVariantsSlice(variants []string) (shortcodeVariant, bool) <span class="cov8" title="1">{
        var (
                bestMatch       shortcodeVariant
                bestMatchWeight int
        )

        for _, variant := range s.variants </span><span class="cov8" title="1">{
                w := s.compareVariants(variants, variant.variants)
                if bestMatchWeight == 0 || w &gt; bestMatchWeight </span><span class="cov8" title="1">{
                        bestMatch = variant
                        bestMatchWeight = w
                }</span>
        }

        <span class="cov8" title="1">return bestMatch, true</span>
}

// calculate a weight for two string slices of same length.
// higher value means "better match".
func (s *shortcodeTemplates) compareVariants(a, b []string) int <span class="cov8" title="1">{
        weight := 0
        k := len(a)
        for i, av := range a </span><span class="cov8" title="1">{
                bv := b[i]
                if av == bv </span><span class="cov8" title="1">{
                        // Add more weight to the left side (language...).
                        weight = weight + k - i
                }</span> else<span class="cov8" title="1"> {
                        weight--
                }</span>
        }
        <span class="cov8" title="1">return weight</span>
}

func templateVariants(name string) []string <span class="cov8" title="1">{
        _, variants := templateNameAndVariants(name)
        return variants
}</span>

func templateNameAndVariants(name string) (string, []string) <span class="cov8" title="1">{
        variants := make([]string, numTemplateVariants)

        parts := strings.Split(name, ".")

        if len(parts) &lt;= 1 </span><span class="cov8" title="1">{
                // No variants.
                return name, variants
        }</span>

        <span class="cov8" title="1">name = parts[0]
        parts = parts[1:]
        lp := len(parts)
        start := len(variants) - lp

        for i, j := start, 0; i &lt; len(variants); i, j = i+1, j+1 </span><span class="cov8" title="1">{
                variants[i] = parts[j]
        }</span>

        <span class="cov8" title="1">if lp &gt; 1 &amp;&amp; lp &lt; len(variants) </span><span class="cov8" title="1">{
                for i := lp - 1; i &gt; 0; i-- </span><span class="cov8" title="1">{
                        variants[i-1] = variants[i]
                }</span>
        }

        <span class="cov8" title="1">if lp == 1 </span><span class="cov8" title="1">{
                // Suffix only. Duplicate it into the output format field to
                // make HTML win over AMP.
                variants[len(variants)-2] = variants[len(variants)-1]
        }</span>

        <span class="cov8" title="1">return name, variants</span>
}

func resolveTemplateType(name string) templateType <span class="cov8" title="1">{
        if isShortcode(name) </span><span class="cov8" title="1">{
                return templateShortcode
        }</span>

        <span class="cov8" title="1">if strings.Contains(name, "partials/") </span><span class="cov8" title="1">{
                return templatePartial
        }</span>

        <span class="cov8" title="1">return templateUndefined</span>
}

func isShortcode(name string) bool <span class="cov8" title="1">{
        return strings.Contains(name, shortcodesPathPrefix)
}</span>

func isInternal(name string) bool <span class="cov8" title="1">{
        return strings.HasPrefix(name, internalPathPrefix)
}</span>
</pre>
		
		<pre class="file" id="file355" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "bytes"
        "embed"
        "io"
        "io/fs"
        "os"
        "path/filepath"
        "reflect"
        "regexp"
        "sort"
        "strings"
        "sync"
        "time"
        "unicode"
        "unicode/utf8"

        "github.com/gohugoio/hugo/common/types"

        "github.com/gohugoio/hugo/helpers"

        "github.com/gohugoio/hugo/output"

        "github.com/gohugoio/hugo/deps"
        "github.com/spf13/afero"

        "github.com/gohugoio/hugo/common/herrors"
        "github.com/gohugoio/hugo/hugofs"
        "github.com/gohugoio/hugo/hugofs/files"
        "github.com/pkg/errors"

        htmltemplate "github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate"
        texttemplate "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate"

        "github.com/gohugoio/hugo/identity"
        "github.com/gohugoio/hugo/tpl"
)

const (
        textTmplNamePrefix = "_text/"

        shortcodesPathPrefix = "shortcodes/"
        internalPathPrefix   = "_internal/"
        baseFileBase         = "baseof"
)

// The identifiers may be truncated in the log, e.g.
// "executing "main" at &lt;$scaled.SRelPermalin...&gt;: can't evaluate field SRelPermalink in type *resource.Image"
var identifiersRe = regexp.MustCompile(`at \&lt;(.*?)(\.{3})?\&gt;:`)

var embeddedTemplatesAliases = map[string][]string{
        "shortcodes/twitter.html": {"shortcodes/tweet.html"},
}

var (
        _ tpl.TemplateManager    = (*templateExec)(nil)
        _ tpl.TemplateHandler    = (*templateExec)(nil)
        _ tpl.TemplateFuncGetter = (*templateExec)(nil)
        _ tpl.TemplateFinder     = (*templateExec)(nil)

        _ tpl.Template = (*templateState)(nil)
        _ tpl.Info     = (*templateState)(nil)
)

var baseTemplateDefineRe = regexp.MustCompile(`^{{-?\s*define`)

// needsBaseTemplate returns true if the first non-comment template block is a
// define block.
// If a base template does not exist, we will handle that when it's used.
func needsBaseTemplate(templ string) bool <span class="cov8" title="1">{
        idx := -1
        inComment := false
        for i := 0; i &lt; len(templ); </span><span class="cov8" title="1">{
                if !inComment &amp;&amp; strings.HasPrefix(templ[i:], "{{/*") </span><span class="cov8" title="1">{
                        inComment = true
                        i += 4
                }</span> else<span class="cov8" title="1"> if inComment &amp;&amp; strings.HasPrefix(templ[i:], "*/}}") </span><span class="cov8" title="1">{
                        inComment = false
                        i += 4
                }</span> else<span class="cov8" title="1"> {
                        r, size := utf8.DecodeRuneInString(templ[i:])
                        if !inComment </span><span class="cov8" title="1">{
                                if strings.HasPrefix(templ[i:], "{{") </span><span class="cov8" title="1">{
                                        idx = i
                                        break</span>
                                } else<span class="cov8" title="1"> if !unicode.IsSpace(r) </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                        <span class="cov8" title="1">i += size</span>
                }
        }

        <span class="cov8" title="1">if idx == -1 </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">return baseTemplateDefineRe.MatchString(templ[idx:])</span>
}

func newIdentity(name string) identity.Manager <span class="cov8" title="1">{
        return identity.NewManager(identity.NewPathIdentity(files.ComponentFolderLayouts, name))
}</span>

func newStandaloneTextTemplate(funcs map[string]interface{}) tpl.TemplateParseFinder <span class="cov8" title="1">{
        return &amp;textTemplateWrapperWithLock{
                RWMutex:  &amp;sync.RWMutex{},
                Template: texttemplate.New("").Funcs(funcs),
        }
}</span>

func newTemplateExec(d *deps.Deps) (*templateExec, error) <span class="cov8" title="1">{
        exec, funcs := newTemplateExecuter(d)
        funcMap := make(map[string]interface{})
        for k, v := range funcs </span><span class="cov8" title="1">{
                funcMap[k] = v.Interface()
        }</span>

        <span class="cov8" title="1">h := &amp;templateHandler{
                nameBaseTemplateName: make(map[string]string),
                transformNotFound:    make(map[string]*templateState),
                identityNotFound:     make(map[string][]identity.Manager),

                shortcodes:   make(map[string]*shortcodeTemplates),
                templateInfo: make(map[string]tpl.Info),
                baseof:       make(map[string]templateInfo),
                needsBaseof:  make(map[string]templateInfo),

                main: newTemplateNamespace(funcMap),

                Deps:                d,
                layoutHandler:       output.NewLayoutHandler(),
                layoutsFs:           d.BaseFs.Layouts.Fs,
                layoutTemplateCache: make(map[layoutCacheKey]tpl.Template),
        }

        if err := h.loadEmbedded(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if err := h.loadTemplates(); err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">e := &amp;templateExec{
                d:               d,
                executor:        exec,
                funcs:           funcs,
                templateHandler: h,
        }

        d.SetTmpl(e)
        d.SetTextTmpl(newStandaloneTextTemplate(funcMap))

        if d.WithTemplate != nil </span><span class="cov8" title="1">{
                if err := d.WithTemplate(e); err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>
        }

        <span class="cov8" title="1">return e, nil</span>
}

func newTemplateNamespace(funcs map[string]interface{}) *templateNamespace <span class="cov8" title="1">{
        return &amp;templateNamespace{
                prototypeHTML: htmltemplate.New("").Funcs(funcs),
                prototypeText: texttemplate.New("").Funcs(funcs),
                templateStateMap: &amp;templateStateMap{
                        templates: make(map[string]*templateState),
                },
        }
}</span>

func newTemplateState(templ tpl.Template, info templateInfo) *templateState <span class="cov8" title="1">{
        return &amp;templateState{
                info:      info,
                typ:       info.resolveType(),
                Template:  templ,
                Manager:   newIdentity(info.name),
                parseInfo: tpl.DefaultParseInfo,
        }
}</span>

type layoutCacheKey struct {
        d output.LayoutDescriptor
        f string
}

type templateExec struct {
        d        *deps.Deps
        executor texttemplate.Executer
        funcs    map[string]reflect.Value

        *templateHandler
}

func (t templateExec) Clone(d *deps.Deps) *templateExec <span class="cov0" title="0">{
        exec, funcs := newTemplateExecuter(d)
        t.executor = exec
        t.funcs = funcs
        t.d = d
        return &amp;t
}</span>

func (t *templateExec) Execute(templ tpl.Template, wr io.Writer, data interface{}) error <span class="cov8" title="1">{
        if rlocker, ok := templ.(types.RLocker); ok </span><span class="cov0" title="0">{
                rlocker.RLock()
                defer rlocker.RUnlock()
        }</span>
        <span class="cov8" title="1">if t.Metrics != nil </span><span class="cov0" title="0">{
                defer t.Metrics.MeasureSince(templ.Name(), time.Now())
        }</span>

        <span class="cov8" title="1">execErr := t.executor.Execute(templ, wr, data)
        if execErr != nil </span><span class="cov0" title="0">{
                execErr = t.addFileContext(templ, execErr)
        }</span>
        <span class="cov8" title="1">return execErr</span>
}

func (t *templateExec) GetFunc(name string) (reflect.Value, bool) <span class="cov0" title="0">{
        v, found := t.funcs[name]
        return v, found
}</span>

func (t *templateExec) MarkReady() error <span class="cov0" title="0">{
        var err error
        t.readyInit.Do(func() </span><span class="cov0" title="0">{
                // We only need the clones if base templates are in use.
                if len(t.needsBaseof) &gt; 0 </span><span class="cov0" title="0">{
                        err = t.main.createPrototypes()
                }</span>
        })

        <span class="cov0" title="0">return err</span>
}

type templateHandler struct {
        main        *templateNamespace
        needsBaseof map[string]templateInfo
        baseof      map[string]templateInfo

        readyInit sync.Once

        // This is the filesystem to load the templates from. All the templates are
        // stored in the root of this filesystem.
        layoutsFs afero.Fs

        layoutHandler *output.LayoutHandler

        layoutTemplateCache   map[layoutCacheKey]tpl.Template
        layoutTemplateCacheMu sync.RWMutex

        *deps.Deps

        // Used to get proper filenames in errors
        nameBaseTemplateName map[string]string

        // Holds name and source of template definitions not found during the first
        // AST transformation pass.
        transformNotFound map[string]*templateState

        // Holds identities of templates not found during first pass.
        identityNotFound map[string][]identity.Manager

        // shortcodes maps shortcode name to template variants
        // (language, output format etc.) of that shortcode.
        shortcodes map[string]*shortcodeTemplates

        // templateInfo maps template name to some additional information about that template.
        // Note that for shortcodes that same information is embedded in the
        // shortcodeTemplates type.
        templateInfo map[string]tpl.Info
}

// AddTemplate parses and adds a template to the collection.
// Templates with name prefixed with "_text" will be handled as plain
// text templates.
func (t *templateHandler) AddTemplate(name, tpl string) error <span class="cov8" title="1">{
        templ, err := t.addTemplateTo(t.newTemplateInfo(name, tpl), t.main)
        if err == nil </span><span class="cov8" title="1">{
                t.applyTemplateTransformers(t.main, templ)
        }</span>
        <span class="cov8" title="1">return err</span>
}

func (t *templateHandler) Lookup(name string) (tpl.Template, bool) <span class="cov8" title="1">{
        templ, found := t.main.Lookup(name)
        if found </span><span class="cov8" title="1">{
                return templ, true
        }</span>

        <span class="cov8" title="1">return nil, false</span>
}

func (t *templateHandler) LookupLayout(d output.LayoutDescriptor, f output.Format) (tpl.Template, bool, error) <span class="cov0" title="0">{
        key := layoutCacheKey{d, f.Name}
        t.layoutTemplateCacheMu.RLock()
        if cacheVal, found := t.layoutTemplateCache[key]; found </span><span class="cov0" title="0">{
                t.layoutTemplateCacheMu.RUnlock()
                return cacheVal, true, nil
        }</span>
        <span class="cov0" title="0">t.layoutTemplateCacheMu.RUnlock()

        t.layoutTemplateCacheMu.Lock()
        defer t.layoutTemplateCacheMu.Unlock()

        templ, found, err := t.findLayout(d, f)
        if err == nil &amp;&amp; found </span><span class="cov0" title="0">{
                t.layoutTemplateCache[key] = templ
                return templ, true, nil
        }</span>

        <span class="cov0" title="0">return nil, false, err</span>
}

// This currently only applies to shortcodes and what we get here is the
// shortcode name.
func (t *templateHandler) LookupVariant(name string, variants tpl.TemplateVariants) (tpl.Template, bool, bool) <span class="cov8" title="1">{
        name = templateBaseName(templateShortcode, name)
        s, found := t.shortcodes[name]
        if !found </span><span class="cov0" title="0">{
                return nil, false, false
        }</span>

        <span class="cov8" title="1">sv, found := s.fromVariants(variants)
        if !found </span><span class="cov0" title="0">{
                return nil, false, false
        }</span>

        <span class="cov8" title="1">more := len(s.variants) &gt; 1

        return sv.ts, true, more</span>
}

// LookupVariants returns all variants of name, nil if none found.
func (t *templateHandler) LookupVariants(name string) []tpl.Template <span class="cov0" title="0">{
        name = templateBaseName(templateShortcode, name)
        s, found := t.shortcodes[name]
        if !found </span><span class="cov0" title="0">{
                return nil
        }</span>

        <span class="cov0" title="0">variants := make([]tpl.Template, len(s.variants))
        for i := 0; i &lt; len(variants); i++ </span><span class="cov0" title="0">{
                variants[i] = s.variants[i].ts
        }</span>

        <span class="cov0" title="0">return variants</span>
}

func (t *templateHandler) HasTemplate(name string) bool <span class="cov8" title="1">{
        if _, found := t.baseof[name]; found </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">if _, found := t.needsBaseof[name]; found </span><span class="cov0" title="0">{
                return true
        }</span>

        <span class="cov8" title="1">_, found := t.Lookup(name)
        return found</span>
}

func (t *templateHandler) findLayout(d output.LayoutDescriptor, f output.Format) (tpl.Template, bool, error) <span class="cov0" title="0">{
        layouts, _ := t.layoutHandler.For(d, f)
        for _, name := range layouts </span><span class="cov0" title="0">{
                templ, found := t.main.Lookup(name)
                if found </span><span class="cov0" title="0">{
                        return templ, true, nil
                }</span>

                <span class="cov0" title="0">overlay, found := t.needsBaseof[name]

                if !found </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov0" title="0">d.Baseof = true
                baseLayouts, _ := t.layoutHandler.For(d, f)
                var base templateInfo
                found = false
                for _, l := range baseLayouts </span><span class="cov0" title="0">{
                        base, found = t.baseof[l]
                        if found </span><span class="cov0" title="0">{
                                break</span>
                        }
                }

                <span class="cov0" title="0">templ, err := t.applyBaseTemplate(overlay, base)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, false, err
                }</span>

                <span class="cov0" title="0">ts := newTemplateState(templ, overlay)

                if found </span><span class="cov0" title="0">{
                        ts.baseInfo = base

                        // Add the base identity to detect changes
                        ts.Add(identity.NewPathIdentity(files.ComponentFolderLayouts, base.name))
                }</span>

                <span class="cov0" title="0">t.applyTemplateTransformers(t.main, ts)

                if err := t.extractPartials(ts.Template); err != nil </span><span class="cov0" title="0">{
                        return nil, false, err
                }</span>

                <span class="cov0" title="0">return ts, true, nil</span>

        }

        <span class="cov0" title="0">return nil, false, nil</span>
}

func (t *templateHandler) findTemplate(name string) *templateState <span class="cov8" title="1">{
        if templ, found := t.Lookup(name); found </span><span class="cov8" title="1">{
                return templ.(*templateState)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

func (t *templateHandler) newTemplateInfo(name, tpl string) templateInfo <span class="cov8" title="1">{
        var isText bool
        name, isText = t.nameIsText(name)
        return templateInfo{
                name:     name,
                isText:   isText,
                template: tpl,
        }
}</span>

func (t *templateHandler) addFileContext(templ tpl.Template, inerr error) error <span class="cov0" title="0">{
        if strings.HasPrefix(templ.Name(), "_internal") </span><span class="cov0" title="0">{
                return inerr
        }</span>

        <span class="cov0" title="0">ts, ok := templ.(*templateState)
        if !ok </span><span class="cov0" title="0">{
                return inerr
        }</span>

        //lint:ignore ST1008 the error is the main result
        <span class="cov0" title="0">checkFilename := func(info templateInfo, inErr error) (error, bool) </span><span class="cov0" title="0">{
                if info.filename == "" </span><span class="cov0" title="0">{
                        return inErr, false
                }</span>

                <span class="cov0" title="0">lineMatcher := func(m herrors.LineMatcher) bool </span><span class="cov0" title="0">{
                        if m.Position.LineNumber != m.LineNumber </span><span class="cov0" title="0">{
                                return false
                        }</span>

                        <span class="cov0" title="0">identifiers := t.extractIdentifiers(m.Error.Error())

                        for _, id := range identifiers </span><span class="cov0" title="0">{
                                if strings.Contains(m.Line, id) </span><span class="cov0" title="0">{
                                        return true
                                }</span>
                        }
                        <span class="cov0" title="0">return false</span>
                }

                <span class="cov0" title="0">f, err := t.layoutsFs.Open(info.filename)
                if err != nil </span><span class="cov0" title="0">{
                        return inErr, false
                }</span>
                <span class="cov0" title="0">defer f.Close()

                fe, ok := herrors.WithFileContext(inErr, info.realFilename, f, lineMatcher)
                if ok </span><span class="cov0" title="0">{
                        return fe, true
                }</span>
                <span class="cov0" title="0">return inErr, false</span>
        }

        <span class="cov0" title="0">inerr = errors.Wrap(inerr, "execute of template failed")

        if err, ok := checkFilename(ts.info, inerr); ok </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">err, _ := checkFilename(ts.baseInfo, inerr)

        return err</span>
}

func (t *templateHandler) addShortcodeVariant(ts *templateState) <span class="cov8" title="1">{
        name := ts.Name()
        base := templateBaseName(templateShortcode, name)

        shortcodename, variants := templateNameAndVariants(base)

        templs, found := t.shortcodes[shortcodename]
        if !found </span><span class="cov8" title="1">{
                templs = &amp;shortcodeTemplates{}
                t.shortcodes[shortcodename] = templs
        }</span>

        <span class="cov8" title="1">sv := shortcodeVariant{variants: variants, ts: ts}

        i := templs.indexOf(variants)

        if i != -1 </span><span class="cov8" title="1">{
                // Only replace if it's an override of an internal template.
                if !isInternal(name) </span><span class="cov0" title="0">{
                        templs.variants[i] = sv
                }</span>
        } else<span class="cov8" title="1"> {
                templs.variants = append(templs.variants, sv)
        }</span>
}

func (t *templateHandler) addTemplateFile(name, path string) error <span class="cov0" title="0">{
        getTemplate := func(filename string) (templateInfo, error) </span><span class="cov0" title="0">{
                fs := t.Layouts.Fs
                b, err := afero.ReadFile(fs, filename)
                if err != nil </span><span class="cov0" title="0">{
                        return templateInfo{filename: filename, fs: fs}, err
                }</span>

                <span class="cov0" title="0">s := removeLeadingBOM(string(b))

                realFilename := filename
                if fi, err := fs.Stat(filename); err == nil </span><span class="cov0" title="0">{
                        if fim, ok := fi.(hugofs.FileMetaInfo); ok </span><span class="cov0" title="0">{
                                realFilename = fim.Meta().Filename
                        }</span>
                }

                <span class="cov0" title="0">var isText bool
                name, isText = t.nameIsText(name)

                return templateInfo{
                        name:         name,
                        isText:       isText,
                        template:     s,
                        filename:     filename,
                        realFilename: realFilename,
                        fs:           fs,
                }, nil</span>
        }

        <span class="cov0" title="0">tinfo, err := getTemplate(path)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">if isBaseTemplatePath(name) </span><span class="cov0" title="0">{
                // Store it for later.
                t.baseof[name] = tinfo
                return nil
        }</span>

        <span class="cov0" title="0">needsBaseof := !t.noBaseNeeded(name) &amp;&amp; needsBaseTemplate(tinfo.template)
        if needsBaseof </span><span class="cov0" title="0">{
                t.needsBaseof[name] = tinfo
                return nil
        }</span>

        <span class="cov0" title="0">templ, err := t.addTemplateTo(tinfo, t.main)
        if err != nil </span><span class="cov0" title="0">{
                return tinfo.errWithFileContext("parse failed", err)
        }</span>
        <span class="cov0" title="0">t.applyTemplateTransformers(t.main, templ)

        return nil</span>
}

func (t *templateHandler) addTemplateTo(info templateInfo, to *templateNamespace) (*templateState, error) <span class="cov8" title="1">{
        return to.parse(info)
}</span>

func (t *templateHandler) applyBaseTemplate(overlay, base templateInfo) (tpl.Template, error) <span class="cov0" title="0">{
        if overlay.isText </span><span class="cov0" title="0">{
                var (
                        templ = t.main.prototypeTextClone.New(overlay.name)
                        err   error
                )

                if !base.IsZero() </span><span class="cov0" title="0">{
                        templ, err = templ.Parse(base.template)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, base.errWithFileContext("parse failed", err)
                        }</span>
                }

                <span class="cov0" title="0">templ, err = texttemplate.Must(templ.Clone()).Parse(overlay.template)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, overlay.errWithFileContext("parse failed", err)
                }</span>

                // The extra lookup is a workaround, see
                // * https://github.com/golang/go/issues/16101
                // * https://github.com/gohugoio/hugo/issues/2549
                // templ = templ.Lookup(templ.Name())

                <span class="cov0" title="0">return templ, nil</span>
        }

        <span class="cov0" title="0">var (
                templ = t.main.prototypeHTMLClone.New(overlay.name)
                err   error
        )

        if !base.IsZero() </span><span class="cov0" title="0">{
                templ, err = templ.Parse(base.template)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, base.errWithFileContext("parse failed", err)
                }</span>
        }

        <span class="cov0" title="0">templ, err = htmltemplate.Must(templ.Clone()).Parse(overlay.template)
        if err != nil </span><span class="cov0" title="0">{
                return nil, overlay.errWithFileContext("parse failed", err)
        }</span>

        // The extra lookup is a workaround, see
        // * https://github.com/golang/go/issues/16101
        // * https://github.com/gohugoio/hugo/issues/2549
        <span class="cov0" title="0">templ = templ.Lookup(templ.Name())

        return templ, err</span>
}

func (t *templateHandler) applyTemplateTransformers(ns *templateNamespace, ts *templateState) (*templateContext, error) <span class="cov8" title="1">{
        c, err := applyTemplateTransformers(ts, ns.newTemplateLookup(ts))
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">for k := range c.templateNotFound </span><span class="cov8" title="1">{
                t.transformNotFound[k] = ts
                t.identityNotFound[k] = append(t.identityNotFound[k], c.t)
        }</span>

        <span class="cov8" title="1">for k := range c.identityNotFound </span><span class="cov8" title="1">{
                t.identityNotFound[k] = append(t.identityNotFound[k], c.t)
        }</span>

        <span class="cov8" title="1">return c, err</span>
}

func (t *templateHandler) extractIdentifiers(line string) []string <span class="cov0" title="0">{
        m := identifiersRe.FindAllStringSubmatch(line, -1)
        identifiers := make([]string, len(m))
        for i := 0; i &lt; len(m); i++ </span><span class="cov0" title="0">{
                identifiers[i] = m[i][1]
        }</span>
        <span class="cov0" title="0">return identifiers</span>
}

//go:embed embedded/templates/*
var embededTemplatesFs embed.FS

func (t *templateHandler) loadEmbedded() error <span class="cov8" title="1">{
        return fs.WalkDir(embededTemplatesFs, ".", func(path string, d fs.DirEntry, err error) error </span><span class="cov8" title="1">{
                if d == nil || d.IsDir() </span><span class="cov8" title="1">{
                        return nil
                }</span>

                <span class="cov8" title="1">templb, err := embededTemplatesFs.ReadFile(path)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                // Get the newlines on Windows in line with how we had it back when we used Go Generate
                // to write the templates to Go files.
                <span class="cov8" title="1">templ := string(bytes.ReplaceAll(templb, []byte("\r\n"), []byte("\n")))
                name := strings.TrimPrefix(filepath.ToSlash(path), "embedded/templates/")

                if err := t.AddTemplate(internalPathPrefix+name, templ); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov8" title="1">if aliases, found := embeddedTemplatesAliases[name]; found </span><span class="cov8" title="1">{
                        // TODO(bep) avoid reparsing these aliases
                        for _, alias := range aliases </span><span class="cov8" title="1">{
                                alias = internalPathPrefix + alias
                                if err := t.AddTemplate(alias, templ); err != nil </span><span class="cov0" title="0">{
                                        return err
                                }</span>
                        }
                }

                <span class="cov8" title="1">return nil</span>
        })
}

func (t *templateHandler) loadTemplates() error <span class="cov8" title="1">{
        walker := func(path string, fi hugofs.FileMetaInfo, err error) error </span><span class="cov0" title="0">{
                if err != nil || fi.IsDir() </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if isDotFile(path) || isBackupFile(path) </span><span class="cov0" title="0">{
                        return nil
                }</span>

                <span class="cov0" title="0">name := strings.TrimPrefix(filepath.ToSlash(path), "/")
                filename := filepath.Base(path)
                outputFormat, found := t.OutputFormatsConfig.FromFilename(filename)

                if found &amp;&amp; outputFormat.IsPlainText </span><span class="cov0" title="0">{
                        name = textTmplNamePrefix + name
                }</span>

                <span class="cov0" title="0">if err := t.addTemplateFile(name, path); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">if err := helpers.SymbolicWalk(t.Layouts.Fs, "", walker); err != nil </span><span class="cov0" title="0">{
                if !os.IsNotExist(err) </span><span class="cov0" title="0">{
                        return err
                }</span>
                <span class="cov0" title="0">return nil</span>
        }

        <span class="cov8" title="1">return nil</span>
}

func (t *templateHandler) nameIsText(name string) (string, bool) <span class="cov8" title="1">{
        isText := strings.HasPrefix(name, textTmplNamePrefix)
        if isText </span><span class="cov0" title="0">{
                name = strings.TrimPrefix(name, textTmplNamePrefix)
        }</span>
        <span class="cov8" title="1">return name, isText</span>
}

func (t *templateHandler) noBaseNeeded(name string) bool <span class="cov0" title="0">{
        if strings.HasPrefix(name, "shortcodes/") || strings.HasPrefix(name, "partials/") </span><span class="cov0" title="0">{
                return true
        }</span>
        <span class="cov0" title="0">return strings.Contains(name, "_markup/")</span>
}

func (t *templateHandler) extractPartials(templ tpl.Template) error <span class="cov8" title="1">{
        templs := templates(templ)
        for _, templ := range templs </span><span class="cov8" title="1">{
                if templ.Name() == "" || !strings.HasPrefix(templ.Name(), "partials/") </span><span class="cov8" title="1">{
                        continue</span>
                }

                <span class="cov8" title="1">ts := newTemplateState(templ, templateInfo{name: templ.Name()})
                ts.typ = templatePartial

                t.main.mu.RLock()
                _, found := t.main.templates[templ.Name()]
                t.main.mu.RUnlock()

                if !found </span><span class="cov8" title="1">{
                        t.main.mu.Lock()
                        // This is a template defined inline.
                        _, err := applyTemplateTransformers(ts, t.main.newTemplateLookup(ts))
                        if err != nil </span><span class="cov0" title="0">{
                                t.main.mu.Unlock()
                                return err
                        }</span>
                        <span class="cov8" title="1">t.main.templates[templ.Name()] = ts
                        t.main.mu.Unlock()</span>

                }
        }

        <span class="cov8" title="1">return nil</span>
}

func (t *templateHandler) postTransform() error <span class="cov8" title="1">{
        defineCheckedHTML := false
        defineCheckedText := false

        for _, v := range t.main.templates </span><span class="cov8" title="1">{
                if v.typ == templateShortcode </span><span class="cov8" title="1">{
                        t.addShortcodeVariant(v)
                }</span>

                <span class="cov8" title="1">if defineCheckedHTML &amp;&amp; defineCheckedText </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">isText := isText(v.Template)
                if isText </span><span class="cov0" title="0">{
                        if defineCheckedText </span><span class="cov0" title="0">{
                                continue</span>
                        }
                        <span class="cov0" title="0">defineCheckedText = true</span>
                } else<span class="cov8" title="1"> {
                        if defineCheckedHTML </span><span class="cov8" title="1">{
                                continue</span>
                        }
                        <span class="cov8" title="1">defineCheckedHTML = true</span>
                }

                <span class="cov8" title="1">if err := t.extractPartials(v.Template); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">for name, source := range t.transformNotFound </span><span class="cov8" title="1">{
                lookup := t.main.newTemplateLookup(source)
                templ := lookup(name)
                if templ != nil </span><span class="cov8" title="1">{
                        _, err := applyTemplateTransformers(templ, lookup)
                        if err != nil </span><span class="cov0" title="0">{
                                return err
                        }</span>
                }
        }

        <span class="cov8" title="1">for k, v := range t.identityNotFound </span><span class="cov8" title="1">{
                ts := t.findTemplate(k)
                if ts != nil </span><span class="cov8" title="1">{
                        for _, im := range v </span><span class="cov8" title="1">{
                                im.Add(ts)
                        }</span>
                }
        }

        <span class="cov8" title="1">for _, v := range t.shortcodes </span><span class="cov8" title="1">{
                sort.Slice(v.variants, func(i, j int) bool </span><span class="cov0" title="0">{
                        v1, v2 := v.variants[i], v.variants[j]
                        name1, name2 := v1.ts.Name(), v2.ts.Name()
                        isHTMl1, isHTML2 := strings.HasSuffix(name1, "html"), strings.HasSuffix(name2, "html")

                        // There will be a weighted selection later, but make
                        // sure these are sorted to get a stable selection for
                        // output formats missing specific templates.
                        // Prefer HTML.
                        if isHTMl1 || isHTML2 &amp;&amp; !(isHTMl1 &amp;&amp; isHTML2) </span><span class="cov0" title="0">{
                                return isHTMl1
                        }</span>

                        <span class="cov0" title="0">return name1 &lt; name2</span>
                })
        }

        <span class="cov8" title="1">return nil</span>
}

type templateNamespace struct {
        prototypeText      *texttemplate.Template
        prototypeHTML      *htmltemplate.Template
        prototypeTextClone *texttemplate.Template
        prototypeHTMLClone *htmltemplate.Template

        *templateStateMap
}

func (t templateNamespace) Clone() *templateNamespace <span class="cov0" title="0">{
        t.mu.Lock()
        defer t.mu.Unlock()

        t.templateStateMap = &amp;templateStateMap{
                templates: make(map[string]*templateState),
        }

        t.prototypeText = texttemplate.Must(t.prototypeText.Clone())
        t.prototypeHTML = htmltemplate.Must(t.prototypeHTML.Clone())

        return &amp;t
}</span>

func (t *templateNamespace) Lookup(name string) (tpl.Template, bool) <span class="cov8" title="1">{
        t.mu.RLock()
        defer t.mu.RUnlock()

        templ, found := t.templates[name]
        if !found </span><span class="cov8" title="1">{
                return nil, false
        }</span>

        <span class="cov8" title="1">return templ, found</span>
}

func (t *templateNamespace) createPrototypes() error <span class="cov0" title="0">{
        t.prototypeTextClone = texttemplate.Must(t.prototypeText.Clone())
        t.prototypeHTMLClone = htmltemplate.Must(t.prototypeHTML.Clone())

        return nil
}</span>

func (t *templateNamespace) newTemplateLookup(in *templateState) func(name string) *templateState <span class="cov8" title="1">{
        return func(name string) *templateState </span><span class="cov8" title="1">{
                if templ, found := t.templates[name]; found </span><span class="cov8" title="1">{
                        if templ.isText() != in.isText() </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov8" title="1">return templ</span>
                }
                <span class="cov8" title="1">if templ, found := findTemplateIn(name, in); found </span><span class="cov8" title="1">{
                        return newTemplateState(templ, templateInfo{name: templ.Name()})
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}

func (t *templateNamespace) parse(info templateInfo) (*templateState, error) <span class="cov8" title="1">{
        t.mu.Lock()
        defer t.mu.Unlock()

        if info.isText </span><span class="cov0" title="0">{
                prototype := t.prototypeText

                templ, err := prototype.New(info.name).Parse(info.template)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

                <span class="cov0" title="0">ts := newTemplateState(templ, info)

                t.templates[info.name] = ts

                return ts, nil</span>
        }

        <span class="cov8" title="1">prototype := t.prototypeHTML

        templ, err := prototype.New(info.name).Parse(info.template)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">ts := newTemplateState(templ, info)

        t.templates[info.name] = ts

        return ts, nil</span>
}

type templateState struct {
        tpl.Template

        typ       templateType
        parseInfo tpl.ParseInfo
        identity.Manager

        info     templateInfo
        baseInfo templateInfo // Set when a base template is used.
}

func (t *templateState) ParseInfo() tpl.ParseInfo <span class="cov8" title="1">{
        return t.parseInfo
}</span>

func (t *templateState) isText() bool <span class="cov8" title="1">{
        return isText(t.Template)
}</span>

func isText(templ tpl.Template) bool <span class="cov8" title="1">{
        _, isText := templ.(*texttemplate.Template)
        return isText
}</span>

type templateStateMap struct {
        mu        sync.RWMutex
        templates map[string]*templateState
}

type templateWrapperWithLock struct {
        *sync.RWMutex
        tpl.Template
}

type textTemplateWrapperWithLock struct {
        *sync.RWMutex
        *texttemplate.Template
}

func (t *textTemplateWrapperWithLock) Lookup(name string) (tpl.Template, bool) <span class="cov0" title="0">{
        t.RLock()
        templ := t.Template.Lookup(name)
        t.RUnlock()
        if templ == nil </span><span class="cov0" title="0">{
                return nil, false
        }</span>
        <span class="cov0" title="0">return &amp;textTemplateWrapperWithLock{
                RWMutex:  t.RWMutex,
                Template: templ,
        }, true</span>
}

func (t *textTemplateWrapperWithLock) LookupVariant(name string, variants tpl.TemplateVariants) (tpl.Template, bool, bool) <span class="cov0" title="0">{
        panic("not supported")</span>
}

func (t *textTemplateWrapperWithLock) LookupVariants(name string) []tpl.Template <span class="cov0" title="0">{
        panic("not supported")</span>
}

func (t *textTemplateWrapperWithLock) Parse(name, tpl string) (tpl.Template, error) <span class="cov0" title="0">{
        t.Lock()
        defer t.Unlock()
        return t.Template.New(name).Parse(tpl)
}</span>

func isBackupFile(path string) bool <span class="cov0" title="0">{
        return path[len(path)-1] == '~'
}</span>

func isBaseTemplatePath(path string) bool <span class="cov0" title="0">{
        return strings.Contains(filepath.Base(path), baseFileBase)
}</span>

func isDotFile(path string) bool <span class="cov0" title="0">{
        return filepath.Base(path)[0] == '.'
}</span>

func removeLeadingBOM(s string) string <span class="cov0" title="0">{
        const bom = '\ufeff'

        for i, r := range s </span><span class="cov0" title="0">{
                if i == 0 &amp;&amp; r != bom </span><span class="cov0" title="0">{
                        return s
                }</span>
                <span class="cov0" title="0">if i &gt; 0 </span><span class="cov0" title="0">{
                        return s[i:]
                }</span>
        }

        <span class="cov0" title="0">return s</span>
}

// resolves _internal/shortcodes/param.html =&gt; param.html etc.
func templateBaseName(typ templateType, name string) string <span class="cov8" title="1">{
        name = strings.TrimPrefix(name, internalPathPrefix)
        switch typ </span>{
        case templateShortcode:<span class="cov8" title="1">
                return strings.TrimPrefix(name, shortcodesPathPrefix)</span>
        default:<span class="cov0" title="0">
                panic("not implemented")</span>
        }
}

func unwrap(templ tpl.Template) tpl.Template <span class="cov8" title="1">{
        if ts, ok := templ.(*templateState); ok </span><span class="cov8" title="1">{
                return ts.Template
        }</span>
        <span class="cov8" title="1">return templ</span>
}

func templates(in tpl.Template) []tpl.Template <span class="cov8" title="1">{
        var templs []tpl.Template
        in = unwrap(in)
        if textt, ok := in.(*texttemplate.Template); ok </span><span class="cov0" title="0">{
                for _, t := range textt.Templates() </span><span class="cov0" title="0">{
                        templs = append(templs, t)
                }</span>
        }

        <span class="cov8" title="1">if htmlt, ok := in.(*htmltemplate.Template); ok </span><span class="cov8" title="1">{
                for _, t := range htmlt.Templates() </span><span class="cov8" title="1">{
                        templs = append(templs, t)
                }</span>
        }

        <span class="cov8" title="1">return templs</span>
}
</pre>
		
		<pre class="file" id="file356" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "github.com/gohugoio/hugo/deps"
)

// TemplateProvider manages templates.
type TemplateProvider struct{}

// DefaultTemplateProvider is a globally available TemplateProvider.
var DefaultTemplateProvider *TemplateProvider

// Update updates the Hugo Template System in the provided Deps
// with all the additional features, templates &amp; functions.
func (*TemplateProvider) Update(d *deps.Deps) error <span class="cov8" title="1">{
        tmpl, err := newTemplateExec(d)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">return tmpl.postTransform()</span>
}

// Clone clones.
func (*TemplateProvider) Clone(d *deps.Deps) error <span class="cov0" title="0">{
        t := d.Tmpl().(*templateExec)
        d.SetTmpl(t.Clone(d))
        return nil
}</span>
</pre>
		
		<pre class="file" id="file357" style="display: none">// Copyright 2016 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "regexp"
        "strings"

        htmltemplate "github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate"
        texttemplate "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate"

        "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate/parse"

        "github.com/gohugoio/hugo/common/maps"
        "github.com/gohugoio/hugo/tpl"
        "github.com/mitchellh/mapstructure"
        "github.com/pkg/errors"
)

type templateType int

const (
        templateUndefined templateType = iota
        templateShortcode
        templatePartial
)

type templateContext struct {
        visited          map[string]bool
        templateNotFound map[string]bool
        identityNotFound map[string]bool
        lookupFn         func(name string) *templateState

        // The last error encountered.
        err error

        // Set when we're done checking for config header.
        configChecked bool

        t *templateState

        // Store away the return node in partials.
        returnNode *parse.CommandNode
}

func (c templateContext) getIfNotVisited(name string) *templateState <span class="cov8" title="1">{
        if c.visited[name] </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">c.visited[name] = true
        templ := c.lookupFn(name)
        if templ == nil </span><span class="cov8" title="1">{
                // This may be a inline template defined outside of this file
                // and not yet parsed. Unusual, but it happens.
                // Store the name to try again later.
                c.templateNotFound[name] = true
        }</span>

        <span class="cov8" title="1">return templ</span>
}

func newTemplateContext(
        t *templateState,
        lookupFn func(name string) *templateState) *templateContext <span class="cov8" title="1">{
        return &amp;templateContext{
                t:                t,
                lookupFn:         lookupFn,
                visited:          make(map[string]bool),
                templateNotFound: make(map[string]bool),
                identityNotFound: make(map[string]bool),
        }
}</span>

func applyTemplateTransformers(
        t *templateState,
        lookupFn func(name string) *templateState) (*templateContext, error) <span class="cov8" title="1">{
        if t == nil </span><span class="cov0" title="0">{
                return nil, errors.New("expected template, but none provided")
        }</span>

        <span class="cov8" title="1">c := newTemplateContext(t, lookupFn)
        tree := getParseTree(t.Template)

        _, err := c.applyTransformations(tree.Root)

        if err == nil &amp;&amp; c.returnNode != nil </span><span class="cov0" title="0">{
                // This is a partial with a return statement.
                c.t.parseInfo.HasReturn = true
                tree.Root = c.wrapInPartialReturnWrapper(tree.Root)
        }</span>

        <span class="cov8" title="1">return c, err</span>
}

func getParseTree(templ tpl.Template) *parse.Tree <span class="cov8" title="1">{
        templ = unwrap(templ)
        if text, ok := templ.(*texttemplate.Template); ok </span><span class="cov0" title="0">{
                return text.Tree
        }</span>
        <span class="cov8" title="1">return templ.(*htmltemplate.Template).Tree</span>
}

const (
        // We parse this template and modify the nodes in order to assign
        // the return value of a partial to a contextWrapper via Set. We use
        // "range" over a one-element slice so we can shift dot to the
        // partial's argument, Arg, while allowing Arg to be falsy.
        partialReturnWrapperTempl = `{{ $_hugo_dot := $ }}{{ $ := .Arg }}{{ range (slice .Arg) }}{{ $_hugo_dot.Set ("PLACEHOLDER") }}{{ end }}`
)

var partialReturnWrapper *parse.ListNode

func init() <span class="cov8" title="1">{
        templ, err := texttemplate.New("").Parse(partialReturnWrapperTempl)
        if err != nil </span><span class="cov0" title="0">{
                panic(err)</span>
        }
        <span class="cov8" title="1">partialReturnWrapper = templ.Tree.Root</span>
}

// wrapInPartialReturnWrapper copies and modifies the parsed nodes of a
// predefined partial return wrapper to insert those of a user-defined partial.
func (c *templateContext) wrapInPartialReturnWrapper(n *parse.ListNode) *parse.ListNode <span class="cov0" title="0">{
        wrapper := partialReturnWrapper.CopyList()
        rangeNode := wrapper.Nodes[2].(*parse.RangeNode)
        retn := rangeNode.List.Nodes[0]
        setCmd := retn.(*parse.ActionNode).Pipe.Cmds[0]
        setPipe := setCmd.Args[1].(*parse.PipeNode)
        // Replace PLACEHOLDER with the real return value.
        // Note that this is a PipeNode, so it will be wrapped in parens.
        setPipe.Cmds = []*parse.CommandNode{c.returnNode}
        rangeNode.List.Nodes = append(n.Nodes, retn)

        return wrapper
}</span>

// applyTransformations do 2 things:
// 1) Parses partial return statement.
// 2) Tracks template (partial) dependencies and some other info.
func (c *templateContext) applyTransformations(n parse.Node) (bool, error) <span class="cov8" title="1">{
        switch x := n.(type) </span>{
        case *parse.ListNode:<span class="cov8" title="1">
                if x != nil </span><span class="cov8" title="1">{
                        c.applyTransformationsToNodes(x.Nodes...)
                }</span>
        case *parse.ActionNode:<span class="cov8" title="1">
                c.applyTransformationsToNodes(x.Pipe)</span>
        case *parse.IfNode:<span class="cov8" title="1">
                c.applyTransformationsToNodes(x.Pipe, x.List, x.ElseList)</span>
        case *parse.WithNode:<span class="cov8" title="1">
                c.applyTransformationsToNodes(x.Pipe, x.List, x.ElseList)</span>
        case *parse.RangeNode:<span class="cov8" title="1">
                c.applyTransformationsToNodes(x.Pipe, x.List, x.ElseList)</span>
        case *parse.TemplateNode:<span class="cov8" title="1">
                subTempl := c.getIfNotVisited(x.Name)
                if subTempl != nil </span><span class="cov8" title="1">{
                        c.applyTransformationsToNodes(getParseTree(subTempl.Template).Root)
                }</span>
        case *parse.PipeNode:<span class="cov8" title="1">
                c.collectConfig(x)
                for i, cmd := range x.Cmds </span><span class="cov8" title="1">{
                        keep, _ := c.applyTransformations(cmd)
                        if !keep </span><span class="cov0" title="0">{
                                x.Cmds = append(x.Cmds[:i], x.Cmds[i+1:]...)
                        }</span>
                }

        case *parse.CommandNode:<span class="cov8" title="1">
                c.collectPartialInfo(x)
                c.collectInner(x)
                keep := c.collectReturnNode(x)

                for _, elem := range x.Args </span><span class="cov8" title="1">{
                        switch an := elem.(type) </span>{
                        case *parse.PipeNode:<span class="cov8" title="1">
                                c.applyTransformations(an)</span>
                        }
                }
                <span class="cov8" title="1">return keep, c.err</span>
        }

        <span class="cov8" title="1">return true, c.err</span>
}

func (c *templateContext) applyTransformationsToNodes(nodes ...parse.Node) <span class="cov8" title="1">{
        for _, node := range nodes </span><span class="cov8" title="1">{
                c.applyTransformations(node)
        }</span>
}

func (c *templateContext) hasIdent(idents []string, ident string) bool <span class="cov8" title="1">{
        for _, id := range idents </span><span class="cov8" title="1">{
                if id == ident </span><span class="cov8" title="1">{
                        return true
                }</span>
        }
        <span class="cov8" title="1">return false</span>
}

// collectConfig collects and parses any leading template config variable declaration.
// This will be the first PipeNode in the template, and will be a variable declaration
// on the form:
//    {{ $_hugo_config:= `{ "version": 1 }` }}
func (c *templateContext) collectConfig(n *parse.PipeNode) <span class="cov8" title="1">{
        if c.t.typ != templateShortcode </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if c.configChecked </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">c.configChecked = true

        if len(n.Decl) != 1 || len(n.Cmds) != 1 </span><span class="cov8" title="1">{
                // This cannot be a config declaration
                return
        }</span>

        <span class="cov8" title="1">v := n.Decl[0]

        if len(v.Ident) == 0 || v.Ident[0] != "$_hugo_config" </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">cmd := n.Cmds[0]

        if len(cmd.Args) == 0 </span><span class="cov0" title="0">{
                return
        }</span>

        <span class="cov8" title="1">if s, ok := cmd.Args[0].(*parse.StringNode); ok </span><span class="cov8" title="1">{
                errMsg := "failed to decode $_hugo_config in template"
                m, err := maps.ToStringMapE(s.Text)
                if err != nil </span><span class="cov0" title="0">{
                        c.err = errors.Wrap(err, errMsg)
                        return
                }</span>
                <span class="cov8" title="1">if err := mapstructure.WeakDecode(m, &amp;c.t.parseInfo.Config); err != nil </span><span class="cov0" title="0">{
                        c.err = errors.Wrap(err, errMsg)
                }</span>
        }
}

// collectInner determines if the given CommandNode represents a
// shortcode call to its .Inner.
func (c *templateContext) collectInner(n *parse.CommandNode) <span class="cov8" title="1">{
        if c.t.typ != templateShortcode </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">if c.t.parseInfo.IsInner || len(n.Args) == 0 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">for _, arg := range n.Args </span><span class="cov8" title="1">{
                var idents []string
                switch nt := arg.(type) </span>{
                case *parse.FieldNode:<span class="cov8" title="1">
                        idents = nt.Ident</span>
                case *parse.VariableNode:<span class="cov8" title="1">
                        idents = nt.Ident</span>
                }

                <span class="cov8" title="1">if c.hasIdent(idents, "Inner") </span><span class="cov8" title="1">{
                        c.t.parseInfo.IsInner = true
                        break</span>
                }
        }
}

var partialRe = regexp.MustCompile(`^partial(Cached)?$|^partials\.Include(Cached)?$`)

func (c *templateContext) collectPartialInfo(x *parse.CommandNode) <span class="cov8" title="1">{
        if len(x.Args) &lt; 2 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">first := x.Args[0]
        var id string
        switch v := first.(type) </span>{
        case *parse.IdentifierNode:<span class="cov8" title="1">
                id = v.Ident</span>
        case *parse.ChainNode:<span class="cov8" title="1">
                id = v.String()</span>
        }

        <span class="cov8" title="1">if partialRe.MatchString(id) </span><span class="cov8" title="1">{
                partialName := strings.Trim(x.Args[1].String(), "\"")
                if !strings.Contains(partialName, ".") </span><span class="cov8" title="1">{
                        partialName += ".html"
                }</span>
                <span class="cov8" title="1">partialName = "partials/" + partialName
                info := c.lookupFn(partialName)

                if info != nil </span><span class="cov0" title="0">{
                        c.t.Add(info)
                }</span> else<span class="cov8" title="1"> {
                        // Delay for later
                        c.identityNotFound[partialName] = true
                }</span>
        }
}

func (c *templateContext) collectReturnNode(n *parse.CommandNode) bool <span class="cov8" title="1">{
        if c.t.typ != templatePartial || c.returnNode != nil </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">if len(n.Args) &lt; 2 </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov8" title="1">ident, ok := n.Args[0].(*parse.IdentifierNode)
        if !ok || ident.Ident != "return" </span><span class="cov8" title="1">{
                return true
        }</span>

        <span class="cov0" title="0">c.returnNode = n
        // Remove the "return" identifiers
        c.returnNode.Args = c.returnNode.Args[1:]

        return false</span>
}

func findTemplateIn(name string, in tpl.Template) (tpl.Template, bool) <span class="cov8" title="1">{
        in = unwrap(in)
        if text, ok := in.(*texttemplate.Template); ok </span><span class="cov0" title="0">{
                if templ := text.Lookup(name); templ != nil </span><span class="cov0" title="0">{
                        return templ, true
                }</span>
                <span class="cov0" title="0">return nil, false</span>
        }
        <span class="cov8" title="1">if templ := in.(*htmltemplate.Template).Lookup(name); templ != nil </span><span class="cov8" title="1">{
                return templ, true
        }</span>
        <span class="cov8" title="1">return nil, false</span>
}
</pre>
		
		<pre class="file" id="file358" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "github.com/gohugoio/hugo/common/herrors"
        "github.com/pkg/errors"
        "github.com/spf13/afero"
)

type templateInfo struct {
        name     string
        template string
        isText   bool // HTML or plain text template.

        // Used to create some error context in error situations
        fs afero.Fs

        // The filename relative to the fs above.
        filename string

        // The real filename (if possible). Used for logging.
        realFilename string
}

func (t templateInfo) IsZero() bool <span class="cov0" title="0">{
        return t.name == ""
}</span>

func (t templateInfo) resolveType() templateType <span class="cov8" title="1">{
        return resolveTemplateType(t.name)
}</span>

func (info templateInfo) errWithFileContext(what string, err error) error <span class="cov0" title="0">{
        err = errors.Wrapf(err, what)

        err, _ = herrors.WithFileContextForFile(
                err,
                info.realFilename,
                info.filename,
                info.fs,
                herrors.SimpleLineMatcher)

        return err
}</span>
</pre>
		
		<pre class="file" id="file359" style="display: none">// Copyright 2017-present The Hugo Authors. All rights reserved.
//
// Portions Copyright The Go Authors.

// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package tplimpl

import (
        "reflect"
        "strings"

        "github.com/gohugoio/hugo/tpl"

        "github.com/gohugoio/hugo/common/maps"

        template "github.com/gohugoio/hugo/tpl/internal/go_templates/htmltemplate"
        texttemplate "github.com/gohugoio/hugo/tpl/internal/go_templates/texttemplate"

        "github.com/gohugoio/hugo/deps"

        "github.com/gohugoio/hugo/tpl/internal"

        // Init the namespaces
        _ "github.com/gohugoio/hugo/tpl/cast"
        _ "github.com/gohugoio/hugo/tpl/collections"
        _ "github.com/gohugoio/hugo/tpl/compare"
        _ "github.com/gohugoio/hugo/tpl/crypto"
        _ "github.com/gohugoio/hugo/tpl/data"
        _ "github.com/gohugoio/hugo/tpl/debug"
        _ "github.com/gohugoio/hugo/tpl/encoding"
        _ "github.com/gohugoio/hugo/tpl/fmt"
        _ "github.com/gohugoio/hugo/tpl/hugo"
        _ "github.com/gohugoio/hugo/tpl/images"
        _ "github.com/gohugoio/hugo/tpl/inflect"
        _ "github.com/gohugoio/hugo/tpl/js"
        _ "github.com/gohugoio/hugo/tpl/lang"
        _ "github.com/gohugoio/hugo/tpl/math"
        _ "github.com/gohugoio/hugo/tpl/openapi/openapi3"
        _ "github.com/gohugoio/hugo/tpl/os"
        _ "github.com/gohugoio/hugo/tpl/partials"
        _ "github.com/gohugoio/hugo/tpl/path"
        _ "github.com/gohugoio/hugo/tpl/reflect"
        _ "github.com/gohugoio/hugo/tpl/resources"
        _ "github.com/gohugoio/hugo/tpl/safe"
        _ "github.com/gohugoio/hugo/tpl/site"
        _ "github.com/gohugoio/hugo/tpl/strings"
        _ "github.com/gohugoio/hugo/tpl/templates"
        _ "github.com/gohugoio/hugo/tpl/time"
        _ "github.com/gohugoio/hugo/tpl/transform"
        _ "github.com/gohugoio/hugo/tpl/urls"
)

var (
        _    texttemplate.ExecHelper = (*templateExecHelper)(nil)
        zero reflect.Value
)

type templateExecHelper struct {
        running bool // whether we're in server mode.
        funcs   map[string]reflect.Value
}

func (t *templateExecHelper) GetFunc(tmpl texttemplate.Preparer, name string) (reflect.Value, bool) <span class="cov8" title="1">{
        if fn, found := t.funcs[name]; found </span><span class="cov8" title="1">{
                return fn, true
        }</span>
        <span class="cov0" title="0">return zero, false</span>
}

func (t *templateExecHelper) GetMapValue(tmpl texttemplate.Preparer, receiver, key reflect.Value) (reflect.Value, bool) <span class="cov8" title="1">{
        if params, ok := receiver.Interface().(maps.Params); ok </span><span class="cov0" title="0">{
                // Case insensitive.
                keystr := strings.ToLower(key.String())
                v, found := params[keystr]
                if !found </span><span class="cov0" title="0">{
                        return zero, false
                }</span>
                <span class="cov0" title="0">return reflect.ValueOf(v), true</span>
        }

        <span class="cov8" title="1">v := receiver.MapIndex(key)

        return v, v.IsValid()</span>
}

func (t *templateExecHelper) GetMethod(tmpl texttemplate.Preparer, receiver reflect.Value, name string) (method reflect.Value, firstArg reflect.Value) <span class="cov8" title="1">{
        if t.running </span><span class="cov0" title="0">{
                // This is a hot path and receiver.MethodByName really shows up in the benchmarks,
                // so we maintain a list of method names with that signature.
                switch name </span>{
                case "GetPage", "Render":<span class="cov0" title="0">
                        if info, ok := tmpl.(tpl.Info); ok </span><span class="cov0" title="0">{
                                if m := receiver.MethodByName(name + "WithTemplateInfo"); m.IsValid() </span><span class="cov0" title="0">{
                                        return m, reflect.ValueOf(info)
                                }</span>
                        }
                }
        }

        <span class="cov8" title="1">return receiver.MethodByName(name), zero</span>
}

func newTemplateExecuter(d *deps.Deps) (texttemplate.Executer, map[string]reflect.Value) <span class="cov8" title="1">{
        funcs := createFuncMap(d)
        funcsv := make(map[string]reflect.Value)

        for k, v := range funcs </span><span class="cov8" title="1">{
                vv := reflect.ValueOf(v)
                funcsv[k] = vv
        }</span>

        // Duplicate Go's internal funcs here for faster lookups.
        <span class="cov8" title="1">for k, v := range template.GoFuncs </span><span class="cov8" title="1">{
                if _, exists := funcsv[k]; !exists </span><span class="cov8" title="1">{
                        vv, ok := v.(reflect.Value)
                        if !ok </span><span class="cov8" title="1">{
                                vv = reflect.ValueOf(v)
                        }</span>
                        <span class="cov8" title="1">funcsv[k] = vv</span>
                }
        }

        <span class="cov8" title="1">for k, v := range texttemplate.GoFuncs </span><span class="cov8" title="1">{
                if _, exists := funcsv[k]; !exists </span><span class="cov8" title="1">{
                        funcsv[k] = v
                }</span>
        }

        <span class="cov8" title="1">exeHelper := &amp;templateExecHelper{
                running: d.Running,
                funcs:   funcsv,
        }

        return texttemplate.NewExecuter(
                exeHelper,
        ), funcsv</span>
}

func createFuncMap(d *deps.Deps) map[string]interface{} <span class="cov8" title="1">{
        funcMap := template.FuncMap{}

        // Merge the namespace funcs
        for _, nsf := range internal.TemplateFuncsNamespaceRegistry </span><span class="cov8" title="1">{
                ns := nsf(d)
                if _, exists := funcMap[ns.Name]; exists </span><span class="cov0" title="0">{
                        panic(ns.Name + " is a duplicate template func")</span>
                }
                <span class="cov8" title="1">funcMap[ns.Name] = ns.Context
                for _, mm := range ns.MethodMappings </span><span class="cov8" title="1">{
                        for _, alias := range mm.Aliases </span><span class="cov8" title="1">{
                                if _, exists := funcMap[alias]; exists </span><span class="cov0" title="0">{
                                        panic(alias + " is a duplicate template func")</span>
                                }
                                <span class="cov8" title="1">funcMap[alias] = mm.Method</span>
                        }
                }
        }

        <span class="cov8" title="1">if d.OverloadedTemplateFuncs != nil </span><span class="cov0" title="0">{
                for k, v := range d.OverloadedTemplateFuncs </span><span class="cov0" title="0">{
                        funcMap[k] = v
                }</span>
        }

        <span class="cov8" title="1">return funcMap</span>
}
</pre>
		
		<pre class="file" id="file360" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package transform

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "transform"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.Emojify,
                        []string{"emojify"},
                        [][2]string{
                                {`{{ "I :heart: Hugo" | emojify }}`, `I ❤️ Hugo`},
                        },
                )

                ns.AddMethodMapping(ctx.Highlight,
                        []string{"highlight"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.HTMLEscape,
                        []string{"htmlEscape"},
                        [][2]string{
                                {
                                        `{{ htmlEscape "Cathal Garvey &amp; The Sunshine Band &lt;cathal@foo.bar&gt;" | safeHTML}}`,
                                        `Cathal Garvey &amp;amp; The Sunshine Band &amp;lt;cathal@foo.bar&amp;gt;`,
                                },
                                {
                                        `{{ htmlEscape "Cathal Garvey &amp; The Sunshine Band &lt;cathal@foo.bar&gt;"}}`,
                                        `Cathal Garvey &amp;amp;amp; The Sunshine Band &amp;amp;lt;cathal@foo.bar&amp;amp;gt;`,
                                },
                                {
                                        `{{ htmlEscape "Cathal Garvey &amp; The Sunshine Band &lt;cathal@foo.bar&gt;" | htmlUnescape | safeHTML }}`,
                                        `Cathal Garvey &amp; The Sunshine Band &lt;cathal@foo.bar&gt;`,
                                },
                        },
                )

                ns.AddMethodMapping(ctx.HTMLUnescape,
                        []string{"htmlUnescape"},
                        [][2]string{
                                {
                                        `{{ htmlUnescape "Cathal Garvey &amp;amp; The Sunshine Band &amp;lt;cathal@foo.bar&amp;gt;" | safeHTML}}`,
                                        `Cathal Garvey &amp; The Sunshine Band &lt;cathal@foo.bar&gt;`,
                                },
                                {
                                        `{{"Cathal Garvey &amp;amp;amp; The Sunshine Band &amp;amp;lt;cathal@foo.bar&amp;amp;gt;" | htmlUnescape | htmlUnescape | safeHTML}}`,
                                        `Cathal Garvey &amp; The Sunshine Band &lt;cathal@foo.bar&gt;`,
                                },
                                {
                                        `{{"Cathal Garvey &amp;amp;amp; The Sunshine Band &amp;amp;lt;cathal@foo.bar&amp;amp;gt;" | htmlUnescape | htmlUnescape }}`,
                                        `Cathal Garvey &amp;amp; The Sunshine Band &amp;lt;cathal@foo.bar&amp;gt;`,
                                },
                                {
                                        `{{ htmlUnescape "Cathal Garvey &amp;amp; The Sunshine Band &amp;lt;cathal@foo.bar&amp;gt;" | htmlEscape | safeHTML }}`,
                                        `Cathal Garvey &amp;amp; The Sunshine Band &amp;lt;cathal@foo.bar&amp;gt;`,
                                },
                        },
                )

                ns.AddMethodMapping(ctx.Markdownify,
                        []string{"markdownify"},
                        [][2]string{
                                {`{{ .Title | markdownify}}`, `&lt;strong&gt;BatMan&lt;/strong&gt;`},
                        },
                )

                ns.AddMethodMapping(ctx.Plainify,
                        []string{"plainify"},
                        [][2]string{
                                {`{{ plainify  "Hello &lt;strong&gt;world&lt;/strong&gt;, gophers!" }}`, `Hello world, gophers!`},
                        },
                )

                ns.AddMethodMapping(ctx.Remarshal,
                        nil,
                        [][2]string{
                                {`{{ "title = \"Hello World\"" | transform.Remarshal "json" | safeHTML }}`, "{\n   \"title\": \"Hello World\"\n}\n"},
                        },
                )

                ns.AddMethodMapping(ctx.Unmarshal,
                        []string{"unmarshal"},
                        [][2]string{
                                {`{{ "hello = \"Hello World\"" | transform.Unmarshal }}`, "map[hello:Hello World]"},
                                {`{{ "hello = \"Hello World\"" | resources.FromString "data/greetings.toml" | transform.Unmarshal }}`, "map[hello:Hello World]"},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file361" style="display: none">package transform

import (
        "bytes"
        "strings"

        "github.com/pkg/errors"

        "github.com/gohugoio/hugo/parser"
        "github.com/gohugoio/hugo/parser/metadecoders"
        "github.com/spf13/cast"
)

// Remarshal is used in the Hugo documentation to convert configuration
// examples from YAML to JSON, TOML (and possibly the other way around).
// The is primarily a helper for the Hugo docs site.
// It is not a general purpose YAML to TOML converter etc., and may
// change without notice if it serves a purpose in the docs.
// Format is one of json, yaml or toml.
func (ns *Namespace) Remarshal(format string, data interface{}) (string, error) <span class="cov8" title="1">{
        var meta map[string]interface{}

        format = strings.TrimSpace(strings.ToLower(format))

        mark, err := toFormatMark(format)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">if m, ok := data.(map[string]interface{}); ok </span><span class="cov8" title="1">{
                meta = m
        }</span> else<span class="cov8" title="1"> {
                from, err := cast.ToStringE(data)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>

                <span class="cov8" title="1">from = strings.TrimSpace(from)
                if from == "" </span><span class="cov0" title="0">{
                        return "", nil
                }</span>

                <span class="cov8" title="1">fromFormat := metadecoders.Default.FormatFromContentString(from)
                if fromFormat == "" </span><span class="cov8" title="1">{
                        return "", errors.New("failed to detect format from content")
                }</span>

                <span class="cov8" title="1">meta, err = metadecoders.Default.UnmarshalToMap([]byte(from), fromFormat)
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        // Make it so 1.0 float64 prints as 1 etc.
        <span class="cov8" title="1">applyMarshalTypes(meta)

        var result bytes.Buffer
        if err := parser.InterfaceToConfig(meta, mark, &amp;result); err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov8" title="1">return result.String(), nil</span>
}

// The unmarshal/marshal dance is extremely type lossy, and we need
// to make sure that integer types prints as "43" and not "43.0" in
// all formats, hence this hack.
func applyMarshalTypes(m map[string]interface{}) <span class="cov8" title="1">{
        for k, v := range m </span><span class="cov8" title="1">{
                switch t := v.(type) </span>{
                case map[string]interface{}:<span class="cov8" title="1">
                        applyMarshalTypes(t)</span>
                case float64:<span class="cov0" title="0">
                        i := int64(t)
                        if t == float64(i) </span><span class="cov0" title="0">{
                                m[k] = i
                        }</span>
                }
        }
}

func toFormatMark(format string) (metadecoders.Format, error) <span class="cov8" title="1">{
        if f := metadecoders.FormatFromString(format); f != "" </span><span class="cov8" title="1">{
                return f, nil
        }</span>

        <span class="cov8" title="1">return "", errors.New("failed to detect target data serialization format")</span>
}
</pre>
		
		<pre class="file" id="file362" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package transform provides template functions for transforming content.
package transform

import (
        "html"
        "html/template"

        "github.com/gohugoio/hugo/cache/namedmemcache"

        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/helpers"
        "github.com/spf13/cast"
)

// New returns a new instance of the transform-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        cache := namedmemcache.New()
        deps.BuildStartListeners.Add(
                func() </span><span class="cov0" title="0">{
                        cache.Clear()
                }</span>)

        <span class="cov8" title="1">return &amp;Namespace{
                cache: cache,
                deps:  deps,
        }</span>
}

// Namespace provides template functions for the "transform" namespace.
type Namespace struct {
        cache *namedmemcache.Cache
        deps  *deps.Deps
}

// Emojify returns a copy of s with all emoji codes replaced with actual emojis.
//
// See http://www.emoji-cheat-sheet.com/
func (ns *Namespace) Emojify(s interface{}) (template.HTML, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return template.HTML(helpers.Emojify([]byte(ss))), nil</span>
}

// Highlight returns a copy of s as an HTML string with syntax
// highlighting applied.
func (ns *Namespace) Highlight(s interface{}, lang string, opts ...interface{}) (template.HTML, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">sopts := ""
        if len(opts) &gt; 0 </span><span class="cov8" title="1">{
                sopts, err = cast.ToStringE(opts[0])
                if err != nil </span><span class="cov0" title="0">{
                        return "", err
                }</span>
        }

        <span class="cov8" title="1">highlighted, _ := ns.deps.ContentSpec.Converters.Highlight(ss, lang, sopts)
        return template.HTML(highlighted), nil</span>
}

// HTMLEscape returns a copy of s with reserved HTML characters escaped.
func (ns *Namespace) HTMLEscape(s interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return html.EscapeString(ss), nil</span>
}

// HTMLUnescape returns a copy of with HTML escape requences converted to plain
// text.
func (ns *Namespace) HTMLUnescape(s interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return html.UnescapeString(ss), nil</span>
}

// Markdownify renders a given input from Markdown to HTML.
func (ns *Namespace) Markdownify(s interface{}) (template.HTML, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">b, err := ns.deps.ContentSpec.RenderMarkdown([]byte(ss))
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        // Strip if this is a short inline type of text.
        <span class="cov8" title="1">b = ns.deps.ContentSpec.TrimShortHTML(b)

        return helpers.BytesToHTML(b), nil</span>
}

// Plainify returns a copy of s with all HTML tags removed.
func (ns *Namespace) Plainify(s interface{}) (string, error) <span class="cov8" title="1">{
        ss, err := cast.ToStringE(s)
        if err != nil </span><span class="cov8" title="1">{
                return "", err
        }</span>

        <span class="cov8" title="1">return helpers.StripHTML(ss), nil</span>
}
</pre>
		
		<pre class="file" id="file363" style="display: none">// Copyright 2019 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package transform

import (
        "io/ioutil"
        "strings"

        "github.com/gohugoio/hugo/resources/resource"

        "github.com/gohugoio/hugo/common/types"

        "github.com/mitchellh/mapstructure"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/parser/metadecoders"
        "github.com/pkg/errors"

        "github.com/spf13/cast"
)

// Unmarshal unmarshals the data given, which can be either a string, json.RawMessage
// or a Resource. Supported formats are JSON, TOML, YAML, and CSV.
// You can optionally provide an options map as the first argument.
func (ns *Namespace) Unmarshal(args ...interface{}) (interface{}, error) <span class="cov8" title="1">{
        if len(args) &lt; 1 || len(args) &gt; 2 </span><span class="cov0" title="0">{
                return nil, errors.New("unmarshal takes 1 or 2 arguments")
        }</span>

        <span class="cov8" title="1">var data interface{}
        decoder := metadecoders.Default

        if len(args) == 1 </span><span class="cov8" title="1">{
                data = args[0]
        }</span> else<span class="cov8" title="1"> {
                m, ok := args[0].(map[string]interface{})
                if !ok </span><span class="cov0" title="0">{
                        return nil, errors.New("first argument must be a map")
                }</span>

                <span class="cov8" title="1">var err error

                data = args[1]
                decoder, err = decodeDecoder(m)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, errors.WithMessage(err, "failed to decode options")
                }</span>
        }

        <span class="cov8" title="1">if r, ok := data.(resource.UnmarshableResource); ok </span><span class="cov8" title="1">{
                key := r.Key()

                if key == "" </span><span class="cov0" title="0">{
                        return nil, errors.New("no Key set in Resource")
                }</span>

                <span class="cov8" title="1">if decoder != metadecoders.Default </span><span class="cov8" title="1">{
                        key += decoder.OptionsKey()
                }</span>

                <span class="cov8" title="1">return ns.cache.GetOrCreate(key, func() (interface{}, error) </span><span class="cov8" title="1">{
                        f := metadecoders.FormatFromMediaType(r.MediaType())
                        if f == "" </span><span class="cov8" title="1">{
                                return nil, errors.Errorf("MIME %q not supported", r.MediaType())
                        }</span>

                        <span class="cov8" title="1">reader, err := r.ReadSeekCloser()
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>
                        <span class="cov8" title="1">defer reader.Close()

                        b, err := ioutil.ReadAll(reader)
                        if err != nil </span><span class="cov0" title="0">{
                                return nil, err
                        }</span>

                        <span class="cov8" title="1">return decoder.Unmarshal(b, f)</span>
                })
        }

        <span class="cov8" title="1">dataStr, err := types.ToStringE(data)
        if err != nil </span><span class="cov8" title="1">{
                return nil, errors.Errorf("type %T not supported", data)
        }</span>

        <span class="cov8" title="1">if dataStr == "" </span><span class="cov0" title="0">{
                return nil, errors.New("no data to transform")
        }</span>

        <span class="cov8" title="1">key := helpers.MD5String(dataStr)

        return ns.cache.GetOrCreate(key, func() (interface{}, error) </span><span class="cov8" title="1">{
                f := decoder.FormatFromContentString(dataStr)
                if f == "" </span><span class="cov8" title="1">{
                        return nil, errors.New("unknown format")
                }</span>

                <span class="cov8" title="1">return decoder.Unmarshal([]byte(dataStr), f)</span>
        })
}

func decodeDecoder(m map[string]interface{}) (metadecoders.Decoder, error) <span class="cov8" title="1">{
        opts := metadecoders.Default

        if m == nil </span><span class="cov0" title="0">{
                return opts, nil
        }</span>

        // mapstructure does not support string to rune conversion, so do that manually.
        // See https://github.com/mitchellh/mapstructure/issues/151
        <span class="cov8" title="1">for k, v := range m </span><span class="cov8" title="1">{
                if strings.EqualFold(k, "Delimiter") </span><span class="cov8" title="1">{
                        r, err := stringToRune(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return opts, err
                        }</span>
                        <span class="cov8" title="1">opts.Delimiter = r
                        delete(m, k)</span>

                } else<span class="cov8" title="1"> if strings.EqualFold(k, "Comment") </span><span class="cov8" title="1">{
                        r, err := stringToRune(v)
                        if err != nil </span><span class="cov0" title="0">{
                                return opts, err
                        }</span>
                        <span class="cov8" title="1">opts.Comment = r
                        delete(m, k)</span>
                }
        }

        <span class="cov8" title="1">err := mapstructure.WeakDecode(m, &amp;opts)

        return opts, err</span>
}

func stringToRune(v interface{}) (rune, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(v)
        if err != nil </span><span class="cov0" title="0">{
                return 0, err
        }</span>

        <span class="cov8" title="1">if len(s) == 0 </span><span class="cov0" title="0">{
                return 0, nil
        }</span>

        <span class="cov8" title="1">var r rune

        for i, rr := range s </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        r = rr
                }</span> else<span class="cov0" title="0"> {
                        return 0, errors.Errorf("invalid character: %q", v)
                }</span>
        }

        <span class="cov8" title="1">return r, nil</span>
}
</pre>
		
		<pre class="file" id="file364" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package urls

import (
        "github.com/gohugoio/hugo/deps"
        "github.com/gohugoio/hugo/tpl/internal"
)

const name = "urls"

func init() <span class="cov8" title="1">{
        f := func(d *deps.Deps) *internal.TemplateFuncsNamespace </span><span class="cov8" title="1">{
                ctx := New(d)

                ns := &amp;internal.TemplateFuncsNamespace{
                        Name:    name,
                        Context: func(args ...interface{}) (interface{}, error) </span><span class="cov8" title="1">{ return ctx, nil }</span>,
                }

                <span class="cov8" title="1">ns.AddMethodMapping(ctx.AbsURL,
                        []string{"absURL"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.AbsLangURL,
                        []string{"absLangURL"},
                        [][2]string{},
                )
                ns.AddMethodMapping(ctx.Ref,
                        []string{"ref"},
                        [][2]string{},
                )
                ns.AddMethodMapping(ctx.RelURL,
                        []string{"relURL"},
                        [][2]string{},
                )
                ns.AddMethodMapping(ctx.RelLangURL,
                        []string{"relLangURL"},
                        [][2]string{},
                )
                ns.AddMethodMapping(ctx.RelRef,
                        []string{"relref"},
                        [][2]string{},
                )
                ns.AddMethodMapping(ctx.URLize,
                        []string{"urlize"},
                        [][2]string{},
                )

                ns.AddMethodMapping(ctx.Anchorize,
                        []string{"anchorize"},
                        [][2]string{
                                {`{{ "This is a title" | anchorize }}`, `this-is-a-title`},
                        },
                )

                return ns</span>
        }

        <span class="cov8" title="1">internal.AddTemplateFuncsNamespace(f)</span>
}
</pre>
		
		<pre class="file" id="file365" style="display: none">// Copyright 2017 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package urls provides template functions to deal with URLs.
package urls

import (
        "errors"
        "fmt"
        "html/template"
        "net/url"

        "github.com/gohugoio/hugo/common/urls"
        "github.com/gohugoio/hugo/deps"
        _errors "github.com/pkg/errors"
        "github.com/spf13/cast"
)

// New returns a new instance of the urls-namespaced template functions.
func New(deps *deps.Deps) *Namespace <span class="cov8" title="1">{
        return &amp;Namespace{
                deps:      deps,
                multihost: deps.Cfg.GetBool("multihost"),
        }
}</span>

// Namespace provides template functions for the "urls" namespace.
type Namespace struct {
        deps      *deps.Deps
        multihost bool
}

// AbsURL takes a given string and converts it to an absolute URL.
func (ns *Namespace) AbsURL(a interface{}) (template.HTML, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">return template.HTML(ns.deps.PathSpec.AbsURL(s, false)), nil</span>
}

// Parse parses rawurl into a URL structure. The rawurl may be relative or
// absolute.
func (ns *Namespace) Parse(rawurl interface{}) (*url.URL, error) <span class="cov8" title="1">{
        s, err := cast.ToStringE(rawurl)
        if err != nil </span><span class="cov8" title="1">{
                return nil, _errors.Wrap(err, "Error in Parse")
        }</span>

        <span class="cov8" title="1">return url.Parse(s)</span>
}

// RelURL takes a given string and prepends the relative path according to a
// page's position in the project directory structure.
func (ns *Namespace) RelURL(a interface{}) (template.HTML, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>

        <span class="cov0" title="0">return template.HTML(ns.deps.PathSpec.RelURL(s, false)), nil</span>
}

// URLize returns the given argument formatted as URL.
func (ns *Namespace) URLize(a interface{}) (string, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return ns.deps.PathSpec.URLize(s), nil</span>
}

// Anchorize creates sanitized anchor names that are compatible with Blackfriday.
func (ns *Namespace) Anchorize(a interface{}) (string, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", nil
        }</span>
        <span class="cov0" title="0">return ns.deps.ContentSpec.SanitizeAnchorName(s), nil</span>
}

// Ref returns the absolute URL path to a given content item.
func (ns *Namespace) Ref(in interface{}, args interface{}) (template.HTML, error) <span class="cov0" title="0">{
        p, ok := in.(urls.RefLinker)
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("invalid Page received in Ref")
        }</span>
        <span class="cov0" title="0">argsm, err := ns.refArgsToMap(args)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>
        <span class="cov0" title="0">s, err := p.Ref(argsm)
        return template.HTML(s), err</span>
}

// RelRef returns the relative URL path to a given content item.
func (ns *Namespace) RelRef(in interface{}, args interface{}) (template.HTML, error) <span class="cov0" title="0">{
        p, ok := in.(urls.RefLinker)
        if !ok </span><span class="cov0" title="0">{
                return "", errors.New("invalid Page received in RelRef")
        }</span>
        <span class="cov0" title="0">argsm, err := ns.refArgsToMap(args)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">s, err := p.RelRef(argsm)
        return template.HTML(s), err</span>
}

func (ns *Namespace) refArgsToMap(args interface{}) (map[string]interface{}, error) <span class="cov0" title="0">{
        var (
                s  string
                of string
        )

        v := args
        if _, ok := v.([]interface{}); ok </span><span class="cov0" title="0">{
                v = cast.ToStringSlice(v)
        }</span>

        <span class="cov0" title="0">switch v := v.(type) </span>{
        case map[string]interface{}:<span class="cov0" title="0">
                return v, nil</span>
        case map[string]string:<span class="cov0" title="0">
                m := make(map[string]interface{})
                for k, v := range v </span><span class="cov0" title="0">{
                        m[k] = v
                }</span>
                <span class="cov0" title="0">return m, nil</span>
        case []string:<span class="cov0" title="0">
                if len(v) == 0 || len(v) &gt; 2 </span><span class="cov0" title="0">{
                        return nil, fmt.Errorf("invalid number of arguments to ref")
                }</span>
                // These where the options before we introduced the map type:
                <span class="cov0" title="0">s = v[0]
                if len(v) == 2 </span><span class="cov0" title="0">{
                        of = v[1]
                }</span>
        default:<span class="cov0" title="0">
                var err error
                s, err = cast.ToStringE(args)
                if err != nil </span><span class="cov0" title="0">{
                        return nil, err
                }</span>

        }

        <span class="cov0" title="0">return map[string]interface{}{
                "path":         s,
                "outputFormat": of,
        }, nil</span>
}

// RelLangURL takes a given string and prepends the relative path according to a
// page's position in the project directory structure and the current language.
func (ns *Namespace) RelLangURL(a interface{}) (template.HTML, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return template.HTML(ns.deps.PathSpec.RelURL(s, !ns.multihost)), nil</span>
}

// AbsLangURL takes a given string and converts it to an absolute URL according
// to a page's position in the project directory structure and the current
// language.
func (ns *Namespace) AbsLangURL(a interface{}) (template.HTML, error) <span class="cov0" title="0">{
        s, err := cast.ToStringE(a)
        if err != nil </span><span class="cov0" title="0">{
                return "", err
        }</span>

        <span class="cov0" title="0">return template.HTML(ns.deps.PathSpec.AbsURL(s, !ns.multihost)), nil</span>
}
</pre>
		
		<pre class="file" id="file366" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package transform

import (
        "bytes"
        "io"

        bp "github.com/gohugoio/hugo/bufferpool"
)

// Transformer is the func that needs to be implemented by a transformation step.
type Transformer func(ft FromTo) error

// BytesReader wraps the Bytes method, usually implemented by bytes.Buffer, and an
// io.Reader.
type BytesReader interface {
        // The slice given by Bytes is valid for use only until the next buffer modification.
        // That is, if you want to use this value outside of the current transformer step,
        // you need to take a copy.
        Bytes() []byte

        io.Reader
}

// FromTo is sent to each transformation step in the chain.
type FromTo interface {
        From() BytesReader
        To() io.Writer
}

// Chain is an ordered processing chain. The next transform operation will
// receive the output from the previous.
type Chain []Transformer

// New creates a content transformer chain given the provided transform funcs.
func New(trs ...Transformer) Chain <span class="cov8" title="1">{
        return trs
}</span>

// NewEmpty creates a new slice of transformers with a capacity of 20.
func NewEmpty() Chain <span class="cov8" title="1">{
        return make(Chain, 0, 20)
}</span>

// Implements contentTransformer
// Content is read from the from-buffer and rewritten to to the to-buffer.
type fromToBuffer struct {
        from *bytes.Buffer
        to   *bytes.Buffer
}

func (ft fromToBuffer) From() BytesReader <span class="cov8" title="1">{
        return ft.from
}</span>

func (ft fromToBuffer) To() io.Writer <span class="cov8" title="1">{
        return ft.to
}</span>

// Apply passes the given from io.Reader through the transformation chain.
// The result is written to to.
func (c *Chain) Apply(to io.Writer, from io.Reader) error <span class="cov8" title="1">{
        if len(*c) == 0 </span><span class="cov8" title="1">{
                _, err := io.Copy(to, from)
                return err
        }</span>

        <span class="cov8" title="1">b1 := bp.GetBuffer()
        defer bp.PutBuffer(b1)

        if _, err := b1.ReadFrom(from); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">b2 := bp.GetBuffer()
        defer bp.PutBuffer(b2)

        fb := &amp;fromToBuffer{from: b1, to: b2}

        for i, tr := range *c </span><span class="cov8" title="1">{
                if i &gt; 0 </span><span class="cov8" title="1">{
                        if fb.from == b1 </span><span class="cov8" title="1">{
                                fb.from = b2
                                fb.to = b1
                                fb.to.Reset()
                        }</span> else<span class="cov8" title="1"> {
                                fb.from = b1
                                fb.to = b2
                                fb.to.Reset()
                        }</span>
                }

                <span class="cov8" title="1">if err := tr(fb); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov8" title="1">_, err := fb.to.WriteTo(to)
        return err</span>
}
</pre>
		
		<pre class="file" id="file367" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package livereloadinject

import (
        "bytes"
        "fmt"
        "html"
        "net/url"
        "strings"

        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/transform"
)

type tag struct {
        markup       []byte
        appendScript bool
}

var tags = []tag{
        {markup: []byte("&lt;head&gt;"), appendScript: true},
        {markup: []byte("&lt;HEAD&gt;"), appendScript: true},
        {markup: []byte("&lt;/body&gt;")},
        {markup: []byte("&lt;/BODY&gt;")},
}

// New creates a function that can be used
// to inject a script tag for the livereload JavaScript in a HTML document.
func New(baseURL url.URL) transform.Transformer <span class="cov8" title="1">{
        return func(ft transform.FromTo) error </span><span class="cov8" title="1">{
                b := ft.From().Bytes()
                idx := -1
                var match tag
                // We used to insert the livereload script right before the closing body.
                // This does not work when combined with tools such as Turbolinks.
                // So we try to inject the script as early as possible.
                for _, t := range tags </span><span class="cov8" title="1">{
                        idx = bytes.Index(b, t.markup)
                        if idx != -1 </span><span class="cov8" title="1">{
                                match = t
                                break</span>
                        }
                }

                <span class="cov8" title="1">path := strings.TrimSuffix(baseURL.Path, "/")

                src := path + "/livereload.js?mindelay=10&amp;v=2"
                src += "&amp;port=" + baseURL.Port()
                src += "&amp;path=" + strings.TrimPrefix(path+"/livereload", "/")

                c := make([]byte, len(b))
                copy(c, b)

                if idx == -1 </span><span class="cov8" title="1">{
                        _, err := ft.To().Write(c)
                        return err
                }</span>

                <span class="cov8" title="1">script := []byte(fmt.Sprintf(`&lt;script src="%s" data-no-instant defer&gt;&lt;/script&gt;`, html.EscapeString(src)))

                i := idx
                if match.appendScript </span><span class="cov8" title="1">{
                        i += len(match.markup)
                }</span>

                <span class="cov8" title="1">c = append(c[:i], append(script, c[i:]...)...)

                if _, err := ft.To().Write(c); err != nil </span><span class="cov0" title="0">{
                        helpers.DistinctWarnLog.Println("Failed to inject LiveReload script:", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }
}
</pre>
		
		<pre class="file" id="file368" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package metainject

import (
        "bytes"
        "fmt"
        "regexp"

        "github.com/gohugoio/hugo/common/hugo"
        "github.com/gohugoio/hugo/helpers"
        "github.com/gohugoio/hugo/transform"
)

var (
        metaTagsCheck    = regexp.MustCompile(`(?i)&lt;meta\s+name=['|"]?generator['|"]?`)
        hugoGeneratorTag = fmt.Sprintf(`&lt;meta name="generator" content="Hugo %s" /&gt;`, hugo.CurrentVersion)
)

// HugoGenerator injects a meta generator tag for Hugo if none present.
func HugoGenerator(ft transform.FromTo) error <span class="cov8" title="1">{
        b := ft.From().Bytes()
        if metaTagsCheck.Match(b) </span><span class="cov8" title="1">{
                if _, err := ft.To().Write(b); err != nil </span><span class="cov0" title="0">{
                        helpers.DistinctWarnLog.Println("Failed to inject Hugo generator tag:", err)
                }</span>
                <span class="cov8" title="1">return nil</span>
        }

        <span class="cov8" title="1">head := "&lt;head&gt;"
        replace := []byte(fmt.Sprintf("%s\n\t%s", head, hugoGeneratorTag))
        newcontent := bytes.Replace(b, []byte(head), replace, 1)

        if len(newcontent) == len(b) </span><span class="cov8" title="1">{
                head := "&lt;HEAD&gt;"
                replace := []byte(fmt.Sprintf("%s\n\t%s", head, hugoGeneratorTag))
                newcontent = bytes.Replace(b, []byte(head), replace, 1)
        }</span>

        <span class="cov8" title="1">if _, err := ft.To().Write(newcontent); err != nil </span><span class="cov0" title="0">{
                helpers.DistinctWarnLog.Println("Failed to inject Hugo generator tag:", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}
</pre>
		
		<pre class="file" id="file369" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package urlreplacers

import "github.com/gohugoio/hugo/transform"

var ar = newAbsURLReplacer()

// NewAbsURLTransformer replaces relative URLs with absolute ones
// in HTML files, using the baseURL setting.
func NewAbsURLTransformer(path string) transform.Transformer <span class="cov8" title="1">{
        return func(ft transform.FromTo) error </span><span class="cov8" title="1">{
                ar.replaceInHTML(path, ft)
                return nil
        }</span>
}

// NewAbsURLInXMLTransformer replaces relative URLs with absolute ones
// in XML files, using the baseURL setting.
func NewAbsURLInXMLTransformer(path string) transform.Transformer <span class="cov8" title="1">{
        return func(ft transform.FromTo) error </span><span class="cov8" title="1">{
                ar.replaceInXML(path, ft)
                return nil
        }</span>
}
</pre>
		
		<pre class="file" id="file370" style="display: none">// Copyright 2018 The Hugo Authors. All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package urlreplacers

import (
        "bytes"
        "io"
        "unicode"
        "unicode/utf8"

        "github.com/gohugoio/hugo/transform"
)

type absurllexer struct {
        // the source to absurlify
        content []byte
        // the target for the new absurlified content
        w io.Writer

        // path may be set to a "." relative path
        path []byte

        pos   int // input position
        start int // item start position

        quotes [][]byte
}

type prefix struct {
        disabled bool
        b        []byte
        f        func(l *absurllexer)

        nextPos int
}

func (p *prefix) find(bs []byte, start int) bool <span class="cov8" title="1">{
        if p.disabled </span><span class="cov8" title="1">{
                return false
        }</span>

        <span class="cov8" title="1">if p.nextPos == -1 </span><span class="cov8" title="1">{
                idx := bytes.Index(bs[start:], p.b)

                if idx == -1 </span><span class="cov8" title="1">{
                        p.disabled = true
                        // Find the closest match
                        return false
                }</span>

                <span class="cov8" title="1">p.nextPos = start + idx + len(p.b)</span>
        }

        <span class="cov8" title="1">return true</span>
}

func newPrefixState() []*prefix <span class="cov8" title="1">{
        return []*prefix{
                {b: []byte("src="), f: checkCandidateBase},
                {b: []byte("href="), f: checkCandidateBase},
                {b: []byte("url="), f: checkCandidateBase},
                {b: []byte("action="), f: checkCandidateBase},
                {b: []byte("srcset="), f: checkCandidateSrcset},
        }
}</span>

func (l *absurllexer) emit() <span class="cov8" title="1">{
        l.w.Write(l.content[l.start:l.pos])
        l.start = l.pos
}</span>

var (
        relURLPrefix    = []byte("/")
        relURLPrefixLen = len(relURLPrefix)
)

func (l *absurllexer) consumeQuote() []byte <span class="cov8" title="1">{
        for _, q := range l.quotes </span><span class="cov8" title="1">{
                if bytes.HasPrefix(l.content[l.pos:], q) </span><span class="cov8" title="1">{
                        l.pos += len(q)
                        l.emit()
                        return q
                }</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// handle URLs in src and href.
func checkCandidateBase(l *absurllexer) <span class="cov8" title="1">{
        l.consumeQuote()

        if !bytes.HasPrefix(l.content[l.pos:], relURLPrefix) </span><span class="cov8" title="1">{
                return
        }</span>

        // check for schemaless URLs
        <span class="cov8" title="1">posAfter := l.pos + relURLPrefixLen
        if posAfter &gt;= len(l.content) </span><span class="cov8" title="1">{
                return
        }</span>
        <span class="cov8" title="1">r, _ := utf8.DecodeRune(l.content[posAfter:])
        if r == '/' </span><span class="cov8" title="1">{
                // schemaless: skip
                return
        }</span>
        <span class="cov8" title="1">if l.pos &gt; l.start </span><span class="cov8" title="1">{
                l.emit()
        }</span>
        <span class="cov8" title="1">l.pos += relURLPrefixLen
        l.w.Write(l.path)
        l.start = l.pos</span>
}

func (l *absurllexer) posAfterURL(q []byte) int <span class="cov8" title="1">{
        if len(q) &gt; 0 </span><span class="cov8" title="1">{
                // look for end quote
                return bytes.Index(l.content[l.pos:], q)
        }</span>

        <span class="cov0" title="0">return bytes.IndexFunc(l.content[l.pos:], func(r rune) bool </span><span class="cov0" title="0">{
                return r == '&gt;' || unicode.IsSpace(r)
        }</span>)
}

// handle URLs in srcset.
func checkCandidateSrcset(l *absurllexer) <span class="cov8" title="1">{
        q := l.consumeQuote()
        if q == nil </span><span class="cov8" title="1">{
                // srcset needs to be quoted.
                return
        }</span>

        // special case, not frequent (me think)
        <span class="cov8" title="1">if !bytes.HasPrefix(l.content[l.pos:], relURLPrefix) </span><span class="cov0" title="0">{
                return
        }</span>

        // check for schemaless URLs
        <span class="cov8" title="1">posAfter := l.pos + relURLPrefixLen
        if posAfter &gt;= len(l.content) </span><span class="cov0" title="0">{
                return
        }</span>
        <span class="cov8" title="1">r, _ := utf8.DecodeRune(l.content[posAfter:])
        if r == '/' </span><span class="cov8" title="1">{
                // schemaless: skip
                return
        }</span>

        <span class="cov8" title="1">posEnd := l.posAfterURL(q)

        // safe guard
        if posEnd &lt; 0 || posEnd &gt; 2000 </span><span class="cov8" title="1">{
                return
        }</span>

        <span class="cov8" title="1">if l.pos &gt; l.start </span><span class="cov0" title="0">{
                l.emit()
        }</span>

        <span class="cov8" title="1">section := l.content[l.pos : l.pos+posEnd+1]

        fields := bytes.Fields(section)
        for i, f := range fields </span><span class="cov8" title="1">{
                if f[0] == '/' </span><span class="cov8" title="1">{
                        l.w.Write(l.path)
                        l.w.Write(f[1:])

                }</span> else<span class="cov8" title="1"> {
                        l.w.Write(f)
                }</span>

                <span class="cov8" title="1">if i &lt; len(fields)-1 </span><span class="cov8" title="1">{
                        l.w.Write([]byte(" "))
                }</span>
        }

        <span class="cov8" title="1">l.pos += len(section)
        l.start = l.pos</span>
}

// main loop
func (l *absurllexer) replace() <span class="cov8" title="1">{
        contentLength := len(l.content)

        prefixes := newPrefixState()

        for </span><span class="cov8" title="1">{
                if l.pos &gt;= contentLength </span><span class="cov0" title="0">{
                        break</span>
                }

                <span class="cov8" title="1">var match *prefix

                for _, p := range prefixes </span><span class="cov8" title="1">{
                        if !p.find(l.content, l.pos) </span><span class="cov8" title="1">{
                                continue</span>
                        }

                        <span class="cov8" title="1">if match == nil || p.nextPos &lt; match.nextPos </span><span class="cov8" title="1">{
                                match = p
                        }</span>
                }

                <span class="cov8" title="1">if match == nil </span><span class="cov8" title="1">{
                        // Done!
                        l.pos = contentLength
                        break</span>
                } else<span class="cov8" title="1"> {
                        l.pos = match.nextPos
                        match.nextPos = -1
                        match.f(l)
                }</span>
        }
        // Done!
        <span class="cov8" title="1">if l.pos &gt; l.start </span><span class="cov8" title="1">{
                l.emit()
        }</span>
}

func doReplace(path string, ct transform.FromTo, quotes [][]byte) <span class="cov8" title="1">{
        lexer := &amp;absurllexer{
                content: ct.From().Bytes(),
                w:       ct.To(),
                path:    []byte(path),
                quotes:  quotes,
        }

        lexer.replace()
}</span>

type absURLReplacer struct {
        htmlQuotes [][]byte
        xmlQuotes  [][]byte
}

func newAbsURLReplacer() *absURLReplacer <span class="cov8" title="1">{
        return &amp;absURLReplacer{
                htmlQuotes: [][]byte{[]byte("\""), []byte("'")},
                xmlQuotes:  [][]byte{[]byte("&amp;#34;"), []byte("&amp;#39;")},
        }
}</span>

func (au *absURLReplacer) replaceInHTML(path string, ct transform.FromTo) <span class="cov8" title="1">{
        doReplace(path, ct, au.htmlQuotes)
}</span>

func (au *absURLReplacer) replaceInXML(path string, ct transform.FromTo) <span class="cov8" title="1">{
        doReplace(path, ct, au.xmlQuotes)
}</span>
</pre>
		
		<pre class="file" id="file371" style="display: none">// Package filenotify provides a mechanism for watching file(s) for changes.
// Generally leans on fsnotify, but provides a poll-based notifier which fsnotify does not support.
// These are wrapped up in a common interface so that either can be used interchangeably in your code.
//
// This package is adapted from https://github.com/moby/moby/tree/master/pkg/filenotify, Apache-2.0 License.
// Hopefully this can be replaced with an external package sometime in the future, see https://github.com/fsnotify/fsnotify/issues/9
package filenotify

import (
        "time"

        "github.com/fsnotify/fsnotify"
)

// FileWatcher is an interface for implementing file notification watchers
type FileWatcher interface {
        Events() &lt;-chan fsnotify.Event
        Errors() &lt;-chan error
        Add(name string) error
        Remove(name string) error
        Close() error
}

// New tries to use an fs-event watcher, and falls back to the poller if there is an error
func New(interval time.Duration) (FileWatcher, error) <span class="cov0" title="0">{
        if watcher, err := NewEventWatcher(); err == nil </span><span class="cov0" title="0">{
                return watcher, nil
        }</span>
        <span class="cov0" title="0">return NewPollingWatcher(interval), nil</span>
}

// NewPollingWatcher returns a poll-based file watcher
func NewPollingWatcher(interval time.Duration) FileWatcher <span class="cov8" title="1">{
        return &amp;filePoller{
                interval: interval,
                done:     make(chan struct{}),
                events:   make(chan fsnotify.Event),
                errors:   make(chan error),
        }
}</span>

// NewEventWatcher returns an fs-event based file watcher
func NewEventWatcher() (FileWatcher, error) <span class="cov0" title="0">{
        watcher, err := fsnotify.NewWatcher()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>
        <span class="cov0" title="0">return &amp;fsNotifyWatcher{watcher}, nil</span>
}
</pre>
		
		<pre class="file" id="file372" style="display: none">// Package filenotify is adapted from https://github.com/moby/moby/tree/master/pkg/filenotify, Apache-2.0 License.
// Hopefully this can be replaced with an external package sometime in the future, see https://github.com/fsnotify/fsnotify/issues/9
package filenotify

import "github.com/fsnotify/fsnotify"

// fsNotifyWatcher wraps the fsnotify package to satisfy the FileNotifier interface
type fsNotifyWatcher struct {
        *fsnotify.Watcher
}

// Events returns the fsnotify event channel receiver
func (w *fsNotifyWatcher) Events() &lt;-chan fsnotify.Event <span class="cov0" title="0">{
        return w.Watcher.Events
}</span>

// Errors returns the fsnotify error channel receiver
func (w *fsNotifyWatcher) Errors() &lt;-chan error <span class="cov0" title="0">{
        return w.Watcher.Errors
}</span>
</pre>
		
		<pre class="file" id="file373" style="display: none">// Package filenotify is adapted from https://github.com/moby/moby/tree/master/pkg/filenotify, Apache-2.0 License.
// Hopefully this can be replaced with an external package sometime in the future, see https://github.com/fsnotify/fsnotify/issues/9
package filenotify

import (
        "errors"
        "fmt"
        "os"
        "path/filepath"
        "sync"
        "time"

        "github.com/fsnotify/fsnotify"
)

var (
        // errPollerClosed is returned when the poller is closed
        errPollerClosed = errors.New("poller is closed")
        // errNoSuchWatch is returned when trying to remove a watch that doesn't exist
        errNoSuchWatch = errors.New("watch does not exist")
)

// filePoller is used to poll files for changes, especially in cases where fsnotify
// can't be run (e.g. when inotify handles are exhausted)
// filePoller satisfies the FileWatcher interface
type filePoller struct {
        // the duration between polls.
        interval time.Duration
        // watches is the list of files currently being polled, close the associated channel to stop the watch
        watches map[string]struct{}
        // Will be closed when done.
        done chan struct{}
        // events is the channel to listen to for watch events
        events chan fsnotify.Event
        // errors is the channel to listen to for watch errors
        errors chan error
        // mu locks the poller for modification
        mu sync.Mutex
        // closed is used to specify when the poller has already closed
        closed bool
}

// Add adds a filename to the list of watches
// once added the file is polled for changes in a separate goroutine
func (w *filePoller) Add(name string) error <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if w.closed </span><span class="cov8" title="1">{
                return errPollerClosed
        }</span>

        <span class="cov8" title="1">item, err := newItemToWatch(name)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>
        <span class="cov8" title="1">if item.left.FileInfo == nil </span><span class="cov8" title="1">{
                return os.ErrNotExist
        }</span>

        <span class="cov8" title="1">if w.watches == nil </span><span class="cov8" title="1">{
                w.watches = make(map[string]struct{})
        }</span>
        <span class="cov8" title="1">if _, exists := w.watches[name]; exists </span><span class="cov0" title="0">{
                return fmt.Errorf("watch exists")
        }</span>
        <span class="cov8" title="1">w.watches[name] = struct{}{}

        go w.watch(item)
        return nil</span>
}

// Remove stops and removes watch with the specified name
func (w *filePoller) Remove(name string) error <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()
        return w.remove(name)
}</span>

func (w *filePoller) remove(name string) error <span class="cov8" title="1">{
        if w.closed </span><span class="cov8" title="1">{
                return errPollerClosed
        }</span>

        <span class="cov8" title="1">_, exists := w.watches[name]
        if !exists </span><span class="cov8" title="1">{
                return errNoSuchWatch
        }</span>
        <span class="cov8" title="1">delete(w.watches, name)
        return nil</span>
}

// Events returns the event channel
// This is used for notifications on events about watched files
func (w *filePoller) Events() &lt;-chan fsnotify.Event <span class="cov8" title="1">{
        return w.events
}</span>

// Errors returns the errors channel
// This is used for notifications about errors on watched files
func (w *filePoller) Errors() &lt;-chan error <span class="cov8" title="1">{
        return w.errors
}</span>

// Close closes the poller
// All watches are stopped, removed, and the poller cannot be added to
func (w *filePoller) Close() error <span class="cov8" title="1">{
        w.mu.Lock()
        defer w.mu.Unlock()

        if w.closed </span><span class="cov8" title="1">{
                return nil
        }</span>
        <span class="cov8" title="1">w.closed = true
        close(w.done)
        for name := range w.watches </span><span class="cov8" title="1">{
                w.remove(name)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// sendEvent publishes the specified event to the events channel
func (w *filePoller) sendEvent(e fsnotify.Event) error <span class="cov8" title="1">{
        select </span>{
        case w.events &lt;- e:<span class="cov8" title="1"></span>
        case &lt;-w.done:<span class="cov0" title="0">
                return fmt.Errorf("closed")</span>
        }
        <span class="cov8" title="1">return nil</span>
}

// sendErr publishes the specified error to the errors channel
func (w *filePoller) sendErr(e error) error <span class="cov0" title="0">{
        select </span>{
        case w.errors &lt;- e:<span class="cov0" title="0"></span>
        case &lt;-w.done:<span class="cov0" title="0">
                return fmt.Errorf("closed")</span>
        }
        <span class="cov0" title="0">return nil</span>
}

// watch watches item for changes until done is closed.
func (w *filePoller) watch(item *itemToWatch) <span class="cov8" title="1">{
        ticker := time.NewTicker(w.interval)
        defer ticker.Stop()

        for </span><span class="cov8" title="1">{
                select </span>{
                case &lt;-ticker.C:<span class="cov8" title="1"></span>
                case &lt;-w.done:<span class="cov8" title="1">
                        return</span>
                }

                <span class="cov8" title="1">evs, err := item.checkForChanges()
                if err != nil </span><span class="cov0" title="0">{
                        if err := w.sendErr(err); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

                <span class="cov8" title="1">item.left, item.right = item.right, item.left

                for _, ev := range evs </span><span class="cov8" title="1">{
                        if err := w.sendEvent(ev); err != nil </span><span class="cov0" title="0">{
                                return
                        }</span>
                }

        }
}

// recording records the state of a file or a dir.
type recording struct {
        os.FileInfo

        // Set if FileInfo is a dir.
        entries map[string]os.FileInfo
}

func (r *recording) clear() <span class="cov8" title="1">{
        r.FileInfo = nil
        if r.entries != nil </span><span class="cov8" title="1">{
                for k := range r.entries </span><span class="cov8" title="1">{
                        delete(r.entries, k)
                }</span>
        }
}

func (r *recording) record(filename string) error <span class="cov8" title="1">{
        r.clear()

        fi, err := os.Stat(filename)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if fi == nil </span><span class="cov8" title="1">{
                return nil
        }</span>

        <span class="cov8" title="1">r.FileInfo = fi

        // If fi is a dir, we watch the files inside that directory (not recursively).
        // This matches the behaviour of fsnotity.
        if fi.IsDir() </span><span class="cov8" title="1">{
                f, err := os.Open(filename)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }
                <span class="cov8" title="1">defer f.Close()

                fis, err := f.Readdir(-1)
                if err != nil </span><span class="cov0" title="0">{
                        if os.IsNotExist(err) </span><span class="cov0" title="0">{
                                return nil
                        }</span>
                        <span class="cov0" title="0">return err</span>
                }

                <span class="cov8" title="1">for _, fi := range fis </span><span class="cov8" title="1">{
                        r.entries[fi.Name()] = fi
                }</span>
        }

        <span class="cov8" title="1">return nil</span>
}

// itemToWatch may be a file or a dir.
type itemToWatch struct {
        // Full path to the filename.
        filename string

        // Snapshots of the stat state of this file or dir.
        left  *recording
        right *recording
}

func newItemToWatch(filename string) (*itemToWatch, error) <span class="cov8" title="1">{
        r := &amp;recording{
                entries: make(map[string]os.FileInfo),
        }
        err := r.record(filename)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">return &amp;itemToWatch{filename: filename, left: r}, nil</span>

}

func (item *itemToWatch) checkForChanges() ([]fsnotify.Event, error) <span class="cov8" title="1">{
        if item.right == nil </span><span class="cov8" title="1">{
                item.right = &amp;recording{
                        entries: make(map[string]os.FileInfo),
                }
        }</span>

        <span class="cov8" title="1">err := item.right.record(item.filename)
        if err != nil &amp;&amp; !os.IsNotExist(err) </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">dirOp := checkChange(item.left.FileInfo, item.right.FileInfo)

        if dirOp != 0 </span><span class="cov8" title="1">{
                evs := []fsnotify.Event{fsnotify.Event{Op: dirOp, Name: item.filename}}
                return evs, nil
        }</span>

        <span class="cov8" title="1">if item.left.FileInfo == nil || !item.left.IsDir() </span><span class="cov8" title="1">{
                // Done.
                return nil, nil
        }</span>

        <span class="cov8" title="1">leftIsIn := false
        left, right := item.left.entries, item.right.entries
        if len(right) &gt; len(left) </span><span class="cov8" title="1">{
                left, right = right, left
                leftIsIn = true
        }</span>

        <span class="cov8" title="1">var evs []fsnotify.Event

        for name, fi1 := range left </span><span class="cov8" title="1">{
                fi2 := right[name]
                fil, fir := fi1, fi2
                if leftIsIn </span><span class="cov8" title="1">{
                        fil, fir = fir, fil
                }</span>
                <span class="cov8" title="1">op := checkChange(fil, fir)
                if op != 0 </span><span class="cov8" title="1">{
                        evs = append(evs, fsnotify.Event{Op: op, Name: filepath.Join(item.filename, name)})
                }</span>

        }

        <span class="cov8" title="1">return evs, nil</span>

}

func checkChange(fi1, fi2 os.FileInfo) fsnotify.Op <span class="cov8" title="1">{
        if fi1 == nil &amp;&amp; fi2 != nil </span><span class="cov8" title="1">{
                return fsnotify.Create
        }</span>
        <span class="cov8" title="1">if fi1 != nil &amp;&amp; fi2 == nil </span><span class="cov8" title="1">{
                return fsnotify.Remove
        }</span>
        <span class="cov8" title="1">if fi1 == nil &amp;&amp; fi2 == nil </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if fi1.IsDir() || fi2.IsDir() </span><span class="cov8" title="1">{
                return 0
        }</span>
        <span class="cov8" title="1">if fi1.Mode() != fi2.Mode() </span><span class="cov8" title="1">{
                return fsnotify.Chmod
        }</span>
        <span class="cov8" title="1">if fi1.ModTime() != fi2.ModTime() || fi1.Size() != fi2.Size() </span><span class="cov8" title="1">{
                return fsnotify.Write
        }</span>

        <span class="cov8" title="1">return 0</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
